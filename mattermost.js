// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import * as AdminActions from 'mattermost-redux/actions/admin';
import * as UserActions from 'mattermost-redux/actions/users';
import * as TeamActions from 'mattermost-redux/actions/teams';
import {Client4} from 'mattermost-redux/client';
import {bindClientFunc} from 'mattermost-redux/actions/helpers';

import {trackEvent} from 'actions/telemetry_actions.jsx';

import {emitUserLoggedOutEvent} from 'actions/global_actions';
import {getOnNavigationConfirmed} from 'selectors/views/admin';
import store from 'stores/redux_store.jsx';
import {ActionTypes} from 'utils/constants';

const dispatch = store.dispatch;
const getState = store.getState;

export async function reloadConfig(success, error) {
    const {data, error: err} = await dispatch(AdminActions.reloadConfig());
    if (data && success) {
        dispatch(AdminActions.getConfig());
        dispatch(AdminActions.getEnvironmentConfig());
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function adminResetMfa(userId, success, error) {
    const {data, error: err} = await UserActions.updateUserMfa(userId, false)(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function getClusterStatus(success, error) {
    const {data, error: err} = await AdminActions.getClusterStatus()(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function ldapTest(success, error) {
    const {data, error: err} = await AdminActions.testLdap()(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function invalidateAllCaches(success, error) {
    const {data, error: err} = await AdminActions.invalidateCaches()(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function recycleDatabaseConnection(success, error) {
    const {data, error: err} = await AdminActions.recycleDatabase()(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function adminResetEmail(user, success, error) {
    const {data, error: err} = await UserActions.patchUser(user)(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function samlCertificateStatus(success, error) {
    const {data, error: err} = await AdminActions.getSamlCertificateStatus()(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export function getOAuthAppInfo(clientId) {
    return bindClientFunc({
        clientFunc: Client4.getOAuthAppInfo,
        params: [clientId],
    });
}

export function allowOAuth2({responseType, clientId, redirectUri, state, scope}) {
    return bindClientFunc({
        clientFunc: Client4.authorizeOAuthApp,
        params: [responseType, clientId, redirectUri, state, scope],
    });
}

export async function emailToLdap(loginId, password, token, ldapId, ldapPassword, success, error) {
    const {data, error: err} = await UserActions.switchEmailToLdap(loginId, password, ldapId, ldapPassword, token)(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function emailToOAuth(loginId, password, token, newType, success, error) {
    const {data, error: err} = await UserActions.switchEmailToOAuth(newType, loginId, password, token)(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function oauthToEmail(currentService, email, password, success, error) {
    const {data, error: err} = await UserActions.switchOAuthToEmail(currentService, email, password)(dispatch, getState);
    if (data) {
        if (data.follow_link) {
            emitUserLoggedOutEvent(data.follow_link);
        }
        if (success) {
            success(data);
        }
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function uploadBrandImage(brandImage, success, error) {
    const {data, error: err} = await AdminActions.uploadBrandImage(brandImage)(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function deleteBrandImage(success, error) {
    const {data, error: err} = await AdminActions.deleteBrandImage()(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function uploadPublicSamlCertificate(file, success, error) {
    const {data, error: err} = await AdminActions.uploadPublicSamlCertificate(file)(dispatch, getState);
    if (data && success) {
        success('saml-public.crt');
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function uploadPrivateSamlCertificate(file, success, error) {
    const {data, error: err} = await AdminActions.uploadPrivateSamlCertificate(file)(dispatch, getState);
    if (data && success) {
        success('saml-private.key');
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function uploadPublicLdapCertificate(file, success, error) {
    const {data, error: err} = await AdminActions.uploadPublicLdapCertificate(file)(dispatch, getState);
    if (data && success) {
        success('ldap-public.crt');
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}
export async function uploadPrivateLdapCertificate(file, success, error) {
    const {data, error: err} = await AdminActions.uploadPrivateLdapCertificate(file)(dispatch, getState);
    if (data && success) {
        success('ldap-private.key');
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function uploadIdpSamlCertificate(file, success, error) {
    const {data, error: err} = await AdminActions.uploadIdpSamlCertificate(file)(dispatch, getState);
    if (data && success) {
        success('saml-idp.crt');
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function removePublicSamlCertificate(success, error) {
    const {data, error: err} = await AdminActions.removePublicSamlCertificate()(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function removePrivateSamlCertificate(success, error) {
    const {data, error: err} = await AdminActions.removePrivateSamlCertificate()(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function removePublicLdapCertificate(success, error) {
    const {data, error: err} = await AdminActions.removePublicLdapCertificate()(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function removePrivateLdapCertificate(success, error) {
    const {data, error: err} = await AdminActions.removePrivateLdapCertificate()(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function removeIdpSamlCertificate(success, error) {
    const {data, error: err} = await AdminActions.removeIdpSamlCertificate()(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function getStandardAnalytics(teamId) {
    await AdminActions.getStandardAnalytics(teamId)(dispatch, getState);
}

export async function getAdvancedAnalytics(teamId) {
    await AdminActions.getAdvancedAnalytics(teamId)(dispatch, getState);
}

export async function getBotPostsPerDayAnalytics(teamId) {
    await AdminActions.getBotPostsPerDayAnalytics(teamId)(dispatch, getState);
}

export async function getPostsPerDayAnalytics(teamId) {
    await AdminActions.getPostsPerDayAnalytics(teamId)(dispatch, getState);
}

export async function getUsersPerDayAnalytics(teamId) {
    await AdminActions.getUsersPerDayAnalytics(teamId)(dispatch, getState);
}

export async function elasticsearchTest(config, success, error) {
    const {data, error: err} = await AdminActions.testElasticsearch(config)(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function testS3Connection(success, error) {
    const {data, error: err} = await AdminActions.testS3Connection()(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function elasticsearchPurgeIndexes(success, error) {
    const {data, error: err} = await AdminActions.purgeElasticsearchIndexes()(dispatch, getState);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function blevePurgeIndexes(success, error) {
    const purgeBleveIndexes = bindClientFunc({
        clientFunc: Client4.purgeBleveIndexes,
        params: [],
    });

    const {data, error: err} = await dispatch(purgeBleveIndexes);
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export function setNavigationBlocked(blocked) {
    return {
        type: ActionTypes.SET_NAVIGATION_BLOCKED,
        blocked,
    };
}

export function deferNavigation(onNavigationConfirmed) {
    return {
        type: ActionTypes.DEFER_NAVIGATION,
        onNavigationConfirmed,
    };
}

export function cancelNavigation() {
    return {
        type: ActionTypes.CANCEL_NAVIGATION,
    };
}

export function confirmNavigation() {
    // have to rename these because of lint no-shadow
    return (thunkDispatch, thunkGetState) => {
        const callback = getOnNavigationConfirmed(thunkGetState());

        if (callback) {
            callback();
        }

        thunkDispatch({
            type: ActionTypes.CONFIRM_NAVIGATION,
        });
    };
}

export async function invalidateAllEmailInvites(success, error) {
    const {data, error: err} = await dispatch(TeamActions.invalidateAllEmailInvites());
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function testSmtp(success, error) {
    const {data, error: err} = await dispatch(AdminActions.testEmail());
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export function registerAdminConsolePlugin(pluginId, reducer) {
    return (storeDispatch) => {
        storeDispatch({
            type: ActionTypes.RECEIVED_ADMIN_CONSOLE_REDUCER,
            data: {
                pluginId,
                reducer,
            },
        });
    };
}

export function unregisterAdminConsolePlugin(pluginId) {
    return (storeDispatch) => {
        storeDispatch({
            type: ActionTypes.REMOVED_ADMIN_CONSOLE_REDUCER,
            data: {
                pluginId,
            },
        });
    };
}

export async function testSiteURL(success, error, siteURL) {
    const {data, error: err} = await dispatch(AdminActions.testSiteURL(siteURL));
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export function registerAdminConsoleCustomSetting(pluginId, key, component, {showTitle}) {
    return (storeDispatch) => {
        storeDispatch({
            type: ActionTypes.RECEIVED_ADMIN_CONSOLE_CUSTOM_COMPONENT,
            data: {
                pluginId,
                key,
                component,
                options: {showTitle},
            },
        });
    };
}

export async function getSamlMetadataFromIdp(success, error, samlMetadataURL) {
    const {data, error: err} = await dispatch(AdminActions.getSamlMetadataFromIdp(samlMetadataURL));
    if (data && success) {
        success(data);
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export async function setSamlIdpCertificateFromMetadata(success, error, certData) {
    const {data, error: err} = await AdminActions.setSamlIdpCertificateFromMetadata(certData)(dispatch, getState);
    if (data && success) {
        success('saml-idp.crt');
    } else if (err && error) {
        error({id: err.server_error_id, ...err});
    }
}

export function upgradeToE0() {
    return async () => {
        trackEvent('api', 'upgrade_to_e0_requested');
        const data = await Client4.upgradeToEnterprise();
        return data;
    };
}

export function upgradeToE0Status() {
    return async () => {
        const data = await Client4.upgradeToEnterpriseStatus();
        return data;
    };
}

export function restartServer() {
    return async () => {
        const data = await Client4.restartServer();
        return data;
    };
}

export function ping() {
    return async () => {
        const data = await Client4.ping();
        return data;
    };
}

export function requestTrialLicense(users, termsAccepted, receiveEmailsAccepted, page) {
    return async () => {
        try {
            trackEvent('api', 'api_request_trial_license', {from_page: page});
            const response = await Client4.requestTrialLicense({users, terms_accepted: termsAccepted, receive_emails_accepted: receiveEmailsAccepted});

            return {data: response};
        } catch (e) {
            // In the event that the status code returned is 451, this request has been blocked because it originated from an embargoed country_dropdown
            return {error: e.message, data: {status: e.status_code}};
        }
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import ReactSelect from 'react-select';
import {Props as AsyncSelectProps} from 'react-select/async';

import {AppField, AppSelectOption} from '@mattermost/types/apps';

const AsyncSelect = require('react-select/lib/Async').default as React.ElementType<AsyncSelectProps<AppSelectOption>>; // eslint-disable-line global-require

export type Props = {
    field: AppField;
    label: React.ReactNode;
    helpText: React.ReactNode;
    value: AppSelectOption | null;
    onChange: (value: AppSelectOption) => void;
    performLookup: (name: string, userInput: string) => Promise<AppSelectOption[]>;
};

export type State = {
    refreshNonce: string;
    field: AppField;
}

const reactStyles = {
    menuPortal: (provided: React.CSSProperties) => ({
        ...provided,
        zIndex: 9999,
    }),
};

const commonProps = {
    isClearable: true,
    openMenuOnFocus: false,
    classNamePrefix: 'react-select-auto react-select',
    menuPortalTarget: document.body,
    styles: reactStyles,
    components: {
        MultiValueLabel: (props: {data: {label: string}}) => (
            <div className='react-select__padded-component'>
                {props.data.label}
            </div>
        ),
    },
};

export default class AppsFormSelectField extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            field: props.field,
            refreshNonce: Math.random().toString(),
        };
    }
    static getDerivedStateFromProps(nextProps: Props, prevState: State) {
        if (nextProps.field !== prevState.field) {
            return {
                field: nextProps.field,
                refreshNonce: Math.random().toString(),
            };
        }

        return null;
    }

    onChange = (selectedOption: AppSelectOption) => {
        this.props.onChange(selectedOption);
    }

    loadDynamicOptions = async (userInput: string): Promise<AppSelectOption[]> => {
        return this.props.performLookup(this.props.field.name, userInput);
    }

    renderDynamicSelect() {
        const {field} = this.props;
        const placeholder = field.hint || '';
        const value = this.props.value;

        return (
            <div className={'react-select'}>
                <AsyncSelect
                    id={`MultiInput_${field.name}`}
                    loadOptions={this.loadDynamicOptions}
                    defaultOptions={true}
                    isMulti={field.multiselect || false}
                    placeholder={placeholder}
                    value={value}
                    onChange={this.onChange as any} // types are not working correctly for multiselect
                    isDisabled={field.readonly}
                    {...commonProps}
                />
            </div>
        );
    }

    renderStaticSelect() {
        const {field} = this.props;

        const placeholder = field.hint || '';

        const options = field.options;
        const value = this.props.value;

        return (
            <div className={'react-select'}>
                <ReactSelect
                    id={`MultiInput_${field.name}`}
                    options={options}
                    isMulti={field.multiselect || false}
                    placeholder={placeholder}
                    value={value}
                    onChange={this.onChange as any} // types are not working correctly for multiselect
                    isDisabled={field.readonly}
                    {...commonProps}
                />
            </div>
        );
    }

    render() {
        const {field, label, helpText} = this.props;

        let selectComponent;
        if (field.type === 'dynamic_select') {
            selectComponent = this.renderDynamicSelect();
        } else if (field.type === 'static_select') {
            selectComponent = this.renderStaticSelect();
        } else {
            return null;
        }

        return (
            <div className='form-group'>
                {label && (
                    <label>
                        {label}
                    </label>
                )}
                <React.Fragment key={this.state.refreshNonce}>
                    {selectComponent}
                    <div className='help-text'>
                        {helpText}
                    </div>
                </React.Fragment>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {AppField, AppSelectOption} from '@mattermost/types/apps';
import {Channel} from '@mattermost/types/channels';
import {UserProfile} from '@mattermost/types/users';
import {UserAutocomplete} from '@mattermost/types/autocomplete';

import {AppFieldTypes} from 'mattermost-redux/constants/apps';
import {displayUsername} from 'mattermost-redux/utils/user_utils';

import GenericUserProvider from 'components/suggestion/generic_user_provider';
import GenericChannelProvider from 'components/suggestion/generic_channel_provider.jsx';

import TextSetting, {InputTypes} from 'components/widgets/settings/text_setting';
import AutocompleteSelector from 'components/autocomplete_selector';
import ModalSuggestionList from 'components/suggestion/modal_suggestion_list.jsx';
import BoolSetting from 'components/widgets/settings/bool_setting';
import Provider from 'components/suggestion/provider';

import Markdown from 'components/markdown';

import AppsFormSelectField from './apps_form_select_field';

const TEXT_DEFAULT_MAX_LENGTH = 150;
const TEXTAREA_DEFAULT_MAX_LENGTH = 3000;

export interface Props {
    field: AppField;
    name: string;
    errorText?: React.ReactNode;
    teammateNameDisplay?: string;

    value: AppSelectOption | string | boolean | number | null;
    onChange: (name: string, value: any) => void;
    autoFocus?: boolean;
    listComponent?: React.ComponentProps<typeof AutocompleteSelector>['listComponent'];
    performLookup: (name: string, userInput: string) => Promise<AppSelectOption[]>;
    actions: {
        autocompleteChannels: (term: string, success: (channels: Channel[]) => void, error: () => void) => (dispatch: any, getState: any) => Promise<void>;
        autocompleteUsers: (search: string) => Promise<UserAutocomplete>;
    };
}

export default class AppsFormField extends React.PureComponent<Props> {
    private providers: Provider[] = [];

    static defaultProps = {
        listComponent: ModalSuggestionList,
    };

    constructor(props: Props) {
        super(props);
        this.setProviders();
    }

    handleSelected = (selected: AppSelectOption | UserProfile | Channel) => {
        const {name, field, onChange} = this.props;

        if (field.type === AppFieldTypes.USER) {
            const user = selected as UserProfile;
            let selectedLabel = user.username;
            if (this.props.teammateNameDisplay) {
                selectedLabel = displayUsername(user, this.props.teammateNameDisplay);
            }
            const option = {label: selectedLabel, value: user.id};
            onChange(name, option);
        } else if (field.type === AppFieldTypes.CHANNEL) {
            const channel = selected as Channel;
            const option = {label: channel.display_name, value: channel.id};
            onChange(name, option);
        } else {
            const option = selected as AppSelectOption;
            onChange(name, option);
        }
    }

    setProviders = () => {
        const {actions, field} = this.props;

        let providers: Provider[] = [];
        if (field.type === AppFieldTypes.USER) {
            providers = [new GenericUserProvider(actions.autocompleteUsers)];
        } else if (field.type === AppFieldTypes.CHANNEL) {
            providers = [new GenericChannelProvider(actions.autocompleteChannels)];
        }

        this.providers = providers;
    }

    render() {
        const {
            field,
            name,
            value,
            onChange,
            errorText,
            listComponent,
        } = this.props;

        const placeholder = field.hint || '';

        const displayName = (field.modal_label || field.label) as string;
        let displayNameContent: React.ReactNode = (field.modal_label || field.label) as string;
        displayNameContent = (
            <React.Fragment>
                {displayName}
                {!field.is_required && (
                    <span className='light'>
                        {' (optional)'}
                    </span>
                )}
            </React.Fragment>
        );

        const helpText = field.description;
        let helpTextContent: React.ReactNode = <Markdown message={helpText}/>;
        if (errorText) {
            helpTextContent = (
                <React.Fragment>
                    <Markdown message={helpText}/>
                    <div className='error-text mt-3'>
                        {errorText}
                    </div>
                </React.Fragment>
            );
        }

        switch (field.type) {
        case AppFieldTypes.TEXT: {
            const subtype = field.subtype || 'text';

            let maxLength = field.max_length;
            if (!maxLength) {
                if (subtype === 'textarea') {
                    maxLength = TEXTAREA_DEFAULT_MAX_LENGTH;
                } else {
                    maxLength = TEXT_DEFAULT_MAX_LENGTH;
                }
            }

            let textType: InputTypes = 'input';
            if (subtype && TextSetting.validTypes.includes(subtype)) {
                textType = subtype as InputTypes;
            }

            const textValue = value as string;
            return (
                <TextSetting
                    autoFocus={this.props.autoFocus}
                    id={name}
                    disabled={field.readonly}
                    type={textType}
                    label={displayNameContent}
                    maxLength={maxLength}
                    value={textValue || ''}
                    placeholder={placeholder}
                    helpText={helpTextContent}
                    onChange={onChange}
                    resizable={false}
                />
            );
        }
        case AppFieldTypes.CHANNEL:
        case AppFieldTypes.USER: {
            let selectedValue: string | undefined;
            if (this.props.value) {
                selectedValue = (this.props.value as AppSelectOption).label;
            }
            return (
                <AutocompleteSelector
                    id={name}
                    disabled={field.readonly}
                    providers={this.providers}
                    onSelected={this.handleSelected}
                    label={displayNameContent}
                    helpText={helpTextContent}
                    placeholder={placeholder}
                    value={selectedValue}
                    listComponent={listComponent}
                />
            );
        }
        case AppFieldTypes.STATIC_SELECT:
        case AppFieldTypes.DYNAMIC_SELECT: {
            return (
                <AppsFormSelectField
                    {...this.props}
                    field={field}
                    label={displayNameContent}
                    helpText={helpTextContent}
                    onChange={this.handleSelected}
                    value={this.props.value as AppSelectOption | null}
                />
            );
        }
        case AppFieldTypes.BOOL: {
            const boolValue = value as boolean;
            return (
                <BoolSetting
                    autoFocus={this.props.autoFocus}
                    id={name}
                    disabled={field.readonly}
                    label={displayNameContent}
                    value={boolValue || false}
                    helpText={helpTextContent}
                    placeholder={placeholder}
                    onChange={onChange}
                />
            );
        }
        case AppFieldTypes.MARKDOWN: {
            return (
                <Markdown
                    message={field.description}
                />
            );
        }
        }

        return null;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {ActionFunc, GenericAction} from 'mattermost-redux/types/actions';

import {getTeammateNameDisplaySetting} from 'mattermost-redux/selectors/entities/preferences';

import {GlobalState} from '@mattermost/types/store';

import {autocompleteChannels} from 'actions/channel_actions';
import {autocompleteUsers} from 'actions/user_actions';

import AppsFormField, {Props} from './apps_form_field';

function mapStateToProps(state: GlobalState) {
    return {
        teammateNameDisplay: getTeammateNameDisplaySetting(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc>, Props['actions']>({
            autocompleteChannels,
            autocompleteUsers,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(AppsFormField);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import Markdown from 'components/markdown';

type Props = {
    id?: string;
    value: string;
};

const markdownOptions = {singleline: false, mentionHighlight: false};

const AppsFormHeader: React.FC<Props> = (props: Props) => {
    return (
        <Markdown
            message={props.value}
            options={markdownOptions}
        />
    );
};

export default AppsFormHeader;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal, Fade} from 'react-bootstrap';
import {FormattedMessage, injectIntl, WrappedComponentProps} from 'react-intl';

import {
    checkDialogElementForError, checkIfErrorsMatchElements,
} from 'mattermost-redux/utils/integration_utils';
import {AppCallResponse, AppField, AppForm, AppFormValues, AppSelectOption, FormResponseData, AppLookupResponse, AppFormValue} from '@mattermost/types/apps';
import {DialogElement} from '@mattermost/types/integrations';
import {AppCallResponseTypes, AppFieldTypes} from 'mattermost-redux/constants/apps';

import {DoAppCallResult} from 'types/apps';

import SpinnerButton from 'components/spinner_button';
import LoadingSpinner from 'components/widgets/loading/loading_spinner';
import SuggestionList from 'components/suggestion/suggestion_list';
import ModalSuggestionList from 'components/suggestion/modal_suggestion_list';

import {localizeMessage} from 'utils/utils';

import {filterEmptyOptions} from 'utils/apps';
import Markdown from 'components/markdown';

import AppsFormField from './apps_form_field';
import AppsFormHeader from './apps_form_header';

import './apps_form_component.scss';

export type AppsFormProps = {
    form: AppForm;
    isEmbedded?: boolean;
    onExited: () => void;
    actions: {
        submit: (submission: {
            values: AppFormValues;
        }) => Promise<DoAppCallResult<FormResponseData>>;
        performLookupCall: (field: AppField, values: AppFormValues, userInput: string) => Promise<DoAppCallResult<AppLookupResponse>>;
        refreshOnSelect: (field: AppField, values: AppFormValues) => Promise<DoAppCallResult<FormResponseData>>;
    };
}

export type Props = AppsFormProps & WrappedComponentProps<'intl'>;

export type State = {
    show: boolean;
    values: AppFormValues;
    formError: string | null;
    fieldErrors: {[name: string]: React.ReactNode};
    loading: boolean;
    submitting: string | null;
    form: AppForm;
}

const initFormValues = (form: AppForm): AppFormValues => {
    const values: AppFormValues = {};
    if (form && form.fields) {
        form.fields.forEach((f) => {
            let defaultValue: AppFormValue = null;
            if (f.type === AppFieldTypes.BOOL) {
                defaultValue = false;
            }

            values[f.name] = f.value || defaultValue;
        });
    }

    return values;
};

export class AppsForm extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        const {form} = props;
        const values = initFormValues(form);

        this.state = {
            loading: false,
            show: true,
            values,
            formError: null,
            fieldErrors: {},
            submitting: null,
            form,
        };
    }

    static getDerivedStateFromProps(nextProps: Props, prevState: State) {
        if (nextProps.form !== prevState.form) {
            return {
                values: initFormValues(nextProps.form),
                form: nextProps.form,
            };
        }

        return null;
    }

    updateErrors = (elements: DialogElement[], fieldErrors?: {[x: string]: string}, formError?: string): boolean => {
        let hasErrors = false;
        const state = {} as State;

        if (formError) {
            hasErrors = true;
            state.formError = formError;
        }

        if (fieldErrors && Object.keys(fieldErrors).length >= 0) {
            hasErrors = true;
            if (checkIfErrorsMatchElements(fieldErrors as any, elements)) {
                state.fieldErrors = {};
                for (const [key, value] of Object.entries(fieldErrors)) {
                    state.fieldErrors[key] = (<Markdown message={value}/>);
                }
            } else if (!state.formError) {
                const field = Object.keys(fieldErrors)[0];
                state.formError = this.props.intl.formatMessage({
                    id: 'apps.error.responses.unknown_field_error',
                    defaultMessage: 'Received an error for an unknown field. Field name: `{field}`. Error:\n{error}',
                }, {
                    field,
                    error: fieldErrors[field],
                });
            }
        }

        if (hasErrors) {
            this.setState(state);
        }

        return hasErrors;
    }

    handleSubmit = async (e: React.FormEvent, submitName?: string, value?: string) => {
        e.preventDefault();

        const {fields} = this.props.form;
        const values = this.state.values;
        if (submitName && value) {
            values[submitName] = value;
        }

        const fieldErrors: {[name: string]: React.ReactNode} = {};

        const elements = fieldsAsElements(fields);
        elements?.forEach((element) => {
            const error = checkDialogElementForError( // TODO: make sure all required values are present in `element`
                element,
                values[element.name],
            );
            if (error) {
                fieldErrors[element.name] = (
                    <FormattedMessage
                        id={error.id}
                        defaultMessage={error.defaultMessage}
                        values={error.values}
                    />
                );
            }
        });

        this.setState({fieldErrors});
        if (Object.keys(fieldErrors).length !== 0) {
            const formError = this.props.intl.formatMessage({
                id: 'apps.error.form.required_fields_empty',
                defaultMessage: 'Please fix all field errors',
            });

            this.setState({formError});
            return;
        }

        const submission = {
            values,
        };

        let submitting = 'submit';
        if (submitName && value) {
            submitting = value;
        }

        this.setState({submitting, formError: null});
        const res = await this.props.actions.submit(submission);
        this.setState({submitting: null});

        if (res.error) {
            const errorResponse = res.error;
            const errorMessage = errorResponse.text;
            const hasErrors = this.updateErrors(elements, errorResponse.data?.errors, errorMessage);
            if (!hasErrors) {
                this.handleHide(false);
            }
            return;
        }

        const callResponse = res.data as AppCallResponse<FormResponseData>;

        let hasErrors = false;
        let updatedForm = false;
        switch (callResponse.type) {
        case AppCallResponseTypes.FORM:
            updatedForm = true;
            break;
        case AppCallResponseTypes.OK:
        case AppCallResponseTypes.NAVIGATE:
            break;
        default:
            hasErrors = true;
            this.updateErrors([], undefined, this.props.intl.formatMessage({
                id: 'apps.error.responses.unknown_type',
                defaultMessage: 'App response type not supported. Response type: {type}.',
            }, {
                type: callResponse.type,
            }));
        }

        if (!hasErrors && !updatedForm) {
            this.handleHide(true);
        }
    };

    performLookup = async (name: string, userInput: string): Promise<AppSelectOption[]> => {
        const intl = this.props.intl;
        const field = this.props.form.fields?.find((f) => f.name === name);
        if (!field) {
            return [];
        }

        const res = await this.props.actions.performLookupCall(field, this.state.values, userInput);
        if (res.error) {
            const errorResponse = res.error;
            const errMsg = errorResponse.text || intl.formatMessage({
                id: 'apps.error.unknown',
                defaultMessage: 'Unknown error.',
            });
            this.setState({
                fieldErrors: {
                    ...this.state.fieldErrors,
                    [field.name]: errMsg,
                },
            });
            return [];
        }

        const callResp = res.data!;
        switch (callResp.type) {
        case AppCallResponseTypes.OK: {
            let items = callResp.data?.items || [];
            items = items?.filter(filterEmptyOptions);
            return items;
        }
        case AppCallResponseTypes.FORM:
        case AppCallResponseTypes.NAVIGATE: {
            const errMsg = intl.formatMessage({
                id: 'apps.error.responses.unexpected_type',
                defaultMessage: 'App response type was not expected. Response type: {type}.',
            }, {
                type: callResp.type,
            },
            );
            this.setState({
                fieldErrors: {
                    ...this.state.fieldErrors,
                    [field.name]: errMsg,
                },
            });
            return [];
        }
        default: {
            const errMsg = intl.formatMessage({
                id: 'apps.error.responses.unknown_type',
                defaultMessage: 'App response type not supported. Response type: {type}.',
            }, {
                type: callResp.type,
            },
            );
            this.setState({
                fieldErrors: {
                    ...this.state.fieldErrors,
                    [field.name]: errMsg,
                },
            });
            return [];
        }
        }
    }

    onHide = () => {
        this.handleHide(false);
    };

    handleHide = (submitted = false) => {
        const {form} = this.props;

        if (!submitted && form.submit_on_cancel) {
            // const dialog = {
            //     url,
            //     callback_id: callbackId,
            //     state,
            //     cancelled: true,
            // };

            // this.props.actions.submit(dialog);
        }

        this.setState({show: false});
    };

    onChange = (name: string, value: any) => {
        const field = this.props.form.fields?.find((f) => f.name === name);
        if (!field) {
            return;
        }

        const values = {...this.state.values, [name]: value};

        if (field.refresh) {
            this.setState({loading: true});
            this.props.actions.refreshOnSelect(field, values).then((res) => {
                this.setState({loading: false});
                if (res.error) {
                    const errorResponse = res.error;
                    const errorMsg = errorResponse.text;
                    const errors = errorResponse.data?.errors;
                    const elements = fieldsAsElements(this.props.form.fields);
                    this.updateErrors(elements, errors, errorMsg);
                    return;
                }

                const callResponse = res.data!;
                switch (callResponse.type) {
                case AppCallResponseTypes.FORM:
                    return;
                case AppCallResponseTypes.OK:
                case AppCallResponseTypes.NAVIGATE:
                    this.updateErrors([], undefined, this.props.intl.formatMessage({
                        id: 'apps.error.responses.unexpected_type',
                        defaultMessage: 'App response type was not expected. Response type: {type}.',
                    }, {
                        type: callResponse.type,
                    }));
                    return;
                default:
                    this.updateErrors([], undefined, this.props.intl.formatMessage({
                        id: 'apps.error.responses.unknown_type',
                        defaultMessage: 'App response type not supported. Response type: {type}.',
                    }, {
                        type: callResponse.type,
                    }));
                }
            });
        }

        this.setState({values});
    };

    renderModal() {
        const {fields, header} = this.props.form;
        const loading = Boolean(this.state.loading);
        const bodyClass = loading ? 'apps-form-modal-body-loading' : 'apps-form-modal-body-loaded';
        const bodyClassNames = 'apps-form-modal-body-common ' + bodyClass;
        return (
            <Modal
                id='appsModal'
                dialogClassName='a11y__modal about-modal'
                show={this.state.show}
                onHide={this.onHide}
                onExited={this.props.onExited}
                backdrop='static'
                role='dialog'
                aria-labelledby='appsModalLabel'
            >
                <form
                    onSubmit={this.handleSubmit}
                    autoComplete={'off'}
                >
                    <Modal.Header
                        closeButton={true}
                        style={{borderBottom: fields && fields.length ? '' : '0px'}}
                    >
                        <Modal.Title
                            componentClass='h1'
                            id='appsModalLabel'
                        >
                            {this.renderHeader()}
                        </Modal.Title>
                    </Modal.Header>
                    {(fields || header) && (
                        <Modal.Body>
                            <Fade in={loading}>
                                <div
                                    className={
                                        bodyClassNames
                                    }
                                >
                                    <LoadingSpinner style={{fontSize: '24px'}}/>
                                </div>
                            </Fade>
                            {this.renderBody()}
                        </Modal.Body>
                    )}
                    <Modal.Footer>
                        {this.renderFooter()}
                    </Modal.Footer>
                </form>
            </Modal>
        );
    }

    renderEmbedded() {
        const {fields, header} = this.props.form;

        return (
            <form onSubmit={this.handleSubmit}>
                <div>
                    {this.renderHeader()}
                </div>
                {(fields || header) && (
                    <div>
                        {this.renderBody()}
                    </div>
                )}
                <div>
                    {this.renderFooter()}
                </div>
            </form>
        );
    }

    renderHeader() {
        const {
            title,
            icon,
        } = this.props.form;

        let iconComponent;
        if (icon) {
            iconComponent = (
                <img
                    id='appsModalIconUrl'
                    alt={'modal title icon'}
                    className='more-modal__image'
                    width='36'
                    height='36'
                    src={icon}
                />
            );
        }

        return (
            <React.Fragment>
                {iconComponent}
                {title}
            </React.Fragment>
        );
    }

    renderElements() {
        const {isEmbedded, form} = this.props;

        const {fields} = form;
        if (!fields) {
            return null;
        }

        return fields.filter((f) => f.name !== form.submit_buttons).map((field, index) => {
            return (
                <AppsFormField
                    field={field}
                    key={field.name}
                    autoFocus={index === 0}
                    name={field.name}
                    errorText={this.state.fieldErrors[field.name]}
                    value={this.state.values[field.name]}
                    performLookup={this.performLookup}
                    onChange={this.onChange}
                    listComponent={isEmbedded ? SuggestionList : ModalSuggestionList}
                />
            );
        });
    }

    renderBody() {
        const {fields, header} = this.props.form;

        return (fields || header) && (
            <React.Fragment>
                {header && (
                    <AppsFormHeader
                        id='appsModalHeader'
                        value={header}
                    />
                )}
                {this.renderElements()}
            </React.Fragment>
        );
    }

    renderFooter() {
        const {fields} = this.props.form;

        const submitText: React.ReactNode = (
            <FormattedMessage
                id='interactive_dialog.submit'
                defaultMessage='Submit'
            />
        );

        let submitButtons = [(
            <SpinnerButton
                id='appsModalSubmit'
                key='submit'
                type='submit'
                autoFocus={!fields || fields.length === 0}
                className='btn btn-primary save-button'
                spinning={Boolean(this.state.submitting)}
                spinningText={localizeMessage(
                    'interactive_dialog.submitting',
                    'Submitting...',
                )}
            >
                {submitText}
            </SpinnerButton>
        )];

        if (this.props.form.submit_buttons) {
            const field = fields?.find((f) => f.name === this.props.form.submit_buttons);
            if (field) {
                const buttons = field.options?.map((o) => (
                    <SpinnerButton
                        id={'appsModalSubmit' + o.value}
                        key={o.value}
                        type='submit'
                        className='btn btn-primary save-button'
                        spinning={this.state.submitting === o.value}
                        spinningText={o.label}
                        onClick={(e: React.MouseEvent) => this.handleSubmit(e, field.name, o.value)}
                    >
                        {o.label}
                    </SpinnerButton>
                ));
                if (buttons) {
                    submitButtons = buttons;
                }
            }
        }

        return (
            <React.Fragment>
                <div>
                    {this.state.formError && (
                        <div>
                            <div className='error-text'>
                                <Markdown message={this.state.formError}/>
                            </div>
                        </div>
                    )}
                    <button
                        id='appsModalCancel'
                        type='button'
                        className='btn btn-link cancel-button'
                        onClick={this.onHide}
                    >
                        <FormattedMessage
                            id='interactive_dialog.cancel'
                            defaultMessage='Cancel'
                        />
                    </button>
                    {submitButtons}
                </div>
            </React.Fragment>
        );
    }

    render() {
        return this.props.isEmbedded ? this.renderEmbedded() : this.renderModal();
    }
}

function fieldsAsElements(fields?: AppField[]): DialogElement[] {
    return fields?.map((f) => ({
        name: f.name,
        type: f.type,
        subtype: f.subtype,
        optional: !f.is_required,
    })) as DialogElement[];
}

export default injectIntl(AppsForm);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {injectIntl, IntlShape} from 'react-intl';

import {AppContext, AppField, AppForm, AppFormValues, FormResponseData, AppLookupResponse} from '@mattermost/types/apps';
import {AppCallResponseTypes} from 'mattermost-redux/constants/apps';

import {DoAppSubmit, DoAppFetchForm, DoAppLookup, DoAppCallResult, PostEphemeralCallResponseForContext} from 'types/apps';
import {createCallRequest, makeCallErrorResponse} from 'utils/apps';

import AppsForm from './apps_form_component';

type Props = {
    intl: IntlShape;
    form?: AppForm;
    context?: AppContext;
    onExited: () => void;
    actions: {
        doAppSubmit: DoAppSubmit<any>;
        doAppFetchForm: DoAppFetchForm<any>;
        doAppLookup: DoAppLookup<any>;
        postEphemeralCallResponseForContext: PostEphemeralCallResponseForContext;
    };
};

type State = {
    form?: AppForm;
}

class AppsFormContainer extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);
        this.state = {form: props.form};
    }

    submitForm = async (submission: {values: AppFormValues}): Promise<DoAppCallResult<FormResponseData>> => {
        const makeErrorMsg = (msg: string) => {
            return this.props.intl.formatMessage(
                {
                    id: 'apps.error.form.submit.pretext',
                    defaultMessage: 'There has been an error submitting the modal. Contact the app developer. Details: {details}',
                },
                {details: msg},
            );
        };
        const {form} = this.state;
        if (!form) {
            const errMsg = this.props.intl.formatMessage({id: 'apps.error.form.no_form', defaultMessage: '`form` is not defined'});
            return {error: makeCallErrorResponse(makeErrorMsg(errMsg))};
        }
        if (!form.submit) {
            const errMsg = this.props.intl.formatMessage({id: 'apps.error.form.no_submit', defaultMessage: '`submit` is not defined'});
            return {error: makeCallErrorResponse(makeErrorMsg(errMsg))};
        }
        if (!this.props.context) {
            return {error: makeCallErrorResponse('unreachable: empty context')};
        }

        const creq = createCallRequest(form.submit, this.props.context, {}, submission.values);
        const res = await this.props.actions.doAppSubmit(creq, this.props.intl) as DoAppCallResult<FormResponseData>;
        if (res.error) {
            return res;
        }

        const callResp = res.data!;
        switch (callResp.type) {
        case AppCallResponseTypes.OK:
            if (callResp.text) {
                this.props.actions.postEphemeralCallResponseForContext(
                    callResp,
                    callResp.text,
                    creq.context,
                );
            }
            break;
        case AppCallResponseTypes.FORM:
            this.setState({form: callResp.form});
            break;
        case AppCallResponseTypes.NAVIGATE:
        default:
            return {error: makeCallErrorResponse(makeErrorMsg(this.props.intl.formatMessage(
                {
                    id: 'apps.error.responses.unknown_type',
                    defaultMessage: 'App response type not supported. Response type: {type}.',
                }, {
                    type: callResp.type,
                },
            )))};
        }
        return res;
    };

    refreshOnSelect = async (field: AppField, values: AppFormValues): Promise<DoAppCallResult<FormResponseData>> => {
        const makeErrMsg = (message: string) => this.props.intl.formatMessage(
            {
                id: 'apps.error.form.refresh',
                defaultMessage: 'There has been an error updating the modal. Contact the app developer. Details: {details}',
            },
            {details: message},
        );

        const {form} = this.state;
        if (!form) {
            return {error: makeCallErrorResponse(makeErrMsg(this.props.intl.formatMessage({
                id: 'apps.error.form.no_form',
                defaultMessage: '`form` is not defined.',
            })))};
        }
        if (!form.source) {
            return {error: makeCallErrorResponse(makeErrMsg(this.props.intl.formatMessage({
                id: 'apps.error.form.no_source',
                defaultMessage: '`source` is not defined.',
            })))};
        }
        if (!field.refresh) {
            // Should never happen
            return {error: makeCallErrorResponse(makeErrMsg(this.props.intl.formatMessage({
                id: 'apps.error.form.refresh_no_refresh',
                defaultMessage: 'Called refresh on no refresh field.',
            })))};
        }
        if (!this.props.context) {
            return {error: makeCallErrorResponse('unreachable: empty context')};
        }

        const creq = createCallRequest(form.source, this.props.context, {}, values);
        creq.selected_field = field.name;

        const res = await this.props.actions.doAppFetchForm(creq, this.props.intl);
        if (res.error) {
            return res;
        }

        const callResp = res.data!;
        switch (callResp.type) {
        case AppCallResponseTypes.FORM:
            this.setState({form: callResp.form});
            break;
        case AppCallResponseTypes.OK:
        case AppCallResponseTypes.NAVIGATE:
            return {error: makeCallErrorResponse(makeErrMsg(this.props.intl.formatMessage({
                id: 'apps.error.responses.unexpected_type',
                defaultMessage: 'App response type was not expected. Response type: {type}.',
            }, {
                type: callResp.type,
            },
            )))};
        default:
            return {error: makeCallErrorResponse(makeErrMsg(this.props.intl.formatMessage({
                id: 'apps.error.responses.unknown_type',
                defaultMessage: 'App response type not supported. Response type: {type}.',
            }, {
                type: callResp.type,
            },
            )))};
        }
        return res;
    };

    performLookupCall = async (field: AppField, values: AppFormValues, userInput: string): Promise<DoAppCallResult<AppLookupResponse>> => {
        const intl = this.props.intl;
        const makeErrorMsg = (message: string) => intl.formatMessage(
            {
                id: 'apps.error.form.refresh',
                defaultMessage: 'There has been an error fetching the select fields. Contact the app developer. Details: {details}',
            },
            {details: message},
        );
        if (!field.lookup) {
            return {error: makeCallErrorResponse(makeErrorMsg(intl.formatMessage({
                id: 'apps.error.form.no_lookup',
                defaultMessage: '`lookup` is not defined.',
            })))};
        }
        if (!this.props.context) {
            return {error: makeCallErrorResponse('unreachable: empty context')};
        }

        const creq = createCallRequest(field.lookup, this.props.context, {}, values);
        creq.selected_field = field.name;
        creq.query = userInput;

        return this.props.actions.doAppLookup(creq, intl);
    }

    render() {
        const {form} = this.state;

        if (!form?.submit || !this.props.context) {
            return null;
        }

        return (
            <AppsForm
                form={form}
                onExited={this.props.onExited}
                actions={{
                    submit: this.submitForm,
                    performLookupCall: this.performLookupCall,
                    refreshOnSelect: this.refreshOnSelect,
                }}
            />
        );
    }
}

// Exported for tests
export {AppsFormContainer as RawAppsFormContainer};

export default injectIntl(AppsFormContainer);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {ActionFunc, GenericAction} from 'mattermost-redux/types/actions';
import {DoAppSubmit, DoAppFetchForm, DoAppLookup, PostEphemeralCallResponseForContext} from 'types/apps';

import {doAppSubmit, doAppFetchForm, doAppLookup, postEphemeralCallResponseForContext} from 'actions/apps';

import AppsFormContainer from './apps_form_container';

type Actions = {
    doAppSubmit: DoAppSubmit<any>;
    doAppFetchForm: DoAppFetchForm<any>;
    doAppLookup: DoAppLookup<any>;
    postEphemeralCallResponseForContext: PostEphemeralCallResponseForContext;
};

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc>, Actions>({
            doAppSubmit,
            doAppFetchForm,
            doAppLookup,
            postEphemeralCallResponseForContext,
        }, dispatch),
    };
}

export default connect(null, mapDispatchToProps)(AppsFormContainer);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {Client4} from 'mattermost-redux/client';
import {Action, ActionFunc, DispatchFunc} from 'mattermost-redux/types/actions';
import {AppCallResponse, AppForm, AppCallRequest, AppContext, AppBinding} from '@mattermost/types/apps';
import {AppCallResponseTypes} from 'mattermost-redux/constants/apps';
import {Post} from '@mattermost/types/posts';
import {CommandArgs} from '@mattermost/types/integrations';

import {openModal} from 'actions/views/modals';

import AppsForm from 'components/apps_form';

import {ModalIdentifiers} from 'utils/constants';
import {getSiteURL, shouldOpenInNewTab} from 'utils/url';
import {getHistory} from 'utils/browser_history';
import {createCallRequest, makeCallErrorResponse} from 'utils/apps';

import {cleanForm} from 'mattermost-redux/utils/apps';

import {sendEphemeralPost} from './global_actions';

export function handleBindingClick<Res=unknown>(binding: AppBinding, context: AppContext, intl: any): ActionFunc {
    return async (dispatch: DispatchFunc) => {
        // Fetch form
        let form = binding.form;
        if (form?.source) {
            const callRequest = createCallRequest(form.source, context);
            const res = await dispatch(doAppFetchForm<Res>(callRequest, intl));
            if (res.error) {
                return res;
            }
            form = res.data.form;
        }

        // Open form
        if (form) {
            // This should come properly formed, but using preventive checks
            if (!form?.submit) {
                const errMsg = intl.formatMessage({
                    id: 'apps.error.malformed_binding',
                    defaultMessage: 'This binding is not properly formed. Contact the App developer.',
                });
                return {error: makeCallErrorResponse(errMsg)};
            }

            const res: AppCallResponse = {
                type: AppCallResponseTypes.FORM,
                form,
            };
            return {data: res};
        }

        // Submit binding
        // This should come properly formed, but using preventive checks
        if (!binding.submit) {
            const errMsg = intl.formatMessage({
                id: 'apps.error.malformed_binding',
                defaultMessage: 'This binding is not properly formed. Contact the App developer.',
            });
            return {error: makeCallErrorResponse(errMsg)};
        }

        const callRequest = createCallRequest(
            binding.submit,
            context,
        );

        const res = await dispatch(doAppSubmit<Res>(callRequest, intl));
        return res;
    };
}

export function doAppSubmit<Res=unknown>(inCall: AppCallRequest, intl: any): ActionFunc {
    return async () => {
        try {
            const call: AppCallRequest = {
                ...inCall,
                context: {
                    ...inCall.context,
                    track_as_submit: true,
                },
            };
            const res = await Client4.executeAppCall(call, true) as AppCallResponse<Res>;
            const responseType = res.type || AppCallResponseTypes.OK;

            switch (responseType) {
            case AppCallResponseTypes.OK:
                return {data: res};
            case AppCallResponseTypes.ERROR:
                return {error: res};
            case AppCallResponseTypes.FORM:
                if (!res.form?.submit) {
                    const errMsg = intl.formatMessage({
                        id: 'apps.error.responses.form.no_form',
                        defaultMessage: 'Response type is `form`, but no valid form was included in response.',
                    });
                    return {error: makeCallErrorResponse(errMsg)};
                }

                cleanForm(res.form);
                return {data: res};

            case AppCallResponseTypes.NAVIGATE: {
                if (!res.navigate_to_url) {
                    const errMsg = intl.formatMessage({
                        id: 'apps.error.responses.navigate.no_url',
                        defaultMessage: 'Response type is `navigate`, but no url was included in response.',
                    });
                    return {error: makeCallErrorResponse(errMsg)};
                }
                if (shouldOpenInNewTab(res.navigate_to_url, getSiteURL())) {
                    window.open(res.navigate_to_url);
                    return {data: res};
                }
                const navigateURL = res.navigate_to_url.startsWith(getSiteURL()) ?
                    res.navigate_to_url.slice(getSiteURL().length) :
                    res.navigate_to_url;
                getHistory().push(navigateURL);
                return {data: res};
            }
            default: {
                const errMsg = intl.formatMessage({
                    id: 'apps.error.responses.unknown_type',
                    defaultMessage: 'App response type not supported. Response type: {type}.',
                }, {type: responseType});
                return {error: makeCallErrorResponse(errMsg)};
            }
            }
        } catch (error: any) {
            const errMsg = error.message || intl.formatMessage({
                id: 'apps.error.responses.unexpected_error',
                defaultMessage: 'Received an unexpected error.',
            });
            return {error: makeCallErrorResponse(errMsg)};
        }
    };
}

export function doAppFetchForm<Res=unknown>(call: AppCallRequest, intl: any): ActionFunc {
    return async () => {
        try {
            const res = await Client4.executeAppCall(call, false) as AppCallResponse<Res>;
            const responseType = res.type || AppCallResponseTypes.OK;

            switch (responseType) {
            case AppCallResponseTypes.ERROR:
                return {error: res};
            case AppCallResponseTypes.FORM:
                if (!res.form?.submit) {
                    const errMsg = intl.formatMessage({
                        id: 'apps.error.responses.form.no_form',
                        defaultMessage: 'Response type is `form`, but no valid form was included in response.',
                    });
                    return {error: makeCallErrorResponse(errMsg)};
                }
                cleanForm(res.form);
                return {data: res};
            default: {
                const errMsg = intl.formatMessage({
                    id: 'apps.error.responses.unknown_type',
                    defaultMessage: 'App response type not supported. Response type: {type}.',
                }, {type: responseType});
                return {error: makeCallErrorResponse(errMsg)};
            }
            }
        } catch (error: any) {
            const errMsg = error.message || intl.formatMessage({
                id: 'apps.error.responses.unexpected_error',
                defaultMessage: 'Received an unexpected error.',
            });
            return {error: makeCallErrorResponse(errMsg)};
        }
    };
}

export function doAppLookup<Res=unknown>(call: AppCallRequest, intl: any): ActionFunc {
    return async () => {
        try {
            const res = await Client4.executeAppCall(call, false) as AppCallResponse<Res>;
            const responseType = res.type || AppCallResponseTypes.OK;

            switch (responseType) {
            case AppCallResponseTypes.OK:
                return {data: res};
            case AppCallResponseTypes.ERROR:
                return {error: res};

            default: {
                const errMsg = intl.formatMessage({
                    id: 'apps.error.responses.unknown_type',
                    defaultMessage: 'App response type not supported. Response type: {type}.',
                }, {type: responseType});
                return {error: makeCallErrorResponse(errMsg)};
            }
            }
        } catch (error: any) {
            const errMsg = error.message || intl.formatMessage({
                id: 'apps.error.responses.unexpected_error',
                defaultMessage: 'Received an unexpected error.',
            });
            return {error: makeCallErrorResponse(errMsg)};
        }
    };
}

export function makeFetchBindings(location: string): (userId: string, channelId: string, teamId: string) => ActionFunc {
    return (userId: string, channelId: string, teamId: string): ActionFunc => {
        return async () => {
            try {
                const allBindings = await Client4.getAppsBindings(userId, channelId, teamId);
                const headerBindings = allBindings.filter((b) => b.location === location);
                const bindings = headerBindings.reduce((accum: AppBinding[], current: AppBinding) => accum.concat(current.bindings || []), []);
                return {data: bindings};
            } catch {
                return {data: []};
            }
        };
    };
}

export function openAppsModal(form: AppForm, context: AppContext): Action {
    return openModal({
        modalId: ModalIdentifiers.APPS_MODAL,
        dialogType: AppsForm,
        dialogProps: {
            form,
            context,
        },
    });
}

export function postEphemeralCallResponseForPost(response: AppCallResponse, message: string, post: Post): ActionFunc {
    return sendEphemeralPost(
        message,
        post.channel_id,
        post.root_id || post.id,
        response.app_metadata?.bot_user_id,
    );
}

export function postEphemeralCallResponseForChannel(response: AppCallResponse, message: string, channelID: string): ActionFunc {
    return sendEphemeralPost(
        message,
        channelID,
        '',
        response.app_metadata?.bot_user_id,
    );
}

export function postEphemeralCallResponseForContext(response: AppCallResponse, message: string, context: AppContext): ActionFunc {
    return sendEphemeralPost(
        message,
        context.channel_id,
        context.root_id || context.post_id,
        response.app_metadata?.bot_user_id,
    );
}

export function postEphemeralCallResponseForCommandArgs(response: AppCallResponse, message: string, args: CommandArgs): ActionFunc {
    return sendEphemeralPost(
        message,
        args.channel_id,
        args.root_id,
        response.app_metadata?.bot_user_id,
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {Stripe} from '@stripe/stripe-js';
import {getCode} from 'country-list';

import {getCloudCustomer, getCloudProducts, getCloudSubscription, getInvoices} from 'mattermost-redux/actions/cloud';
import {Client4} from 'mattermost-redux/client';
import {getCloudErrors} from 'mattermost-redux/selectors/entities/cloud';
import {ActionFunc, DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';

import {getConfirmCardSetup} from 'components/payment_form/stripe';

import {trackEvent} from 'actions/telemetry_actions.jsx';

import {StripeSetupIntent, BillingDetails} from 'types/cloud/sku';
import {CloudTypes} from 'mattermost-redux/action_types';

// Returns true for success, and false for any error
export function completeStripeAddPaymentMethod(
    stripe: Stripe,
    billingDetails: BillingDetails,
    isDevMode: boolean,
) {
    return async () => {
        let paymentSetupIntent: StripeSetupIntent;
        try {
            paymentSetupIntent = await Client4.createPaymentMethod() as StripeSetupIntent;
        } catch (error) {
            return error;
        }
        const cardSetupFunction = getConfirmCardSetup(isDevMode);
        const confirmCardSetup = cardSetupFunction(stripe.confirmCardSetup);

        const result = await confirmCardSetup(
            paymentSetupIntent.client_secret,
            {
                payment_method: {
                    card: billingDetails.card,
                    billing_details: {
                        name: billingDetails.name,
                        address: {
                            line1: billingDetails.address,
                            line2: billingDetails.address2,
                            city: billingDetails.city,
                            state: billingDetails.state,
                            country: getCode(billingDetails.country),
                            postal_code: billingDetails.postalCode,
                        },
                    },
                },
            },
        );

        if (!result) {
            return false;
        }

        const {setupIntent, error: stripeError} = result;

        if (stripeError) {
            return false;
        }

        if (setupIntent == null) {
            return false;
        }

        if (setupIntent.status !== 'succeeded') {
            return false;
        }

        try {
            await Client4.confirmPaymentMethod(setupIntent.id);
        } catch (error) {
            return false;
        }

        return true;
    };
}

export function subscribeCloudSubscription(productId: string, seats = 0) {
    return async () => {
        try {
            await Client4.subscribeCloudProduct(productId, seats);
        } catch (error) {
            return error;
        }
        return true;
    };
}

export function requestCloudTrial(page: string, subscriptionId: string, email = ''): ActionFunc {
    trackEvent('api', 'api_request_cloud_trial_license', {from_page: page});
    return async (dispatch: DispatchFunc): Promise<any> => {
        try {
            const newSubscription = await Client4.requestCloudTrial(subscriptionId, email);
            dispatch({
                type: CloudTypes.RECEIVED_CLOUD_SUBSCRIPTION,
                data: newSubscription.data,
            });
        } catch (error) {
            return false;
        }
        return true;
    };
}

export function validateBusinessEmail(email = '') {
    trackEvent('api', 'api_validate_business_email');
    return async () => {
        try {
            const res = await Client4.validateBusinessEmail(email);
            return res.data.is_valid;
        } catch (error) {
            return false;
        }
    };
}

export function validateWorkspaceBusinessEmail() {
    trackEvent('api', 'api_validate_workspace_business_email');
    return async () => {
        try {
            const res = await Client4.validateWorkspaceBusinessEmail();
            return res.data.is_valid;
        } catch (error) {
            return false;
        }
    };
}

export function getCloudLimits(): ActionFunc {
    return async (dispatch: DispatchFunc) => {
        try {
            dispatch({
                type: CloudTypes.CLOUD_LIMITS_REQUEST,
            });
            const result = await Client4.getCloudLimits();
            if (result) {
                dispatch({
                    type: CloudTypes.RECEIVED_CLOUD_LIMITS,
                    data: result,
                });
            }
        } catch (error) {
            dispatch({
                type: CloudTypes.CLOUD_LIMITS_FAILED,
            });
            return error;
        }
        return true;
    };
}

export function getMessagesUsage(): ActionFunc {
    return async (dispatch: DispatchFunc) => {
        try {
            const result = await Client4.getPostsUsage();
            if (result) {
                dispatch({
                    type: CloudTypes.RECEIVED_MESSAGES_USAGE,
                    data: result.count,
                });
            }
        } catch (error) {
            return error;
        }
        return true;
    };
}

export function getFilesUsage(): ActionFunc {
    return async (dispatch: DispatchFunc) => {
        try {
            const result = await Client4.getFilesUsage();

            if (result) {
                // match limit notation in bits
                const inBits = result.bytes * 8;
                dispatch({
                    type: CloudTypes.RECEIVED_FILES_USAGE,
                    data: inBits,
                });
            }
        } catch (error) {
            return error;
        }
        return {data: true};
    };
}

export function getBoardsUsage(): ActionFunc {
    return async (dispatch: DispatchFunc) => {
        try {
            const result = await Client4.getBoardsUsage();
            if (result) {
                dispatch({
                    type: CloudTypes.RECEIVED_BOARDS_USAGE,

                    // the views and cards properties are the limits, not usage.
                    // So they are not passed in to the usage.
                    data: result.used_cards,
                });
            }
        } catch (error) {
            return error;
        }
        return {data: true};
    };
}

export function getTeamsUsage(): ActionFunc {
    return async (dispatch: DispatchFunc) => {
        try {
            const result = await Client4.getTeamsUsage();
            if (result) {
                dispatch({
                    type: CloudTypes.RECEIVED_TEAMS_USAGE,
                    data: {active: result.active, cloudArchived: result.cloud_archived},
                });
            }
        } catch (error) {
            return error;
        }
        return {data: false};
    };
}

export function retryFailedCloudFetches() {
    return (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const errors = getCloudErrors(getState());
        if (Object.keys(errors).length === 0) {
            return {data: true};
        }

        if (errors.subscription) {
            dispatch(getCloudSubscription());
        }

        if (errors.products) {
            dispatch(getCloudProducts());
        }

        if (errors.customer) {
            dispatch(getCloudCustomer());
        }

        if (errors.invoices) {
            dispatch(getInvoices());
        }

        if (errors.limits) {
            getCloudLimits()(dispatch, getState);
        }

        return {data: true};
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {Client4} from 'mattermost-redux/client';
import {unfavoriteChannel} from 'mattermost-redux/actions/channels';
import {savePreferences} from 'mattermost-redux/actions/preferences';
import {getCurrentChannel, getRedirectChannelNameForTeam, isFavoriteChannel} from 'mattermost-redux/selectors/entities/channels';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {getCurrentRelativeTeamUrl, getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {appsEnabled} from 'mattermost-redux/selectors/entities/apps';
import {IntegrationTypes} from 'mattermost-redux/action_types';
import {ActionFunc, DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';
import type {CommandArgs} from '@mattermost/types/integrations';

import {AppCallResponseTypes} from 'mattermost-redux/constants/apps';

import {DoAppCallResult} from 'types/apps';

import {openModal} from 'actions/views/modals';
import * as GlobalActions from 'actions/global_actions';
import * as PostActions from 'actions/post_actions';

import {isUrlSafe, getSiteURL} from 'utils/url';
import {localizeMessage, getUserIdFromChannelName, localizeAndFormatMessage} from 'utils/utils';
import * as UserAgent from 'utils/user_agent';
import {Constants, ModalIdentifiers} from 'utils/constants';
import {getHistory} from 'utils/browser_history';

import UserSettingsModal from 'components/user_settings/modal';
import {AppCommandParser} from 'components/suggestion/command_provider/app_command_parser/app_command_parser';
import {intlShim} from 'components/suggestion/command_provider/app_command_parser/app_command_parser_dependencies';
import LeaveChannelModal from 'components/leave_channel_modal';
import KeyboardShortcutsModal from 'components/keyboard_shortcuts/keyboard_shortcuts_modal/keyboard_shortcuts_modal';

import {GlobalState} from 'types/store';

import {t} from 'utils/i18n';
import MarketplaceModal from 'components/plugin_marketplace';

import {haveICurrentTeamPermission} from 'mattermost-redux/selectors/entities/roles';
import {Permissions} from 'mattermost-redux/constants';
import {isMarketplaceEnabled} from 'mattermost-redux/selectors/entities/general';

import {doAppSubmit, openAppsModal, postEphemeralCallResponseForCommandArgs} from './apps';
import {trackEvent} from './telemetry_actions';

export function executeCommand(message: string, args: CommandArgs): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState() as GlobalState;

        let msg = message;

        let cmdLength = msg.indexOf(' ');
        if (cmdLength < 0) {
            cmdLength = msg.length;
        }
        const cmd = msg.substring(0, cmdLength).toLowerCase();
        if (cmd === '/code') {
            msg = cmd + ' ' + msg.substring(cmdLength, msg.length).trimEnd();
        } else {
            msg = cmd + ' ' + msg.substring(cmdLength, msg.length).trim();
        }

        // Add track event for certain slash commands
        const commandsWithTelemetry = [
            {command: '/help', telemetry: 'slash-command-help'},
            {command: '/marketplace', telemetry: 'slash-command-marketplace'},
        ];
        for (const command of commandsWithTelemetry) {
            if (msg.startsWith(command.command)) {
                trackEvent('slash-commands', command.telemetry);
                break;
            }
        }

        switch (cmd) {
        case '/search':
            dispatch(PostActions.searchForTerm(msg.substring(cmdLength + 1, msg.length)));
            return {data: true};
        case '/shortcuts':
            if (UserAgent.isMobile()) {
                const error = {message: localizeMessage('create_post.shortcutsNotSupported', 'Keyboard shortcuts are not supported on your device')};
                return {error};
            }

            dispatch(openModal({modalId: ModalIdentifiers.KEYBOARD_SHORTCUTS_MODAL, dialogType: KeyboardShortcutsModal}));
            return {data: true};
        case '/leave': {
            // /leave command not supported in reply threads.
            if (args.channel_id && args.root_id) {
                dispatch(GlobalActions.sendEphemeralPost('/leave is not supported in reply threads. Use it in the center channel instead.', args.channel_id, args.root_id));
                return {data: true};
            }
            const channel = getCurrentChannel(state) || {};
            if (channel.type === Constants.PRIVATE_CHANNEL) {
                dispatch(openModal({modalId: ModalIdentifiers.LEAVE_PRIVATE_CHANNEL_MODAL, dialogType: LeaveChannelModal, dialogProps: {channel}}));
                return {data: true};
            }
            if (
                channel.type === Constants.DM_CHANNEL ||
                channel.type === Constants.GM_CHANNEL
            ) {
                const currentUserId = getCurrentUserId(state);
                let name;
                let category;
                if (channel.type === Constants.DM_CHANNEL) {
                    name = getUserIdFromChannelName(channel);
                    category = Constants.Preferences.CATEGORY_DIRECT_CHANNEL_SHOW;
                } else {
                    name = channel.id;
                    category = Constants.Preferences.CATEGORY_GROUP_CHANNEL_SHOW;
                }
                const currentTeamId = getCurrentTeamId(state);
                const redirectChannel = getRedirectChannelNameForTeam(state, currentTeamId);
                const teamUrl = getCurrentRelativeTeamUrl(state);
                getHistory().push(`${teamUrl}/channels/${redirectChannel}`);

                dispatch(savePreferences(currentUserId, [{category, name, user_id: currentUserId, value: 'false'}]));
                if (isFavoriteChannel(state, channel.id)) {
                    dispatch(unfavoriteChannel(channel.id));
                }

                return {data: true};
            }
            break;
        }
        case '/settings':
            dispatch(openModal({modalId: ModalIdentifiers.USER_SETTINGS, dialogType: UserSettingsModal, dialogProps: {isContentProductSettings: true}}));
            return {data: true};
        case '/marketplace':
            // check if user has permissions to access the read plugins
            if (!haveICurrentTeamPermission(state, Permissions.SYSCONSOLE_READ_PLUGINS)) {
                return {error: {message: localizeMessage('marketplace_command.no_permission', 'You do not have the appropriate permissions to access the marketplace.')}};
            }

            // check config to see if marketplace is enabled
            if (!isMarketplaceEnabled(state)) {
                return {error: {message: localizeMessage('marketplace_command.disabled', 'The marketplace is disabled. Please contact your System Administrator for details.')}};
            }

            dispatch(openModal({modalId: ModalIdentifiers.PLUGIN_MARKETPLACE, dialogType: MarketplaceModal}));
            return {data: true};
        case '/collapse':
        case '/expand':
            dispatch(PostActions.resetEmbedVisibility());
            dispatch(PostActions.resetInlineImageVisibility());
        }

        if (appsEnabled(state)) {
            const getGlobalState = () => getState() as GlobalState;
            const createErrorMessage = (errMessage: string) => {
                return {error: {message: errMessage}};
            };
            const parser = new AppCommandParser({dispatch, getState: getGlobalState} as any, intlShim, args.channel_id, args.team_id, args.root_id);
            if (parser.isAppCommand(msg)) {
                try {
                    const {creq, errorMessage} = await parser.composeCommandSubmitCall(msg);
                    if (!creq) {
                        return createErrorMessage(errorMessage!);
                    }

                    const res = await dispatch(doAppSubmit(creq, intlShim)) as DoAppCallResult;

                    if (res.error) {
                        const errorResponse = res.error;
                        return createErrorMessage(errorResponse.text || intlShim.formatMessage({
                            id: 'apps.error.unknown',
                            defaultMessage: 'Unknown error.',
                        }));
                    }

                    const callResp = res.data!;
                    switch (callResp.type) {
                    case AppCallResponseTypes.OK:
                        if (callResp.text) {
                            dispatch(postEphemeralCallResponseForCommandArgs(callResp, callResp.text, args));
                        }
                        return {data: true};
                    case AppCallResponseTypes.FORM:
                        if (callResp.form) {
                            dispatch(openAppsModal(callResp.form, creq.context));
                        }
                        return {data: true};
                    case AppCallResponseTypes.NAVIGATE:
                        return {data: true};
                    default:
                        return createErrorMessage(localizeAndFormatMessage(
                            t('apps.error.responses.unknown_type'),
                            'App response type not supported. Response type: {type}.',
                            {type: callResp.type},
                        ));
                    }
                } catch (err: any) {
                    return createErrorMessage(err.message || localizeMessage('apps.error.unknown', 'Unknown error.'));
                }
            }
        }

        let data;
        try {
            data = await Client4.executeCommand(msg, args);
        } catch (err) {
            return {error: err};
        }

        const hasGotoLocation = data.goto_location && isUrlSafe(data.goto_location);

        if (msg.trim() === '/logout') {
            GlobalActions.emitUserLoggedOutEvent(hasGotoLocation ? data.goto_location : '/');
            return {data: true};
        }

        if (data.trigger_id) {
            dispatch({type: IntegrationTypes.RECEIVED_DIALOG_TRIGGER_ID, data: data.trigger_id});
        }

        if (hasGotoLocation) {
            if (data.goto_location.startsWith('/')) {
                getHistory().push(data.goto_location);
            } else if (data.goto_location.startsWith(getSiteURL())) {
                getHistory().push(data.goto_location.substr(getSiteURL().length));
            } else {
                window.open(data.goto_location);
            }
        }

        return {data: true};
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal} from 'react-bootstrap';

import MenuWrapper from '../../menu_wrapper';
import Menu from '../../menu';
import SubMenuItem from '../../menu_items/submenu_item';

import * as Utils from 'utils/utils';

import './submenu_modal.scss';

type Props = {
    elements?: Array<React.ComponentProps<typeof SubMenuItem>>;
    onExited: () => void;
}

type State = {
    show: boolean;
}

export default class SubMenuModal extends React.PureComponent<Props, State> {
    public constructor(props: Props) {
        super(props);
        this.state = {
            show: true,
        };
    }

    public onHide = () => { //public because it is used on tests
        this.setState({show: false});
    }

    public render() {
        let SubMenuItems;
        if (this.props.elements) {
            SubMenuItems = this.props.elements.map((element) => {
                return (
                    <Menu.ItemSubMenu
                        key={element.id}
                        id={element.id}
                        text={element.text}
                        subMenu={element.subMenu}
                        action={element.action}
                        filter={element.filter}
                        root={false}
                    />
                );
            });
        }
        return (
            <Modal
                dialogClassName={'SubMenuModal a11y__modal mobile-sub-menu'}
                show={this.state.show}
                onHide={this.onHide}
                onExited={this.props.onExited}
                enforceFocus={false}
                id='submenuModal'
                role='dialog'
            >
                <Modal.Body
                    onClick={this.onHide}
                >
                    <MenuWrapper>
                        <Menu
                            openLeft={true}
                            ariaLabel={Utils.localizeMessage('post_info.submenu.mobile', 'mobile submenu').toLowerCase()}
                        >
                            {SubMenuItems}
                        </Menu>
                        <div/>
                    </MenuWrapper>
                </Modal.Body>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {batchActions} from 'redux-batched-actions';

import {
    fetchMyChannelsAndMembersREST,
    getChannelByNameAndTeamName,
    getChannelStats,
    selectChannel,
} from 'mattermost-redux/actions/channels';
import {logout, loadMe, loadMeREST} from 'mattermost-redux/actions/users';
import {Preferences} from 'mattermost-redux/constants';
import {getConfig, isPerformanceDebuggingEnabled} from 'mattermost-redux/selectors/entities/general';
import {getCurrentTeamId, getMyTeams, getTeam, getMyTeamMember, getTeamMemberships} from 'mattermost-redux/selectors/entities/teams';
import {getBool, isCollapsedThreadsEnabled, isGraphQLEnabled} from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentUser, getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {getCurrentChannelStats, getCurrentChannelId, getMyChannelMember, getRedirectChannelNameForTeam, getChannelsNameMapInTeam, getAllDirectChannels, getChannelMessageCount} from 'mattermost-redux/selectors/entities/channels';
import {appsEnabled} from 'mattermost-redux/selectors/entities/apps';
import {ChannelTypes} from 'mattermost-redux/action_types';
import {fetchAppBindings} from 'mattermost-redux/actions/apps';
import {Channel, ChannelMembership} from '@mattermost/types/channels';
import {UserProfile} from '@mattermost/types/users';
import {Post} from '@mattermost/types/posts';
import {ActionFunc, DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';
import {Team} from '@mattermost/types/teams';
import {calculateUnreadCount} from 'mattermost-redux/utils/channel_utils';

import {getHistory} from 'utils/browser_history';
import {handleNewPost} from 'actions/post_actions';
import {stopPeriodicStatusUpdates} from 'actions/status_actions';
import {loadProfilesForSidebar} from 'actions/user_actions';
import {closeRightHandSide, closeMenu as closeRhsMenu, updateRhsState} from 'actions/views/rhs';
import {clearUserCookie} from 'actions/views/cookie';
import {close as closeLhs} from 'actions/views/lhs';
import * as WebsocketActions from 'actions/websocket_actions.jsx';
import {getCurrentLocale} from 'selectors/i18n';
import {getIsRhsOpen, getPreviousRhsState, getRhsState} from 'selectors/rhs';
import BrowserStore from 'stores/browser_store';
import store from 'stores/redux_store.jsx';
import LocalStorageStore from 'stores/local_storage_store';
import WebSocketClient from 'client/web_websocket_client.jsx';

import {GlobalState} from 'types/store';

import {ActionTypes, PostTypes, RHSStates, ModalIdentifiers, PreviousViewedTypes} from 'utils/constants';
import {filterAndSortTeamsByDisplayName} from 'utils/team_utils';
import * as Utils from 'utils/utils';
import SubMenuModal from '../components/widgets/menu/menu_modals/submenu_modal/submenu_modal';

import {openModal} from './views/modals';

const dispatch = store.dispatch;
const getState = store.getState;

export function emitChannelClickEvent(channel: Channel) {
    function switchToChannel(chan: Channel) {
        const state = getState();
        const userId = getCurrentUserId(state);
        const teamId = chan.team_id || getCurrentTeamId(state);
        const isRHSOpened = getIsRhsOpen(state);
        const isPinnedPostsShowing = getRhsState(state) === RHSStates.PIN;
        const isChannelFilesShowing = getRhsState(state) === RHSStates.CHANNEL_FILES;
        const member = getMyChannelMember(state, chan.id);
        const currentChannelId = getCurrentChannelId(state);
        const previousRhsState = getPreviousRhsState(state);

        dispatch(getChannelStats(chan.id));

        const penultimate = LocalStorageStore.getPreviousChannelName(userId, teamId);
        const penultimateType = LocalStorageStore.getPreviousViewedType(userId, teamId);
        if (penultimate !== chan.name) {
            LocalStorageStore.setPenultimateChannelName(userId, teamId, penultimate);
            LocalStorageStore.setPreviousChannelName(userId, teamId, chan.name);
        }

        if (penultimateType !== PreviousViewedTypes.CHANNELS || penultimate !== chan.name) {
            LocalStorageStore.setPreviousViewedType(userId, teamId, PreviousViewedTypes.CHANNELS);
            LocalStorageStore.setPenultimateViewedType(userId, teamId, penultimateType);
        }

        // When switching to a different channel if the pinned posts is showing
        // Update the RHS state to reflect the pinned post of the selected channel
        if (isRHSOpened && isPinnedPostsShowing) {
            dispatch(updateRhsState(RHSStates.PIN, chan.id, previousRhsState));
        }

        if (isRHSOpened && isChannelFilesShowing) {
            dispatch(updateRhsState(RHSStates.CHANNEL_FILES, chan.id, previousRhsState));
        }

        if (currentChannelId) {
            loadProfilesForSidebar();
        }

        dispatch(batchActions([
            {
                type: ChannelTypes.SELECT_CHANNEL,
                data: chan.id,
            },
            {
                type: ActionTypes.SELECT_CHANNEL_WITH_MEMBER,
                data: chan.id,
                channel: chan,
                member: member || {},
            },
            setLastUnreadChannel(state, chan),
        ]));

        if (appsEnabled(state)) {
            dispatch(fetchAppBindings(chan.id));
        }
    }

    switchToChannel(channel);
}

function setLastUnreadChannel(state: GlobalState, channel: Channel) {
    const member = getMyChannelMember(state, channel.id);
    const messageCount = getChannelMessageCount(state, channel.id);

    let hadMentions = false;
    let hadUnreads = false;
    if (member && messageCount) {
        const crtEnabled = isCollapsedThreadsEnabled(state);

        const unreadCount = calculateUnreadCount(messageCount, member, crtEnabled);

        hadMentions = unreadCount.mentions > 0;
        hadUnreads = unreadCount.showUnread && unreadCount.messages > 0;
    }

    return {
        type: ActionTypes.SET_LAST_UNREAD_CHANNEL,
        channelId: channel.id,
        hadMentions,
        hadUnreads,
    };
}

export const clearLastUnreadChannel = {
    type: ActionTypes.SET_LAST_UNREAD_CHANNEL,
    channelId: '',
};

export function updateNewMessagesAtInChannel(channelId: string, lastViewedAt = Date.now()) {
    return {
        type: ActionTypes.UPDATE_CHANNEL_LAST_VIEWED_AT,
        channel_id: channelId,
        last_viewed_at: lastViewedAt,
    };
}

export function emitCloseRightHandSide() {
    dispatch(closeRightHandSide());
}

export function showMobileSubMenuModal(elements: any[]) { // TODO Use more specific type
    const submenuModalData = {
        modalId: ModalIdentifiers.MOBILE_SUBMENU,
        dialogType: SubMenuModal,
        dialogProps: {
            elements,
        },
    };

    dispatch(openModal(submenuModalData));
}

export function sendEphemeralPost(message: string, channelId?: string, parentId?: string, userId?: string): ActionFunc {
    return (doDispatch: DispatchFunc, doGetState: GetStateFunc) => {
        const timestamp = Utils.getTimestamp();
        const post = {
            id: Utils.generateId(),
            user_id: userId || '0',
            channel_id: channelId || getCurrentChannelId(doGetState()),
            message,
            type: PostTypes.EPHEMERAL,
            create_at: timestamp,
            update_at: timestamp,
            root_id: parentId || '',
            props: {},
        } as Post;

        return doDispatch(handleNewPost(post));
    };
}

export function sendGenericPostMessage(message: string, channelId?: string, parentId?: string, userId?: string): ActionFunc {
    return (doDispatch: DispatchFunc, doGetState: GetStateFunc) => {
        const timestamp = Utils.getTimestamp();
        const post = {
            id: Utils.generateId(),
            user_id: userId || '0',
            channel_id: channelId || getCurrentChannelId(doGetState()),
            message,
            type: PostTypes.SYSTEM_GENERIC,
            create_at: timestamp,
            update_at: timestamp,
            root_id: parentId || '',
            props: {},
        } as Post;

        return doDispatch(handleNewPost(post));
    };
}

export function sendAddToChannelEphemeralPost(user: UserProfile, addedUsername: string, addedUserId: string, channelId: string, postRootId = '', timestamp: number) {
    const post = {
        id: Utils.generateId(),
        user_id: user.id,
        channel_id: channelId || getCurrentChannelId(getState()),
        message: '',
        type: PostTypes.EPHEMERAL_ADD_TO_CHANNEL,
        create_at: timestamp,
        update_at: timestamp,
        root_id: postRootId,
        props: {
            username: user.username,
            addedUsername,
            addedUserId,
        },
    } as unknown as Post;

    dispatch(handleNewPost(post));
}

let lastTimeTypingSent = 0;
export function emitLocalUserTypingEvent(channelId: string, parentPostId: string) {
    const userTyping = async (actionDispatch: DispatchFunc, actionGetState: GetStateFunc) => {
        const state = actionGetState();
        const config = getConfig(state);

        if (
            isPerformanceDebuggingEnabled(state) &&
            getBool(state, Preferences.CATEGORY_PERFORMANCE_DEBUGGING, Preferences.NAME_DISABLE_TYPING_MESSAGES)
        ) {
            return {data: false};
        }

        const t = Date.now();
        const stats = getCurrentChannelStats(state);
        const membersInChannel = stats ? stats.member_count : 0;

        const timeBetweenUserTypingUpdatesMilliseconds = Utils.stringToNumber(config.TimeBetweenUserTypingUpdatesMilliseconds);
        const maxNotificationsPerChannel = Utils.stringToNumber(config.MaxNotificationsPerChannel);

        if (((t - lastTimeTypingSent) > timeBetweenUserTypingUpdatesMilliseconds) &&
            (membersInChannel < maxNotificationsPerChannel) && (config.EnableUserTypingMessages === 'true')) {
            WebSocketClient.userTyping(channelId, parentPostId);
            lastTimeTypingSent = t;
        }

        return {data: true};
    };

    return dispatch(userTyping);
}

export function emitUserLoggedOutEvent(redirectTo = '/', shouldSignalLogout = true, userAction = true) {
    // If the logout was intentional, discard knowledge about having previously been logged in.
    // This bit is otherwise used to detect session expirations on the login page.
    if (userAction) {
        LocalStorageStore.setWasLoggedIn(false);
    }

    dispatch(logout()).then(() => {
        if (shouldSignalLogout) {
            BrowserStore.signalLogout();
        }

        stopPeriodicStatusUpdates();
        WebsocketActions.close();

        clearUserCookie();

        getHistory().push(redirectTo);
    }).catch(() => {
        getHistory().push(redirectTo);
    });
}

export function toggleSideBarRightMenuAction() {
    return (doDispatch: DispatchFunc) => {
        doDispatch(closeRightHandSide());
        doDispatch(closeLhs());
        doDispatch(closeRhsMenu());
    };
}

export function emitBrowserFocus(focus: boolean) {
    dispatch({
        type: ActionTypes.BROWSER_CHANGE_FOCUS,
        focus,
    });
}

export async function getTeamRedirectChannelIfIsAccesible(user: UserProfile, team: Team) {
    let state = getState();
    let channel = null;

    const myMember = getMyTeamMember(state, team.id);
    if (!myMember || Object.keys(myMember).length === 0) {
        return null;
    }

    let teamChannels = getChannelsNameMapInTeam(state, team.id);
    if (!teamChannels || Object.keys(teamChannels).length === 0) {
        // This should be executed in pretty limited scenarios (empty teams)
        await dispatch(fetchMyChannelsAndMembersREST(team.id)); // eslint-disable-line no-await-in-loop
        state = getState();
        teamChannels = getChannelsNameMapInTeam(state, team.id);
    }

    const channelName = LocalStorageStore.getPreviousChannelName(user.id, team.id);
    channel = teamChannels[channelName];

    if (typeof channel === 'undefined') {
        const dmList = getAllDirectChannels(state);
        channel = dmList.find((directChannel) => directChannel.name === channelName);
    }

    let channelMember: ChannelMembership | null | undefined;
    if (channel) {
        channelMember = getMyChannelMember(state, channel.id);
    }

    if (!channel || !channelMember) {
        // This should be executed in pretty limited scenarios (when the last visited channel in the team has been removed)
        await dispatch(getChannelByNameAndTeamName(team.name, channelName)); // eslint-disable-line no-await-in-loop
        state = getState();
        teamChannels = getChannelsNameMapInTeam(state, team.id);
        channel = teamChannels[channelName];
        channelMember = getMyChannelMember(state, channel && channel.id);
    }

    if (!channel || !channelMember) {
        const redirectedChannelName = getRedirectChannelNameForTeam(state, team.id);
        channel = teamChannels[redirectedChannelName];
        channelMember = getMyChannelMember(state, channel && channel.id);
    }

    if (channel && channelMember) {
        return channel;
    }
    return null;
}

export async function redirectUserToDefaultTeam() {
    let state = getState();

    // Assume we need to load the user if they don't have any team memberships loaded or the user loaded
    let user = getCurrentUser(state);
    const shouldLoadUser = Utils.isEmptyObject(getTeamMemberships(state)) || !user;

    if (shouldLoadUser) {
        if (isGraphQLEnabled(state)) {
            await dispatch(loadMe());
        } else {
            await dispatch(loadMeREST());
        }
        state = getState();
        user = getCurrentUser(state);
    }

    if (!user) {
        return;
    }

    const locale = getCurrentLocale(state);
    const teamId = LocalStorageStore.getPreviousTeamId(user.id);

    let myTeams = getMyTeams(state);
    if (myTeams.length === 0) {
        getHistory().push('/select_team');
        return;
    }

    let team: Team | undefined;
    if (teamId) {
        team = getTeam(state, teamId);
    }

    if (team && team.delete_at === 0) {
        const channel = await getTeamRedirectChannelIfIsAccesible(user, team);
        if (channel) {
            dispatch(selectChannel(channel.id));
            getHistory().push(`/${team.name}/channels/${channel.name}`);
            return;
        }
    }

    myTeams = filterAndSortTeamsByDisplayName(myTeams, locale);

    for (const myTeam of myTeams) {
        // This should execute async behavior in a pretty limited set of situations, so shouldn't be a problem
        const channel = await getTeamRedirectChannelIfIsAccesible(user, myTeam); // eslint-disable-line no-await-in-loop
        if (channel) {
            dispatch(selectChannel(channel.id));
            getHistory().push(`/${myTeam.name}/channels/${channel.name}`);
            return;
        }
    }

    getHistory().push('/select_team');
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

export function runMessageWillBePostedHooks(originalPost) {
    return async (dispatch, getState) => {
        const hooks = getState().plugins.components.MessageWillBePosted;
        if (!hooks || hooks.length === 0) {
            return {data: originalPost};
        }

        let post = originalPost;

        for (const hook of hooks) {
            const result = await hook.hook(post); // eslint-disable-line no-await-in-loop

            if (result) {
                if (result.error) {
                    return {
                        error: result.error,
                    };
                }

                post = result.post;
            }
        }

        return {data: post};
    };
}

export function runSlashCommandWillBePostedHooks(originalMessage, originalArgs) {
    return async (dispatch, getState) => {
        const hooks = getState().plugins.components.SlashCommandWillBePosted;
        if (!hooks || hooks.length === 0) {
            return {data: {message: originalMessage, args: originalArgs}};
        }

        let message = originalMessage;
        let args = originalArgs;

        for (const hook of hooks) {
            const result = await hook.hook(message, args); // eslint-disable-line no-await-in-loop

            if (result) {
                if (result.error) {
                    return {
                        error: result.error,
                    };
                }

                message = result.message;
                args = result.args;

                // The first plugin to consume the slash command by returning an empty object
                // should terminate the processing by subsequent plugins.
                if (Object.keys(result).length === 0) {
                    break;
                }
            }
        }

        return {data: {message, args}};
    };
}

export function runMessageWillBeUpdatedHooks(newPost, oldPost) {
    return async (dispatch, getState) => {
        const hooks = getState().plugins.components.MessageWillBeUpdated;
        if (!hooks || hooks.length === 0) {
            return {data: newPost};
        }

        let post = newPost;

        for (const hook of hooks) {
            const result = await hook.hook(post, oldPost); // eslint-disable-line no-await-in-loop

            if (result) {
                if (result.error) {
                    return {
                        error: result.error,
                    };
                }

                post = result.post;
            }
        }

        return {data: post};
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {Client4} from 'mattermost-redux/client';

import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentChannelId} from 'mattermost-redux/selectors/entities/channels';
import {isCloudLicense} from 'mattermost-redux/selectors/entities/general';
import {appsEnabled} from 'mattermost-redux/selectors/entities/apps';

import {ActionFunc, DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';
import type {MarketplaceApp, MarketplacePlugin} from '@mattermost/types/marketplace';
import type {CommandArgs} from '@mattermost/types/integrations';

import {GlobalState} from 'types/store';

import {getApp, getFilter, getPlugin} from 'selectors/views/marketplace';
import {ActionTypes} from 'utils/constants';

import {isError} from 'types/actions';

import {executeCommand} from './command';

// fetchPlugins fetches the latest marketplace plugins and apps, subject to any existing search filter.
export function fetchListing(localOnly = false): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState() as GlobalState;
        const filter = getFilter(state);

        let plugins: MarketplacePlugin[];
        let apps: MarketplaceApp[] = [];

        try {
            plugins = await Client4.getMarketplacePlugins(filter, localOnly);
        } catch (error: any) {
            // If the marketplace server is unreachable, try to get the local plugins only.
            if (error.server_error_id === 'app.plugin.marketplace_client.failed_to_fetch' && !localOnly) {
                await dispatch(fetchListing(true));
            }
            return {error};
        }

        dispatch({
            type: ActionTypes.RECEIVED_MARKETPLACE_PLUGINS,
            plugins,
        });

        if (appsEnabled(state)) {
            try {
                apps = await Client4.getMarketplaceApps(filter);
            } catch (error) {
                return {data: plugins};
            }

            dispatch({
                type: ActionTypes.RECEIVED_MARKETPLACE_APPS,
                apps,
            });
        }

        if (plugins) {
            return {data: (plugins as Array<MarketplacePlugin | MarketplaceApp>).concat(apps)};
        }

        return {data: apps};
    };
}

// filterListing sets a search filter for marketplace listing, fetching the latest data.
export function filterListing(filter: string): ActionFunc {
    return async (dispatch: DispatchFunc) => {
        dispatch({
            type: ActionTypes.FILTER_MARKETPLACE_LISTING,
            filter,
        });

        return dispatch(fetchListing());
    };
}

// installPlugin installs the latest version of the given plugin from the marketplace.
//
// On success, it also requests the current state of the plugins to reflect the newly installed plugin.
export function installPlugin(id: string) {
    return async (dispatch: DispatchFunc, getState: GetStateFunc): Promise<void> => {
        dispatch({
            type: ActionTypes.INSTALLING_MARKETPLACE_ITEM,
            id,
        });

        const state = getState() as GlobalState;

        const marketplacePlugin = getPlugin(state, id);
        if (!marketplacePlugin) {
            dispatch({
                type: ActionTypes.INSTALLING_MARKETPLACE_ITEM_FAILED,
                id,
                error: 'Unknown plugin: ' + id,
            });
            return;
        }

        try {
            await Client4.installMarketplacePlugin(id);
        } catch (error: any) {
            dispatch({
                type: ActionTypes.INSTALLING_MARKETPLACE_ITEM_FAILED,
                id,
                error: error.message,
            });
            return;
        }

        await dispatch(fetchListing());
        dispatch({
            type: ActionTypes.INSTALLING_MARKETPLACE_ITEM_SUCCEEDED,
            id,
        });
    };
}

// installApp installed an App using a given URL via the /apps install slash command.
//
// On success, it also requests the current state of the plugins to reflect the newly installed plugin.
export function installApp(id: string) {
    return async (dispatch: DispatchFunc, getState: GetStateFunc): Promise<boolean> => {
        dispatch({
            type: ActionTypes.INSTALLING_MARKETPLACE_ITEM,
            id,
        });

        const state = getState() as GlobalState;

        const channelID = getCurrentChannelId(state);
        const teamID = getCurrentTeamId(state);

        const app = getApp(state, id);
        if (!app) {
            dispatch({
                type: ActionTypes.INSTALLING_MARKETPLACE_ITEM_FAILED,
                id,
                error: 'Unknown app: ' + id,
            });
            return false;
        }

        const args: CommandArgs = {
            channel_id: channelID,
            team_id: teamID,
        };

        let command = `/apps install listed ${id}`;
        if (isCloudLicense(state)) {
            command = `/apps install ${id}`;
        }

        const result = await dispatch(executeCommand(command, args));
        if (isError(result)) {
            dispatch({
                type: ActionTypes.INSTALLING_MARKETPLACE_ITEM_FAILED,
                id,
                error: result.error.message,
            });
            return false;
        }

        dispatch({
            type: ActionTypes.INSTALLING_MARKETPLACE_ITEM_SUCCEEDED,
            id,
        });
        return true;
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionTypes} from 'utils/constants';

export function setAddChannelDropdown(open: boolean) {
    return {
        type: ActionTypes.ADD_CHANNEL_DROPDOWN_TOGGLE,
        open,
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionTypes} from 'utils/constants';

export function setNeedsLoggedInLimitReachedCheck(data: boolean) {
    return {
        type: ActionTypes.NEEDS_LOGGED_IN_LIMIT_REACHED_CHECK,
        data,
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {batchActions} from 'redux-batched-actions';
import {AnyAction} from 'redux';

import {Channel} from '@mattermost/types/channels';

import {
    leaveChannel as leaveChannelRedux,
    joinChannel,
    markChannelAsRead,
    unfavoriteChannel,
    deleteChannel as deleteChannelRedux,
} from 'mattermost-redux/actions/channels';
import * as PostActions from 'mattermost-redux/actions/posts';
import {TeamTypes} from 'mattermost-redux/action_types';
import {DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';
import {autocompleteUsers} from 'mattermost-redux/actions/users';
import {selectTeam} from 'mattermost-redux/actions/teams';
import {Posts, RequestStatus} from 'mattermost-redux/constants';

import {
    getChannel,
    getChannelsNameMapInCurrentTeam,
    getCurrentChannel,
    getRedirectChannelNameForTeam,
    getMyChannels,
    getMyChannelMemberships,
    getAllDirectChannelsNameMapInCurrentTeam,
    isFavoriteChannel,
    isManuallyUnread,
    getCurrentChannelId,
} from 'mattermost-redux/selectors/entities/channels';
import {
    getCurrentRelativeTeamUrl,
    getCurrentTeam,
    getCurrentTeamId,
    getTeam,
    getTeamsList,
} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentUserId, getUserByUsername} from 'mattermost-redux/selectors/entities/users';
import {getMostRecentPostIdInChannel, getPost} from 'mattermost-redux/selectors/entities/posts';
import {makeAddLastViewAtToProfiles} from 'mattermost-redux/selectors/entities/utils';

import {getChannelByName} from 'mattermost-redux/utils/channel_utils';
import EventEmitter from 'mattermost-redux/utils/event_emitter';

import {closeRightHandSide} from 'actions/views/rhs';
import {openDirectChannelToUserId} from 'actions/channel_actions';
import {loadCustomStatusEmojisForPostList} from 'actions/emoji_actions';
import {getLastViewedChannelName} from 'selectors/local_storage';
import {getLastPostsApiTimeForChannel} from 'selectors/views/channel';
import {getSocketStatus} from 'selectors/views/websocket';
import {getSelectedPost, getSelectedPostId} from 'selectors/rhs';

import {getHistory} from 'utils/browser_history';
import {Constants, ActionTypes, EventTypes, PostRequestTypes} from 'utils/constants';
import {isMobile} from 'utils/utils';
import LocalStorageStore from 'stores/local_storage_store.jsx';
import {isArchivedChannel} from 'utils/channel_utils';
import type {GlobalState} from 'types/store';

export function checkAndSetMobileView() {
    return (dispatch: DispatchFunc) => {
        dispatch({
            type: ActionTypes.UPDATE_MOBILE_VIEW,
            data: isMobile(),
        });
        return {data: true};
    };
}

export function goToLastViewedChannel() {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();
        const currentChannel = getCurrentChannel(state) || {};
        const channelsInTeam = getChannelsNameMapInCurrentTeam(state);
        const directChannel = getAllDirectChannelsNameMapInCurrentTeam(state);
        const channels = Object.assign({}, channelsInTeam, directChannel);

        let channelToSwitchTo = getChannelByName(channels, getLastViewedChannelName(state));

        if (currentChannel.id === channelToSwitchTo!.id) {
            channelToSwitchTo = getChannelByName(channels, getRedirectChannelNameForTeam(state, getCurrentTeamId(state)));
        }

        return dispatch(switchToChannel(channelToSwitchTo!));
    };
}

export function switchToChannelById(channelId: string) {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();
        const channel = getChannel(state, channelId);
        return dispatch(switchToChannel(channel));
    };
}

export function switchToChannel(channel: Channel & {userId?: string}) {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();
        const selectedTeamId = channel.team_id;
        const teamUrl = selectedTeamId ? `/${getTeam(state, selectedTeamId).name}` : getCurrentRelativeTeamUrl(state);

        if (channel.userId) {
            const username = channel.userId ? channel.name : channel.display_name;
            const user = getUserByUsername(state, username);
            if (!user) {
                return {error: true};
            }

            const direct = await dispatch(openDirectChannelToUserId(user.id));
            if (direct.error) {
                return {error: true};
            }
            getHistory().push(`${teamUrl}/messages/@${channel.name}`);
        } else if (channel.type === Constants.GM_CHANNEL) {
            const gmChannel = getChannel(state, channel.id);
            getHistory().push(`${teamUrl}/channels/${gmChannel.name}`);
        } else if (channel.type === Constants.THREADS) {
            getHistory().push(`${teamUrl}/${channel.name}`);
        } else if (channel.type === Constants.INSIGHTS) {
            getHistory().push(`${teamUrl}/${channel.name}`);
        } else {
            getHistory().push(`${teamUrl}/channels/${channel.name}`);
        }

        return {data: true};
    };
}

export function joinChannelById(channelId: string) {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();
        const currentUserId = getCurrentUserId(state);
        const currentTeamId = getCurrentTeamId(state);

        return dispatch(joinChannel(currentUserId, currentTeamId, channelId));
    };
}

export function leaveChannel(channelId: string) {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let state = getState();
        const currentUserId = getCurrentUserId(state);
        const currentTeam = getCurrentTeam(state);
        const channel = getChannel(state, channelId);
        const currentChannelId = getCurrentChannelId(state);

        if (isFavoriteChannel(state, channelId)) {
            dispatch(unfavoriteChannel(channelId));
        }

        const teamUrl = getCurrentRelativeTeamUrl(state);

        if (!isArchivedChannel(channel)) {
            LocalStorageStore.removePreviousChannel(currentUserId, currentTeam.id, state);
        }
        const {error} = await dispatch(leaveChannelRedux(channelId));
        if (error) {
            return {error};
        }
        state = getState();

        const prevChannelName = LocalStorageStore.getPreviousChannelName(currentUserId, currentTeam.id, state);
        const channelsInTeam = getChannelsNameMapInCurrentTeam(state);
        const prevChannel = getChannelByName(channelsInTeam, prevChannelName);
        if (!prevChannel || !getMyChannelMemberships(state)[prevChannel.id]) {
            LocalStorageStore.removePreviousChannel(currentUserId, currentTeam.id, state);
        }
        const selectedPost = getSelectedPost(state as GlobalState);
        const selectedPostId = getSelectedPostId(state as GlobalState);
        if (selectedPostId && selectedPost.exists === false) {
            dispatch(closeRightHandSide());
        }

        if (getMyChannels(getState()).filter((c) => c.type === Constants.OPEN_CHANNEL || c.type === Constants.PRIVATE_CHANNEL).length === 0) {
            LocalStorageStore.removePreviousChannel(currentUserId, currentTeam.id, state);
            dispatch(selectTeam(''));
            dispatch({type: TeamTypes.LEAVE_TEAM, data: currentTeam});
            getHistory().push('/');
        } else if (channelId === currentChannelId) {
            // We only need to leave the channel if we are in the channel
            getHistory().push(teamUrl);
        }

        return {
            data: true,
        };
    };
}

export function leaveDirectChannel(channelName: string) {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();
        const currentUserId = getCurrentUserId(state);
        const teams = getTeamsList(state); // dms are shared across teams but on local storage are set linked to one, we need to look into all.
        teams.forEach((currentTeam) => {
            const previousChannel = LocalStorageStore.getPreviousChannelName(currentUserId, currentTeam.id, state);
            const penultimateChannel = LocalStorageStore.getPenultimateChannelName(currentUserId, currentTeam.id, state);
            if (channelName === previousChannel) {
                LocalStorageStore.removePreviousChannel(currentUserId, currentTeam.id, state);
            } else if (channelName === penultimateChannel) {
                LocalStorageStore.removePenultimateChannelName(currentUserId, currentTeam.id);
            }
        });
        return {
            data: true,
        };
    };
}

export function autocompleteUsersInChannel(prefix: string, channelId: string) {
    const addLastViewAtToProfiles = makeAddLastViewAtToProfiles();
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();
        const currentTeamId = getCurrentTeamId(state);

        const response = await dispatch(autocompleteUsers(prefix, currentTeamId, channelId));

        const data = response.data;
        if (data) {
            return {
                ...response,
                data: {
                    ...data,
                    users: addLastViewAtToProfiles(state, data.users || []),
                    out_of_channel: addLastViewAtToProfiles(state, data.out_of_channel || []),
                },
            };
        }

        return response;
    };
}

export function loadUnreads(channelId: string, prefetch = false) {
    return async (dispatch: DispatchFunc) => {
        const time = Date.now();
        if (prefetch) {
            dispatch({
                type: ActionTypes.PREFETCH_POSTS_FOR_CHANNEL,
                channelId,
                status: RequestStatus.STARTED,
            });
        }
        const {data, error} = await dispatch(PostActions.getPostsUnread(channelId));
        if (error) {
            if (prefetch) {
                dispatch({
                    type: ActionTypes.PREFETCH_POSTS_FOR_CHANNEL,
                    channelId,
                    status: RequestStatus.FAILURE,
                });
            }
            return {
                error,
                atLatestMessage: false,
                atOldestmessage: false,
            };
        }
        dispatch(loadCustomStatusEmojisForPostList(data.posts));

        const actions = [];
        actions.push({
            type: ActionTypes.INCREASE_POST_VISIBILITY,
            data: channelId,
            amount: data.order.length,
        });

        if (prefetch) {
            actions.push({
                type: ActionTypes.PREFETCH_POSTS_FOR_CHANNEL,
                channelId,
                status: RequestStatus.SUCCESS,
            });
        }

        if (data.next_post_id === '') {
            actions.push({
                type: ActionTypes.RECEIVED_POSTS_FOR_CHANNEL_AT_TIME,
                channelId,
                time,
            });
        }

        dispatch(batchActions(actions));
        return {
            atLatestMessage: data.next_post_id === '',
            atOldestmessage: data.prev_post_id === '',
        };
    };
}

export function loadPostsAround(channelId: string, focusedPostId: string) {
    return async (dispatch: DispatchFunc) => {
        const {data, error} = await dispatch(PostActions.getPostsAround(channelId, focusedPostId, Posts.POST_CHUNK_SIZE / 2));
        if (error) {
            return {
                error,
                atLatestMessage: false,
                atOldestmessage: false,
            };
        }

        dispatch({
            type: ActionTypes.INCREASE_POST_VISIBILITY,
            data: channelId,
            amount: data.order.length,
        });
        return {
            atLatestMessage: data.next_post_id === '',
            atOldestmessage: data.prev_post_id === '',
        };
    };
}

export function loadLatestPosts(channelId: string) {
    return async (dispatch: DispatchFunc) => {
        const time = Date.now();
        const {data, error} = await dispatch(PostActions.getPosts(channelId, 0, Posts.POST_CHUNK_SIZE / 2));

        if (error) {
            return {
                error,
                atLatestMessage: false,
                atOldestmessage: false,
            };
        }

        dispatch({
            type: ActionTypes.RECEIVED_POSTS_FOR_CHANNEL_AT_TIME,
            channelId,
            time,
        });

        return {
            data,
            atLatestMessage: data.next_post_id === '',
            atOldestmessage: data.prev_post_id === '',
        };
    };
}

export interface LoadPostsReturnValue {
    error?: string;
    moreToLoad: boolean;
}

export type CanLoadMorePosts = typeof PostRequestTypes[keyof typeof PostRequestTypes] | undefined

export interface LoadPostsParameters {
    channelId: string;
    postId: string;
    type: CanLoadMorePosts;
}

export function loadPosts({
    channelId,
    postId,
    type,
}: LoadPostsParameters) {
    //type here can be BEFORE_ID or AFTER_ID
    return async (dispatch: DispatchFunc): Promise<LoadPostsReturnValue> => {
        const POST_INCREASE_AMOUNT = Constants.POST_CHUNK_SIZE / 2;

        dispatch({
            type: ActionTypes.LOADING_POSTS,
            data: true,
            channelId,
        });

        const page = 0;
        let result;
        if (type === PostRequestTypes.BEFORE_ID) {
            result = await dispatch(PostActions.getPostsBefore(channelId, postId, page, POST_INCREASE_AMOUNT));
        } else {
            result = await dispatch(PostActions.getPostsAfter(channelId, postId, page, POST_INCREASE_AMOUNT));
        }

        const {data} = result;

        const actions: AnyAction[] = [{
            type: ActionTypes.LOADING_POSTS,
            data: false,
            channelId,
        }];

        if (result.error) {
            return {
                error: result.error,
                moreToLoad: true,
            };
        }

        dispatch(loadCustomStatusEmojisForPostList(data.posts));
        actions.push({
            type: ActionTypes.INCREASE_POST_VISIBILITY,
            data: channelId,
            amount: data.order.length,
        });

        dispatch(batchActions(actions));

        return {
            moreToLoad: type === PostRequestTypes.BEFORE_ID ? data.prev_post_id !== '' : data.next_post_id !== '',
        };
    };
}

export function syncPostsInChannel(channelId: string, since: number, prefetch = false) {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const time = Date.now();
        const state = getState();
        const socketStatus = getSocketStatus(state as GlobalState);
        let sinceTimeToGetPosts = since;
        const lastPostsApiCallForChannel = getLastPostsApiTimeForChannel(state as GlobalState, channelId);
        const actions = [];

        if (lastPostsApiCallForChannel && lastPostsApiCallForChannel < socketStatus.lastDisconnectAt) {
            sinceTimeToGetPosts = lastPostsApiCallForChannel;
        }

        if (prefetch) {
            dispatch({
                type: ActionTypes.PREFETCH_POSTS_FOR_CHANNEL,
                channelId,
                status: RequestStatus.STARTED,
            });
        }

        const {data, error} = await dispatch(PostActions.getPostsSince(channelId, sinceTimeToGetPosts));
        if (data) {
            actions.push({
                type: ActionTypes.RECEIVED_POSTS_FOR_CHANNEL_AT_TIME,
                channelId,
                time,
            });
        }

        if (prefetch) {
            if (error) {
                actions.push({
                    type: ActionTypes.PREFETCH_POSTS_FOR_CHANNEL,
                    channelId,
                    status: RequestStatus.FAILURE,
                });
            } else {
                actions.push({
                    type: ActionTypes.PREFETCH_POSTS_FOR_CHANNEL,
                    channelId,
                    status: RequestStatus.SUCCESS,
                });
            }
        }

        dispatch(batchActions(actions));

        return {data, error};
    };
}

export function prefetchChannelPosts(channelId: string, jitter: number) {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();
        const recentPostIdInChannel = getMostRecentPostIdInChannel(state, channelId);

        if (!state.entities.posts.postsInChannel[channelId] || !recentPostIdInChannel) {
            if (jitter) {
                await new Promise((resolve) => setTimeout(resolve, jitter));
            }
            return dispatch(loadUnreads(channelId, true));
        }

        const recentPost = getPost(state, recentPostIdInChannel);
        return dispatch(syncPostsInChannel(channelId, recentPost.create_at, true));
    };
}

export function scrollPostListToBottom() {
    return () => {
        EventEmitter.emit(EventTypes.POST_LIST_SCROLL_TO_BOTTOM);
    };
}

export function markChannelAsReadOnFocus(channelId: string) {
    return (dispatch: DispatchFunc, getState: GetStateFunc) => {
        if (isManuallyUnread(getState(), channelId)) {
            return;
        }

        dispatch(markChannelAsRead(channelId));
    };
}

export function updateToastStatus(status: boolean) {
    return (dispatch: DispatchFunc) => {
        dispatch({
            type: ActionTypes.UPDATE_TOAST_STATUS,
            data: status,
        });
    };
}

export function deleteChannel(channelId: string) {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const res = await dispatch(deleteChannelRedux(channelId));
        if (res.error) {
            return {data: false};
        }
        const state = getState() as GlobalState;

        const selectedPost = getSelectedPost(state);
        const selectedPostId = getSelectedPostId(state);
        if (selectedPostId && !selectedPost.exists) {
            dispatch(closeRightHandSide());
        }

        return {data: true};
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {createSelector} from 'reselect';

import {Post} from '@mattermost/types/posts';

import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {
    makeGetMessageInHistoryItem,
    getPost,
    makeGetPostIdsForThread,
} from 'mattermost-redux/selectors/entities/posts';
import {getCustomEmojisByName} from 'mattermost-redux/selectors/entities/emojis';
import {
    removeReaction,
    addMessageIntoHistory,
    moveHistoryIndexBack,
    moveHistoryIndexForward,
} from 'mattermost-redux/actions/posts';
import {Posts} from 'mattermost-redux/constants';
import {isPostPendingOrFailed} from 'mattermost-redux/utils/post_utils';

import * as PostActions from 'actions/post_actions';
import {executeCommand} from 'actions/command';
import {runMessageWillBePostedHooks, runSlashCommandWillBePostedHooks} from 'actions/hooks';
import {actionOnGlobalItemsWithPrefix} from 'actions/storage';
import {updateDraft, removeDraft} from 'actions/views/drafts';
import EmojiMap from 'utils/emoji_map';
import {getPostDraft} from 'selectors/rhs';

import * as Utils from 'utils/utils';
import {Constants, StoragePrefixes} from 'utils/constants';
import type {PostDraft} from 'types/store/draft';
import type {GlobalState} from 'types/store';
import type {DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';

export function clearCommentDraftUploads() {
    return actionOnGlobalItemsWithPrefix(StoragePrefixes.COMMENT_DRAFT, (_key: string, draft: PostDraft) => {
        if (!draft || !draft.uploadsInProgress || draft.uploadsInProgress.length === 0) {
            return draft;
        }

        return {...draft, uploadsInProgress: []};
    });
}

// Temporarily store draft manually in localStorage since the current version of redux-persist
// we're on will not save the draft quickly enough on page unload.
export function updateCommentDraft(rootId: string, draft?: PostDraft, save = false) {
    const key = `${StoragePrefixes.COMMENT_DRAFT}${rootId}`;
    return updateDraft(key, draft ?? null, rootId, save);
}

export function makeOnMoveHistoryIndex(rootId: string, direction: number) {
    const getMessageInHistory = makeGetMessageInHistoryItem(Posts.MESSAGE_TYPES.COMMENT as 'comment');

    return () => (dispatch: DispatchFunc, getState: () => GlobalState) => {
        const draft = getPostDraft(getState(), StoragePrefixes.COMMENT_DRAFT, rootId);
        if (draft.message !== '' && draft.message !== getMessageInHistory(getState())) {
            return {data: true};
        }

        if (direction === -1) {
            dispatch(moveHistoryIndexBack(Posts.MESSAGE_TYPES.COMMENT as 'comment'));
        } else if (direction === 1) {
            dispatch(moveHistoryIndexForward(Posts.MESSAGE_TYPES.COMMENT as 'comment'));
        }

        const nextMessageInHistory = getMessageInHistory(getState());

        dispatch(updateCommentDraft(rootId, {...draft, message: nextMessageInHistory}));
        return {data: true};
    };
}

export function submitPost(channelId: string, rootId: string, draft: PostDraft) {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();

        const userId = getCurrentUserId(state);

        const time = Utils.getTimestamp();

        let post = {
            file_ids: [],
            message: draft.message,
            channel_id: channelId,
            root_id: rootId,
            pending_post_id: `${userId}:${time}`,
            user_id: userId,
            create_at: time,
            metadata: {},
            props: {...draft.props},
        } as unknown as Post;

        const hookResult = await dispatch(runMessageWillBePostedHooks(post));
        if (hookResult.error) {
            return {error: hookResult.error};
        }

        post = hookResult.data;

        return dispatch(PostActions.createPost(post, draft.fileInfos));
    };
}

export function submitReaction(postId: string, action: string, emojiName: string) {
    return (dispatch: DispatchFunc) => {
        if (action === '+') {
            dispatch(PostActions.addReaction(postId, emojiName));
        } else if (action === '-') {
            dispatch(removeReaction(postId, emojiName));
        }
        return {data: true};
    };
}

export function submitCommand(channelId: string, rootId: string, draft: PostDraft) {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();

        const teamId = getCurrentTeamId(state);

        let args = {
            channel_id: channelId,
            team_id: teamId,
            root_id: rootId,
        };

        let {message} = draft;

        const hookResult = await dispatch(runSlashCommandWillBePostedHooks(message, args));
        if (hookResult.error) {
            return {error: hookResult.error};
        } else if (!hookResult.data.message && !hookResult.data.args) {
            // do nothing with an empty return from a hook
            return {};
        }

        message = hookResult.data.message;
        args = hookResult.data.args;

        const {error} = await dispatch(executeCommand(message, args));

        if (error) {
            if (error.sendMessage) {
                return dispatch(submitPost(channelId, rootId, draft));
            }
            throw (error);
        }

        return {};
    };
}

export function makeOnSubmit(channelId: string, rootId: string, latestPostId: string) {
    return (draft: PostDraft, options: {ignoreSlash?: boolean} = {}) => async (dispatch: DispatchFunc, getState: () => GlobalState) => {
        const {message} = draft;

        dispatch(addMessageIntoHistory(message));

        const key = `${StoragePrefixes.COMMENT_DRAFT}${rootId}`;
        dispatch(removeDraft(key, channelId, rootId));

        const isReaction = Utils.REACTION_PATTERN.exec(message);

        const emojis = getCustomEmojisByName(getState());
        const emojiMap = new EmojiMap(emojis);

        if (isReaction && emojiMap.has(isReaction[2])) {
            dispatch(submitReaction(latestPostId, isReaction[1], isReaction[2]));
        } else if (message.indexOf('/') === 0 && !options.ignoreSlash) {
            try {
                await dispatch(submitCommand(channelId, rootId, draft));
            } catch (err) {
                dispatch(updateCommentDraft(rootId, draft, true));
                throw err;
            }
        } else {
            dispatch(submitPost(channelId, rootId, draft));
        }
        return {data: true};
    };
}

function makeGetCurrentUsersLatestReply() {
    const getPostIdsInThread = makeGetPostIdsForThread();
    return createSelector(
        'makeGetCurrentUsersLatestReply',
        getCurrentUserId,
        getPostIdsInThread,
        (state) => (id: string) => getPost(state, id),
        (_state, rootId) => rootId,
        (userId, postIds, getPostById, rootId) => {
            let lastPost = null;

            if (!postIds) {
                return lastPost;
            }

            for (const id of postIds) {
                const post = getPostById(id) || {};

                // don't edit webhook posts, deleted posts, or system messages
                if (
                    post.user_id !== userId ||
                    (post.props && post.props.from_webhook) ||
                    post.state === Constants.POST_DELETED ||
                    (post.type && post.type.startsWith(Constants.SYSTEM_MESSAGE_PREFIX)) ||
                    isPostPendingOrFailed(post)
                ) {
                    continue;
                }

                if (rootId) {
                    if (post.root_id === rootId || post.id === rootId) {
                        lastPost = post;
                        break;
                    }
                } else {
                    lastPost = post;
                    break;
                }
            }

            return lastPost;
        },
    );
}

export function makeOnEditLatestPost(rootId: string) {
    const getCurrentUsersLatestPost = makeGetCurrentUsersLatestReply();

    return () => (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();

        const lastPost = getCurrentUsersLatestPost(state, rootId);

        if (!lastPost) {
            return {data: false};
        }

        return dispatch(PostActions.setEditingPost(
            lastPost.id,
            'reply_textbox',
            Utils.localizeMessage('create_comment.commentTitle', 'Comment'),
            true,
        ));
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {searchAssociatedGroupsForReferenceLocal} from 'mattermost-redux/selectors/entities/groups';
import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {isCustomGroupsEnabled} from 'mattermost-redux/selectors/entities/preferences';
import {haveIChannelPermission} from 'mattermost-redux/selectors/entities/roles';
import {searchGroups} from 'mattermost-redux/actions/groups';
import Permissions from 'mattermost-redux/constants/permissions';

export function searchAssociatedGroupsForReference(prefix, teamId, channelId) {
    return async (dispatch, getState) => {
        const state = getState();
        if (!haveIChannelPermission(state,
            teamId,
            channelId,
            Permissions.USE_GROUP_MENTIONS,
        )) {
            return {data: []};
        }

        const config = getConfig(state);
        const isTimezoneEnabled = config.ExperimentalTimezone === 'true';

        if (isCustomGroupsEnabled(state)) {
            await dispatch(searchGroups({
                q: prefix,
                filter_allow_reference: true,
                page: 0,
                per_page: 60,
                include_member_count: true,
                include_channel_member_count: channelId,
                include_timezones: isTimezoneEnabled,
            }));
        }
        return {data: searchAssociatedGroupsForReferenceLocal(state, prefix, teamId, channelId)};
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionTypes} from 'utils/constants';

export const toggle = () => (dispatch) => dispatch({
    type: ActionTypes.TOGGLE_LHS,
});

export const open = () => (dispatch) => dispatch({
    type: ActionTypes.OPEN_LHS,
});

export const close = () => (dispatch) => dispatch({
    type: ActionTypes.CLOSE_LHS,
});

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionTypes} from 'utils/constants';

export function dismissNotice(type) {
    return (dispatch) => {
        dispatch({
            type: ActionTypes.DISMISS_NOTICE,
            data: type,
        });

        return {data: true};
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {getCurrentTeamId, getTeam} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentUser, getCurrentUserId} from 'mattermost-redux/selectors/entities/common';
import {DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';
import {GlobalState} from 'types/store';
import {getHistory} from 'utils/browser_history';
import InvitationModal from 'components/invitation_modal';
import LocalStorageStore from 'stores/local_storage_store';
import {ActionTypes, Constants, ModalIdentifiers} from 'utils/constants';

import {getTeamRedirectChannelIfIsAccesible} from 'actions/global_actions';

import {openModal} from './modals';

export function switchToChannels() {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState() as GlobalState;
        const currentUserId = getCurrentUserId(state);
        const user = getCurrentUser(state);
        const teamId = getCurrentTeamId(state) || LocalStorageStore.getPreviousTeamId(currentUserId);
        const team = getTeam(state, teamId || '');

        const channel = await getTeamRedirectChannelIfIsAccesible(user, team);
        const channelName = channel?.name || Constants.DEFAULT_CHANNEL;

        getHistory().push(`/${team.name}/channels/${channelName}`);
        return {data: true};
    };
}

export function openInvitationsModal(timeout = 1) {
    return (dispatch: DispatchFunc) => {
        dispatch(switchToChannels());
        setTimeout(() => {
            dispatch(openModal({
                modalId: ModalIdentifiers.INVITATION,
                dialogType: InvitationModal,
                dialogProps: {
                },
            }));
        }, timeout);
        return {data: true};
    };
}

export function setShowOnboardingTaskCompletion(open: boolean) {
    return {
        type: ActionTypes.SHOW_ONBOARDING_TASK_COMPLETION,
        open,
    };
}

export function setShowOnboardingCompleteProfileTour(open: boolean) {
    return {
        type: ActionTypes.SHOW_ONBOARDING_COMPLETE_PROFILE_TOUR,
        open,
    };
}

export function setShowOnboardingVisitConsoleTour(open: boolean) {
    return {
        type: ActionTypes.SHOW_ONBOARDING_VISIT_CONSOLE_TOUR,
        open,
    };
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import * as PostActions from 'mattermost-redux/actions/posts';

import {Permissions} from 'mattermost-redux/constants';
import {logError} from 'mattermost-redux/actions/errors';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {haveIChannelPermission, haveICurrentChannelPermission} from 'mattermost-redux/selectors/entities/roles';
import {getLicense} from 'mattermost-redux/selectors/entities/general';
import {isCustomGroupsEnabled} from 'mattermost-redux/selectors/entities/preferences';
import {getAssociatedGroupsForReferenceByMention} from 'mattermost-redux/selectors/entities/groups';
import {getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';

import * as Utils from 'utils/utils';
import {getSiteURL} from 'utils/url';
import {containsAtChannel, groupsMentionedInText} from 'utils/post_utils';
import {ActionTypes, AnnouncementBarTypes} from 'utils/constants';

import {runMessageWillBePostedHooks} from '../hooks';

export function editPost(post) {
    return async (dispatch, getState) => {
        const result = await PostActions.editPost(post)(dispatch, getState);

        // Send to error bar if it's an edit post error about time limit.
        if (result.error && result.error.server_error_id === 'api.post.update_post.permissions_time_limit.app_error') {
            dispatch(logError({type: AnnouncementBarTypes.ANNOUNCEMENT, message: result.error.message}, true));
        }

        return result;
    };
}

export function forwardPost(post, channel, message = '') {
    return async (dispatch, getState) => {
        const state = getState();
        const channelId = channel.id;

        const currentUserId = getCurrentUserId(state);
        const currentTeam = getCurrentTeam(state);

        const relativePermaLink = Utils.getPermalinkURL(state, currentTeam.id, post.id);
        const permaLink = `${getSiteURL()}${relativePermaLink}`;

        const license = getLicense(state);
        const isLDAPEnabled = license?.IsLicensed === 'true' && license?.LDAPGroups === 'true';
        const useLDAPGroupMentions = isLDAPEnabled && haveICurrentChannelPermission(state, Permissions.USE_GROUP_MENTIONS);
        const useChannelMentions = haveIChannelPermission(state, channel.team_id, channelId, Permissions.USE_CHANNEL_MENTIONS);
        const useCustomGroupMentions = isCustomGroupsEnabled(state) && haveICurrentChannelPermission(state, Permissions.USE_GROUP_MENTIONS);
        const groupsWithAllowReference = useLDAPGroupMentions || useCustomGroupMentions ? getAssociatedGroupsForReferenceByMention(state, currentTeam.id, channelId) : null;

        let newPost = {};

        newPost.channel_id = channelId;

        const time = Utils.getTimestamp();
        const userId = currentUserId;

        newPost.message = message ? `${message}\n${permaLink}` : permaLink;
        newPost.pending_post_id = `${userId}:${time}`;
        newPost.user_id = userId;
        newPost.create_at = time;
        newPost.metadata = {};
        newPost.props = {};

        if (!useChannelMentions && containsAtChannel(newPost.message, {checkAllMentions: true})) {
            newPost.props.mentionHighlightDisabled = true;
        }

        if (!useLDAPGroupMentions && !useCustomGroupMentions && groupsMentionedInText(newPost.message, groupsWithAllowReference)) {
            newPost.props.disable_group_highlight = true;
        }

        const hookResult = await dispatch(runMessageWillBePostedHooks(newPost));

        if (hookResult.error) {
            return hookResult;
        }

        newPost = hookResult.data;

        return dispatch(PostActions.createPost(newPost, []));
    };
}

export function selectAttachmentMenuAction(postId, actionId, cookie, dataSource, text, value) {
    return async (dispatch) => {
        dispatch({
            type: ActionTypes.SELECT_ATTACHMENT_MENU_ACTION,
            data: {
                postId,
                actions: {
                    [actionId]: {
                        text,
                        value,
                    },
                },
            },
        });

        dispatch(PostActions.doPostActionWithCookie(postId, actionId, cookie, value));

        return {data: true};
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionTypes} from 'utils/constants';

export function setProductMenuSwitcherOpen(open: boolean) {
    return {
        type: ActionTypes.SET_PRODUCT_SWITCHER_OPEN,
        open,
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {Client4} from 'mattermost-redux/client';
import {getClientConfig, getLicenseConfig} from 'mattermost-redux/actions/general';
import {loadMe, loadMeREST} from 'mattermost-redux/actions/users';
import {DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';
import {GlobalState} from 'types/store';

import {getCurrentLocale, getTranslations} from 'selectors/i18n';
import {Translations} from 'types/store/i18n';
import {ActionTypes} from 'utils/constants';
import en from 'i18n/en.json';

const pluginTranslationSources: Record<string, TranslationPluginFunction> = {};

export type TranslationPluginFunction = (locale: string) => Translations

export function loadConfigAndMe() {
    return async (dispatch: DispatchFunc) => {
        const [{data: clientConfig}] = await Promise.all([
            dispatch(getClientConfig()),
            dispatch(getLicenseConfig()),
        ]);

        const isGraphQLEnabled = clientConfig && clientConfig.FeatureFlagGraphQL === 'true';

        let isMeLoaded = false;
        if (document.cookie.includes('MMUSERID=')) {
            if (isGraphQLEnabled) {
                const dataFromLoadMe = await dispatch(loadMe());
                isMeLoaded = dataFromLoadMe?.data ?? false;
            } else {
                const dataFromLoadMeREST = await dispatch(loadMeREST());
                isMeLoaded = dataFromLoadMeREST?.data ?? false;
            }
        }

        return {data: isMeLoaded};
    };
}

export function registerPluginTranslationsSource(pluginId: string, sourceFunction: TranslationPluginFunction) {
    pluginTranslationSources[pluginId] = sourceFunction;
    return (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState() as GlobalState;
        const locale = getCurrentLocale(state);
        const immutableTranslations = getTranslations(state, locale);
        const translations = {};
        Object.assign(translations, immutableTranslations);
        if (immutableTranslations) {
            Object.assign(translations, sourceFunction(locale));
            dispatch({
                type: ActionTypes.RECEIVED_TRANSLATIONS,
                data: {
                    locale,
                    translations,
                },
            });
        }
    };
}

export function unregisterPluginTranslationsSource(pluginId: string) {
    Reflect.deleteProperty(pluginTranslationSources, pluginId);
}

export function loadTranslations(locale: string, url: string) {
    return async (dispatch: DispatchFunc) => {
        const translations = {...en};
        Object.values(pluginTranslationSources).forEach((pluginFunc) => {
            Object.assign(translations, pluginFunc(locale));
        });

        // Need to go to the server for languages other than English
        if (locale !== 'en') {
            try {
                const serverTranslations = await Client4.getTranslations(url);
                Object.assign(translations, serverTranslations);
            } catch (error) {
                console.error(error); //eslint-disable-line no-console
            }
        }
        dispatch({
            type: ActionTypes.RECEIVED_TRANSLATIONS,
            data: {
                locale,
                translations,
            },
        });
        return {data: true};
    };
}

export function registerCustomPostRenderer(type: string, component: any, id: string) {
    return async (dispatch: DispatchFunc) => {
        // piggyback on plugins state to register a custom post renderer
        dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_POST_COMPONENT,
            data: {
                postTypeId: id,
                pluginId: id,
                type,
                component,
            },
        });
        return {data: true};
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {SearchTypes} from 'utils/constants';

export function setModalSearchTerm(term) {
    return {
        type: SearchTypes.SET_MODAL_SEARCH,
        data: term,
    };
}

export function setPopoverSearchTerm(term) {
    return {
        type: SearchTypes.SET_POPOVER_SEARCH,
        data: term,
    };
}

export function setChannelMembersRhsSearchTerm(term) {
    return {
        type: SearchTypes.SET_CHANNEL_MEMBERS_RHS_SEARCH,
        data: term,
    };
}

export function setModalFilters(filters = {}) {
    return {
        type: SearchTypes.SET_MODAL_FILTERS,
        data: filters,
    };
}

export function setUserGridSearch(term) {
    return {
        type: SearchTypes.SET_USER_GRID_SEARCH,
        data: term,
    };
}

export function setUserGridFilters(filters = {}) {
    return {
        type: SearchTypes.SET_USER_GRID_FILTERS,
        data: filters,
    };
}

export function setSystemUsersSearch(term, team = '', filter = '') {
    return {
        type: SearchTypes.SET_SYSTEM_USERS_SEARCH,
        data: {term, team, filter},
    };
}

export function setTeamListSearch(term) {
    return {
        type: SearchTypes.SET_TEAM_LIST_SEARCH,
        data: term,
    };
}

export function setChannelListSearch(term) {
    return {
        type: SearchTypes.SET_CHANNEL_LIST_SEARCH,
        data: term,
    };
}

export function setChannelListFilters(filters = {}) {
    return {
        type: SearchTypes.SET_CHANNEL_LIST_FILTERS,
        data: filters,
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionTypes} from 'utils/constants';

export function setStatusDropdown(open: boolean) {
    return {
        type: ActionTypes.STATUS_DROPDOWN_TOGGLE,
        open,
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionTypes} from '../../utils/constants';

export function setShowPreviewOnCreateComment(showPreview) {
    return {
        type: ActionTypes.SET_SHOW_PREVIEW_ON_CREATE_COMMENT,
        showPreview,
    };
}

export function setShowPreviewOnCreatePost(showPreview) {
    return {
        type: ActionTypes.SET_SHOW_PREVIEW_ON_CREATE_POST,
        showPreview,
    };
}

export function setShowPreviewOnEditChannelHeaderModal(showPreview) {
    return {
        type: ActionTypes.SET_SHOW_PREVIEW_ON_EDIT_CHANNEL_HEADER_MODAL,
        showPreview,
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {batchActions} from 'redux-batched-actions';

import {UserTypes} from 'mattermost-redux/action_types';

import {getCurrentUserId, getUsers} from 'mattermost-redux/selectors/entities/users';

import {ActionFunc, DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';

import {getKnownUsers} from './users';

export function removeNotVisibleUsers(): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();
        let knownUsers: Set<string>;
        try {
            const fetchResult = await dispatch(getKnownUsers());
            knownUsers = new Set((fetchResult as any).data);
        } catch (err) {
            return {error: err};
        }
        knownUsers.add(getCurrentUserId(state));

        const allUsers = Object.keys(getUsers(state));
        const usersToRemove = new Set(allUsers.filter((x) => !knownUsers.has(x)));

        const actions = [];
        for (const userToRemove of usersToRemove.values()) {
            actions.push({type: UserTypes.PROFILE_NO_LONGER_VISIBLE, data: {user_id: userToRemove}});
        }
        if (actions.length > 0) {
            dispatch(batchActions(actions));
        }

        return {data: true};
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionTypes} from 'utils/constants';

export function incrementWsErrorCount() {
    return async (dispatch) => {
        dispatch({
            type: ActionTypes.INCREMENT_WS_ERROR_COUNT,
        });
    };
}

export function resetWsErrorCount() {
    return async (dispatch) => {
        dispatch({
            type: ActionTypes.RESET_WS_ERROR_COUNT,
        });
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

type Props = {
    currentUserId: string;
    onExited: () => void;
    channelName?: string;
    remover?: string;
}

type State = {
    show: boolean;
}

export default class RemovedFromChannelModal extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {show: true};
    }

    onHide = () => {
        this.setState({show: false});
    }

    render() {
        let channelName: JSX.Element | string;
        let remover: JSX.Element | string;

        channelName = (
            <FormattedMessage
                id='removed_channel.channelName'
                defaultMessage='the channel'
            />
        );
        if (this.props.channelName) {
            channelName = this.props.channelName;
        }

        remover = (
            <FormattedMessage
                id='removed_channel.someone'
                defaultMessage='Someone'
            />
        );
        if (this.props.remover) {
            remover = this.props.remover;
        }

        if (this.props.currentUserId === '') {
            return null;
        }

        return (
            <Modal
                dialogClassName='a11y__modal'
                show={this.state.show}
                onHide={this.onHide}
                onExited={this.props.onExited}
                role='dialog'
                aria-labelledby='removeFromChannelModalLabel'
            >
                <Modal.Header closeButton={true}>
                    <Modal.Title
                        componentClass='h1'
                        id='removeFromChannelModalLabel'
                    >
                        <FormattedMessage
                            id='removed_channel.from'
                            defaultMessage='Removed from '
                        />
                        <span className='name'>
                            {channelName}
                        </span>
                    </Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    <p>
                        <FormattedMessage
                            id='removed_channel.remover'
                            defaultMessage='{remover} removed you from {channel}'
                            values={{
                                remover,
                                channel: (channelName),
                            }}
                        />
                    </p>
                </Modal.Body>
                <Modal.Footer>
                    <button
                        type='button'
                        className='btn btn-primary'
                        onClick={this.onHide}
                        id='removedChannelBtn'
                    >
                        <FormattedMessage
                            id='removed_channel.okay'
                            defaultMessage='Okay'
                        />
                    </button>
                </Modal.Footer>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getCurrentUserId, getUser} from 'mattermost-redux/selectors/entities/users';

import {GlobalState} from 'types/store';

import RemovedFromChannelModal from './removed_from_channel_modal';

type Props = {
    removerId: string;
}

function mapStateToProps(state: GlobalState, ownProps: Props) {
    const remover = getUser(state, ownProps.removerId);
    return {
        currentUserId: getCurrentUserId(state),
        remover: remover && remover.username,
    };
}

export default connect(mapStateToProps)(RemovedFromChannelModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/* eslint-disable max-lines */

import {batchActions} from 'redux-batched-actions';

import {
    ChannelTypes,
    EmojiTypes,
    GroupTypes,
    PostTypes,
    TeamTypes,
    UserTypes,
    RoleTypes,
    GeneralTypes,
    AdminTypes,
    IntegrationTypes,
    PreferenceTypes,
    AppsTypes,
    CloudTypes,
} from 'mattermost-redux/action_types';
import {General, Permissions} from 'mattermost-redux/constants';
import {addChannelToInitialCategory, fetchMyCategories, receivedCategoryOrder} from 'mattermost-redux/actions/channel_categories';
import {
    getChannelAndMyMember,
    getMyChannelMember,
    getChannelStats,
    viewChannel,
    markChannelAsRead,
    getChannelMemberCountsByGroup,
} from 'mattermost-redux/actions/channels';
import {getCloudSubscription} from 'mattermost-redux/actions/cloud';
import {loadRolesIfNeeded} from 'mattermost-redux/actions/roles';

import {isCollapsedThreadsEnabled} from 'mattermost-redux/selectors/entities/preferences';
import {getNewestThreadInTeam, getThread, getThreads} from 'mattermost-redux/selectors/entities/threads';
import {
    getThread as fetchThread,
    getCountsAndThreadsSince,
    handleAllMarkedRead,
    handleReadChanged,
    handleFollowChanged,
    handleThreadArrived,
    handleAllThreadsInChannelMarkedRead,
    updateThreadRead,
    decrementThreadCounts,
} from 'mattermost-redux/actions/threads';

import {setServerVersion, getClientConfig} from 'mattermost-redux/actions/general';
import {
    getCustomEmojiForReaction,
    getPosts,
    getPostThread,
    getProfilesAndStatusesForPosts,
    getThreadsForPosts,
    postDeleted,
    receivedNewPost,
    receivedPost,
} from 'mattermost-redux/actions/posts';
import {clearErrors, logError} from 'mattermost-redux/actions/errors';

import * as TeamActions from 'mattermost-redux/actions/teams';
import {
    checkForModifiedUsers,
    getUser as loadUser,
} from 'mattermost-redux/actions/users';
import {removeNotVisibleUsers} from 'mattermost-redux/actions/websocket';
import {setGlobalItem} from 'actions/storage';
import {transformServerDraft} from 'actions/views/drafts';

import {Client4} from 'mattermost-redux/client';
import {getCurrentUser, getCurrentUserId, getUser, getIsManualStatusForUserId, isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';
import {getMyTeams, getCurrentRelativeTeamUrl, getCurrentTeamId, getCurrentTeamUrl, getTeam} from 'mattermost-redux/selectors/entities/teams';
import {getConfig, getLicense} from 'mattermost-redux/selectors/entities/general';
import {
    getChannel,
    getChannelMembersInChannels,
    getChannelsInTeam,
    getCurrentChannel,
    getCurrentChannelId,
    getRedirectChannelNameForTeam,
} from 'mattermost-redux/selectors/entities/channels';
import {getPost, getMostRecentPostIdInChannel} from 'mattermost-redux/selectors/entities/posts';
import {haveISystemPermission, haveITeamPermission} from 'mattermost-redux/selectors/entities/roles';
import {appsFeatureFlagEnabled} from 'mattermost-redux/selectors/entities/apps';
import {getStandardAnalytics} from 'mattermost-redux/actions/admin';

import {fetchAppBindings, fetchRHSAppsBindings} from 'mattermost-redux/actions/apps';

import {getConnectionId} from 'selectors/general';
import {getSelectedChannelId, getSelectedPost} from 'selectors/rhs';
import {isThreadOpen, isThreadManuallyUnread} from 'selectors/views/threads';

import {openModal} from 'actions/views/modals';
import {incrementWsErrorCount, resetWsErrorCount} from 'actions/views/system';
import {closeRightHandSide} from 'actions/views/rhs';
import {syncPostsInChannel} from 'actions/views/channel';
import {updateThreadLastOpened} from 'actions/views/threads';

import {getHistory} from 'utils/browser_history';
import {loadChannelsForCurrentUser} from 'actions/channel_actions';
import {loadCustomEmojisIfNeeded} from 'actions/emoji_actions';
import {redirectUserToDefaultTeam} from 'actions/global_actions';
import {handleNewPost} from 'actions/post_actions';
import * as StatusActions from 'actions/status_actions';
import {loadProfilesForSidebar} from 'actions/user_actions';
import store from 'stores/redux_store.jsx';
import WebSocketClient from 'client/web_websocket_client.jsx';
import {loadPlugin, loadPluginsIfNecessary, removePlugin} from 'plugins';
import {ActionTypes, Constants, AnnouncementBarMessages, SocketEvents, UserStatuses, ModalIdentifiers, WarnMetricTypes} from 'utils/constants';
import {getSiteURL} from 'utils/url';
import {isGuest} from 'mattermost-redux/utils/user_utils';
import RemovedFromChannelModal from 'components/removed_from_channel_modal';
import InteractiveDialog from 'components/interactive_dialog';
import {
    getTeamsUsage,
} from 'actions/cloud';

const dispatch = store.dispatch;
const getState = store.getState;

const MAX_WEBSOCKET_FAILS = 7;

const pluginEventHandlers = {};

export function initialize() {
    if (!window.WebSocket) {
        console.log('Browser does not support websocket'); //eslint-disable-line no-console
        return;
    }

    const config = getConfig(getState());
    let connUrl = '';
    if (config.WebsocketURL) {
        connUrl = config.WebsocketURL;
    } else {
        connUrl = new URL(getSiteURL());

        // replace the protocol with a websocket one
        if (connUrl.protocol === 'https:') {
            connUrl.protocol = 'wss:';
        } else {
            connUrl.protocol = 'ws:';
        }

        // append a port number if one isn't already specified
        if (!(/:\d+$/).test(connUrl.host)) {
            if (connUrl.protocol === 'wss:') {
                connUrl.host += ':' + config.WebsocketSecurePort;
            } else {
                connUrl.host += ':' + config.WebsocketPort;
            }
        }

        connUrl = connUrl.toString();
    }

    // Strip any trailing slash before appending the pathname below.
    if (connUrl.length > 0 && connUrl[connUrl.length - 1] === '/') {
        connUrl = connUrl.substring(0, connUrl.length - 1);
    }

    connUrl += Client4.getUrlVersion() + '/websocket';

    WebSocketClient.addMessageListener(handleEvent);
    WebSocketClient.addFirstConnectListener(handleFirstConnect);
    WebSocketClient.addReconnectListener(() => reconnect(false));
    WebSocketClient.addMissedMessageListener(restart);
    WebSocketClient.addCloseListener(handleClose);

    WebSocketClient.initialize(connUrl);
}

export function close() {
    WebSocketClient.close();
}

function reconnectWebSocket() {
    close();
    initialize();
}

const pluginReconnectHandlers = {};

export function registerPluginReconnectHandler(pluginId, handler) {
    pluginReconnectHandlers[pluginId] = handler;
}

export function unregisterPluginReconnectHandler(pluginId) {
    Reflect.deleteProperty(pluginReconnectHandlers, pluginId);
}

function restart() {
    reconnect(false);

    // We fetch the client config again on the server restart.
    dispatch(getClientConfig());
}

export function reconnect(includeWebSocket = true) {
    if (includeWebSocket) {
        reconnectWebSocket();
    }

    dispatch({
        type: GeneralTypes.WEBSOCKET_SUCCESS,
        timestamp: Date.now(),
    });

    const state = getState();
    const currentTeamId = getCurrentTeamId(state);
    if (currentTeamId) {
        const currentUserId = getCurrentUserId(state);
        const currentChannelId = getCurrentChannelId(state);
        const mostRecentId = getMostRecentPostIdInChannel(state, currentChannelId);
        const mostRecentPost = getPost(state, mostRecentId);

        if (appsFeatureFlagEnabled(state)) {
            dispatch(handleRefreshAppsBindings());
        }

        dispatch(loadChannelsForCurrentUser());

        if (mostRecentPost) {
            dispatch(syncPostsInChannel(currentChannelId, mostRecentPost.create_at));
        } else if (currentChannelId) {
            // if network timed-out the first time when loading a channel
            // we can request for getPosts again when socket is connected
            dispatch(getPosts(currentChannelId));
        }
        StatusActions.loadStatusesForChannelAndSidebar();

        const crtEnabled = isCollapsedThreadsEnabled(state);
        dispatch(TeamActions.getMyTeamUnreads(crtEnabled, true));
        if (crtEnabled) {
            const teams = getMyTeams(state);
            syncThreads(currentTeamId, currentUserId);

            for (const team of teams) {
                if (team.id === currentTeamId) {
                    continue;
                }
                syncThreads(team.id, currentUserId);
            }
        }
    }

    loadPluginsIfNecessary();

    Object.values(pluginReconnectHandlers).forEach((handler) => {
        if (handler && typeof handler === 'function') {
            handler();
        }
    });

    if (state.websocket.lastDisconnectAt) {
        dispatch(checkForModifiedUsers());
    }

    dispatch(resetWsErrorCount());
    dispatch(clearErrors());
}

function syncThreads(teamId, userId) {
    const state = getState();
    const newestThread = getNewestThreadInTeam(state, teamId);

    // no need to sync if we have nothing yet
    if (!newestThread) {
        return;
    }
    dispatch(getCountsAndThreadsSince(userId, teamId, newestThread.last_reply_at));
}

export function registerPluginWebSocketEvent(pluginId, event, action) {
    if (!pluginEventHandlers[pluginId]) {
        pluginEventHandlers[pluginId] = {};
    }
    pluginEventHandlers[pluginId][event] = action;
}

export function unregisterPluginWebSocketEvent(pluginId, event) {
    const events = pluginEventHandlers[pluginId];
    if (!events) {
        return;
    }

    Reflect.deleteProperty(events, event);
}

export function unregisterAllPluginWebSocketEvents(pluginId) {
    Reflect.deleteProperty(pluginEventHandlers, pluginId);
}

function handleFirstConnect() {
    dispatch(batchActions([
        {
            type: GeneralTypes.WEBSOCKET_SUCCESS,
            timestamp: Date.now(),
        },
        clearErrors(),
    ]));
}

function handleClose(failCount) {
    if (failCount > MAX_WEBSOCKET_FAILS) {
        dispatch(logError({type: 'critical', message: AnnouncementBarMessages.WEBSOCKET_PORT_ERROR}, true));
    }
    dispatch(batchActions([
        {
            type: GeneralTypes.WEBSOCKET_FAILURE,
            timestamp: Date.now(),
        },
        incrementWsErrorCount(),
    ]));
}

export function handleEvent(msg) {
    switch (msg.event) {
    case SocketEvents.POSTED:
    case SocketEvents.EPHEMERAL_MESSAGE:
        handleNewPostEventDebounced(msg);
        break;

    case SocketEvents.POST_EDITED:
        handlePostEditEvent(msg);
        break;

    case SocketEvents.POST_DELETED:
        handlePostDeleteEvent(msg);
        break;

    case SocketEvents.POST_UNREAD:
        handlePostUnreadEvent(msg);
        break;

    case SocketEvents.LEAVE_TEAM:
        handleLeaveTeamEvent(msg);
        break;

    case SocketEvents.UPDATE_TEAM:
        handleUpdateTeamEvent(msg);
        break;

    case SocketEvents.UPDATE_TEAM_SCHEME:
        handleUpdateTeamSchemeEvent(msg);
        break;

    case SocketEvents.DELETE_TEAM:
        handleDeleteTeamEvent(msg);
        break;

    case SocketEvents.ADDED_TO_TEAM:
        handleTeamAddedEvent(msg);
        break;

    case SocketEvents.USER_ADDED:
        dispatch(handleUserAddedEvent(msg));
        break;

    case SocketEvents.USER_REMOVED:
        handleUserRemovedEvent(msg);
        break;

    case SocketEvents.USER_UPDATED:
        handleUserUpdatedEvent(msg);
        break;

    case SocketEvents.ROLE_ADDED:
        handleRoleAddedEvent(msg);
        break;

    case SocketEvents.ROLE_REMOVED:
        handleRoleRemovedEvent(msg);
        break;

    case SocketEvents.CHANNEL_SCHEME_UPDATED:
        handleChannelSchemeUpdatedEvent(msg);
        break;

    case SocketEvents.MEMBERROLE_UPDATED:
        handleUpdateMemberRoleEvent(msg);
        break;

    case SocketEvents.ROLE_UPDATED:
        handleRoleUpdatedEvent(msg);
        break;

    case SocketEvents.CHANNEL_CREATED:
        dispatch(handleChannelCreatedEvent(msg));
        break;

    case SocketEvents.CHANNEL_DELETED:
        handleChannelDeletedEvent(msg);
        break;

    case SocketEvents.CHANNEL_UNARCHIVED:
        handleChannelUnarchivedEvent(msg);
        break;

    case SocketEvents.CHANNEL_CONVERTED:
        handleChannelConvertedEvent(msg);
        break;

    case SocketEvents.CHANNEL_UPDATED:
        dispatch(handleChannelUpdatedEvent(msg));
        break;

    case SocketEvents.CHANNEL_MEMBER_UPDATED:
        handleChannelMemberUpdatedEvent(msg);
        break;

    case SocketEvents.DIRECT_ADDED:
        dispatch(handleDirectAddedEvent(msg));
        break;

    case SocketEvents.GROUP_ADDED:
        dispatch(handleGroupAddedEvent(msg));
        break;

    case SocketEvents.PREFERENCE_CHANGED:
        handlePreferenceChangedEvent(msg);
        break;

    case SocketEvents.PREFERENCES_CHANGED:
        handlePreferencesChangedEvent(msg);
        break;

    case SocketEvents.PREFERENCES_DELETED:
        handlePreferencesDeletedEvent(msg);
        break;

    case SocketEvents.STATUS_CHANGED:
        handleStatusChangedEvent(msg);
        break;

    case SocketEvents.HELLO:
        handleHelloEvent(msg);
        break;

    case SocketEvents.REACTION_ADDED:
        handleReactionAddedEvent(msg);
        break;

    case SocketEvents.REACTION_REMOVED:
        handleReactionRemovedEvent(msg);
        break;

    case SocketEvents.EMOJI_ADDED:
        handleAddEmoji(msg);
        break;

    case SocketEvents.CHANNEL_VIEWED:
        handleChannelViewedEvent(msg);
        break;

    case SocketEvents.PLUGIN_ENABLED:
        handlePluginEnabled(msg);
        break;

    case SocketEvents.PLUGIN_DISABLED:
        handlePluginDisabled(msg);
        break;

    case SocketEvents.USER_ROLE_UPDATED:
        handleUserRoleUpdated(msg);
        break;

    case SocketEvents.CONFIG_CHANGED:
        handleConfigChanged(msg);
        break;

    case SocketEvents.LICENSE_CHANGED:
        handleLicenseChanged(msg);
        break;

    case SocketEvents.PLUGIN_STATUSES_CHANGED:
        handlePluginStatusesChangedEvent(msg);
        break;

    case SocketEvents.OPEN_DIALOG:
        handleOpenDialogEvent(msg);
        break;

    case SocketEvents.RECEIVED_GROUP:
        handleGroupUpdatedEvent(msg);
        break;

    case SocketEvents.GROUP_MEMBER_ADD:
        dispatch(handleGroupAddedMemberEvent(msg));
        break;

    case SocketEvents.GROUP_MEMBER_DELETED:
        dispatch(handleGroupDeletedMemberEvent(msg));
        break;

    case SocketEvents.RECEIVED_GROUP_ASSOCIATED_TO_TEAM:
        handleGroupAssociatedToTeamEvent(msg);
        break;

    case SocketEvents.RECEIVED_GROUP_NOT_ASSOCIATED_TO_TEAM:
        handleGroupNotAssociatedToTeamEvent(msg);
        break;

    case SocketEvents.RECEIVED_GROUP_ASSOCIATED_TO_CHANNEL:
        handleGroupAssociatedToChannelEvent(msg);
        break;

    case SocketEvents.RECEIVED_GROUP_NOT_ASSOCIATED_TO_CHANNEL:
        handleGroupNotAssociatedToChannelEvent(msg);
        break;

    case SocketEvents.WARN_METRIC_STATUS_RECEIVED:
        handleWarnMetricStatusReceivedEvent(msg);
        break;

    case SocketEvents.WARN_METRIC_STATUS_REMOVED:
        handleWarnMetricStatusRemovedEvent(msg);
        break;

    case SocketEvents.SIDEBAR_CATEGORY_CREATED:
        dispatch(handleSidebarCategoryCreated(msg));
        break;

    case SocketEvents.SIDEBAR_CATEGORY_UPDATED:
        dispatch(handleSidebarCategoryUpdated(msg));
        break;

    case SocketEvents.SIDEBAR_CATEGORY_DELETED:
        dispatch(handleSidebarCategoryDeleted(msg));
        break;
    case SocketEvents.SIDEBAR_CATEGORY_ORDER_UPDATED:
        dispatch(handleSidebarCategoryOrderUpdated(msg));
        break;
    case SocketEvents.USER_ACTIVATION_STATUS_CHANGED:
        dispatch(handleUserActivationStatusChange());
        break;
    case SocketEvents.CLOUD_PAYMENT_STATUS_UPDATED:
        dispatch(handleCloudPaymentStatusUpdated(msg));
        break;
    case SocketEvents.CLOUD_SUBSCRIPTION_CHANGED:
        dispatch(handleCloudSubscriptionChanged(msg));
        break;
    case SocketEvents.FIRST_ADMIN_VISIT_MARKETPLACE_STATUS_RECEIVED:
        handleFirstAdminVisitMarketplaceStatusReceivedEvent(msg);
        break;
    case SocketEvents.THREAD_FOLLOW_CHANGED:
        dispatch(handleThreadFollowChanged(msg));
        break;
    case SocketEvents.THREAD_READ_CHANGED:
        dispatch(handleThreadReadChanged(msg));
        break;
    case SocketEvents.THREAD_UPDATED:
        dispatch(handleThreadUpdated(msg));
        break;
    case SocketEvents.APPS_FRAMEWORK_REFRESH_BINDINGS:
        dispatch(handleRefreshAppsBindings());
        break;
    case SocketEvents.APPS_FRAMEWORK_PLUGIN_ENABLED:
        dispatch(handleAppsPluginEnabled());
        break;
    case SocketEvents.APPS_FRAMEWORK_PLUGIN_DISABLED:
        dispatch(handleAppsPluginDisabled());
        break;
    case SocketEvents.POST_ACKNOWLEDGEMENT_ADDED:
        dispatch(handlePostAcknowledgementAdded(msg));
        break;
    case SocketEvents.POST_ACKNOWLEDGEMENT_REMOVED:
        dispatch(handlePostAcknowledgementRemoved(msg));
        break;
    case SocketEvents.DRAFT_CREATED:
    case SocketEvents.DRAFT_UPDATED:
        dispatch(handleUpsertDraftEvent(msg));
        break;
    case SocketEvents.DRAFT_DELETED:
        dispatch(handleDeleteDraftEvent(msg));
        break;
    default:
    }

    Object.values(pluginEventHandlers).forEach((pluginEvents) => {
        if (!pluginEvents) {
            return;
        }

        if (pluginEvents.hasOwnProperty(msg.event) && typeof pluginEvents[msg.event] === 'function') {
            pluginEvents[msg.event](msg);
        }
    });
}

// handleChannelConvertedEvent handles updating of channel which is converted from public to private
function handleChannelConvertedEvent(msg) {
    const channelId = msg.data.channel_id;
    if (channelId) {
        const channel = getChannel(getState(), channelId);
        if (channel) {
            dispatch({
                type: ChannelTypes.RECEIVED_CHANNEL,
                data: {...channel, type: General.PRIVATE_CHANNEL},
            });
        }
    }
}

export function handleChannelUpdatedEvent(msg) {
    return (doDispatch, doGetState) => {
        const channel = JSON.parse(msg.data.channel);

        doDispatch({type: ChannelTypes.RECEIVED_CHANNEL, data: channel});

        const state = doGetState();
        if (channel.id === getCurrentChannelId(state)) {
            getHistory().replace(`${getCurrentRelativeTeamUrl(state)}/channels/${channel.name}`);
        }
    };
}

function handleChannelMemberUpdatedEvent(msg) {
    const channelMember = JSON.parse(msg.data.channelMember);
    const roles = channelMember.roles.split(' ');
    dispatch(loadRolesIfNeeded(roles));
    dispatch({type: ChannelTypes.RECEIVED_MY_CHANNEL_MEMBER, data: channelMember});
}

function debouncePostEvent(wait) {
    let timeout;
    let queue = [];
    let count = 0;

    // Called when timeout triggered
    const triggered = () => {
        timeout = null;

        if (queue.length > 0) {
            dispatch(handleNewPostEvents(queue));
        }

        queue = [];
        count = 0;
    };

    return function fx(msg) {
        if (timeout && count > 4) {
            // If the timeout is going this is the second or further event so queue them up.
            if (queue.push(msg) > 200) {
                // Don't run us out of memory, give up if the queue gets insane
                queue = [];
                console.log('channel broken because of too many incoming messages'); //eslint-disable-line no-console
            }
            clearTimeout(timeout);
            timeout = setTimeout(triggered, wait);
        } else {
            // Apply immediately for events up until count reaches limit
            count += 1;
            dispatch(handleNewPostEvent(msg));
            clearTimeout(timeout);
            timeout = setTimeout(triggered, wait);
        }
    };
}

const handleNewPostEventDebounced = debouncePostEvent(100);

export function handleNewPostEvent(msg) {
    return (myDispatch, myGetState) => {
        const post = JSON.parse(msg.data.post);

        if (window.logPostEvents) {
            // eslint-disable-next-line no-console
            console.log('handleNewPostEvent - new post received', post);
        }

        myDispatch(handleNewPost(post, msg));

        getProfilesAndStatusesForPosts([post], myDispatch, myGetState);

        // Since status updates aren't real time, assume another user is online if they have posted and:
        // 1. The user hasn't set their status manually to something that isn't online
        // 2. The server hasn't told the client not to set the user to online. This happens when:
        //     a. The post is from the auto responder
        //     b. The post is a response to a push notification
        if (
            post.user_id !== getCurrentUserId(myGetState()) &&
            !getIsManualStatusForUserId(myGetState(), post.user_id) &&
            msg.data.set_online
        ) {
            myDispatch({
                type: UserTypes.RECEIVED_STATUSES,
                data: [{user_id: post.user_id, status: UserStatuses.ONLINE}],
            });
        }
    };
}

export function handleNewPostEvents(queue) {
    return (myDispatch, myGetState) => {
        // Note that this method doesn't properly update the sidebar state for these posts
        const posts = queue.map((msg) => JSON.parse(msg.data.post));

        if (window.logPostEvents) {
            // eslint-disable-next-line no-console
            console.log('handleNewPostEvents - new posts received', posts);
        }

        // Receive the posts as one continuous block since they were received within a short period
        const crtEnabled = isCollapsedThreadsEnabled(myGetState());
        const actions = posts.map((post) => receivedNewPost(post, crtEnabled));
        myDispatch(batchActions(actions));

        // Load the posts' threads
        myDispatch(getThreadsForPosts(posts));

        // And any other data needed for them
        getProfilesAndStatusesForPosts(posts, myDispatch, myGetState);
    };
}

export function handlePostEditEvent(msg) {
    // Store post
    const post = JSON.parse(msg.data.post);

    if (window.logPostEvents) {
        // eslint-disable-next-line no-console
        console.log('handlePostEditEvent - post edit received', post);
    }

    const crtEnabled = isCollapsedThreadsEnabled(getState());
    dispatch(receivedPost(post, crtEnabled));

    getProfilesAndStatusesForPosts([post], dispatch, getState);
    const currentChannelId = getCurrentChannelId(getState());

    // Update channel state
    if (currentChannelId === msg.broadcast.channel_id) {
        dispatch(getChannelStats(currentChannelId));
        if (window.isActive) {
            dispatch(viewChannel(currentChannelId));
        }
    }
}

async function handlePostDeleteEvent(msg) {
    const post = JSON.parse(msg.data.post);

    if (window.logPostEvents) {
        // eslint-disable-next-line no-console
        console.log('handlePostDeleteEvent - post delete received', post);
    }

    const state = getState();
    const collapsedThreads = isCollapsedThreadsEnabled(state);

    if (!post.root_id && collapsedThreads) {
        dispatch(decrementThreadCounts(post));
    }

    dispatch(postDeleted(post));

    // update thread when a comment is deleted and CRT is on
    if (post.root_id && collapsedThreads) {
        const thread = getThread(state, post.root_id);
        if (thread) {
            const userId = getCurrentUserId(state);
            const teamId = getCurrentTeamId(state);
            dispatch(fetchThread(userId, teamId, post.root_id, true));
        } else {
            const res = await dispatch(getPostThread(post.root_id));
            const {order, posts} = res.data;
            const rootPost = posts[order[0]];
            dispatch(receivedPost(rootPost));
        }
    }

    if (post.is_pinned) {
        dispatch(getChannelStats(post.channel_id));
    }
}

export function handlePostUnreadEvent(msg) {
    dispatch(
        {
            type: ActionTypes.POST_UNREAD_SUCCESS,
            data: {
                lastViewedAt: msg.data.last_viewed_at,
                channelId: msg.broadcast.channel_id,
                msgCount: msg.data.msg_count,
                msgCountRoot: msg.data.msg_count_root,
                mentionCount: msg.data.mention_count,
                mentionCountRoot: msg.data.mention_count_root,
            },
        },
    );
}

async function handleTeamAddedEvent(msg) {
    await dispatch(TeamActions.getTeam(msg.data.team_id));
    await dispatch(TeamActions.getMyTeamMembers());
    const state = getState();
    await dispatch(TeamActions.getMyTeamUnreads(isCollapsedThreadsEnabled(state)));
    const license = getLicense(state);
    if (license.Cloud === 'true') {
        dispatch(getTeamsUsage());
    }
}

export function handleLeaveTeamEvent(msg) {
    const state = getState();

    const actions = [
        {
            type: UserTypes.RECEIVED_PROFILE_NOT_IN_TEAM,
            data: {id: msg.data.team_id, user_id: msg.data.user_id},
        },
        {
            type: TeamTypes.REMOVE_MEMBER_FROM_TEAM,
            data: {team_id: msg.data.team_id, user_id: msg.data.user_id},
        },
    ];

    const channelsPerTeam = getChannelsInTeam(state);
    const channels = (channelsPerTeam && channelsPerTeam[msg.data.team_id]) || [];

    for (const channel of channels) {
        actions.push({
            type: ChannelTypes.REMOVE_MEMBER_FROM_CHANNEL,
            data: {id: channel, user_id: msg.data.user_id},
        });
    }

    dispatch(batchActions(actions));
    const currentUser = getCurrentUser(state);

    if (currentUser.id === msg.data.user_id) {
        dispatch({type: TeamTypes.LEAVE_TEAM, data: {id: msg.data.team_id}});

        // if they are on the team being removed redirect them to default team
        if (getCurrentTeamId(state) === msg.data.team_id) {
            if (!global.location.pathname.startsWith('/admin_console')) {
                redirectUserToDefaultTeam();
            }
        }
        if (isGuest(currentUser.roles)) {
            dispatch(removeNotVisibleUsers());
        }
    } else {
        const team = getTeam(state, msg.data.team_id);
        const members = getChannelMembersInChannels(state);
        const isMember = Object.values(members).some((member) => member[msg.data.user_id]);
        if (team && isGuest(currentUser.roles) && !isMember) {
            dispatch(batchActions([
                {
                    type: UserTypes.PROFILE_NO_LONGER_VISIBLE,
                    data: {user_id: msg.data.user_id},
                },
                {
                    type: TeamTypes.REMOVE_MEMBER_FROM_TEAM,
                    data: {team_id: team.id, user_id: msg.data.user_id},
                },
            ]));
        }
    }
}

function handleUpdateTeamEvent(msg) {
    const state = store.getState();
    const license = getLicense(state);
    dispatch({type: TeamTypes.UPDATED_TEAM, data: JSON.parse(msg.data.team)});
    if (license.Cloud === 'true') {
        dispatch(getTeamsUsage());
    }
}

function handleUpdateTeamSchemeEvent() {
    dispatch(TeamActions.getMyTeamMembers());
}

function handleDeleteTeamEvent(msg) {
    const deletedTeam = JSON.parse(msg.data.team);
    const state = store.getState();
    const {teams} = state.entities.teams;
    const license = getLicense(state);
    if (license.Cloud === 'true') {
        dispatch(getTeamsUsage());
    }
    if (
        deletedTeam &&
        teams &&
        teams[deletedTeam.id] &&
        teams[deletedTeam.id].delete_at === 0
    ) {
        const {currentUserId} = state.entities.users;
        const {currentTeamId, myMembers} = state.entities.teams;
        const teamMembers = Object.values(myMembers);
        const teamMember = teamMembers.find((m) => m.user_id === currentUserId && m.team_id === currentTeamId);

        let newTeamId = '';
        if (
            deletedTeam &&
            teamMember &&
            deletedTeam.id === teamMember.team_id
        ) {
            const myTeams = {};
            getMyTeams(state).forEach((t) => {
                myTeams[t.id] = t;
            });

            for (let i = 0; i < teamMembers.length; i++) {
                const memberTeamId = teamMembers[i].team_id;
                if (
                    myTeams &&
                    myTeams[memberTeamId] &&
                    myTeams[memberTeamId].delete_at === 0 &&
                    deletedTeam.id !== memberTeamId
                ) {
                    newTeamId = memberTeamId;
                    break;
                }
            }
        }

        dispatch(batchActions([
            {type: TeamTypes.RECEIVED_TEAM_DELETED, data: {id: deletedTeam.id}},
            {type: TeamTypes.UPDATED_TEAM, data: deletedTeam},
        ]));

        if (currentTeamId === deletedTeam.id) {
            if (newTeamId) {
                dispatch({type: TeamTypes.SELECT_TEAM, data: newTeamId});
                const globalState = getState();
                const redirectChannel = getRedirectChannelNameForTeam(globalState, newTeamId);
                getHistory().push(`${getCurrentTeamUrl(globalState)}/channels/${redirectChannel}`);
            } else {
                getHistory().push('/');
            }
        }
    }
}

function handleUpdateMemberRoleEvent(msg) {
    const memberData = JSON.parse(msg.data.member);
    const newRoles = memberData.roles.split(' ');

    dispatch(loadRolesIfNeeded(newRoles));

    dispatch({
        type: TeamTypes.RECEIVED_MY_TEAM_MEMBER,
        data: memberData,
    });
}

function handleDirectAddedEvent(msg) {
    return fetchChannelAndAddToSidebar(msg.broadcast.channel_id);
}

function handleGroupAddedEvent(msg) {
    return fetchChannelAndAddToSidebar(msg.broadcast.channel_id);
}

function handleUserAddedEvent(msg) {
    return async (doDispatch, doGetState) => {
        const state = doGetState();
        const config = getConfig(state);
        const license = getLicense(state);
        const isTimezoneEnabled = config.ExperimentalTimezone === 'true';
        const currentChannelId = getCurrentChannelId(state);
        if (currentChannelId === msg.broadcast.channel_id) {
            doDispatch(getChannelStats(currentChannelId));
            doDispatch({
                type: UserTypes.RECEIVED_PROFILE_IN_CHANNEL,
                data: {id: msg.broadcast.channel_id, user_id: msg.data.user_id},
            });
            if (license?.IsLicensed === 'true' && license?.LDAPGroups === 'true' && config.EnableConfirmNotificationsToChannel === 'true') {
                doDispatch(getChannelMemberCountsByGroup(currentChannelId, isTimezoneEnabled));
            }
        }

        // Load the channel so that it appears in the sidebar
        const currentTeamId = getCurrentTeamId(doGetState());
        const currentUserId = getCurrentUserId(doGetState());
        if (currentTeamId === msg.data.team_id && currentUserId === msg.data.user_id) {
            doDispatch(fetchChannelAndAddToSidebar(msg.broadcast.channel_id));
        }

        // This event is fired when a user first joins the server, so refresh analytics to see if we're now over the user limit
        if (license.Cloud === 'true' && isCurrentUserSystemAdmin(doGetState())) {
            doDispatch(getStandardAnalytics());
        }
    };
}

function fetchChannelAndAddToSidebar(channelId) {
    return async (doDispatch) => {
        const {data, error} = await doDispatch(getChannelAndMyMember(channelId));

        if (!error) {
            doDispatch(addChannelToInitialCategory(data.channel));
        }
    };
}

export function handleUserRemovedEvent(msg) {
    const state = getState();
    const currentChannel = getCurrentChannel(state) || {};
    const currentUser = getCurrentUser(state);
    const config = getConfig(state);
    const license = getLicense(state);
    const isTimezoneEnabled = config.ExperimentalTimezone === 'true';

    if (msg.broadcast.user_id === currentUser.id) {
        dispatch(loadChannelsForCurrentUser());

        const rhsChannelId = getSelectedChannelId(state);
        if (msg.data.channel_id === rhsChannelId) {
            dispatch(closeRightHandSide());
        }

        if (msg.data.channel_id === currentChannel.id) {
            if (msg.data.remover_id !== msg.broadcast.user_id) {
                const user = getUser(state, msg.data.remover_id);
                if (!user) {
                    dispatch(loadUser(msg.data.remover_id));
                }

                dispatch(openModal({
                    modalId: ModalIdentifiers.REMOVED_FROM_CHANNEL,
                    dialogType: RemovedFromChannelModal,
                    dialogProps: {
                        channelName: currentChannel.display_name,
                        removerId: msg.data.remover_id,
                    },
                }));
            }
        }

        const channel = getChannel(state, msg.data.channel_id);

        dispatch({
            type: ChannelTypes.LEAVE_CHANNEL,
            data: {
                id: msg.data.channel_id,
                user_id: msg.broadcast.user_id,
                team_id: channel?.team_id,
            },
        });

        if (msg.data.channel_id === currentChannel.id) {
            redirectUserToDefaultTeam();
        }

        if (isGuest(currentUser.roles)) {
            dispatch(removeNotVisibleUsers());
        }
    } else if (msg.broadcast.channel_id === currentChannel.id) {
        dispatch(getChannelStats(currentChannel.id));
        dispatch({
            type: UserTypes.RECEIVED_PROFILE_NOT_IN_CHANNEL,
            data: {id: msg.broadcast.channel_id, user_id: msg.data.user_id},
        });
        if (license?.IsLicensed === 'true' && license?.LDAPGroups === 'true' && config.EnableConfirmNotificationsToChannel === 'true') {
            dispatch(getChannelMemberCountsByGroup(currentChannel.id, isTimezoneEnabled));
        }
    }

    if (msg.broadcast.user_id !== currentUser.id) {
        const channel = getChannel(state, msg.broadcast.channel_id);
        const members = getChannelMembersInChannels(state);
        const isMember = Object.values(members).some((member) => member[msg.data.user_id]);
        if (channel && isGuest(currentUser.roles) && !isMember) {
            const actions = [
                {
                    type: UserTypes.PROFILE_NO_LONGER_VISIBLE,
                    data: {user_id: msg.data.user_id},
                },
                {
                    type: TeamTypes.REMOVE_MEMBER_FROM_TEAM,
                    data: {team_id: channel.team_id, user_id: msg.data.user_id},
                },
            ];
            dispatch(batchActions(actions));
        }
    }

    const channelId = msg.broadcast.channel_id || msg.data.channel_id;
    const userId = msg.broadcast.user_id || msg.data.user_id;
    const channel = getChannel(state, channelId);
    if (channel && !haveISystemPermission(state, {permission: Permissions.VIEW_MEMBERS}) && !haveITeamPermission(state, channel.team_id, Permissions.VIEW_MEMBERS)) {
        dispatch(batchActions([
            {
                type: UserTypes.RECEIVED_PROFILE_NOT_IN_TEAM,
                data: {id: channel.team_id, user_id: userId},
            },
            {
                type: TeamTypes.REMOVE_MEMBER_FROM_TEAM,
                data: {team_id: channel.team_id, user_id: userId},
            },
        ]));
    }
}

export async function handleUserUpdatedEvent(msg) {
    // This websocket event is sent to all non-guest users on the server, so be careful requesting data from the server
    // in response to it. That can overwhelm the server if every connected user makes such a request at the same time.
    // See https://mattermost.atlassian.net/browse/MM-40050 for more information.

    const state = getState();
    const currentUser = getCurrentUser(state);
    const user = msg.data.user;
    if (user && user.props) {
        const customStatus = user.props.customStatus ? JSON.parse(user.props.customStatus) : undefined;
        dispatch(loadCustomEmojisIfNeeded([customStatus?.emoji]));
    }

    if (currentUser.id === user.id) {
        if (user.update_at > currentUser.update_at) {
            // update user to unsanitized user data recieved from websocket message
            dispatch({
                type: UserTypes.RECEIVED_ME,
                data: user,
            });
            dispatch(loadRolesIfNeeded(user.roles.split(' ')));
        }
    } else {
        dispatch({
            type: UserTypes.RECEIVED_PROFILE,
            data: user,
        });
    }
}

function handleRoleAddedEvent(msg) {
    const role = JSON.parse(msg.data.role);

    dispatch({
        type: RoleTypes.RECEIVED_ROLE,
        data: role,
    });
}

function handleRoleRemovedEvent(msg) {
    const role = JSON.parse(msg.data.role);

    dispatch({
        type: RoleTypes.ROLE_DELETED,
        data: role,
    });
}

function handleChannelSchemeUpdatedEvent(msg) {
    dispatch(getMyChannelMember(msg.broadcast.channel_id));
}

function handleRoleUpdatedEvent(msg) {
    const role = JSON.parse(msg.data.role);

    dispatch({
        type: RoleTypes.RECEIVED_ROLE,
        data: role,
    });
}

function handleChannelCreatedEvent(msg) {
    return async (myDispatch, myGetState) => {
        const channelId = msg.data.channel_id;
        const teamId = msg.data.team_id;
        const state = myGetState();

        if (getCurrentTeamId(state) === teamId) {
            let channel = getChannel(state, channelId);

            if (!channel) {
                await myDispatch(getChannelAndMyMember(channelId));

                channel = getChannel(myGetState(), channelId);
            }

            myDispatch(addChannelToInitialCategory(channel, false));
        }
    };
}

function handleChannelDeletedEvent(msg) {
    const state = getState();
    const config = getConfig(state);
    const viewArchivedChannels = config.ExperimentalViewArchivedChannels === 'true';
    if (getCurrentChannelId(state) === msg.data.channel_id && !viewArchivedChannels) {
        const teamUrl = getCurrentRelativeTeamUrl(state);
        const currentTeamId = getCurrentTeamId(state);
        const redirectChannel = getRedirectChannelNameForTeam(state, currentTeamId);
        getHistory().push(teamUrl + '/channels/' + redirectChannel);
    }

    dispatch({type: ChannelTypes.RECEIVED_CHANNEL_DELETED, data: {id: msg.data.channel_id, team_id: msg.broadcast.team_id, deleteAt: msg.data.delete_at, viewArchivedChannels}});
}

function handleChannelUnarchivedEvent(msg) {
    const state = getState();
    const config = getConfig(state);
    const viewArchivedChannels = config.ExperimentalViewArchivedChannels === 'true';

    dispatch({type: ChannelTypes.RECEIVED_CHANNEL_UNARCHIVED, data: {id: msg.data.channel_id, team_id: msg.broadcast.team_id, viewArchivedChannels}});
}

function handlePreferenceChangedEvent(msg) {
    const preference = JSON.parse(msg.data.preference);
    dispatch({type: PreferenceTypes.RECEIVED_PREFERENCES, data: [preference]});

    if (addedNewDmUser(preference)) {
        loadProfilesForSidebar();
    }
}

function handlePreferencesChangedEvent(msg) {
    const preferences = JSON.parse(msg.data.preferences);
    dispatch({type: PreferenceTypes.RECEIVED_PREFERENCES, data: preferences});

    if (preferences.findIndex(addedNewDmUser) !== -1) {
        loadProfilesForSidebar();
    }
}

function handlePreferencesDeletedEvent(msg) {
    const preferences = JSON.parse(msg.data.preferences);
    dispatch({type: PreferenceTypes.DELETED_PREFERENCES, data: preferences});
}

function addedNewDmUser(preference) {
    return preference.category === Constants.Preferences.CATEGORY_DIRECT_CHANNEL_SHOW && preference.value === 'true';
}

function handleStatusChangedEvent(msg) {
    dispatch({
        type: UserTypes.RECEIVED_STATUSES,
        data: [{user_id: msg.data.user_id, status: msg.data.status}],
    });
}

function handleHelloEvent(msg) {
    setServerVersion(msg.data.server_version)(dispatch, getState);
    dispatch(setConnectionId(msg.data.connection_id));
}

function handleReactionAddedEvent(msg) {
    const reaction = JSON.parse(msg.data.reaction);

    dispatch(getCustomEmojiForReaction(reaction.emoji_name));

    dispatch({
        type: PostTypes.RECEIVED_REACTION,
        data: reaction,
    });
}

function setConnectionId(connectionId) {
    return {
        type: GeneralTypes.SET_CONNECTION_ID,
        payload: {connectionId},
    };
}

function handleAddEmoji(msg) {
    const data = JSON.parse(msg.data.emoji);

    dispatch({
        type: EmojiTypes.RECEIVED_CUSTOM_EMOJI,
        data,
    });
}

function handleReactionRemovedEvent(msg) {
    const reaction = JSON.parse(msg.data.reaction);

    dispatch({
        type: PostTypes.REACTION_DELETED,
        data: reaction,
    });
}

function handleChannelViewedEvent(msg) {
    // Useful for when multiple devices have the app open to different channels
    if ((!window.isActive || getCurrentChannelId(getState()) !== msg.data.channel_id) &&
        getCurrentUserId(getState()) === msg.broadcast.user_id) {
        dispatch(markChannelAsRead(msg.data.channel_id, '', false));
    }
}

export function handlePluginEnabled(msg) {
    const manifest = msg.data.manifest;
    dispatch({type: ActionTypes.RECEIVED_WEBAPP_PLUGIN, data: manifest});

    loadPlugin(manifest).catch((error) => {
        console.error(error.message); //eslint-disable-line no-console
    });
}

export function handlePluginDisabled(msg) {
    const manifest = msg.data.manifest;
    removePlugin(manifest);
}

function handleUserRoleUpdated(msg) {
    const user = store.getState().entities.users.profiles[msg.data.user_id];

    if (user) {
        const roles = msg.data.roles;
        const newRoles = roles.split(' ');
        const demoted = user.roles.includes(Constants.PERMISSIONS_SYSTEM_ADMIN) && !roles.includes(Constants.PERMISSIONS_SYSTEM_ADMIN);

        store.dispatch({type: UserTypes.RECEIVED_PROFILE, data: {...user, roles}});
        dispatch(loadRolesIfNeeded(newRoles));

        if (demoted && global.location.pathname.startsWith('/admin_console')) {
            redirectUserToDefaultTeam();
        }
    }
}

function handleConfigChanged(msg) {
    store.dispatch({type: GeneralTypes.CLIENT_CONFIG_RECEIVED, data: msg.data.config});
}

function handleLicenseChanged(msg) {
    store.dispatch({type: GeneralTypes.CLIENT_LICENSE_RECEIVED, data: msg.data.license});
}

function handlePluginStatusesChangedEvent(msg) {
    store.dispatch({type: AdminTypes.RECEIVED_PLUGIN_STATUSES, data: msg.data.plugin_statuses});
}

function handleOpenDialogEvent(msg) {
    const data = (msg.data && msg.data.dialog) || {};
    const dialog = JSON.parse(data);

    store.dispatch({type: IntegrationTypes.RECEIVED_DIALOG, data: dialog});

    const currentTriggerId = getState().entities.integrations.dialogTriggerId;

    if (dialog.trigger_id !== currentTriggerId) {
        return;
    }

    store.dispatch(openModal({modalId: ModalIdentifiers.INTERACTIVE_DIALOG, dialogType: InteractiveDialog}));
}

function handleGroupUpdatedEvent(msg) {
    const data = JSON.parse(msg.data.group);
    dispatch(
        {
            type: GroupTypes.PATCHED_GROUP,
            data,
        },
    );
}

function handleGroupAddedMemberEvent(msg) {
    return (doDispatch, doGetState) => {
        const state = doGetState();
        const currentUserId = getCurrentUserId(state);
        const data = JSON.parse(msg.data.group_member);

        if (currentUserId === data.user_id) {
            dispatch(
                {
                    type: GroupTypes.ADD_MY_GROUP,
                    data,
                    id: data.group_id,
                },
            );
        }
    };
}

function handleGroupDeletedMemberEvent(msg) {
    return (doDispatch, doGetState) => {
        const state = doGetState();
        const currentUserId = getCurrentUserId(state);
        const data = JSON.parse(msg.data.group_member);

        if (currentUserId === data.user_id) {
            dispatch(
                {
                    type: GroupTypes.REMOVE_MY_GROUP,
                    data,
                    id: data.group_id,
                },
            );
        }
    };
}

function handleGroupAssociatedToTeamEvent(msg) {
    store.dispatch({
        type: GroupTypes.RECEIVED_GROUP_ASSOCIATED_TO_TEAM,
        data: {teamID: msg.broadcast.team_id, groups: [{id: msg.data.group_id}]},
    });
}

function handleGroupNotAssociatedToTeamEvent(msg) {
    store.dispatch({
        type: GroupTypes.RECEIVED_GROUP_NOT_ASSOCIATED_TO_TEAM,
        data: {teamID: msg.broadcast.team_id, groups: [{id: msg.data.group_id}]},
    });
}

function handleGroupAssociatedToChannelEvent(msg) {
    store.dispatch({
        type: GroupTypes.RECEIVED_GROUP_ASSOCIATED_TO_CHANNEL,
        data: {channelID: msg.broadcast.channel_id, groups: [{id: msg.data.group_id}]},
    });
}

function handleGroupNotAssociatedToChannelEvent(msg) {
    store.dispatch({
        type: GroupTypes.RECEIVED_GROUP_NOT_ASSOCIATED_TO_CHANNEL,
        data: {channelID: msg.broadcast.channel_id, groups: [{id: msg.data.group_id}]},
    });
}

function handleWarnMetricStatusReceivedEvent(msg) {
    var receivedData = JSON.parse(msg.data.warnMetricStatus);
    let bannerData;
    if (receivedData.id === WarnMetricTypes.SYSTEM_WARN_METRIC_NUMBER_OF_ACTIVE_USERS_500) {
        bannerData = AnnouncementBarMessages.WARN_METRIC_STATUS_NUMBER_OF_USERS;
    } else if (receivedData.id === WarnMetricTypes.SYSTEM_WARN_METRIC_NUMBER_OF_POSTS_2M) {
        bannerData = AnnouncementBarMessages.WARN_METRIC_STATUS_NUMBER_OF_POSTS;
    }
    store.dispatch(batchActions([
        {
            type: GeneralTypes.WARN_METRIC_STATUS_RECEIVED,
            data: receivedData,
        },
        {
            type: ActionTypes.SHOW_NOTICE,
            data: [bannerData],
        },
    ]));
}

function handleWarnMetricStatusRemovedEvent(msg) {
    store.dispatch({type: GeneralTypes.WARN_METRIC_STATUS_REMOVED, data: {id: msg.data.warnMetricId}});
}

function handleSidebarCategoryCreated(msg) {
    return (doDispatch, doGetState) => {
        const state = doGetState();

        if (msg.broadcast.team_id !== getCurrentTeamId(state)) {
            // The new category will be loaded when we switch teams.
            return;
        }

        // Fetch all categories, including ones that weren't explicitly updated, in case any other categories had channels
        // moved out of them.
        doDispatch(fetchMyCategories(msg.broadcast.team_id));
    };
}

function handleSidebarCategoryUpdated(msg) {
    return (doDispatch, doGetState) => {
        const state = doGetState();

        if (msg.broadcast.team_id !== getCurrentTeamId(state)) {
            // The updated categories will be loaded when we switch teams.
            return;
        }

        // Fetch all categories in case any other categories had channels moved out of them.
        doDispatch(fetchMyCategories(msg.broadcast.team_id));
    };
}

function handleSidebarCategoryDeleted(msg) {
    return (doDispatch, doGetState) => {
        const state = doGetState();

        if (msg.broadcast.team_id !== getCurrentTeamId(state)) {
            // The category will be removed when we switch teams.
            return;
        }

        // Fetch all categories since any channels that were in the deleted category were moved to other categories.
        doDispatch(fetchMyCategories(msg.broadcast.team_id));
    };
}

function handleSidebarCategoryOrderUpdated(msg) {
    return receivedCategoryOrder(msg.broadcast.team_id, msg.data.order);
}

export function handleUserActivationStatusChange() {
    return (doDispatch, doGetState) => {
        const state = doGetState();
        const license = getLicense(state);

        // This event is fired when a user first joins the server, so refresh analytics to see if we're now over the user limit
        if (license.Cloud === 'true') {
            if (isCurrentUserSystemAdmin(state)) {
                doDispatch(getStandardAnalytics());
            }
        }
    };
}

function handleCloudPaymentStatusUpdated() {
    return (doDispatch) => doDispatch(getCloudSubscription());
}

export function handleCloudSubscriptionChanged(msg) {
    return (doDispatch, doGetState) => {
        const state = doGetState();
        const license = getLicense(state);

        if (license.Cloud === 'true') {
            if (msg.data.limits) {
                doDispatch({
                    type: CloudTypes.RECEIVED_CLOUD_LIMITS,
                    data: msg.data.limits,
                });
            }

            if (msg.data.subscription) {
                doDispatch({
                    type: CloudTypes.RECEIVED_CLOUD_SUBSCRIPTION,
                    data: msg.data.subscription,
                });
            }
        }
        return {data: true};
    };
}

function handleRefreshAppsBindings() {
    return (doDispatch, doGetState) => {
        const state = doGetState();

        doDispatch(fetchAppBindings(getCurrentChannelId(state)));

        const siteURL = state.entities.general.config.SiteURL;
        const currentURL = window.location.href;
        let threadIdentifier;
        if (currentURL.startsWith(siteURL)) {
            const parts = currentURL.substr(siteURL.length + (siteURL.endsWith('/') ? 0 : 1)).split('/');
            if (parts.length === 3 && parts[1] === 'threads') {
                threadIdentifier = parts[2];
            }
        }
        const rhsPost = getSelectedPost(state);
        let selectedThread;
        if (threadIdentifier) {
            selectedThread = getThread(state, threadIdentifier);
        }
        const rootID = threadIdentifier || rhsPost?.id;
        const channelID = selectedThread?.post?.channel_id || rhsPost?.channel_id;
        if (!rootID) {
            return {data: true};
        }

        doDispatch(fetchRHSAppsBindings(channelID));
        return {data: true};
    };
}

export function handleAppsPluginEnabled() {
    return {
        type: AppsTypes.APPS_PLUGIN_ENABLED,
    };
}

export function handleAppsPluginDisabled() {
    return {
        type: AppsTypes.APPS_PLUGIN_DISABLED,
    };
}

function handleFirstAdminVisitMarketplaceStatusReceivedEvent(msg) {
    const receivedData = JSON.parse(msg.data.firstAdminVisitMarketplaceStatus);
    store.dispatch({type: GeneralTypes.FIRST_ADMIN_VISIT_MARKETPLACE_STATUS_RECEIVED, data: receivedData});
}

function handleThreadReadChanged(msg) {
    return (doDispatch, doGetState) => {
        if (msg.data.thread_id) {
            const state = doGetState();
            const thread = getThreads(state)?.[msg.data.thread_id];

            // skip marking the thread as read (when the user is viewing the thread)
            if (thread && !isThreadOpen(state, thread.id)) {
                doDispatch(updateThreadLastOpened(thread.id, msg.data.timestamp));
            }

            doDispatch(
                handleReadChanged(
                    msg.data.thread_id,
                    msg.broadcast.team_id,
                    msg.data.channel_id,
                    {
                        lastViewedAt: msg.data.timestamp,
                        prevUnreadMentions: thread?.unread_mentions ?? msg.data.previous_unread_mentions,
                        newUnreadMentions: msg.data.unread_mentions,
                        prevUnreadReplies: thread?.unread_replies ?? msg.data.previous_unread_replies,
                        newUnreadReplies: msg.data.unread_replies,
                    },
                ),
            );
        } else if (msg.broadcast.channel_id) {
            handleAllThreadsInChannelMarkedRead(doDispatch, doGetState, msg.broadcast.channel_id, msg.data.timestamp);
        } else {
            handleAllMarkedRead(doDispatch, msg.broadcast.team_id);
        }
    };
}

function handleThreadUpdated(msg) {
    return (doDispatch, doGetState) => {
        let threadData;
        try {
            threadData = JSON.parse(msg.data.thread);
        } catch {
            // invalid JSON
            return;
        }

        const state = doGetState();
        const currentUserId = getCurrentUserId(state);
        const currentTeamId = getCurrentTeamId(state);

        let lastViewedAt;

        // if current user has replied to the thread
        // make sure to set following as true
        if (currentUserId === threadData.post.user_id) {
            threadData.is_following = true;
        }

        if (isThreadOpen(state, threadData.id) && !isThreadManuallyUnread(state, threadData.id)) {
            lastViewedAt = Date.now();

            // Sometimes `Date.now()` was generating a timestamp before the
            // last_reply_at of the thread, thus marking the thread as unread
            // instead of read. Here we set the timestamp to after the
            // last_reply_at if this happens.
            if (lastViewedAt < threadData.last_reply_at) {
                lastViewedAt = threadData.last_reply_at + 1;
            }

            // prematurely update thread data as read
            // so we won't flash the indicators when
            // we mark the thread as read on the server
            threadData.last_viewed_at = lastViewedAt;
            threadData.unread_mentions = 0;
            threadData.unread_replies = 0;

            // mark thread as read on the server
            dispatch(updateThreadRead(currentUserId, currentTeamId, threadData.id, lastViewedAt));
        }

        handleThreadArrived(doDispatch, doGetState, threadData, msg.broadcast.team_id, msg.data.previous_unread_replies, msg.data.previous_unread_mentions);
    };
}

function handleThreadFollowChanged(msg) {
    return async (doDispatch, doGetState) => {
        const state = doGetState();
        const thread = getThread(state, msg.data.thread_id);
        if (!thread && msg.data.state && msg.data.reply_count) {
            await doDispatch(fetchThread(getCurrentUserId(state), getCurrentTeamId(state), msg.data.thread_id, true));
        }
        handleFollowChanged(doDispatch, msg.data.thread_id, msg.broadcast.team_id, msg.data.state);
    };
}

function handlePostAcknowledgementAdded(msg) {
    const data = JSON.parse(msg.data.acknowledgement);

    return {
        type: PostTypes.CREATE_ACK_POST_SUCCESS,
        data,
    };
}

function handlePostAcknowledgementRemoved(msg) {
    const data = JSON.parse(msg.data.acknowledgement);

    return {
        type: PostTypes.DELETE_ACK_POST_SUCCESS,
        data,
    };
}

function handleUpsertDraftEvent(msg) {
    return async (doDispatch, doGetState) => {
        const state = doGetState();
        const connectionId = getConnectionId(state);

        const draft = JSON.parse(msg.data.draft);
        const {key, value} = transformServerDraft(draft);
        value.show = true;
        value.remote = false;

        if (msg.broadcast.omit_connection_id !== connectionId) {
            value.remote = true;
        }

        doDispatch(setGlobalItem(key, value));
    };
}

function handleDeleteDraftEvent(msg) {
    return async (doDispatch) => {
        const draft = JSON.parse(msg.data.draft);
        const {key} = transformServerDraft(draft);

        doDispatch(setGlobalItem(key, {message: '', fileInfos: [], uploadsInProgress: [], remote: true}));
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {WebSocketClient} from '@mattermost/client';

var WebClient = new WebSocketClient();
export default WebClient;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';
import classNames from 'classnames';
import {useSelector} from 'react-redux';

import MattermostLogo from 'components/widgets/icons/mattermost_logo';
import {GlobalState} from 'types/store';

import './about_build_modal_cloud.scss';

type Props = {
    onExited: () => void;
    config: any;
    license: any;
    show: boolean;
    doHide: () => void;
};

// Webpack global var
declare const COMMIT_HASH: string;

export default function AboutBuildModalCloud(props: Props) {
    const config = props.config;
    const license = props.license;

    let companyName = license.Company;
    const companyInfo = useSelector((state: GlobalState) => state.entities.cloud.customer);

    if (companyInfo) {
        companyName = companyInfo.name;
    }

    const title = (
        <FormattedMessage
            id='about.cloudEdition'
            defaultMessage='Cloud'
        />
    );

    const subTitle = (
        <FormattedMessage
            id='about.enterpriseEditionSst'
            defaultMessage='High trust messaging for the enterprise'
        />
    );

    const licensee = (
        <div className='form-group'>
            <FormattedMessage
                id='about.licensed'
                defaultMessage='Licensed to:'
            />
            {'\u00a0' + companyName}
        </div>
    );

    let mmversion = config.BuildNumber;
    if (!isNaN(config.BuildNumber)) {
        mmversion = 'ci';
    }

    return (
        <Modal
            dialogClassName={classNames('a11y__modal', 'about-modal', 'cloud')}
            show={props.show}
            onHide={props.doHide}
            onExited={props.onExited}
            role='dialog'
            aria-labelledby='aboutModalLabel'
        >
            <Modal.Header closeButton={true}>
                <Modal.Title
                    componentClass='h1'
                    id='aboutModalLabel'
                >
                    <FormattedMessage
                        id='about.title'
                        values={{appTitle: config.SiteName || 'Mattermost'}}
                        defaultMessage='About {appTitle}'
                    />
                </Modal.Title>
            </Modal.Header>
            <Modal.Body>
                <div className='about-modal__content'>
                    <div className='about-modal__logo'>
                        <MattermostLogo/>
                    </div>
                    <div>
                        <h3 className='about-modal__title'>
                            <strong>{'Mattermost'} {title}</strong>
                        </h3>
                        <p className='subtitle'>{subTitle}</p>
                        <div className='description'>
                            <div>
                                <FormattedMessage
                                    id='about.version'
                                    defaultMessage='Mattermost Version:'
                                />
                                <span id='versionString'>{'\u00a0' + mmversion}</span>
                            </div>
                        </div>
                        {licensee}
                        <div className='about-footer'>
                            <FormattedMessage
                                id='about.notice'
                                defaultMessage='Mattermost is made possible by the open source software used in our <linkServer>server</linkServer>, <linkDesktop>desktop</linkDesktop> and <linkMobile>mobile</linkMobile> apps.'
                                values={{
                                    linkServer: (msg: React.ReactNode) => (
                                        <a
                                            href='https://github.com/mattermost/mattermost-server/blob/master/NOTICE.txt'
                                            target='_blank'
                                            rel='noreferrer'
                                        >
                                            {msg}
                                        </a>
                                    ),
                                    linkDesktop: (msg: React.ReactNode) => (
                                        <a
                                            href='https://github.com/mattermost/desktop/blob/master/NOTICE.txt'
                                            target='_blank'
                                            rel='noreferrer'
                                        >
                                            {msg}
                                        </a>
                                    ),
                                    linkMobile: (msg: React.ReactNode) => (
                                        <a
                                            href='https://github.com/mattermost/mattermost-mobile/blob/master/NOTICE.txt'
                                            target='_blank'
                                            rel='noreferrer'
                                        >
                                            {msg}
                                        </a>
                                    ),
                                }}
                            />
                            <div className='copy-right'>
                                <FormattedMessage
                                    id='about.copyright'
                                    defaultMessage='Copyright 2015 - {currentYear} Mattermost, Inc. All rights reserved'
                                    values={{
                                        currentYear: new Date().getFullYear(),
                                    }}
                                />
                            </div>
                        </div>
                    </div>
                    <div/>
                </div>
                <div className='about-modal__hash'>
                    <p>
                        <FormattedMessage
                            id='about.hash'
                            defaultMessage='Build Hash:'
                        />
                        {config.BuildHash}
                        <br/>
                        <FormattedMessage
                            id='about.hashee'
                            defaultMessage='EE Build Hash:'
                        />
                        {config.BuildHashEnterprise}
                        <br/>
                        <FormattedMessage
                            id='about.hashwebapp'
                            defaultMessage='Webapp Build Hash:'
                        />
                        {typeof COMMIT_HASH === 'undefined' ? '' : COMMIT_HASH}
                    </p>
                    <p>
                        <FormattedMessage
                            id='about.date'
                            defaultMessage='Build Date:'
                        />
                        {config.BuildDate}
                    </p>
                </div>
            </Modal.Body>
        </Modal>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

import {ClientConfig, ClientLicense} from '@mattermost/types/config';

import MattermostLogo from 'components/widgets/icons/mattermost_logo';
import Nbsp from 'components/html_entities/nbsp';

import {AboutLinks} from 'utils/constants';

import AboutBuildModalCloud from './about_build_modal_cloud/about_build_modal_cloud';

type Props = {

    /**
     * Function called after the modal has been hidden
     */
    onExited: () => void;

    /**
     * Global config object
     */
    config: Partial<ClientConfig>;

    /**
     * Global license object
     */
    license: ClientLicense;

    /**
     * Webapp build hash override. By default, webpack sets this (so it must be overridden in tests).
     */
    webappBuildHash?: string;
};

type State = {
    show: boolean;
};

export default class AboutBuildModal extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            show: true,
        };
    }

    doHide = () => {
        this.setState({show: false});
    }

    render() {
        const config = this.props.config;
        const license = this.props.license;

        if (license.Cloud === 'true') {
            return (
                <AboutBuildModalCloud
                    {...this.props}
                    {...this.state}
                    doHide={this.doHide}
                />
            );
        }

        let title = (
            <FormattedMessage
                id='about.teamEditiont0'
                defaultMessage='Team Edition'
            />
        );

        let subTitle = (
            <FormattedMessage
                id='about.teamEditionSt'
                defaultMessage='All your team communication in one place, instantly searchable and accessible anywhere.'
            />
        );

        let learnMore = (
            <div>
                <FormattedMessage
                    id='about.teamEditionLearn'
                    defaultMessage='Join the Mattermost community at '
                />
                <a
                    target='_blank'
                    rel='noopener noreferrer'
                    href='https://mattermost.com/community/'
                >
                    {'mattermost.com/community/'}
                </a>
            </div>
        );

        let licensee;
        if (config.BuildEnterpriseReady === 'true') {
            title = (
                <FormattedMessage
                    id='about.teamEditiont1'
                    defaultMessage='Enterprise Edition'
                />
            );

            subTitle = (
                <FormattedMessage
                    id='about.enterpriseEditionSt'
                    defaultMessage='Modern communication from behind your firewall.'
                />
            );

            learnMore = (
                <div>
                    <FormattedMessage
                        id='about.enterpriseEditionLearn'
                        defaultMessage='Learn more about Enterprise Edition at '
                    />
                    <a
                        target='_blank'
                        rel='noopener noreferrer'
                        href='https://mattermost.com/'
                    >
                        {'mattermost.com'}
                    </a>
                </div>
            );

            if (license.IsLicensed === 'true') {
                title = (
                    <FormattedMessage
                        id='about.enterpriseEditione1'
                        defaultMessage='Enterprise Edition'
                    />
                );
                licensee = (
                    <div className='form-group'>
                        <FormattedMessage
                            id='about.licensed'
                            defaultMessage='Licensed to:'
                        />
                        <Nbsp/>{license.Company}
                    </div>
                );
            }
        }

        const termsOfService = (
            <a
                target='_blank'
                id='tosLink'
                rel='noopener noreferrer'
                href={AboutLinks.TERMS_OF_SERVICE}
            >
                <FormattedMessage
                    id='about.tos'
                    defaultMessage='Terms of Use'
                />
            </a>
        );

        const privacyPolicy = (
            <a
                target='_blank'
                id='privacyLink'
                rel='noopener noreferrer'
                href={AboutLinks.PRIVACY_POLICY}
            >
                <FormattedMessage
                    id='about.privacy'
                    defaultMessage='Privacy Policy'
                />
            </a>
        );

        // Only show build number if it's a number (so only builds from Jenkins)
        let buildnumber: JSX.Element | null = (
            <div>
                <FormattedMessage
                    id='about.buildnumber'
                    defaultMessage='Build Number:'
                />
                <span id='buildnumberString'>{'\u00a0' + config.BuildNumber}</span>
            </div>
        );
        if (isNaN(Number(config.BuildNumber))) {
            buildnumber = null;
        }

        let mmversion: string | undefined = config.BuildNumber;
        if (!isNaN(Number(config.BuildNumber))) {
            mmversion = 'ci';
        }

        return (
            <Modal
                dialogClassName='a11y__modal about-modal'
                show={this.state.show}
                onHide={this.doHide}
                onExited={this.props.onExited}
                role='dialog'
                aria-labelledby='aboutModalLabel'
            >
                <Modal.Header closeButton={true}>
                    <Modal.Title
                        componentClass='h1'
                        id='aboutModalLabel'
                    >
                        <FormattedMessage
                            id='about.title'
                            values={{appTitle: config.SiteName || 'Mattermost'}}
                            defaultMessage='About {appTitle}'
                        />
                    </Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    <div className='about-modal__content'>
                        <div className='about-modal__logo'>
                            <MattermostLogo/>
                        </div>
                        <div>
                            <h3 className='about-modal__title'>
                                <strong>{'Mattermost'} {title}</strong>
                            </h3>
                            <p className='about-modal__subtitle pb-2'>{subTitle}</p>
                            <div className='form-group less'>
                                <div>
                                    <FormattedMessage
                                        id='about.version'
                                        defaultMessage='Mattermost Version:'
                                    />
                                    <span id='versionString'>{'\u00a0' + mmversion}</span>
                                </div>
                                <div>
                                    <FormattedMessage
                                        id='about.dbversion'
                                        defaultMessage='Database Schema Version:'
                                    />
                                    <span id='dbversionString'>{'\u00a0' + config.SchemaVersion}</span>
                                </div>
                                {buildnumber}
                                <div>
                                    <FormattedMessage
                                        id='about.database'
                                        defaultMessage='Database:'
                                    />
                                    {'\u00a0' + config.SQLDriverName}
                                </div>
                            </div>
                            {licensee}
                        </div>
                    </div>
                    <div className='about-modal__footer'>
                        {learnMore}
                        <div className='form-group'>
                            <div className='about-modal__copyright'>
                                <FormattedMessage
                                    id='about.copyright'
                                    defaultMessage='Copyright 2015 - {currentYear} Mattermost, Inc. All rights reserved'
                                    values={{
                                        currentYear: new Date().getFullYear(),
                                    }}
                                />
                            </div>
                            <div className='about-modal__links'>
                                {termsOfService}
                                {' - '}
                                {privacyPolicy}
                            </div>
                        </div>
                    </div>
                    <div className='about-modal__notice form-group pt-3'>
                        <p>
                            <FormattedMessage
                                id='about.notice'
                                defaultMessage='Mattermost is made possible by the open source software used in our <linkServer>server</linkServer>, <linkDesktop>desktop</linkDesktop> and <linkMobile>mobile</linkMobile> apps.'
                                values={{
                                    linkServer: (msg: React.ReactNode) => (
                                        <a
                                            href='https://github.com/mattermost/mattermost-server/blob/master/NOTICE.txt'
                                            target='_blank'
                                            rel='noreferrer'
                                        >
                                            {msg}
                                        </a>
                                    ),
                                    linkDesktop: (msg: React.ReactNode) => (
                                        <a
                                            href='https://github.com/mattermost/desktop/blob/master/NOTICE.txt'
                                            target='_blank'
                                            rel='noreferrer'
                                        >
                                            {msg}
                                        </a>
                                    ),
                                    linkMobile: (msg: React.ReactNode) => (
                                        <a
                                            href='https://github.com/mattermost/mattermost-mobile/blob/master/NOTICE.txt'
                                            target='_blank'
                                            rel='noreferrer'
                                        >
                                            {msg}
                                        </a>
                                    ),
                                }}
                            />
                        </p>
                    </div>
                    <div className='about-modal__hash'>
                        <p>
                            <FormattedMessage
                                id='about.hash'
                                defaultMessage='Build Hash:'
                            />
                            <Nbsp/>{config.BuildHash}
                            <br/>
                            <FormattedMessage
                                id='about.hashee'
                                defaultMessage='EE Build Hash:'
                            />
                            <Nbsp/>{config.BuildHashEnterprise}
                            <br/>
                            <FormattedMessage
                                id='about.hashwebapp'
                                defaultMessage='Webapp Build Hash:'
                            />
                            <Nbsp/>{/* global COMMIT_HASH */ this.props.webappBuildHash || (typeof COMMIT_HASH === 'undefined' ? '' : COMMIT_HASH)}
                        </p>
                        <p>
                            <FormattedMessage
                                id='about.date'
                                defaultMessage='Build Date:'
                            />
                            <Nbsp/>{config.BuildDate}
                        </p>
                    </div>
                </Modal.Body>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getConfig, getLicense} from 'mattermost-redux/selectors/entities/general';

import {GlobalState} from 'types/store';

import AboutBuildModal from './about_build_modal';

function mapStateToProps(state: GlobalState) {
    return {
        config: getConfig(state),
        license: getLicense(state),
    };
}

export default connect(mapStateToProps)(AboutBuildModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback} from 'react';
import {FormattedMessage} from 'react-intl';

import {TourTip} from '@mattermost/components';

const translate = {x: 6, y: -16};

type Props = {
    handleNext: (e: React.MouseEvent) => void;
    handleOpen: (e: React.MouseEvent) => void;
    handleDismiss: () => void;
    showTip: boolean;
}

const title = (
    <FormattedMessage
        id='post_info.actions.tutorialTip.title'
        defaultMessage='Actions for messages'
    />
);
const screen = (
    <FormattedMessage
        id='post_info.actions.tutorialTip'
        defaultMessage='Message actions that are provided\nthrough apps, integrations or plugins\nhave moved to this menu item.'
    />
);
const nextBtn = (
    <FormattedMessage
        id={'tutorial_tip.got_it'}
        defaultMessage={'Got it'}
    />
);

export const ActionsTutorialTip = ({handleOpen, handleDismiss, handleNext, showTip}: Props) => {
    const onDismiss = useCallback((e: React.MouseEvent) => {
        e.stopPropagation();
        e.preventDefault();
        handleDismiss();
    }, [handleDismiss]);

    const onNext = useCallback((e: React.MouseEvent) => {
        e.stopPropagation();
        e.preventDefault();
        handleNext(e);
    }, [handleNext]);

    return (
        <TourTip
            show={showTip}
            screen={screen}
            title={title}
            overlayPunchOut={null}
            placement='top'
            pulsatingDotPlacement='left'
            pulsatingDotTranslate={translate}
            step={1}
            singleTip={true}
            showOptOut={false}
            interactivePunchOut={true}
            handleDismiss={onDismiss}
            handleNext={onNext}
            handleOpen={handleOpen}
            nextBtn={nextBtn}
        />
    );
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import classNames from 'classnames';
import {FormattedMessage, injectIntl, IntlShape} from 'react-intl';
import './actions_menu.scss';

import {Tooltip} from 'react-bootstrap';

import FormattedMarkdownMessage from 'components/formatted_markdown_message';

import {Post} from '@mattermost/types/posts';
import {AppBinding} from '@mattermost/types/apps';
import {AppCallResponseTypes} from 'mattermost-redux/constants/apps';

import {HandleBindingClick, PostEphemeralCallResponseForPost, OpenAppsModal} from 'types/apps';
import {Locations, Constants, ModalIdentifiers} from 'utils/constants';
import Permissions from 'mattermost-redux/constants/permissions';
import {ActionsTutorialTip} from 'components/actions_menu/actions_menu_tutorial_tip';
import {ModalData} from 'types/actions';
import MarketplaceModal from 'components/plugin_marketplace';
import OverlayTrigger from 'components/overlay_trigger';
import * as PostUtils from 'utils/post_utils';
import * as Utils from 'utils/utils';
import SystemPermissionGate from 'components/permissions_gates/system_permission_gate';
import Pluggable from 'plugins/pluggable';
import Menu from 'components/widgets/menu/menu';
import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import {PluginComponent} from 'types/store/plugins';
import {createCallContext} from 'utils/apps';

const MENU_BOTTOM_MARGIN = 80;

export const PLUGGABLE_COMPONENT = 'PostDropdownMenuItem';
export type Props = {
    appBindings: AppBinding[] | null;
    appsEnabled: boolean;
    handleDropdownOpened?: (open: boolean) => void;
    intl: IntlShape;
    isMenuOpen?: boolean;
    isSysAdmin: boolean;
    location?: 'CENTER' | 'RHS_ROOT' | 'RHS_COMMENT' | 'SEARCH' | string;
    pluginMenuItems?: PluginComponent[];
    post: Post;
    teamId: string;
    userId: string;
    handleOpenTip: () => void;
    handleNextTip: (e: React.MouseEvent) => void;
    handleDismissTip: () => void;
    showPulsatingDot?: boolean;
    showTutorialTip: boolean;

    /**
     * Components for overriding provided by plugins
     */
    components: {
        [componentName: string]: PluginComponent[];
    };

    actions: {

        /**
         * Function to open a modal
         */
        openModal: <P>(modalData: ModalData<P>) => void;

        /**
         * Function to post the ephemeral message for a call response
         */
        postEphemeralCallResponseForPost: PostEphemeralCallResponseForPost;

        /**
         * Function to handle clicking of any post-menu bindings
         */
        handleBindingClick: HandleBindingClick;

        /**
         * Function to open the Apps modal with a form
         */
        openAppsModal: OpenAppsModal;

        /**
         * Function to get the post menu bindings for this post.
         */
        fetchBindings: (userId: string, channelId: string, teamId: string) => Promise<{data: AppBinding[]}>;

    }; // TechDebt: Made non-mandatory while converting to typescript
}

type State = {
    openUp: boolean;
    appBindings?: AppBinding[];
}

export class ActionMenuClass extends React.PureComponent<Props, State> {
    public static defaultProps: Partial<Props> = {
        appBindings: [],
        location: Locations.CENTER,
        pluginMenuItems: [],
    }
    private buttonRef: React.RefObject<HTMLButtonElement>;

    constructor(props: Props) {
        super(props);

        this.state = {
            openUp: false,
        };

        this.buttonRef = React.createRef<HTMLButtonElement>();
    }

    tooltip = (
        <Tooltip
            id='actions-menu-icon-tooltip'
            className='hidden-xs'
        >
            <FormattedMessage
                id='post_info.tooltip.actions'
                defaultMessage='Message actions'
            />
        </Tooltip>
    )

    componentDidUpdate(prevProps: Props) {
        if (this.props.isMenuOpen && !prevProps.isMenuOpen) {
            this.fetchBindings();
        }
    }

    static getDerivedStateFromProps(props: Props) {
        const state: Partial<State> = { };
        if (props.appBindings) {
            state.appBindings = props.appBindings;
        }
        return state;
    }

    fetchBindings = () => {
        if (this.props.appsEnabled && !this.state.appBindings) {
            this.props.actions.fetchBindings(this.props.userId, this.props.post.channel_id, this.props.teamId).then(({data}) => {
                this.setState({appBindings: data});
            });
        }
    }

    handleOpenMarketplace = (): void => {
        const openMarketplaceData = {
            modalId: ModalIdentifiers.PLUGIN_MARKETPLACE,
            dialogType: MarketplaceModal,
        };
        this.props.actions.openModal(openMarketplaceData);
    };

    onClickAppBinding = async (binding: AppBinding) => {
        const {post, intl} = this.props;

        const context = createCallContext(
            binding.app_id,
            binding.location,
            this.props.post.channel_id,
            this.props.teamId,
            this.props.post.id,
            this.props.post.root_id,
        );

        const res = await this.props.actions.handleBindingClick(binding, context, intl);

        if (res.error) {
            const errorResponse = res.error;
            const errorMessage = errorResponse.text || intl.formatMessage({
                id: 'apps.error.unknown',
                defaultMessage: 'Unknown error occurred.',
            });
            this.props.actions.postEphemeralCallResponseForPost(errorResponse, errorMessage, post);
            return;
        }

        const callResp = res.data!;
        switch (callResp.type) {
        case AppCallResponseTypes.OK:
            if (callResp.text) {
                this.props.actions.postEphemeralCallResponseForPost(callResp, callResp.text, post);
            }
            break;
        case AppCallResponseTypes.NAVIGATE:
            break;
        case AppCallResponseTypes.FORM:
            if (callResp.form) {
                this.props.actions.openAppsModal(callResp.form, context);
            }
            break;
        default: {
            const errorMessage = intl.formatMessage({
                id: 'apps.error.responses.unknown_type',
                defaultMessage: 'App response type not supported. Response type: {type}.',
            }, {
                type: callResp.type,
            });
            this.props.actions.postEphemeralCallResponseForPost(callResp, errorMessage, post);
        }
        }
    }

    visitMarketplaceTip(): React.ReactElement {
        return (
            <SystemPermissionGate
                permissions={[Permissions.MANAGE_SYSTEM]}
                key='visit-marketplace-permissions'
            >
                <div className='visit-marketplace-text' >
                    <FormattedMarkdownMessage
                        id='post_info.actions.noActions'
                        defaultMessage='No Actions currently\nconfigured for this server'
                    />
                </div>
                <div className='visit-marketplace' >
                    <button
                        id='marketPlaceButton'
                        className='btn btn-primary visit-marketplace-button'
                        onClick={this.handleOpenMarketplace}
                    >
                        {Utils.getMenuItemIcon('icon-view-grid-plus-outline visit-marketplace-button-icon')}
                        <span className='visit-marketplace-button-text'>
                            <FormattedMarkdownMessage
                                id='post_info.actions.visitMarketplace'
                                defaultMessage='Visit the Marketplace'
                            />
                        </span>
                    </button>
                </div>
            </SystemPermissionGate>
        );
    }

    handleActionsIconClick = (e: React.MouseEvent) => {
        if (this.props.showPulsatingDot || this.props.showTutorialTip) {
            this.props.handleOpenTip();
            e.preventDefault();
            e.stopPropagation();
        }
    };

    renderDivider = (suffix: string): React.ReactNode => {
        return (
            <li
                id={`divider_post_${this.props.post.id}_${suffix}`}
                className='MenuItem__divider'
                role='menuitem'
            />
        );
    };

    handleDropdownOpened = (open: boolean) => {
        this.props.handleDropdownOpened?.(open);

        if (!open) {
            return;
        }

        const buttonRect = this.buttonRef.current?.getBoundingClientRect();
        let y;
        if (typeof buttonRect?.y === 'undefined') {
            y = typeof buttonRect?.top == 'undefined' ? 0 : buttonRect?.top;
        } else {
            y = buttonRect?.y;
        }
        const windowHeight = window.innerHeight;

        const totalSpace = windowHeight - MENU_BOTTOM_MARGIN;
        const spaceOnTop = y - Constants.CHANNEL_HEADER_HEIGHT;
        const spaceOnBottom = (totalSpace - (spaceOnTop + Constants.POST_AREA_HEIGHT));

        this.setState({
            openUp: (spaceOnTop > spaceOnBottom),
        });
    }

    render(): React.ReactNode {
        const isSystemMessage = PostUtils.isSystemMessage(this.props.post);
        if (isSystemMessage) {
            return null;
        }

        // const isMobile = this.props.isMobileView TODO;

        const pluginItems = this.props.pluginMenuItems?.
            filter((item) => {
                return item.filter ? item.filter(this.props.post.id) : item;
            }).
            map((item) => {
                if (item.subMenu) {
                    return (
                        <Menu.ItemSubMenu
                            key={item.id + '_pluginmenuitem'}
                            id={item.id}
                            postId={this.props.post.id}
                            text={item.text}
                            subMenu={item.subMenu}
                            action={item.action}
                            root={true}
                        />
                    );
                }
                return (
                    <Menu.ItemAction
                        key={item.id + '_pluginmenuitem'}
                        text={item.text}
                        onClick={() => {
                            if (item.action) {
                                item.action(this.props.post.id);
                            }
                        }}
                    />
                );
            }) || [];

        let appBindings = [] as JSX.Element[];
        if (this.props.appsEnabled && this.state.appBindings) {
            appBindings = this.state.appBindings.map((item) => {
                let icon: JSX.Element | undefined;
                if (item.icon) {
                    icon = (
                        <img
                            key={item.app_id + 'app_icon'}
                            src={item.icon}
                        />);
                }

                return (
                    <Menu.ItemAction
                        text={item.label}
                        key={item.app_id + item.location}
                        onClick={() => this.onClickAppBinding(item)}
                        icon={icon}
                    />
                );
            });
        }

        const {formatMessage} = this.props.intl;

        let marketPlace = null;
        if (this.props.isSysAdmin) {
            marketPlace = (
                <React.Fragment key={'marketplace'}>
                    {this.renderDivider('marketplace')}
                    <Menu.ItemAction
                        id={`marketplace_icon_${this.props.post.id}`}
                        key={`marketplace_${this.props.post.id}`}
                        show={true}
                        text={formatMessage({id: 'post_info.marketplace', defaultMessage: 'App Marketplace'})}
                        icon={Utils.getMenuItemIcon('icon-view-grid-plus-outline')}
                        onClick={this.handleOpenMarketplace}
                    />
                </React.Fragment>
            );
        }

        let menuItems;
        const hasApps = Boolean(appBindings.length);
        const hasPluggables = Boolean(this.props.components[PLUGGABLE_COMPONENT]?.length);
        const hasPluginItems = Boolean(pluginItems?.length);

        const hasPluginMenuItems = hasPluginItems || hasApps || hasPluggables;
        if (!this.props.isSysAdmin && !hasPluginMenuItems) {
            return null;
        }

        if (hasPluginItems || hasApps || hasPluggables) {
            const pluggable = (
                <Pluggable
                    postId={this.props.post.id}
                    pluggableName={PLUGGABLE_COMPONENT}
                    key={this.props.post.id + 'pluggable'}
                />);

            menuItems = [
                pluginItems,
                appBindings,
                pluggable,
                marketPlace,
            ];
        } else {
            menuItems = [this.visitMarketplaceTip()];
            if (!this.props.isSysAdmin) {
                return null;
            }
        }

        return (
            <MenuWrapper
                open={this.props.isMenuOpen}
                onToggle={this.handleDropdownOpened}
            >
                <OverlayTrigger
                    className='hidden-xs'
                    delayShow={500}
                    placement='top'
                    overlay={this.tooltip}
                    rootClose={true}
                >
                    <button
                        key='more-actions-button'
                        ref={this.buttonRef}
                        id={`${this.props.location}_actions_button_${this.props.post.id}`}
                        aria-label={Utils.localizeMessage('post_info.actions.tooltip.actions', 'Actions').toLowerCase()}
                        className={classNames('post-menu__item', {
                            'post-menu__item--active': this.props.isMenuOpen,
                        })}
                        type='button'
                        aria-expanded='false'
                        onClick={this.handleActionsIconClick}
                    >
                        <i className={'icon icon-apps'}/>
                        {this.props.showPulsatingDot &&
                            <ActionsTutorialTip
                                showTip={this.props.showTutorialTip}
                                handleNext={this.props.handleNextTip}
                                handleOpen={this.props.handleOpenTip}
                                handleDismiss={this.props.handleDismissTip}
                            />
                        }
                    </button>
                </OverlayTrigger>
                <Menu
                    id={`${this.props.location}_actions_dropdown_${this.props.post.id}`}
                    openLeft={true}
                    openUp={this.state.openUp}
                    ariaLabel={Utils.localizeMessage('post_info.menuAriaLabel', 'Post extra options')}
                    key={`${this.props.location}_actions_dropdown_${this.props.post.id}`}
                >
                    {menuItems}
                </Menu>
            </MenuWrapper>
        );
    }
}

export default injectIntl(ActionMenuClass);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ComponentProps} from 'react';
import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {getCurrentUser, getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {appsEnabled} from 'mattermost-redux/selectors/entities/apps';

import {AppBindingLocations} from 'mattermost-redux/constants/apps';

import {isSystemAdmin} from 'mattermost-redux/utils/user_utils';
import {isSystemMessage} from 'mattermost-redux/utils/post_utils';
import {isCombinedUserActivityPost} from 'mattermost-redux/utils/post_list';

import {GenericAction} from 'mattermost-redux/types/actions';
import {ModalData} from 'types/actions';
import {getIsMobileView} from 'selectors/views/browser';
import {AppBinding} from '@mattermost/types/apps';
import {Post} from '@mattermost/types/posts';
import {HandleBindingClick, OpenAppsModal, PostEphemeralCallResponseForPost} from 'types/apps';
import {GlobalState} from 'types/store';

import {openModal} from 'actions/views/modals';
import {makeFetchBindings, postEphemeralCallResponseForPost, handleBindingClick, openAppsModal} from 'actions/apps';

import ActionsMenu from './actions_menu';
import {makeGetPostOptionBinding} from './selectors';

type Props = {
    post: Post;
    handleCardClick?: (post: Post) => void;
    handleDropdownOpened: (open: boolean) => void;
    isMenuOpen: boolean;
    location?: ComponentProps<typeof ActionsMenu>['location'];
};

const emptyBindings: AppBinding[] = [];

const getPostOptionBinding = makeGetPostOptionBinding();

const fetchBindings = makeFetchBindings(AppBindingLocations.POST_MENU_ITEM);

function mapStateToProps(state: GlobalState, ownProps: Props) {
    const {post} = ownProps;

    const userId = getCurrentUserId(state);
    const systemMessage = isSystemMessage(post);

    const apps = appsEnabled(state);
    const showBindings = apps && !systemMessage && !isCombinedUserActivityPost(post.id);
    let appBindings: AppBinding[] | null = emptyBindings;
    if (showBindings) {
        appBindings = getPostOptionBinding(state, ownProps.location);
    }
    const currentUser = getCurrentUser(state);
    const isSysAdmin = isSystemAdmin(currentUser.roles);

    return {
        appBindings,
        appsEnabled: apps,
        components: state.plugins.components,
        isSysAdmin,
        pluginMenuItems: state.plugins.components.PostDropdownMenu,
        teamId: getCurrentTeamId(state),
        userId,
        isMobileView: getIsMobileView(state),
    };
}

type Actions = {
    handleBindingClick: HandleBindingClick;
    fetchBindings: (userId: string, channelId: string, teamId: string) => Promise<{data: AppBinding[]}>;
    openModal: <P>(modalData: ModalData<P>) => void;
    openAppsModal: OpenAppsModal;
    postEphemeralCallResponseForPost: PostEphemeralCallResponseForPost;
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<any>, Actions>({
            handleBindingClick,
            fetchBindings,
            openModal,
            openAppsModal,
            postEphemeralCallResponseForPost,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(ActionsMenu);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {createSelector} from 'reselect';

import {AppBinding} from '@mattermost/types/apps';

import {AppBindingLocations} from 'mattermost-redux/constants/apps';
import {makeAppBindingsSelector, makeRHSAppBindingSelector} from 'mattermost-redux/selectors/entities/apps';

import {GlobalState} from 'types/store';
import {Locations} from 'utils/constants';

export function makeGetPostOptionBinding(): (state: GlobalState, location?: string) => AppBinding[] | null {
    const centerBindingsSelector = makeAppBindingsSelector(AppBindingLocations.POST_MENU_ITEM);
    const rhsBindingsSelector = makeRHSAppBindingSelector(AppBindingLocations.POST_MENU_ITEM);
    return createSelector(
        'postOptionsBindings',
        centerBindingsSelector,
        rhsBindingsSelector,
        (state: GlobalState, location?: string) => location,
        (centerBindings: AppBinding[], rhsBindings: AppBinding[], location?: string) => {
            switch (location) {
            case Locations.RHS_ROOT:
            case Locations.RHS_COMMENT:
                return rhsBindings;
            case Locations.SEARCH:
                return null;
            case Locations.CENTER:
            default:
                return centerBindings;
            }
        },
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {RefObject} from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

import {Group, GroupsWithCount, SyncablePatch, SyncableType} from '@mattermost/types/groups';

import Constants from 'utils/constants';
import {localizeMessage} from 'utils/utils';

import MultiSelect, {Value} from 'components/multiselect/multiselect';
import groupsAvatar from 'images/groups-avatar.png';
import AddIcon from 'components/widgets/icons/fa_add_icon';
import Nbsp from 'components/html_entities/nbsp';

const GROUPS_PER_PAGE = 50;
const MAX_SELECTABLE_VALUES = 10;

type GroupValue = Value & {member_count?: number};

type Props = {
    currentTeamName: string;
    currentTeamId: string;
    searchTerm: string;
    groups: Group[];

    // used in tandem with 'skipCommit' to allow using this component without performing actual linking
    excludeGroups?: Group[];
    includeGroups?: Group[];
    onExited: () => void;
    skipCommit?: boolean;
    onAddCallback?: (groupIDs: string[]) => void;
    actions: Actions;
}

export type Actions = {
    getGroupsNotAssociatedToTeam: (teamID: string, q?: string, page?: number, perPage?: number) => Promise<{ data: Group[] } | { error: Error }>;
    setModalSearchTerm: (term: string) => void;
    linkGroupSyncable: (groupID: string, syncableID: string, syncableType: SyncableType, patch: SyncablePatch) => Promise<{ data?: boolean; error?: Error }>;
    getAllGroupsAssociatedToTeam: (teamID: string, filterAllowReference: boolean, includeMemberCount: boolean) => Promise<{ data: GroupsWithCount } | { error: Error }>;
};

type State = {
    values: GroupValue[];
    show: boolean;
    search: boolean;
    saving: boolean;
    addError: null | string;
    loadingGroups: boolean;
}

export default class AddGroupsToTeamModal extends React.PureComponent<Props, State> {
    private searchTimeoutId: number;
    private readonly selectedItemRef: RefObject<HTMLDivElement>;

    constructor(props: Props) {
        super(props);

        this.searchTimeoutId = 0;

        this.state = {
            values: [],
            show: true,
            search: false,
            saving: false,
            addError: null,
            loadingGroups: true,
        };

        this.selectedItemRef = React.createRef();
    }

    public componentDidMount() {
        Promise.all([
            this.props.actions.getGroupsNotAssociatedToTeam(this.props.currentTeamId, '', 0, GROUPS_PER_PAGE + 1),
            this.props.actions.getAllGroupsAssociatedToTeam(this.props.currentTeamId, false, true),
        ]).then(() => {
            this.setGroupsLoadingState(false);
        });
    }

    public componentDidUpdate(prevProps: Props) {
        if (this.props.searchTerm !== prevProps.searchTerm) {
            clearTimeout(this.searchTimeoutId);

            const searchTerm = this.props.searchTerm;
            if (searchTerm === '') {
                return;
            }

            this.searchTimeoutId = window.setTimeout(
                async () => {
                    this.setGroupsLoadingState(true);
                    await this.props.actions.getGroupsNotAssociatedToTeam(this.props.currentTeamId, searchTerm);
                    this.setGroupsLoadingState(false);
                },
                Constants.SEARCH_TIMEOUT_MILLISECONDS,
            );
        }
    }

    // public for tests
    public handleHide = () => {
        this.props.actions.setModalSearchTerm('');
        this.setState({show: false});
    }

    // public for tests
    public handleExit = (): void => {
        this.props.onExited();
    }

    // public for tests
    public handleResponse = (err?: Error): void => {
        let addError = null;
        if (err && err.message) {
            addError = err.message;
        }

        this.setState({
            saving: false,
            addError,
        });
    }

    // public for tests
    public handleSubmit = async () => {
        const groupIDs = this.state.values.map((v) => v.id);
        if (groupIDs.length === 0) {
            return;
        }
        if (this.props.skipCommit) {
            if (this.props.onAddCallback) {
                this.props.onAddCallback(groupIDs);
            }
            this.handleHide();
            return;
        }

        this.setState({saving: true});

        await Promise.all(groupIDs.map(async (groupID) => {
            const {error} = await this.props.actions.linkGroupSyncable(groupID, this.props.currentTeamId, SyncableType.Team, {auto_add: true, scheme_admin: false});
            this.handleResponse(error);
            if (!error) {
                this.handleHide();
            }
        }));
    }

    // public for tests
    public addValue = (value: GroupValue): void => {
        const values = Object.assign<GroupValue[], GroupValue[]>([], this.state.values);
        const userIds = values.map((v) => v.id);
        if (value && value.id && userIds.indexOf(value.id) === -1) {
            values.push(value);
        }

        this.setState({values});
    }

    private setGroupsLoadingState = (loadingState: boolean) => {
        this.setState({
            loadingGroups: loadingState,
        });
    }

    // public for tests
    public handlePageChange = (page: number, prevPage: number): void => {
        if (page > prevPage) {
            this.setGroupsLoadingState(true);
            this.props.actions.getGroupsNotAssociatedToTeam(this.props.currentTeamId, this.props.searchTerm, page, GROUPS_PER_PAGE + 1).then(() => {
                this.setGroupsLoadingState(false);
            });
        }
    }

    // public for tests
    public handleDelete = (values: GroupValue[]): void => this.setState({values});

    // public for tests
    public search = (term: string): void => this.props.actions.setModalSearchTerm(term);

    // public for tests
    public renderOption = (option: GroupValue, isSelected: boolean, onAdd: (value: GroupValue) => void, onMouseMove: (value: GroupValue) => void): JSX.Element => {
        const rowSelected = isSelected ? 'more-modal__row--selected' : '';

        return (
            <div
                key={option.id}
                ref={isSelected ? this.selectedItemRef : option.id}
                className={'more-modal__row clickable ' + rowSelected}
                onClick={() => onAdd(option)}
                onMouseMove={() => onMouseMove(option)}
            >
                <img
                    className='more-modal__image'
                    src={groupsAvatar}
                    alt='group picture'
                    width='32'
                    height='32'
                />
                <div
                    className='more-modal__details'
                >
                    <div className='more-modal__name'>
                        {option.display_name}<Nbsp/>{'-'}<Nbsp/><span className='more-modal__name_sub'>
                            <FormattedMessage
                                id='numMembers'
                                defaultMessage='{num, number} {num, plural, one {member} other {members}}'
                                values={{
                                    num: option.member_count,
                                }}
                            />
                        </span>
                    </div>
                </div>
                <div className='more-modal__actions'>
                    <div className='more-modal__actions--round'>
                        <AddIcon/>
                    </div>
                </div>
            </div>
        );
    }

    // public for tests
    public renderValue = (props: { data: Value }): string | undefined => props.data.display_name;

    public render(): JSX.Element {
        const numRemainingText = (
            <div id='numGroupsRemaining'>
                <FormattedMessage
                    id='multiselect.numGroupsRemaining'
                    defaultMessage='Use  to browse,  to select. You can add {num, number} more {num, plural, one {group} other {groups}}. '
                    values={{
                        num: MAX_SELECTABLE_VALUES - this.state.values.length,
                    }}
                />
            </div>
        );

        const buttonSubmitText = localizeMessage('multiselect.add', 'Add');
        const buttonSubmitLoadingText = localizeMessage('multiselect.adding', 'Adding...');

        let addError = null;
        if (this.state.addError) {
            addError = (
                <div className='has-error col-sm-12'>
                    <label className='control-label font-weight--normal'>
                        {this.state.addError}
                    </label>
                </div>
            );
        }

        let groupsToShow = this.props.groups;
        if (this.props.excludeGroups) {
            const hasGroup = (og: Group) => !this.props.excludeGroups?.find((g) => g.id === og.id);
            groupsToShow = groupsToShow.filter(hasGroup);
        }
        if (this.props.includeGroups) {
            const hasGroup = (og: Group) => this.props.includeGroups?.find((g) => g.id === og.id);
            groupsToShow = [...groupsToShow, ...this.props.includeGroups.filter(hasGroup)];
        }

        const groupsOptionsToShow = groupsToShow.map((group) => {
            return {...group, label: group.display_name, value: group.id};
        });

        return (
            <Modal
                id='addGroupsToTeamModal'
                dialogClassName={'a11y__modal more-modal more-direct-channels'}
                show={this.state.show}
                onHide={this.handleHide}
                onExited={this.handleExit}
            >
                <Modal.Header closeButton={true}>
                    <Modal.Title componentClass='h1'>
                        <FormattedMessage
                            id='add_groups_to_team.title'
                            defaultMessage='Add New Groups to {teamName} Team'
                            values={{
                                teamName: (
                                    <strong>{this.props.currentTeamName}</strong>
                                ),
                            }}
                        />
                    </Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    {addError}
                    <MultiSelect
                        key='addGroupsToTeamKey'
                        options={groupsOptionsToShow}
                        optionRenderer={this.renderOption}
                        selectedItemRef={this.selectedItemRef}
                        values={this.state.values}
                        valueRenderer={this.renderValue}
                        perPage={GROUPS_PER_PAGE}
                        handlePageChange={this.handlePageChange}
                        handleInput={this.search}
                        handleDelete={this.handleDelete}
                        handleAdd={this.addValue}
                        handleSubmit={this.handleSubmit}
                        maxValues={MAX_SELECTABLE_VALUES}
                        numRemainingText={numRemainingText}
                        buttonSubmitText={buttonSubmitText}
                        buttonSubmitLoadingText={buttonSubmitLoadingText}
                        saving={this.state.saving}
                        loading={this.state.loadingGroups}
                        placeholderText={localizeMessage('multiselect.addGroupsPlaceholder', 'Search and add groups')}
                    />
                </Modal.Body>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {getGroupsNotAssociatedToTeam, linkGroupSyncable, getAllGroupsAssociatedToTeam} from 'mattermost-redux/actions/groups';
import {getGroupsNotAssociatedToTeam as selectGroupsNotAssociatedToTeam} from 'mattermost-redux/selectors/entities/groups';
import {getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';
import {Team} from '@mattermost/types/teams';
import {Group} from '@mattermost/types/groups';
import {ActionFunc, GenericAction} from 'mattermost-redux/types/actions';

import {setModalSearchTerm} from 'actions/views/search';
import {GlobalState} from '../../types/store';

import AddGroupsToTeamModal, {Actions} from './add_groups_to_team_modal';

type Props = {
    team?: Team;
    skipCommit?: boolean;
    onAddCallback?: (groupIDs: string[]) => void;
    excludeGroups?: Group[];
}

function mapStateToProps(state: GlobalState, ownProps: Props) {
    const searchTerm = state.views.search.modalSearch;

    const team = ownProps.team || getCurrentTeam(state) || {};

    let groups = selectGroupsNotAssociatedToTeam(state, team.id);
    if (searchTerm) {
        const regex = RegExp(searchTerm, 'i');
        groups = groups.filter((group) => regex.test(group.display_name) || regex.test(group.name));
    }

    return {
        currentTeamName: team.display_name,
        currentTeamId: team.id,
        skipCommit: ownProps.skipCommit,
        onAddCallback: ownProps.onAddCallback,
        excludeGroups: ownProps.excludeGroups,
        searchTerm,
        groups,
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc|GenericAction>, Actions>({
            getGroupsNotAssociatedToTeam,
            setModalSearchTerm,
            linkGroupSyncable,
            getAllGroupsAssociatedToTeam,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(AddGroupsToTeamModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import classNames from 'classnames';

import {Client4} from 'mattermost-redux/client';
import {UserProfile} from '@mattermost/types/users';
import {RelationOneToOne} from '@mattermost/types/utilities';

import {isGuest} from 'mattermost-redux/utils/user_utils';
import {displayEntireNameForUser} from 'utils/utils';
import ProfilePicture from 'components/profile_picture';
import AddIcon from 'components/widgets/icons/fa_add_icon';
import GuestBadge from 'components/widgets/badges/guest_badge';
import BotBadge from 'components/widgets/badges/bot_badge';
import {Value} from 'components/multiselect/multiselect';

type UserProfileValue = Value & UserProfile;

type Props = {
    option: UserProfileValue;
    onAdd: (user: UserProfileValue) => void;
    onMouseMove: (user: UserProfileValue) => void;
    userStatuses: RelationOneToOne<UserProfile, string>;
    isSelected: boolean;
}

const MultiSelectOption = React.forwardRef(({
    option,
    onAdd,
    onMouseMove,
    userStatuses,
    isSelected,
}: Props, ref?: React.Ref<HTMLDivElement>) => {
    return (
        <div
            key={option.id}
            className={classNames('more-modal__row clickable', {'more-modal__row--selected': isSelected})}
            onClick={() => onAdd(option)}
            ref={ref}
            onMouseMove={() => onMouseMove(option)}
        >
            <ProfilePicture
                src={Client4.getProfilePictureUrl(option.id, option.last_picture_update)}
                status={userStatuses[option.id]}
                size='md'
                username={option.username}
            />
            <div className='more-modal__details'>
                <div className='more-modal__name'>
                    {displayEntireNameForUser(option)}
                    <BotBadge
                        show={Boolean(option.is_bot)}
                        className='badge-popoverlist'
                    />
                    <GuestBadge
                        show={isGuest(option.roles)}
                        className='popoverlist'
                    />
                </div>
            </div>
            <div className='more-modal__actions'>
                <div className='more-modal__actions--round'>
                    <AddIcon/>
                </div>
            </div>
        </div>
    );
});

export default MultiSelectOption;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {RelationOneToOne} from '@mattermost/types/utilities';
import {ActionResult} from 'mattermost-redux/types/actions';
import {UserProfile} from '@mattermost/types/users';

import {filterProfilesStartingWithTerm} from 'mattermost-redux/utils/user_utils';
import {localizeMessage} from 'utils/utils';
import MultiSelect, {Value} from 'components/multiselect/multiselect';

import Constants from 'utils/constants';

import MultiSelectOption from './multiselect_option/multiselect_option';

const USERS_PER_PAGE = 50;
const MAX_SELECTABLE_VALUES = 256;

type UserProfileValue = Value & UserProfile;

export type Props = {
    multilSelectKey: string;
    userStatuses: RelationOneToOne<UserProfile, string>;
    focusOnLoad?: boolean;

    // Used if we are adding new members to an existing group
    groupId?: string;

    // onSubmitCallback takes an array of UserProfiles and should set usersToAdd in state of parent component
    onSubmitCallback: (userProfiles?: UserProfile[]) => Promise<void>;
    addUserCallback?: (userProfiles: UserProfile[]) => void;
    deleteUserCallback?: (userProfiles: UserProfile[]) => void;

    // These are the optinoal search parameters
    searchOptions?: any;

    // Dictionaries of userid mapped users to exclude or include from this list
    excludeUsers?: Record<string, UserProfileValue>;
    includeUsers?: Record<string, UserProfileValue>;

    profiles: UserProfileValue[];

    savingEnabled: boolean;
    saving: boolean;
    buttonSubmitText?: string;
    buttonSubmitLoadingText?: string;
    backButtonClick?: () => void;
    backButtonClass?: string;
    backButtonText?: string;

    actions: {
        getProfiles: (page?: number, perPage?: number) => Promise<ActionResult>;
        getProfilesNotInGroup: (groupId: string, page?: number, perPage?: number) => Promise<ActionResult>;
        loadStatusesForProfilesList: (users: UserProfile[]) => void;
        searchProfiles: (term: string, options: any) => Promise<ActionResult>;
    };
}

type State = {
    values: UserProfileValue[];
    term: string;
    loadingUsers: boolean;
}

export default class AddUserToGroupMultiSelect extends React.PureComponent<Props, State> {
    private searchTimeoutId = 0;
    selectedItemRef;

    public static defaultProps = {
        includeUsers: {},
        excludeUsers: {},
    };

    constructor(props: Props) {
        super(props);

        this.state = {
            values: [],
            term: '',
            loadingUsers: true,
        } as State;

        this.selectedItemRef = React.createRef<HTMLDivElement>();
    }

    private addValue = (value: UserProfileValue): void => {
        const values: UserProfileValue[] = Object.assign([], this.state.values);
        if (values.indexOf(value) === -1) {
            values.push(value);
        }

        if (this.props.addUserCallback) {
            this.props.addUserCallback(values);
        }

        this.setState({values});
    };

    public componentDidMount(): void {
        if (this.props.groupId) {
            this.props.actions.getProfilesNotInGroup(this.props.groupId).then(() => {
                this.setUsersLoadingState(false);
            });
        } else {
            this.props.actions.getProfiles().then(() => {
                this.setUsersLoadingState(false);
            });
        }

        this.props.actions.loadStatusesForProfilesList(this.props.profiles);
    }

    private handleDelete = (values: UserProfileValue[]): void => {
        if (this.props.deleteUserCallback) {
            this.props.deleteUserCallback(values);
        }

        this.setState({values});
    };

    private setUsersLoadingState = (loadingState: boolean): void => {
        this.setState({
            loadingUsers: loadingState,
        });
    };

    private handlePageChange = (page: number, prevPage: number): void => {
        if (page > prevPage) {
            this.setUsersLoadingState(true);
            if (this.props.groupId) {
                this.props.actions.getProfilesNotInGroup(this.props.groupId, page + 1, USERS_PER_PAGE).then(() => {
                    this.setUsersLoadingState(false);
                });
            } else {
                this.props.actions.getProfiles(page + 1, USERS_PER_PAGE).then(() => {
                    this.setUsersLoadingState(false);
                });
            }
        }
    };

    public handleSubmit = (): void => {
        const userIds = this.state.values.map((v) => v.id);
        if (userIds.length === 0) {
            return;
        }
        this.props.onSubmitCallback(this.state.values);
    };

    public search = (searchTerm: string): void => {
        const term = searchTerm.trim();
        clearTimeout(this.searchTimeoutId);
        this.setState({
            term,
        });

        if (term) {
            this.setUsersLoadingState(true);
            this.searchTimeoutId = window.setTimeout(
                async () => {
                    await this.props.actions.searchProfiles(term, this.props.searchOptions);
                    this.setUsersLoadingState(false);
                },
                Constants.SEARCH_TIMEOUT_MILLISECONDS,
            );
        }
    };

    private renderAriaLabel = (option: UserProfileValue): string => {
        if (!option) {
            return '';
        }
        return option.username;
    }

    renderOption = (option: UserProfileValue, isSelected: boolean, onAdd: (user: UserProfileValue) => void, onMouseMove: (user: UserProfileValue) => void) => {
        return (
            <MultiSelectOption
                option={option}
                onAdd={onAdd}
                isSelected={isSelected}
                onMouseMove={onMouseMove}
                userStatuses={this.props.userStatuses}
                ref={isSelected ? this.selectedItemRef : undefined}
                key={option.id}
            />
        );
    };

    public render = (): JSX.Element => {
        const buttonSubmitText = this.props.buttonSubmitText || localizeMessage('multiselect.createGroup', 'Create Group');
        const buttonSubmitLoadingText = this.props.buttonSubmitLoadingText || localizeMessage('multiselect.creating', 'Creating...');

        let users = filterProfilesStartingWithTerm(this.props.profiles, this.state.term).filter((user) => {
            return user.delete_at === 0 &&
                (this.props.excludeUsers !== undefined && !this.props.excludeUsers[user.id]);
        }).map((user) => user as UserProfileValue);

        if (this.props.includeUsers) {
            const includeUsers = Object.values(this.props.includeUsers);
            users = [...users, ...includeUsers];
        }

        let maxValues;
        let numRemainingText = null;

        if (this.state.values.length >= MAX_SELECTABLE_VALUES) {
            maxValues = MAX_SELECTABLE_VALUES;
            numRemainingText = localizeMessage('multiselect.maxGroupMembers', 'No more than 256 members can be added to a group at once.');
        }

        return (
            <MultiSelect
                key={this.props.multilSelectKey}
                options={users}
                optionRenderer={this.renderOption}
                selectedItemRef={this.selectedItemRef}
                values={this.state.values}
                ariaLabelRenderer={this.renderAriaLabel}
                saveButtonPosition={'bottom'}
                perPage={USERS_PER_PAGE}
                handlePageChange={this.handlePageChange}
                handleInput={this.search}
                handleDelete={this.handleDelete}
                handleAdd={this.addValue}
                handleSubmit={this.handleSubmit}
                buttonSubmitText={buttonSubmitText}
                buttonSubmitLoadingText={buttonSubmitLoadingText}
                saving={this.props.saving}
                loading={this.state.loadingUsers}
                placeholderText={localizeMessage('multiselect.placeholder', 'Search for people')}
                valueWithImage={true}
                focusOnLoad={this.props.focusOnLoad}
                savingEnabled={this.props.savingEnabled}
                backButtonClick={this.props.backButtonClick}
                backButtonClass={this.props.backButtonClass}
                backButtonText={this.props.backButtonText}
                maxValues={maxValues}
                numRemainingText={numRemainingText}
            />
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {getProfilesNotInGroup, searchProfiles, getProfiles} from 'mattermost-redux/actions/users';
import {getProfilesNotInCurrentGroup, getUserStatuses, getProfiles as getUsers} from 'mattermost-redux/selectors/entities/users';
import {Action, ActionResult} from 'mattermost-redux/types/actions';
import {UserProfile} from '@mattermost/types/users';

import {Value} from 'components/multiselect/multiselect';

import {loadStatusesForProfilesList} from 'actions/status_actions';

import {GlobalState} from 'types/store';

import AddUserToGroupMultiSelect from './add_user_to_group_multiselect';

type UserProfileValue = Value & UserProfile;

type OwnProps = {
    groupId?: string;
}

function mapStateToProps(state: GlobalState, props: OwnProps) {
    let profiles: UserProfileValue[];

    if (props.groupId) {
        profiles = getProfilesNotInCurrentGroup(state, props.groupId) as UserProfileValue[];
    } else {
        profiles = getUsers(state) as UserProfileValue[];
    }
    const userStatuses = getUserStatuses(state);

    return {
        groupId: props.groupId,
        profiles,
        userStatuses,
    };
}

type Actions = {
    getProfiles: (page?: number, perPage?: number) => Promise<ActionResult>;
    getProfilesNotInGroup: (groupId: string, page?: number, perPage?: number) => Promise<ActionResult>;
    loadStatusesForProfilesList: (users: UserProfile[]) => void;
    searchProfiles: (term: string, options: any) => Promise<ActionResult>;
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, Actions>({
            getProfiles,
            getProfilesNotInGroup,
            loadStatusesForProfilesList,
            searchProfiles,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(AddUserToGroupMultiSelect);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {NavLink} from 'react-router-dom';

import {getHistory} from 'utils/browser_history';

type Props = {
    id?: string;
    activeClassName?: string;

    // Bool whether navigation is blocked
    blocked: boolean;

    // String Link destination
    to: string;
    actions: {

        // Function for deferring navigation while blocked
        deferNavigation: (func: () => void) => void;
    };
    children?: string | React.ReactNode;
    className?: string;
    onClick?: (e: React.MouseEvent) => void;
};
export default class BlockableLink extends React.PureComponent<Props> {
    private handleClick = (e: React.MouseEvent) => {
        if (this.props.onClick) {
            this.props.onClick(e);
        }
        if (this.props.blocked) {
            e.preventDefault();
            this.props.actions.deferNavigation(() => {
                getHistory().push(this.props.to);
            });
        }
    };

    public render() {
        const props = {...this.props};
        Reflect.deleteProperty(props, 'blocked');
        Reflect.deleteProperty(props, 'actions');

        return (
            <NavLink
                {...props}
                onClick={this.handleClick}
            />
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {deferNavigation} from 'actions/admin_actions';
import {getNavigationBlocked} from 'selectors/views/admin';
import {GlobalState} from 'types/store';

import BlockableLink from './blockable_link';

function mapStateToProps(state: GlobalState) {
    return {
        blocked: getNavigationBlocked(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators({
            deferNavigation,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(BlockableLink);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

type SvgProps = {
    width?: number;
    height?: number;
}

const SystemRolesSVG = (props: SvgProps) => (
    <svg
        width={props.width ? props.width.toString() : '248'}
        height={props.height ? props.height.toString() : '220'}
        viewBox='0 0 248 220'
        fill='none'
        xmlns='http://www.w3.org/2000/svg'
        xmlnsXlink='http://www.w3.org/1999/xlink'
    >
        <g clipPath='url(#clip0)'>
            <path
                d='M238.824 76.0088H148.114C143.322 76.0088 139.438 79.8761 139.438 84.6468V98.9427C139.438 103.713 143.322 107.581 148.114 107.581H238.824C243.616 107.581 247.5 103.713 247.5 98.9427V84.6468C247.5 79.8761 243.616 76.0088 238.824 76.0088Z'
                fill='#133A91'
            />
            <path
                d='M247.5 99.3643C247.491 101.541 246.619 103.626 245.073 105.165C243.527 106.704 241.433 107.573 239.247 107.581H147.691C145.504 107.575 143.408 106.708 141.861 105.168C140.315 103.628 139.443 101.542 139.438 99.3643C139.438 99.3643 142.691 103.478 149.491 103.467H237.338C241.129 103.451 244.768 101.981 247.5 99.3643Z'
                fill='#1E325C'
            />
            <path
                d='M157.115 97.0744C160.613 97.0744 163.449 94.2512 163.449 90.7686C163.449 87.2861 160.613 84.4629 157.115 84.4629C153.617 84.4629 150.781 87.2861 150.781 90.7686C150.781 94.2512 153.617 97.0744 157.115 97.0744Z'
                fill='#32A4EC'
            />
            <path
                d='M210.192 94.1375C212.061 94.1375 213.576 92.6293 213.576 90.7687C213.576 88.9082 212.061 87.3999 210.192 87.3999C208.324 87.3999 206.809 88.9082 206.809 90.7687C206.809 92.6293 208.324 94.1375 210.192 94.1375Z'
                fill='white'
            />
            <path
                d='M221.536 94.1375C223.405 94.1375 224.92 92.6293 224.92 90.7687C224.92 88.9082 223.405 87.3999 221.536 87.3999C219.667 87.3999 218.152 88.9082 218.152 90.7687C218.152 92.6293 219.667 94.1375 221.536 94.1375Z'
                fill='white'
            />
            <path
                d='M232.892 94.1375C234.76 94.1375 236.275 92.6293 236.275 90.7687C236.275 88.9082 234.76 87.3999 232.892 87.3999C231.023 87.3999 229.508 88.9082 229.508 90.7687C229.508 92.6293 231.023 94.1375 232.892 94.1375Z'
                fill='white'
            />
            <path
                d='M238.824 111.997H148.114C143.322 111.997 139.438 115.864 139.438 120.635V134.931C139.438 139.702 143.322 143.569 148.114 143.569H238.824C243.616 143.569 247.5 139.702 247.5 134.931V120.635C247.5 115.864 243.616 111.997 238.824 111.997Z'
                fill='#133A91'
            />
            <path
                d='M247.5 135.352C247.491 137.529 246.619 139.614 245.073 141.153C243.527 142.692 241.433 143.56 239.247 143.569H147.691C145.504 143.563 143.408 142.696 141.861 141.156C140.315 139.616 139.443 137.53 139.438 135.352C139.438 135.352 142.691 139.466 149.491 139.455C156.291 139.444 233.119 139.455 237.338 139.455C241.129 139.438 244.768 137.969 247.5 135.352Z'
                fill='#1E325C'
            />
            <path
                d='M157.115 133.063C160.613 133.063 163.449 130.239 163.449 126.757C163.449 123.274 160.613 120.451 157.115 120.451C153.617 120.451 150.781 123.274 150.781 126.757C150.781 130.239 153.617 133.063 157.115 133.063Z'
                fill='#32A4EC'
            />
            <path
                d='M210.192 130.126C212.061 130.126 213.576 128.618 213.576 126.757C213.576 124.896 212.061 123.388 210.192 123.388C208.324 123.388 206.809 124.896 206.809 126.757C206.809 128.618 208.324 130.126 210.192 130.126Z'
                fill='white'
            />
            <path
                d='M221.536 130.126C223.405 130.126 224.92 128.618 224.92 126.757C224.92 124.896 223.405 123.388 221.536 123.388C219.667 123.388 218.152 124.896 218.152 126.757C218.152 128.618 219.667 130.126 221.536 130.126Z'
                fill='white'
            />
            <path
                d='M232.892 130.126C234.76 130.126 236.275 128.618 236.275 126.757C236.275 124.896 234.76 123.388 232.892 123.388C231.023 123.388 229.508 124.896 229.508 126.757C229.508 128.618 231.023 130.126 232.892 130.126Z'
                fill='white'
            />
            <path
                d='M238.824 147.985H148.114C143.322 147.985 139.438 151.852 139.438 156.623V170.919C139.438 175.689 143.322 179.557 148.114 179.557H238.824C243.616 179.557 247.5 175.689 247.5 170.919V156.623C247.5 151.852 243.616 147.985 238.824 147.985Z'
                fill='#133A91'
            />
            <path
                d='M247.5 171.339C247.494 173.517 246.623 175.604 245.076 177.143C243.53 178.683 241.434 179.551 239.247 179.556H147.691C145.504 179.551 143.408 178.683 141.861 177.143C140.315 175.604 139.443 173.517 139.438 171.339C139.438 171.339 142.691 175.464 149.491 175.442H237.338C241.129 175.426 244.768 173.956 247.5 171.339Z'
                fill='#1E325C'
            />
            <path
                d='M157.115 169.051C160.613 169.051 163.449 166.228 163.449 162.745C163.449 159.263 160.613 156.439 157.115 156.439C153.617 156.439 150.781 159.263 150.781 162.745C150.781 166.228 153.617 169.051 157.115 169.051Z'
                fill='#32A4EC'
            />
            <path
                d='M210.192 166.114C212.061 166.114 213.576 164.606 213.576 162.745C213.576 160.885 212.061 159.376 210.192 159.376C208.324 159.376 206.809 160.885 206.809 162.745C206.809 164.606 208.324 166.114 210.192 166.114Z'
                fill='white'
            />
            <path
                d='M221.536 166.114C223.405 166.114 224.92 164.606 224.92 162.745C224.92 160.885 223.405 159.376 221.536 159.376C219.667 159.376 218.152 160.885 218.152 162.745C218.152 164.606 219.667 166.114 221.536 166.114Z'
                fill='white'
            />
            <path
                d='M232.892 166.114C234.76 166.114 236.275 164.606 236.275 162.745C236.275 160.885 234.76 159.376 232.892 159.376C231.023 159.376 229.508 160.885 229.508 162.745C229.508 164.606 231.023 166.114 232.892 166.114Z'
                fill='white'
            />
            <path
                d='M230.278 107.581H156.671V111.997H230.278V107.581Z'
                fill='#1B1D22'
            />
            <path
                d='M230.278 143.569H156.671V147.985H230.278V143.569Z'
                fill='#1B1D22'
            />
        </g>
        <g clipPath='url(#clip1)'>
            <path
                d='M156.767 62.8653H235.72C236.303 62.8583 236.86 62.6199 237.269 62.2021C237.678 61.7844 237.904 61.2214 237.9 60.6365V7.73663C237.904 7.1517 237.678 6.58874 237.269 6.171C236.86 5.75326 236.303 5.51481 235.72 5.50781H156.767C156.478 5.51128 156.193 5.57164 155.928 5.68553C155.663 5.79941 155.422 5.96457 155.221 6.17154C155.019 6.37851 154.86 6.62325 154.753 6.89179C154.646 7.16033 154.592 7.44741 154.596 7.73663V60.6719C154.598 61.2499 154.827 61.8038 155.233 62.2141C155.639 62.6245 156.19 62.8584 156.767 62.8653Z'
                fill='#202427'
            />
            <path
                d='M148.259 70.6753C148.259 73.3287 150.412 75.9821 153.051 75.9821H239.4C241.88 75.9821 244.183 73.3287 244.183 70.6753H148.259Z'
                fill='#202427'
            />
            <path
                d='M236.196 62.9009H156.255L148.259 70.6665H244.192L236.196 62.9009Z'
                fill='#DCDCDC'
            />
            <path
                d='M233.557 63.5112H158.938L156.281 66.7838H236.223L233.557 63.5112Z'
                fill='#BEBDBE'
            />
            <path
                d='M204.451 68.2256H188.044L186.817 69.853H205.677L204.451 68.2256Z'
                fill='#202427'
            />
            <path
                d='M233.018 10.3457H159.476V58.0626H233.018V10.3457Z'
                fill='#3D4247'
            />
            <path
                d='M196.243 6.75488C196.49 6.75488 196.73 6.82801 196.935 6.96504C197.139 7.10207 197.299 7.29686 197.393 7.52474C197.487 7.75262 197.512 8.00335 197.464 8.24526C197.416 8.48717 197.297 8.70942 197.123 8.88383C196.949 9.05824 196.728 9.17699 196.486 9.22511C196.245 9.27323 195.995 9.24851 195.767 9.15412C195.54 9.05973 195.345 8.89992 195.209 8.69483C195.072 8.48975 194.999 8.24861 194.999 8.00196C194.999 7.6712 195.13 7.35401 195.363 7.12014C195.597 6.88626 195.913 6.75488 196.243 6.75488Z'
                fill='#DCDCDC'
            />
            <path
                d='M203.127 74.1508H189.324C189.095 74.1967 188.859 74.1879 188.635 74.1252C188.41 74.0626 188.204 73.9478 188.032 73.7901C187.86 73.6324 187.727 73.4364 187.645 73.2178C187.563 72.9993 187.533 72.7644 187.559 72.5322H204.83C204.853 72.7582 204.824 72.9865 204.745 73.1995C204.666 73.4125 204.54 73.6046 204.375 73.7609C204.211 73.9172 204.013 74.0336 203.796 74.1012C203.58 74.1688 203.351 74.1858 203.127 74.1508Z'
                fill='#3D4247'
            />
        </g>
        <path
            d='M82.9488 209.295C83.1819 206.313 81.3949 202.66 78.5398 198.275C78.0251 197.486 77.4812 196.668 76.9082 195.839C71.2561 187.616 62.8072 177.064 56.7667 163.745C46.1716 140.361 48.9977 102.362 52.115 81.6862C52.115 81.6862 70.0811 75.6258 78.433 84.0635C78.7605 84.3655 79.0656 84.6912 79.3458 85.0379C83.2303 89.9972 82.5895 101.017 78.6952 115.125C72.4313 137.847 72.4216 148.808 75.1213 158.503C77.4521 166.882 81.8027 174.336 85.8815 187.606C86.3283 189.039 86.7362 190.383 87.1149 191.64C87.4062 192.614 87.6782 193.53 87.9307 194.397C89.7565 200.672 90.5819 204.297 90.6985 206.528C88.125 207.522 85.532 208.408 82.9488 209.295Z'
            fill='#CB8E00'
        />
        <path
            d='M87.513 193.053L85.8912 193.618L85.2114 193.852L80.3557 195.567C79.3825 195.901 78.5261 196.51 77.889 197.32C72.2758 188.902 63.147 177.834 56.7472 163.745C46.152 140.361 48.9781 102.362 52.0955 81.6861C52.0955 81.6861 71.4601 75.1483 79.2875 85.0866C83.1721 90.0459 82.5311 101.066 78.6368 115.174C66.9831 157.519 77.015 159.019 85.8233 187.665C86.4933 189.643 87.0275 191.416 87.513 193.053Z'
            fill='#174AB5'
        />
        <path
            d='M87.513 193.053L85.8912 193.618L85.2114 193.852L80.3557 195.567C79.3825 195.901 78.5261 196.51 77.889 197.32C72.2758 188.902 63.147 177.834 56.7472 163.745C46.152 140.361 48.9781 102.362 52.0955 81.6861C52.0955 81.6861 71.4601 75.1483 79.2875 85.0866C83.1721 90.0459 82.5311 101.066 78.6368 115.174C66.9831 157.519 77.015 159.019 85.8232 187.665C86.4933 189.643 87.0275 191.416 87.513 193.053Z'
            fill='#174AB5'
        />
        <mask
            id='mask0'
            mask-type='alpha'
            maskUnits='userSpaceOnUse'
            x='49'
            y='79'
            width='39'
            height='119'
        >
            <path
                d='M87.513 193.053L85.8912 193.618L85.2114 193.852L80.3557 195.567C79.3825 195.901 78.5261 196.51 77.889 197.32C72.2758 188.902 63.147 177.834 56.7472 163.745C46.152 140.361 48.9781 102.362 52.0955 81.6861C52.0955 81.6861 71.4601 75.1483 79.2875 85.0866C83.1721 90.0459 82.5311 101.066 78.6368 115.174C66.9831 157.519 77.015 159.019 85.8233 187.665C86.4933 189.643 87.0275 191.416 87.513 193.053Z'
                fill='#1452BD'
            />
        </mask>
        <g mask='url(#mask0)'>
            <rect
                x='49.0391'
                y='79.313'
                width='38.642'
                height='118.026'
                fill='url(#pattern0)'
            />
        </g>
        <path
            d='M82.8709 204.677C82.6279 204.759 82.3774 204.818 82.1231 204.852C82.8162 206.766 82.8162 208.863 82.1231 210.776C81.4433 212.91 79.909 215.726 79.4332 217.158C77.9862 221.494 79.4913 220.987 83.9586 214.82C88.4258 208.652 92.4075 212.764 90.0088 202.153C87.6198 202.991 85.2405 203.832 82.8709 204.677Z'
            fill='#2D3039'
        />
        <path
            d='M136.633 160.091C131.622 152.521 137.507 154.382 122.765 160.9C121.939 161.28 121.027 161.66 120.055 162.06L117.9 162.927C100.419 169.747 85.3176 167.652 75.1207 158.562C73.1281 156.784 71.3487 154.78 69.8183 152.589C60.7866 139.738 64.409 111.667 78.4323 84.0737C79.63 81.7158 80.9022 79.3709 82.2488 77.039L101.555 64.168C101.555 64.168 114.811 78.2374 97.6706 113.966C81.3359 148.068 99.6615 150.884 117.637 149.569C118.502 149.51 119.385 149.432 120.25 149.354H120.531C138.983 147.62 136.652 145.817 138.74 154.869C140.828 163.921 142.129 168.383 136.633 160.091Z'
            fill='#CB8E00'
        />
        <path
            d='M121.61 161.416C120.484 161.894 119.25 162.391 117.9 162.927C97.0597 171.023 79.6276 166.532 69.8191 152.579C60.0106 138.627 65.1284 106.717 82.2497 77.0292L101.556 64.1582C101.556 64.1582 114.812 78.2276 97.6714 113.957C80.725 149.305 101.07 151.04 119.639 149.393C119.833 150.445 120.027 151.507 120.212 152.569C120.212 152.813 120.299 153.057 120.328 153.3C120.552 154.547 120.756 155.785 120.95 157.032C120.95 157.266 121.027 157.519 121.066 157.753C121.261 158.971 121.435 160.16 121.61 161.416Z'
            fill='#1C58D9'
        />
        <path
            d='M138.741 154.83C137.051 147.503 138.216 147.288 129.029 148.389C129.534 151.247 130.007 154.112 130.447 156.983C135.303 154.06 132.904 154.411 136.662 160.091C142.13 168.383 140.848 163.93 138.741 154.83Z'
            fill='#2D3039'
        />
        <path
            d='M71.6055 26.8019C71.9257 21.7893 72.9457 16.8467 74.6354 12.1186C76.6651 7.00333 80.7148 2.9988 82.5017 3.19367C86.5902 3.62238 89.7076 1.95626 91.174 4.27518C92.3588 6.36026 90.9992 17.5944 89.6784 18.5492C88.7165 19.0426 87.6899 19.3968 86.629 19.6015L84.9295 28.7992L71.6055 26.8019Z'
            fill='#CB8E00'
        />
        <path
            d='M91.7668 8.79639C93.107 11.6609 93.9714 13.7363 93.9714 13.7363C93.8451 14.7593 90.4072 14.4183 90.4072 14.4183L91.7668 8.79639Z'
            fill='#CB8E00'
        />
        <path
            d='M83.9977 18.8804C85.3754 19.2724 86.8253 19.3358 88.2318 19.0655C88.7659 18.9584 87.1538 19.6014 86.6197 19.7086C85.0464 20.0204 85.3379 20.1471 83.7938 19.7086C83.2402 19.5917 83.4344 18.7635 83.9977 18.8804Z'
            fill='black'
            fillOpacity='0.24'
        />
        <path
            d='M74.4317 1.24505C72.5671 2.63835 71.2172 7.09108 70.5471 9.32231C69.8771 11.5535 71.2172 13.7068 71.4502 16.0257C71.4342 16.4763 71.5224 16.9245 71.7077 17.3352C71.893 17.746 72.1706 18.1081 72.5186 18.3934C73.7131 19.0949 75.1697 17.9354 75.8204 16.7078C76.471 15.4801 76.8983 13.9699 78.1317 13.3366C79.0154 12.8786 80.2683 12.9176 80.7539 12.0407C81.1617 11.3197 80.7539 10.3941 81.0161 9.60486C81.3366 8.56232 82.5699 8.1531 83.6284 7.90952L89.9505 6.40903C91.1581 6.20789 92.3117 5.76021 93.3398 5.09369C93.8929 4.78486 94.3207 4.29151 94.5491 3.69925C94.7775 3.107 94.792 2.45321 94.5901 1.85135C94.3883 1.24949 93.9827 0.737526 93.4439 0.40431C92.9051 0.0710941 92.267 -0.0623556 91.6403 0.0271295C90.2225 0.0271295 89.1736 0.845581 87.8626 1.14763C86.5293 1.28883 85.185 1.28883 83.8517 1.14763C81.084 1.15737 76.7819 -0.508755 74.4317 1.24505Z'
            fill='#66320A'
        />
        <path
            d='M159.562 5.23971C156.144 5.60021 152.91 10.1114 148.598 18.6368C144.286 27.1623 134.031 37.3344 122.377 30.8453C110.723 24.3562 101.012 25.428 86.7845 25.3598C84.3664 25.1551 68.9155 25.1162 65.633 25.4864C41.5196 26.2854 39.8784 51.2771 27.3507 49.7864C11.3851 47.8377 13.4633 29.5689 5.83013 25.0675C-1.80305 20.566 0.314078 23.8495 2.7128 24.9895C5.11152 26.1295 2.71273 27.211 3.85868 32.9206C5.00463 38.6302 4.68419 58.7892 19.5621 65.8239C30.4292 70.9587 43.4619 65.707 53.2025 58.0293C53.1442 59.9779 53.0859 62.0338 53.0082 64.2163C52.61 75.6063 49.3665 83.2938 49.3082 87.6686C63.6103 87.1889 77.9279 87.5142 92.1937 88.6429C95.8549 88.8378 104.731 89.8803 108.402 90.1337C108.402 90.1337 107.334 82.8846 106.703 73.7648C105.829 61.1861 105.955 54.8432 105.265 47.789C131.311 55.8273 148.287 39.5753 151.88 32.1119C158.775 17.7015 157.522 12.4888 157.629 10.316C157.804 6.81814 162.971 4.84998 159.562 5.23971Z'
            fill='#CB8E00'
        />
        <path
            d='M124.426 31.7807C123.901 37.7826 123.076 46.2203 121.007 51.3551C119.939 51.2382 118.948 51.1602 117.967 51.092L117.249 51.0433L115.598 50.9264L114.879 50.8679C111.968 50.6234 109.092 50.0581 106.304 49.1823C106.495 51.3593 106.566 53.5451 106.518 55.7299C106.518 55.9637 106.518 56.217 106.518 56.4509C106.518 57.6883 106.459 58.9647 106.421 60.3482C106.421 60.5041 106.421 60.66 106.421 60.8159C106.421 60.9718 106.421 60.9913 106.421 61.0692C106.421 62.0436 106.421 63.0179 106.421 64.1189C106.421 65.2199 106.421 66.0676 106.421 67.1393C106.421 69.088 106.557 71.251 106.731 73.7161C106.838 75.392 106.974 77.0094 107.11 78.5293C107.11 78.7729 107.11 79.0262 107.178 79.2601C107.285 80.5267 107.411 81.7057 107.528 82.7969C107.528 83.0405 107.528 83.2744 107.596 83.5082C108.042 87.5225 108.411 90.085 108.411 90.085C104.76 89.8316 95.8836 88.7891 92.203 88.5942C77.9436 87.4655 63.6325 87.1402 49.3369 87.6199C49.4212 85.9947 49.6683 84.3821 50.0748 82.8067C50.0748 82.5631 50.1817 82.3098 50.2497 82.0564C50.4051 81.3549 50.5799 80.6047 50.7547 79.8155L50.9294 79.0652C51.1528 78.0909 51.3762 77.1166 51.5899 75.9863C51.8521 74.6905 52.0949 73.3264 52.3182 71.8649C52.5999 69.9747 52.8233 67.9675 52.9495 65.785C52.9495 65.5512 52.9495 65.3076 52.9495 65.0543C52.9495 64.8009 52.9495 64.4697 52.9495 64.1676V63.3297V62.6671C53.0078 61.0303 53.0563 59.4713 53.0952 57.9806L48.8124 61.381L48.2491 61.8292L47.2779 62.5892L46.7244 63.0374C45.1124 64.304 43.8887 65.2589 43.811 65.2589C39.0621 60.8354 36.9353 52.8069 35.1387 46.6491C36.0227 45.8058 36.8531 44.9076 37.6249 43.9599C37.8191 43.7455 37.9938 43.5214 38.1784 43.2973C38.6348 42.742 39.0913 42.1671 39.5574 41.5728L40.1401 40.8225C40.2857 40.6374 40.4218 40.4523 40.5772 40.2671C44.6268 35.1226 49.434 29.2961 57.5819 26.7726C58.485 26.49 59.4367 26.2465 60.4272 26.0418C61.4612 25.8387 62.505 25.689 63.5543 25.5936L64.341 25.5254C64.6906 25.5254 65.0499 25.5254 65.4092 25.467H65.4966C65.8656 25.467 66.4677 25.389 67.0795 25.3501C67.1695 25.5124 67.2701 25.6687 67.3807 25.8177C74.0427 34.9278 84.3271 32.2776 90.6881 25.3306H94.728C97.2919 25.3306 99.7294 25.3306 102.08 25.4475C107.579 25.5697 113.011 26.7024 118.103 28.7895L118.793 29.0818C119.385 29.3546 119.978 29.6371 120.57 29.9392L121.26 30.2802C121.599 30.4556 121.93 30.6407 122.231 30.8356C122.939 31.2036 123.672 31.5195 124.426 31.7807Z'
            fill='white'
        />
        <mask
            id='mask1'
            mask-type='alpha'
            maskUnits='userSpaceOnUse'
            x='35'
            y='25'
            width='90'
            height='66'
        >
            <path
                d='M124.426 31.7807C123.901 37.7826 123.076 46.2203 121.007 51.3551C119.939 51.2382 118.948 51.1602 117.967 51.092L117.249 51.0433L115.598 50.9264L114.879 50.8679C111.968 50.6234 109.092 50.0581 106.304 49.1823C106.495 51.3593 106.566 53.5451 106.518 55.7299C106.518 55.9637 106.518 56.217 106.518 56.4509C106.518 57.6883 106.459 58.9647 106.421 60.3482C106.421 60.5041 106.421 60.66 106.421 60.8159C106.421 60.9718 106.421 60.9913 106.421 61.0692C106.421 62.0436 106.421 63.0179 106.421 64.1189C106.421 65.2199 106.421 66.0676 106.421 67.1393C106.421 69.088 106.557 71.251 106.731 73.7161C106.838 75.392 106.974 77.0094 107.11 78.5293C107.11 78.7729 107.11 79.0262 107.178 79.2601C107.285 80.5267 107.411 81.7057 107.528 82.7969C107.528 83.0405 107.528 83.2743 107.596 83.5082C108.042 87.5225 108.411 90.085 108.411 90.085C104.76 89.8316 95.8836 88.7891 92.203 88.5942C77.9436 87.4655 63.6325 87.1402 49.3369 87.6199C49.4212 85.9947 49.6683 84.3821 50.0748 82.8067C50.0748 82.5631 50.1817 82.3098 50.2497 82.0564C50.4051 81.3549 50.5799 80.6047 50.7547 79.8154L50.9294 79.0652C51.1528 78.0909 51.3762 77.1165 51.5899 75.9863C51.8521 74.6904 52.0949 73.3264 52.3182 71.8649C52.5999 69.9747 52.8233 67.9675 52.9495 65.785C52.9495 65.5512 52.9495 65.3076 52.9495 65.0543C52.9495 64.8009 52.9495 64.4697 52.9495 64.1676V63.3297V62.6671C53.0078 61.0303 53.0563 59.4713 53.0952 57.9806L48.8124 61.381L48.2491 61.8292L47.2779 62.5892L46.7244 63.0374C45.1124 64.304 43.8887 65.2589 43.811 65.2589C39.0621 60.8354 36.9353 52.8069 35.1387 46.649C36.0227 45.8058 36.8531 44.9076 37.6249 43.9599C37.8191 43.7455 37.9938 43.5214 38.1784 43.2973C38.6348 42.742 39.0913 42.1671 39.5574 41.5728L40.1401 40.8225C40.2857 40.6374 40.4218 40.4523 40.5772 40.2671C44.6268 35.1226 49.434 29.2961 57.5819 26.7726C58.485 26.49 59.4367 26.2465 60.4272 26.0418C61.4612 25.8387 62.505 25.689 63.5543 25.5936L64.341 25.5254C64.6906 25.5254 65.0499 25.5254 65.4092 25.467H65.4966C65.8656 25.467 66.4677 25.389 67.0795 25.3501C67.1695 25.5124 67.2701 25.6687 67.3807 25.8177C74.0427 34.9278 84.3271 32.2776 90.6881 25.3306H94.728C97.2919 25.3306 99.7294 25.3306 102.08 25.4475C107.579 25.5697 113.011 26.7024 118.103 28.7895L118.793 29.0818C119.385 29.3546 119.978 29.6371 120.57 29.9392L121.26 30.2802C121.599 30.4556 121.93 30.6407 122.231 30.8356C122.939 31.2036 123.672 31.5195 124.426 31.7807Z'
                fill='white'
            />
        </mask>
        <g mask='url(#mask1)'>
            <rect
                x='34.9004'
                y='25.0215'
                width='89.5363'
                height='65.1502'
                fill='url(#pattern1)'
            />
        </g>
        <path
            d='M107.558 83.5181C88.3681 82.2417 69.1395 79.7474 50.0371 82.7971C50.0371 82.5535 50.1439 82.3002 50.2118 82.0469C69.2365 79.0751 88.368 81.5305 107.509 82.8069C107.509 83.0504 107.538 83.2843 107.558 83.5181Z'
            fill='#E8E9ED'
        />
        <path
            d='M107.139 79.2895C88.3948 76.8902 69.4116 77.0705 50.7158 79.8254L50.8907 79.0751C69.5085 76.3608 88.4069 76.187 107.071 78.5587C107.091 78.7828 107.11 79.0362 107.139 79.2895Z'
            fill='#E8E9ED'
        />
        <path
            d='M106.402 60.3484C106.402 60.592 106.402 60.8258 106.402 61.0694C88.5618 59.9684 70.5278 62.8524 52.9307 65.7755C52.9307 65.5416 52.9307 65.298 52.9307 65.0447C70.5472 62.1119 88.5715 59.2669 106.402 60.3484Z'
            fill='#E8E9ED'
        />
        <path
            d='M106.518 55.7295C106.518 55.9633 106.518 56.2167 106.518 56.4505C88.55 56.5318 70.6614 58.8457 53.2605 63.3391C53.1881 63.3643 53.1094 63.3643 53.0371 63.3391V62.6765C70.5094 58.1524 88.4733 55.8189 106.518 55.7295Z'
            fill='#E8E9ED'
        />
        <path
            d='M94.0492 25.311C91.8739 30.5335 88.3875 35.0544 82.1819 35.4246C75.1023 35.9021 66.6436 32.2775 63.6719 25.5838L64.4586 25.5156C67.44 31.8001 75.4519 35.1713 82.1819 34.7036C87.9602 34.3139 91.2232 30.173 93.2917 25.311H94.0492Z'
            fill='#E8E9ED'
        />
        <path
            d='M121.348 30.2604C120.455 37.2432 119.328 44.187 117.969 51.0917L117.25 51.043C118.648 44.0408 119.785 36.9996 120.659 29.9194L121.348 30.2604Z'
            fill='#E8E9ED'
        />
        <path
            d='M47.3662 62.5795L46.8126 63.0276C42.739 57.2255 39.6693 50.776 37.7324 43.9501C37.9267 43.7358 38.1015 43.5117 38.286 43.2876C40.1926 50.1912 43.2637 56.7162 47.3662 62.5795Z'
            fill='#E8E9ED'
        />
        <path
            d='M40.2965 40.8125C41.6305 48.2229 44.5857 55.2442 48.9494 61.371L48.3861 61.8192C44.0757 55.7721 41.1176 48.8625 39.7139 41.5627L40.2965 40.8125Z'
            fill='#E8E9ED'
        />
        <path
            d='M118.881 29.0623C118.231 36.4105 117.134 43.7121 115.599 50.9264L114.88 50.868C116.434 43.5771 117.54 36.1972 118.191 28.77L118.881 29.0623Z'
            fill='#E8E9ED'
        />
        <path
            d='M88.309 8.28955C86.6871 8.28955 85.1236 8.28955 83.8417 8.28955C81.4139 8.39673 80.2873 8.77671 79.0928 11.0079C78.8792 11.3879 79.5202 11.6413 79.7241 11.2515C79.9606 10.6492 80.3573 10.1235 80.871 9.73182C81.3848 9.3401 81.9958 9.09735 82.6375 9.03004C83.884 8.92118 85.1351 8.87565 86.3861 8.89363C86.9105 8.89363 87.5418 8.89363 88.2119 8.89363C88.2604 8.71825 88.2798 8.5039 88.309 8.28955Z'
            fill='white'
        />
        <path
            d='M88.8532 11.086C88.4701 10.7415 88.1927 10.2946 88.0534 9.7977C87.9141 9.30077 87.9186 8.77432 88.0666 8.27992C88.4065 6.83791 89.5913 5.88305 90.6984 6.14612C91.8055 6.4092 92.4464 7.8025 92.1065 9.24452C91.7666 10.6865 90.5819 11.6414 89.4651 11.3783C89.2429 11.3252 89.0344 11.2256 88.8532 11.086ZM90.9218 6.99381C90.808 6.90915 90.6796 6.84638 90.543 6.80868C89.7952 6.6333 88.9795 7.36405 88.727 8.44556C88.4745 9.52707 88.8727 10.5404 89.6205 10.7158C90.3683 10.8911 91.184 10.1604 91.4462 9.08862C91.5483 8.72468 91.5488 8.33962 91.4478 7.9754C91.3467 7.61117 91.1479 7.28176 90.8732 7.02304L90.9218 6.99381Z'
            fill='white'
        />
        <path
            d='M68.7988 9.91642C66.1476 9.91642 64.2538 13.0246 63.4283 16.3276C62.8068 18.8024 58.9999 19.2993 56.5041 18.7829C53.8626 18.247 51.7261 15.9378 49.0361 15.8599C47.0938 15.7917 45.3263 16.9219 43.588 17.8085C41.8496 18.6952 39.7034 19.4259 37.9942 18.549C36.0519 17.5747 35.3333 15.0707 33.4007 14.1743C31.4681 13.2779 29.0888 14.3984 27.5058 15.8988C25.0356 18.2501 23.4913 21.4146 23.1551 24.814C22.9137 26.5729 23.2225 28.3637 24.0389 29.939C24.4587 30.7173 25.082 31.3662 25.8416 31.8159C26.6013 32.2657 27.4686 32.4993 28.3507 32.4918C30.5358 32.3554 32.4101 30.397 34.5855 30.6503C35.8185 30.8838 36.9162 31.5808 37.6543 32.599C38.4312 33.5733 39.0236 34.6743 39.8102 35.6389C41.0087 37.1048 42.6134 38.1812 44.4216 38.7322C46.2297 39.2832 48.1601 39.2839 49.9687 38.7344C51.7772 38.1848 53.3828 37.1096 54.5824 35.6446C55.782 34.1797 56.5217 32.3908 56.7081 30.5041C56.8344 29.2278 56.7081 27.8442 57.4462 26.7919C58.4173 25.3791 60.3596 25.1648 62.0397 25.194C63.7197 25.2232 65.6038 25.3207 66.8954 24.2197C69.6728 21.8618 67.2353 16.4737 69.9739 14.0768C70.689 13.549 71.4733 13.1228 72.3046 12.8102C73.3728 12.2938 75.354 10.2087 73.4409 9.48771C72.8193 9.26362 71.7802 9.67284 71.1587 9.75079C70.3767 9.8594 69.5882 9.91474 68.7988 9.91642Z'
            fill='#66320A'
        />
        <mask
            id='mask2'
            mask-type='alpha'
            maskUnits='userSpaceOnUse'
            x='23'
            y='9'
            width='52'
            height='31'
        >
            <path
                d='M68.7988 9.91642C66.1476 9.91642 64.2538 13.0246 63.4283 16.3276C62.8068 18.8024 58.9999 19.2993 56.5041 18.7829C53.8626 18.247 51.7261 15.9378 49.0361 15.8599C47.0938 15.7917 45.3263 16.9219 43.588 17.8085C41.8496 18.6952 39.7034 19.4259 37.9942 18.549C36.0519 17.5747 35.3333 15.0707 33.4007 14.1743C31.4681 13.2779 29.0888 14.3984 27.5058 15.8988C25.0356 18.2501 23.4913 21.4146 23.1551 24.814C22.9137 26.5729 23.2225 28.3637 24.0389 29.939C24.4587 30.7173 25.082 31.3662 25.8416 31.8159C26.6013 32.2657 27.4686 32.4993 28.3507 32.4918C30.5358 32.3554 32.4101 30.397 34.5855 30.6503C35.8185 30.8838 36.9162 31.5808 37.6543 32.599C38.4312 33.5733 39.0236 34.6743 39.8102 35.6389C41.0087 37.1048 42.6134 38.1812 44.4216 38.7322C46.2297 39.2832 48.1601 39.2839 49.9687 38.7344C51.7772 38.1848 53.3828 37.1096 54.5824 35.6446C55.782 34.1797 56.5217 32.3908 56.7081 30.5041C56.8344 29.2278 56.7081 27.8442 57.4462 26.7919C58.4173 25.3791 60.3596 25.1648 62.0397 25.194C63.7197 25.2232 65.6038 25.3207 66.8954 24.2197C69.6728 21.8618 67.2353 16.4737 69.9739 14.0768C70.689 13.549 71.4733 13.1228 72.3046 12.8102C73.3728 12.2938 75.354 10.2087 73.4409 9.48771C72.8193 9.26362 71.7802 9.67284 71.1587 9.75079C70.3767 9.8594 69.5882 9.91474 68.7988 9.91642Z'
                fill='#66320A'
            />
        </mask>
        <g mask='url(#mask2)'>
            <rect
                x='22.6484'
                y='8.96924'
                width='51.8367'
                height='30.2146'
                fill='url(#pattern2)'
            />
        </g>
        <path
            d='M71.3728 14.3791C71.1865 12.9517 71.1216 11.511 71.1786 10.0725C71.2466 8.22127 68.372 8.22127 68.2652 10.0725C68.2163 11.7699 68.3137 13.4683 68.5564 15.1488C68.6668 15.51 68.9132 15.8139 69.2432 15.9958C69.5732 16.1777 69.9609 16.2234 70.324 16.1231C70.688 16.0222 70.9996 15.7852 71.1947 15.4607C71.3898 15.1363 71.4535 14.7492 71.3728 14.3791Z'
            fill='white'
        />
        <g clipPath='url(#clip2)'>
            <rect
                x='158.5'
                y='10'
                width='74'
                height='48'
                fill='white'
            />
            <rect
                x='158.5'
                y='10'
                width='24.7429'
                height='48'
                fill='#1E325C'
            />
            <ellipse
                cx='162.704'
                cy='14.3961'
                rx='2.28211'
                ry='2.25743'
                fill='white'
                fillOpacity='0.16'
            />
            <rect
                x='166.428'
                y='12.8516'
                width='11.0502'
                height='1.18812'
                rx='0.594059'
                fill='white'
                fillOpacity='0.32'
            />
            <rect
                x='166.428'
                y='15.228'
                width='7.20666'
                height='0.950496'
                rx='0.475248'
                fill='white'
                fillOpacity='0.32'
            />
            <rect
                x='160.902'
                y='19.7427'
                width='7.20666'
                height='0.950496'
                rx='0.475248'
                fill='white'
                fillOpacity='0.32'
            />
            <rect
                x='160.902'
                y='51.3467'
                width='7.20666'
                height='0.950489'
                rx='0.475245'
                fill='white'
                fillOpacity='0.32'
            />
            <ellipse
                cx='161.983'
                cy='23.6631'
                rx='1.081'
                ry='1.06931'
                fill='white'
                fillOpacity='0.16'
            />
            <rect
                x='164.506'
                y='23.3066'
                width='13.9329'
                height='0.950495'
                rx='0.475247'
                fill='white'
                fillOpacity='0.32'
            />
            <ellipse
                cx='161.983'
                cy='35.7822'
                rx='1.081'
                ry='1.06931'
                fill='white'
                fillOpacity='0.16'
            />
            <rect
                x='164.506'
                y='35.4258'
                width='13.9329'
                height='0.950489'
                rx='0.475245'
                fill='white'
                fillOpacity='0.32'
            />
            <ellipse
                cx='161.983'
                cy='27.7031'
                rx='1.081'
                ry='1.06931'
                fill='white'
                fillOpacity='0.16'
            />
            <rect
                x='164.506'
                y='27.3467'
                width='12.0111'
                height='0.9505'
                rx='0.47525'
                fill='white'
                fillOpacity='0.32'
            />
            <ellipse
                cx='161.983'
                cy='39.8217'
                rx='1.081'
                ry='1.0693'
                fill='white'
                fillOpacity='0.16'
            />
            <rect
                x='164.506'
                y='39.4653'
                width='12.0111'
                height='0.950493'
                rx='0.475246'
                fill='white'
                fillOpacity='0.32'
            />
            <ellipse
                cx='161.983'
                cy='31.7426'
                rx='1.081'
                ry='1.06931'
                fill='white'
                fillOpacity='0.16'
            />
            <rect
                x='164.506'
                y='31.3862'
                width='15.8547'
                height='0.950495'
                rx='0.475247'
                fill='white'
                fillOpacity='0.32'
            />
            <ellipse
                cx='161.983'
                cy='43.8618'
                rx='1.081'
                ry='1.06931'
                fill='white'
                fillOpacity='0.16'
            />
            <rect
                x='164.506'
                y='43.5054'
                width='15.8547'
                height='0.950493'
                rx='0.475246'
                fill='white'
                fillOpacity='0.32'
            />
            <ellipse
                cx='161.983'
                cy='55.2676'
                rx='1.081'
                ry='1.06931'
                fill='white'
                fillOpacity='0.16'
            />
            <rect
                x='164.506'
                y='54.9111'
                width='15.8547'
                height='0.950489'
                rx='0.475245'
                fill='white'
                fillOpacity='0.32'
            />
            <ellipse
                cx='161.983'
                cy='47.9013'
                rx='1.081'
                ry='1.06931'
                fill='white'
                fillOpacity='0.16'
            />
            <rect
                x='164.506'
                y='47.5449'
                width='10.5698'
                height='0.9505'
                rx='0.47525'
                fill='white'
                fillOpacity='0.32'
            />
            <rect
                x='183.243'
                y='16.6533'
                width='45.1618'
                height='13.3069'
                rx='4'
                fill='white'
            />
            <ellipse
                cx='187.755'
                cy='21.1164'
                rx='2.04917'
                ry='2.027'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <rect
                x='191.626'
                y='19.3896'
                width='9.71456'
                height='0.900887'
                rx='0.450443'
                fill='#3D3C40'
                fillOpacity='0.16'
            />
            <rect
                x='191.651'
                y='21.4062'
                width='29.3071'
                height='0.712871'
                rx='0.356435'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <rect
                x='191.651'
                y='23.0693'
                width='24.0222'
                height='0.712873'
                rx='0.356436'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <rect
                x='191.651'
                y='24.4951'
                width='32.9104'
                height='0.712873'
                rx='0.356437'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <rect
                x='191.651'
                y='26.1582'
                width='17.296'
                height='0.712875'
                rx='0.356438'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <rect
                x='183.243'
                y='28.2974'
                width='45.1618'
                height='13.3069'
                rx='4'
                fill='white'
            />
            <ellipse
                cx='187.755'
                cy='32.7604'
                rx='2.04917'
                ry='2.027'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <rect
                x='191.626'
                y='31.0337'
                width='9.71456'
                height='0.900888'
                rx='0.450444'
                fill='#3D3C40'
                fillOpacity='0.16'
            />
            <rect
                x='191.651'
                y='33.0503'
                width='29.3071'
                height='0.712866'
                rx='0.356433'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <rect
                x='191.651'
                y='34.7134'
                width='24.0222'
                height='0.712872'
                rx='0.356436'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <rect
                x='191.651'
                y='36.1392'
                width='32.9104'
                height='0.712885'
                rx='0.356442'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <rect
                x='191.651'
                y='37.8022'
                width='17.296'
                height='0.712872'
                rx='0.356436'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <rect
                x='183.243'
                y='40.8911'
                width='45.1618'
                height='13.3069'
                rx='4'
                fill='white'
            />
            <ellipse
                cx='187.755'
                cy='45.3541'
                rx='2.04917'
                ry='2.027'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <rect
                x='191.626'
                y='43.6274'
                width='9.71456'
                height='0.900875'
                rx='0.450438'
                fill='#3D3C40'
                fillOpacity='0.16'
            />
            <rect
                x='191.651'
                y='45.6436'
                width='29.3071'
                height='0.712879'
                rx='0.35644'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <rect
                x='191.651'
                y='47.3071'
                width='24.0222'
                height='0.712879'
                rx='0.35644'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <rect
                x='191.651'
                y='48.7329'
                width='32.9104'
                height='0.712872'
                rx='0.356436'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <rect
                x='191.651'
                y='50.396'
                width='17.296'
                height='0.712856'
                rx='0.356428'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <rect
                x='183.964'
                y='10.7129'
                width='57.1729'
                height='7.26875'
                rx='3.63438'
                fill='white'
            />
            <ellipse
                cx='198.749'
                cy='13.8153'
                rx='0.627287'
                ry='0.620504'
                fill='#3D3C40'
                fillOpacity='0.16'
            />
            <ellipse
                cx='218.285'
                cy='14.3471'
                rx='0.806509'
                ry='0.797791'
                fill='#3D3C40'
                fillOpacity='0.16'
            />
            <ellipse
                cx='201.438'
                cy='13.8153'
                rx='0.627285'
                ry='0.620504'
                fill='#3D3C40'
                fillOpacity='0.16'
            />
            <rect
                x='186.473'
                y='13.3721'
                width='10.3951'
                height='0.709145'
                rx='0.354572'
                fill='#3D3C40'
                fillOpacity='0.24'
            />
            <rect
                x='220.346'
                y='13.5493'
                width='13.4419'
                height='1.59558'
                rx='0.797791'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <rect
                x='191.133'
                y='15.1445'
                width='15.951'
                height='0.354574'
                rx='0.177287'
                fill='#3D3C40'
                fillOpacity='0.08'
            />
            <ellipse
                cx='187.01'
                cy='15.3224'
                rx='0.537675'
                ry='0.53186'
                fill='#3D3C40'
                fillOpacity='0.16'
            />
            <ellipse
                cx='189.162'
                cy='15.3224'
                rx='0.537673'
                ry='0.53186'
                fill='#3D3C40'
                fillOpacity='0.16'
            />
        </g>
        <rect
            x='158'
            y='9.5'
            width='75'
            height='49'
            stroke='#3F4350'
            strokeOpacity='0.16'
        />
        <g clipPath='url(#clip3)'>
            <path
                d='M195 44C200.799 44 205.5 39.299 205.5 33.5C205.5 27.701 200.799 23 195 23C189.201 23 184.5 27.701 184.5 33.5C184.5 39.299 189.201 44 195 44Z'
                fill='#FFBC1F'
            />
            <path
                d='M199.902 27.1987L192.551 34.7651L190.112 32.2519L187.649 34.7583L192.544 39.7981L192.551 39.7913L192.558 39.7981L202.348 29.7186L199.902 27.1987Z'
                fill='white'
            />
        </g>
        <defs>
            <pattern
                id='pattern0'
                patternContentUnits='objectBoundingBox'
                width='1'
                height='1'
            >
                <use
                    xlinkHref='#image0'
                    transform='scale(0.0121951 0.004)'
                />
            </pattern>
            <pattern
                id='pattern1'
                patternContentUnits='objectBoundingBox'
                width='1'
                height='1'
            >
                <use
                    xlinkHref='#image1'
                    transform='scale(0.00526316 0.00724638)'
                />
            </pattern>
            <pattern
                id='pattern2'
                patternContentUnits='objectBoundingBox'
                width='1'
                height='1'
            >
                <use
                    xlinkHref='#image2'
                    transform='scale(0.00909091 0.015625)'
                />
            </pattern>
            <clipPath id='clip0'>
                <rect
                    width='108.062'
                    height='103.548'
                    fill='white'
                    transform='translate(139.438 76.0088)'
                />
            </clipPath>
            <clipPath id='clip1'>
                <rect
                    width='95.9331'
                    height='70.5007'
                    fill='white'
                    transform='translate(148.259 5.50781)'
                />
            </clipPath>
            <clipPath id='clip2'>
                <rect
                    x='158.5'
                    y='10'
                    width='74'
                    height='48'
                    fill='white'
                />
            </clipPath>
            <clipPath id='clip3'>
                <rect
                    width='21'
                    height='21'
                    fill='white'
                    transform='translate(184.5 23)'
                />
            </clipPath>
            <image
                id='image0'
                width='82'
                height='250'
                xlinkHref='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFIAAAD6CAYAAAAyYxAYAAAdAUlEQVR4Xu2da5PsRpGGSws2YGzuGLPc/WH3//8dILgZe3EYA8ZesMFrbTwZmRVZqSpVdY+mpe7RiXAcnxmNpvUqK69vZk7p/LMJAtMmdzlvkk4gNxKCE8gTyI0Q2Og2p0SeQG6EwEa3OSXyBHIjBDa6zSmRJ5AbIbDRbU6JPIHcCIGNbnNK5AnkRghsdJtTIk8gN0Jgo9ucEnkCuRECG93mlMgTyI0Q2Og2p0SeQG6EwEa3OSXyBHIjBDa6zSmRJ5AbIbDRbU6JPIHcCIGNbnNK5AnkRghsdJtTIk8gN0Jgo9ucEnkCuRECG93mlMgTyI0Q2Og2p0SeQG6EwEa3OSXyBHIjBDa6zSmRJ5AbIbDRbU6JPIHcCIGNbnNK5AnkRghsdJtTIk8gN0Jgo9ucEnkCuRECG93mISVynufvTdP0540wGrrNQwI59OQbX3QCuRGgJ5AnkBshsNFt7lYi53n+Tkrpf6dp+uxaLOZ5/o9pmr649uf9z90tkFs8/DzP304pfTZN0z+eer/DAYmUpJS+NE3Tvy99uOj2zPP8Wkrp062kbu3zHBHIL6WUXp+m6aMrgCyO6jzPbyiQF7+US3/34YC85AFU4v59jfRe8ntGrr13IF85AogAfZdAzvP8nymlP91C941a9rsAcp7n19W6iq4bfTi99jWs8jzPX0kpIcGfjBxVu2ae569O0/Rp72duDuQlILiHeUWOT8eSz/PMdQAnhmqeZwzXN6dp+ssaEEj4NE3v9cA6lNWe5/nHKaUPnuJIP+WBMVDRb7zm5cbPcHOJfAoITkK/P03TByp1vJiPpmn62H1/AZaX7p5kX/MZDwekHscvm8TO8/yDaZre7xzNwomvSd014FzyM4cDMhqT3rHTSIi4+4uoC+d5/mZK6R89CVR/FEN0cRBgYB8SyJokqCH5lh1pd1QB6/+wxhrJkMgoEhHxZXAvD67em7B0YZ31e0RMq8mRwwKpD/CVmrtiMTTuDHG5AvkZsbbqyyIkRD2ogROAkdRR6VNV0w1ZjwwkAM0pJeLl4ngqkIBC9obaDBKZpVCPNKEj/iNgF99XMPn6Gz3XaFRP7gokTnLvyMRj2Dj2SAxHu+bafJUX0vs9o4C1rtsbyB9P0/THoO9EkhqAVYEfjT56YHGfa0HfFcjeg/nvr0Upli1PKX2eUsJdeo+vcWxrVj/qSLtGdSyJ3uyTjn7GQwMZj766Oui1jzT+/hxLO8/z2ymlf07T9D/+eKsuJVaWELHlk25RBz8skGokOPq/jVJhlhQjgiFSg/RxMDiLFFuMxUelbeS6wwCpPiBGIWdnVGdxRBcJBc3m4Ih/wlHUf7+qOg7DYwYoZ82fM+LZFUh1U8jqVCMKlaCFixJ9O/03PiSuEMBlP9LryKcaJVUVuFIL53xvIIfLoSqxHFcMCL5lEcGozuQU4k8KkAaouVAKuBijirooyrt6P/xX759WfVL5XSPn/9bXuAevAl0J8Uj8oiupGmK5+YOzDghIO0kQURlrUtmL69dwOCqQkpU2a9qQQKRDYuB5nnNazfmkoiMb/qjXm0gihupJlcabAtnTUZW6tAFaRCzqBmFYSJ/xH5JnIZ84+M6PNKODs80fLD0GTFJzW9W+bw1kM+EaohuK+tVsi4L49jRNv1YgJBepP8/RFjdIARKdqdLd1G8e+GvV2E2BbH1Ic1UqBqDI0qixALiYpABAgEJP2nH36bXsU6qn0HxR9w5kVVKj3xeiFimIpZQ4suQR0XV/cZYaIE06f5ZSekcl9Vlq4UeRyIKmoscScAv6stexRoByABaJjpqUu5gaCcY9ejJ5yiT4EEBWjjTONdLlfTgkD0ORs9U+Fjfj4nTtIlPkkxXRUdf7ZmAvdYWeDUgN79BlXbdCdR8P7h9EgLDoRv3Bn6aUsMoAihST+X5PjyxOOl/nbzniAeha7N1kvl2ayHhOIHGIyS362HmVaaYWmSOH1c25SnckzZUR0Ax4owIqkCKUeg8km89AtigzJtz9CkLBtYZGft9TfvjSn1XJIzFhtRMkgofBRUGCMBAUoRbMCOc7Un4AHH/sCy5QMEoLysmWBNNddaQC+jX4PGoscEcWiQtvMFRVoCYAXxIZmtDFYhextfqFSP+b5Cj1389irY8AZJGlqUm3SiEWFinleKITAeSP+j1OFP/OZVTzE/W08TtE747Ufi49Yf76mx7t0Q+qEksY94EaG8nkWCFf/UY+ezZmTso58gBr0Y6wdlsUaCMRuLJu1zjWnmN3IBWAb1d8RolqVPK+bnUUZygWTDNvad11FkLCOPv9SnSF5F/N/r05kJaErfF5fBbH3CfVoUYCyBygWH/R+2LpBax5nolm/raSNEZNkG8sCl2jVMD4Qm4C5IhPZkX/SBupuSpKDQQArD1lBiz/txQ4I6OuSliLOKAvoZtc2QvIbia8V09Rl+Xr5oDrAwtJStNobyqr1yqGiyz6qI6+5rqbSGQlBKwyaQPVxCIbST6klAARNwmjQ7gouUhlWAg1OlJQNCH8L42Qru7fGQF2FyBNmlb0Fw/9lq+tWLgXE7FaPfyJZndyDjNS+mIYOprQHXWbdgNy7S1H8r0CL8Up/TlLYPDPf6aUcO5zoWpN/1VOx6ra6amcXR3ykaOi4BXxsW+ti3xJlTCO/4cppZ+nlH7nQtFqVPMUrs8uxmbFd4tdCL1yAIkQYVaY3xkSHVLI0gwQzrp1N/wwpfS+JjKQZvTmJl2xh5HIXt6v17rhj3GF68OLQRp9eg7DhON9dXvyISKbSqUwNxLVOmMbbDJJ/KaUXtXClug5ZZPhR1qJYSHhW/DFbw5kzWio7sMqS87QfyifDF6hq0iXgwJCPE4Cg6MLsFbHEcPjs0ORMz6ScB7V5fIsl1y81bWWYAhJ36E6ivHBXZLB5zbRf0ik7/6qZcaFO7nV89wESJWKVSaDSt9bKaV3Q8K20GeuVr1oZleA+T3wxoWusuKnDvUXXgL0LhJZ8eXo3sKqehYZTva7Wpf5s0Y0WZIUOEkI1yh8oyCEbHo3lG3dd1cgkZxpmv5qDxNCRDMghIgc38g+k9YQb2yCvo3TBKotIQHIqydY7QpkRTJbrRxSxLJ6Tqujy/fTWPFsNDIZleCbSWSt5ePSCKLlW1qHljnU+m/zFTniNcNCYYzyrJQjFGyc9U1np20ukZpQpdbs9V0RTWhWhqNnkUdu3HTgkCESYqmFi8p/5J/4j39SyRQeuQ8Hg9XGG5As0VOlbu3nNwdy9MO2siqtov5aBKRSZqQAJBRdJ9XDivoQwtVIC90lamEXICsJh1w6DYV8HhqJy3VsdYGksKXZcY7u3x0jV4C02NqA7IWiDdCHS7i7AOkeLjdhVjpY+R7xMFGQ9RWS9Qaov1FacHxy1Ii0ybnWEYioAMzXeCHmrGeGxujpGbluVyAdoAUFRXViTjjo0cWJ/r1rAxF3SP8Nbzxyh3p5xqsHNdWAvSmQ0cis+X0tKYgtGmrcMEjZeI1I0NbXPDuQo7qpkfkhM4TTTdhnrNxFh1etjdhJO5JnZAP+/2vPYcFvAWQ3WlAQpaDljAbHXQxKTXI1hkd3yvetJq4uEbqVl4DLY8zdXKbtEUz1HsUL60nwswOpD4nhwNfzCVaxiACgDZme/kfhCz+xVSKwn8UQ8QKE3auO/78oNUzT9Ju1h9cXAYFgk0z5rYCMcS9HTCapNKIRAOKzZQNi+UctgGFcrDSbi/lWGVRJ9rS/Rc/NSNN9Twr9928C5CUfSCW4xmm0egzWnGObSayqGswdkgqjSjvX8nOoCE93efLkqfhMuwPpMj9Zl3odpeWDgk+uYAMmKgCXiPwjz0I8naMWayeJ2fC1WvWocTwUkPqgBb8xGhYFxhf+ZfKUOur8bE4+OGofhuW7ygVqjXUQya5Qswt/dPQ07S6RHYNA+IfjXbB5Q20n99OEl1B0Naj+9F5Bkz9uXkTPuu+qI/WBqjzEta5YK1mozkPiiMGtWUk6Y8OUvh9N0/QH508WoxM7L3Boyt+uQKp+a7UPG7l0MQ/NUZ0BZOHjDc76uV+HPL75eZ5/0ZhTsQDXOdmSBfJFfWs+qrTZcdT5k4cueRLqtcakpytvriNXst/FDCBzg/A3tWZTVA59SOmYas20V6vF+RLC1RqYNwFyZCYuCY3avJ2aTrWRCsrxeSelBM35l63ppQoWakMsfGifg1zA/Mkn9SXeBMjesXAGAUvKNAAGIHGccXtsdKHVXNCRRC1YdEoaJDSsQZ7v4fagQ5uzftTv/Ib6oMPJ290l8gIgM6vWxtdood/H6FbvNoudp+g3RjY8qVth9LPfXCJ7mRX9PuFe0cqhPCIkkawQGXL+X0ByFGib8Owb3S3BsYnktYDdA8g89r9G2Qs0PT/Eo5j8bKXZShdEscjCqYjcTjcqZapPh17AzYEM0Qf6byF9TmfK0gqNo3/q3SYFCH0IHZqcpPXiWHOouD8tVpuCVGSFGpmoauR0qFjbLKjR8TStVh0z48nzLqVmvdo8LEdcBspZXlJrOgBcjZ+jp3BJ+fVQQKq05MSBAmRJ2ua053is9d/ozGYZIbg8pNagP29GGtj7aA9V8jyf0tJqGnMDHlbbZpKby1QAqpVG+hnNJRqaBn2JLt0VyNEPqkcV5hrzIaVdznXOUqqQBRiOhGoTBApWRaV/sTmtavSz2XWHA9K1/eZhSMFAic5TR53P/6EjAQAy/iXukbDXNEtkfYpWB0eXrs4cH21U2hVI39IRohoccuoxwjHXPz49hvQBknwtTE0x/ril1wg5/diui8bTtIY6HcaPdMkIKotidc1f4+8aSV6dcTq8CAH5YwPckVpxzHuccK1WIr2+KFaMa7j0OPvrD3G0ffEqPkxrYIjqSiQUQ4M01njlmbgaj+ro+oFRcA8BZAU8JGUxVaByHW4MDjuAMlxT5gG5sV5IPVLeJZU+tf9mdyBHUmxOHVRb31yJQmo82mKX55ub499SI9GfHZXCXY72SkK32huoD4dTbvMgbciHWea8pVMblpA6+152tjVlhoUmPeeNT64bje5jWAP4ZhK5lvVx7R2LcE4B9fNymUVBIpaJp1Kk0vIshoiXYr02mSgQ3KfNe2xEfVwjxs/1M2FgEoBZd5aEka4lToZr6pElP2mJC7Po+ItkzQsu+3N97kMB6Y+XhnTF2C7nIuGM4yPahCmOPH6nzfqRI7tGwNKShJUduos3Rl7AzSVSAcPv8zu6hJ3r9tJYgtbnI4vB7Aocje7G3MXQsJRtsfLPx9pxpAMlC794YwS02jXPCqS1b6xlWWoNnk76pH7jrLaRo4y2IjVuDQeRTJvMJ+SpxmwhW4YhqsMNG4lTrbprAHex2te+6ZD+WiRi7b6hrycTAXqTpvUlFXXzFvnqEFb7UiBdJ4J3ZeIYbenqSin9MGTP/bo/rxJW9WEtBzD6uZ/1aI9+iNZ1jekBmUVmvqayKsiMU6OWyc/KAvZT/JA6qIOZD1SJlBbDQ0efYVcgg+JfZGesP9uNLiQUZIoKkump0t5y4z9SD/drBTjqAAktGmMkjnsvlTYK4u7uD75ebYKe6+6S5iQX2tkYBouxbRLVf+sR55hLdtyPQXQvAsCRysWOnF4Y2gN1b4lc4+qs8RcBkrBP1uxp+YHsT1GDUcIAVro57rAHkH2/R77aHUhrXu89UKXFzid/rRQbh42s0vhGCfkjsfgRgIwE0eoyxxA+WvOSEU4lqz46OcXRBa3fEWtOe4kMaLpmJtBNgPRLfXqSp7qqKMoHcr40drqKYE502MYmTfIK79za9qypcy2T3ju+h/AjO2m0bGEtqgkOtqXQZB2VRiMAyIB33JksjeoLIrHfrfCHhugnIy87XnMTiVz7YC0Oj1PyfrLKYl6PAgfQqAjKtSQ1cKVohhIKYI37qL/Xq5WCY36pdO4OZA3kFl+nFu65o1vtHazUajJjzbeH+OtqKw96UnpIIPV4N/ut53mWXsWOpOOYY0RsboaVcm2cbDEzowdU7/uHALIxmaU5Vc+OnSPk+y4wACL29jtpqwNCVPKsJ/JJM3mPAiQOdp736PQjVD6JjS077qKUmMAodmh7CVK9+Q0NL/Nwu5BMznygtRHaLd/zJkCucRQVJDtmxcb1QM/LBFVza1yvtuUYczSkYFBuwNe0UoTVcVaJ9+pGQboq9ifqPQtptxd2EyB7+qX1fc9fdMdZ5k2GckOtm1aiGqtLNTom4hA7aX9W2kyzR7L2eW8GZI87PuAiFZNJw9HN61tcHpPMuRXNLJzMWSOTLk+bMSPnFmYM7224JZAXO8OajMCt8d2xfkaQLQqyHm4bwGn7GQxIgEYPY4CE5aYvQnYlNvzMiyb33QzIjsQtWuTi9aHk4KdBS6NTYKZJIcxN88MQWVxuawkubhtZY6gdAsgRHeqa25EyI5zC9TG/kJHZSC/NTh5oyXn6MsJah25PxbQSI4cBUjlAQhqtSKPMkFTJk6GdbuAckpY3LLn1A/nIVqbiY825H+138setB7TJV4SYtUbTQkXp73vtMEA6Nyjzv32zZmU7JzqvmJKiHEjKCcKfDAZJ9ovZ0l6th9v2paKfx9XGZUty4FQuxu8I4CPH6rmuaQxN8lNT8iD2ipQudNw8z5QcfqUrWWQXWBw3ixTGo/0Uj+IQfmRrvLZKZ9EGVxnM/hN/NIP0GSvN5y0BXsZt2/0bO2hFJbS6dVtCtatEdhR7XMCbewqZrqIkfN/suWCfOScelymPZtCQEbCLFFtoivIvsusKHRbIlWgn9yTaEXWGxxi7eVJqYx3VYnCxhrHVAZ6RDBvLxOKLPpf+u+S+l+T/1ErGjLqtZQFI67HxJQgvXXkKlh5xQk5SbDjptpogZ4JG2+oOAaSFZpWVAzXJGeraCovYPJDVTFPUsaOFtEMYm57Uhqz1Yh1qa7OIHkVco7gq2mab1/xDW2RZTAfsfca7ADJIiT9ukv3Rowip1NJoSJuFgmZ9OfZG/5O9YUppicnfPKZWT0jrNFS3xR/maI++eReJ1KRK2o3DeMU8dMSNd1gsWlPw/Abl1sjFKqPt0ECujJhZRBwKRJGXdHPKIRBYXA6RHykWCWemuZKr3k4p/SZEMbWqZeYredVzGCBrWfQKTcVXAH2ng+m+2A1rX8dSA0AezmkujS7VwF2SPvFLToZfcnQYIFuWe+TBfPuwX+DrIyS4k35FtGsMNf3a3M5Zc7ni5zoUkCOgVWJujjkNn8L59rRlP9VPQfXHEuNia1NtDkZzrm6v7fiugKw5x254ks/gFGMcnFWXWrdj9TJESaYPmKXWPRD5a8FzaIaKhwCylgW6RjrDQ1sZwRqb8p4xi6TUhSo2GusUAnRq4YeqTsX1qa64OgqQq/u+1sI0tcxYYEn2OmZFwQe3hG+jPpMJBLFlr+NuZb16CCB70tcCUiVrdtvdbeOSLzUgmdJkHxeuOZBstpo5+hzhqgVv1W3uBUjTbWS9CzcmHGerKhowFL0Y3UBEw9/0LfI3oSOgEQUVjU0qubhWBVmh97LvBciiPc5JkqgEDfkID4k6fOKWqMYsOUfdhhwDLD+bR0G0gNKjXu0i8z9zL0B2N7CHcu1qL6P3WV3TPOFljqNXiLEi5bFId2gga2MMvTSGmDqPhFVdCPUEnTk0lsZcJO8KaceEkLP4um3/rFnuowO5xpGsSqkbEI9elWVBQY8COFa+e6wdqM0ZGybRhwayp+AtH6kGIpNKLTT0BTOt0wAILSQy1SoccbLkSLFw1EcccU//u2sgg8QIYVTBWaS6lF+J820jHISJVhniibRi1fOYxXme/0s7yyRzFF+wRFe9t36E78eYecXC5u2eqt+a/B61xguGm9W41S2yKQPN+rq+uGMxLVYAkqVBNvestYNGjVNejlap/nG0ZduSAoC+zEvWoi6trDYwHlHedWtG6i4kMlrqeZ5JwjKhj0J+7s2uHLkikaFlhkxn8Qw2A9Yv9W3dr+YaHQbIkZxfTWLjBvlgQGyWWk6zBamzSIiMEFgAfB7HPaLWzEs4DJAjH3r0GjdHEkZGzuL4+rk/9kpoxcBErlBeIDTPc6bI1Aj5dwOkGgckJvqFPkERexgJC3HK/c4bM0iEnUVaTE+FDR6hnmOVyKLlOaoEuW70Le99XSu9FY5qbchH7raN+tT367jJ0dzSj5j969qz586LvQHa8vfX+qrjKFmtICJ1jKpBHxo5KxfObDe36tvV/WC2Z+duJLJhaHLWe8V1kqVrlWjFil5SFLO2PM3WW4rNj1C0RAj38wPu5D73DmR1kFw47l6H4keS5CXX6PONhIfvu3q3sHv1BVi0BKhC0nJ94XxNSg93DWRHCpvLI9VxF9fIEfsttwnw71sbsi0Y8oM6rTXaNs/fDZAqAVXOjXPWkSArNbQyQ56VViOmSoyuCQ6+jwRjvWXqfnSP3O++j1i7Z5Dcgt4FCV+Pos0FkuZ49zVbaI7RwXUCLAbVMTbRL6rEOAHo567/EQkmV4lr9elDHe2QJV9sbFJHPWe34xSBoFsBCaOyWENg5WO9npf3xaMBiZTY4ouijWNktAKL3VQ9/HqtyyuQsySsfAggaTaapqnpOGszEkdVIhy1zkWNxsfo+v+e4re41ulHiZQeAsgLdCjxNA52dTJVT2q9ox6d9ZcCJMYGIgFZoKIP27JHGhW9qdlxyFWWKffsjdiygr/JcqIPHxbI3rguF2e32udk9bTG3bwAG4Pje3sAG6P23l0DGUuoNZ9yxWkn+yPrW/SY4jNSdcT1iXxyLLiR9JFCwEQSrU3vvt2fHmdRIxisuJUWAEh2dTs6oPF9/HhFzwVCEj9z+8MAFSAJELJ03pVE1jaA9AxNI9mR5wZZH7c2gsILAhPZEaYRDq13Qpl2KwU58tRvcJMkO3RvQK5OtddoZEEKcEdeWpPVBYojEjnqrX7xTIHRYlmeEG1JjLsCsid9LplQtNh53el8yKKNRAHxY2/wOwkL+VvSapa/1A4Jqo8kPh43+xPTaFbUahzz3EDvs/C2r1s7aCEV4JQTLhpXHV1JWg3SwWNENmuS2iIXqL7DWLzq9j7YuisMTG5BdtfmKVYqwVwn2+0e6mivuDp501K8Rh1x4nJb0SI9OSmld9xIBqFG62ClQj/a/V4KkLV2u7xHR7NCBSnf+ZbQVaBNy1osdZ1itfL1hweyMSkF/YYzbftlfcdDDgONH6TGBknFKednpSzhjNgbdw+k6a8VPpBfN2AZ8DhyRhYMubm9efq+uTfG5g05TyO3fvwIQA6PCrMpLC4stAhGiKQpJUYjvqu6sLq4V4EFaKQ47/u+eyB7vmXPoitfUphu6ifm0dyVxnmbwYYPWZR4XzSQTsfZ7jDb8kkCeLEZWY0SutUWXGaj89BAtmoya8slXXqt6Ak3agqjctyyIkm1PXyGvEb5q/iRHFeTLD9esdoIEGYJ8XPE7m89tESO6E/jZdoMtDBFtfAX1dD45ntpZLobDvkIIFtco1FOXrXq6+Wag/TrpT3Z4P79yFEAe0lgF8n4cNFi71x5VGo0rtInRSZp9IPc+3W+LKHlWZISi66wGom0E8OTPXoZSYtGosKWCjV33lQSGjK+wW2Yp/hFPvKVF29sVqRNenTCoCYZguzqN/y4+J4PBaTG3fh1i/GynQjHLzSXGoz6oH5onU2S9nXuPDnwoYBUg7HWCJofPGTRu/Mh/RTUChf9+w8HZEUfxrSYzCZ34WFrdFf2IeMg5TjtdPcZu7fwBNbcnrW5lWFSoBH2MUx+mxPGh6+9TKvdKIIVu8TC0c87HRqTCk6r3dKVYeudNJW6FTB5Lrrq5e88vI68VH3UVIEyLnDgZcpfbRPJiwXST3j2hkf/X0j97ut5vZUmghdk/5cOZNHE6YCrUmNcl5jNOZdt8/zciwVy9Mjbljsfl9usS1txwNH/f58RJPZm1Ts3AAAAAElFTkSuQmCC'
            />
            <image
                id='image1'
                width='190'
                height='138'
                xlinkHref='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAL4AAACKCAYAAAAUn/AmAAAcQklEQVR4Xu1da3PjNpa9Ni0TJEXKUsvjxOlMJqn+sv//1+xWajeZZDrJdE/belGU5cfWAXBJECIlSi3ZeoBVXd1tgyBxeQDcx7kXZ+QuJ4ETlMDZCY7ZDdlJgBzwHQhOUgIO+Cf52d2gHfAdBk5SAg74J/nZ3aAd8B0GTlICDvgn+dndoB3wHQZOUgIO+Cf52d2gHfAdBk5SAg74J/nZ3aAd8B0GTlICDvgn+dndoB3wHQZOUgIO+Cf52d2gHfAdBk5SAg74J/nZ3aAd8B0GTlICDvgn+dndoB3wHQbWlkCSJL3hcPhl7Rv36AYH/D36GAf0Ki0imh/Q+y68qgP+IX899+4bS8ABf2PRuRvXkAB2CJ+Ixmvcs9OmDvg7Fa/rXEvAAd9BwUlgHyTgVvx9+AruHV5dAg74ry7yg3ogVBT8SVe8tUdEwVZ0+NvbkD5+fCKi2S4l5YC/S+keft+VunkYhrdpmn60hhcT0ehQhuyAfyhfar/e85yInnf8Sjt9hgP+jr+e675SAk1A3dEq1k4CZQ74DpmNJLAGTaFF3W5Id3foF7ZBFXDbWoffCaibDMgBv4mUjrMNAkrrGJAAa5MAlPCT5P1sOPzfSnWo2+3Qw4OgyeSvtxSrA/5bSv8tnx3HfRqNBlvm3HhCiPdZln0yPEFVak0TVWen0nHA36l4j6BzrNB3d/DWLBqz1a5HQUSZMXLo6phga19RFN1MJhOwQL9WJVrY3Rzw1/4cR31DlfpjMzGxqv89y7L/05LYePXWdgMmSXWcQO1Kn2skjvfCtXpSRNENTSbYhfLJ64B/1Dhee3DsSVkVtLJXdYAfQazVIFzvlZbRn/Gus263698FwZw+flwVZCs92QF/vQ9xCq1DIgKQqw1ZqD5PTx6VE1EQvAJIoZZgUjzU+PnR91oAbSBwPBeR3rq4QuWO5IDfQLJH1AQAhWqx3sp8fd2mT58AWIALQMPqburxpogAblw2wHEPPEPQ982VvOvH8fVsNPp5J0GxMPyW0hST2IwqtxzwjwjVDYayGfDLQFWPwcqP6+6u1nDVxqnptlQrvjKY7fswMbA686Tcpvq0YA844DdAy0k1Ka/u1UMv1J0RXV/7NJ0GNB7DeCzUCgXu5yAIrqbT6b/kah4E72k6/b2y0yTp0fOzFz4/t9I0RV9QmVh9UrcoI3UT/z/6gjqU73QO+MeN6k1WTazKAMiclJoAoEn9WQjxQ5ZlvwKQSZLEQ897ors7qDRSx9a/B3kN92NHwN9NmJYtSpKYhsN7wJuIJk3UHk2W+1O2VRMWzzODcrWuVAf84wb+KtXGI9//kWYzgGfRmF2MskJHl7q7EOIfWZb927pvlWvTpyi6slZtuFAvlzE7LZWpzkBu7t4kcgc8Hzfutz66kMKwo41FrK7svWlCZzAB26Iw7FOa/tHwDU1juIlnqKuN6FoGqVvxG0r+1JrpVbYU9JEyQLR2PBY0HMKrU+X29CmOY02HwO9Z9ZBqR7fb7dwtMYgtOe+G7tDtdhzwTw3R9eMtVAXbV9/vxzSZdGoNU/QJ4xSX8u8DsFBf8HfZrbkYjeWJshihLbw/ZmwA/z5PkkTIolaqP7YzeJLZOwpHpD3qdtuwSxzwTwD47Xb7eqy8LssuCagacll1UCpJeuHjo0jTlMGujNkouiZwbDqdNg0GsB3Ym7JMTfGCIPh2qr0+ms4AI3emjWy4P2ftdrunx8LRYzVho6hn2Q7FblFMDkwQ+XMH/BMAPhE10YtrJREEwXsGpG6UB7F83/8wm83gorzQhm5IcRxqjo2Zs2tPLPN5LekWVUEydj3i7yo+/zLj1lStln1ZzwH/NIBvjxL6NtyMWI1t0tmiRMreHagNz8YKmxueeoJgZ2GVA+B90f9HgOqF4rinVRNTBVK/U27TBZ/7kk9kumvZJWrX9ESbMEmSy+FwiOit3H0c8E8M+NpoBQBM4LXa7fbVEnVIUJKEUn8X4gfKsj8pDN/R83OLsuzXmj4LyUL/Z26Pig3c5f2hFVQRITL69AkTUQghbrI4/o/+f/0XUv2a7E62U0zujkdB8C1Np5gQaCs9PQ74Jwb8UnS1PPZchYjjuD9SBqM5OXJGJgJHuBURVtHpvM8GAwS1Lun6+oI+fQKdwfMfH28M/o3tnWmRELeUZb9pIOL3uABKTkuE+nOeg18FqMY6aIVdBSs32ppBKyasXcODFARBfzqdIgCnVKDb2zC8v79ChQgH/NMDft2IzVIiADlFUXQ1mUwQ3LIvE8is6jA57ZmEuJG7ggIl+9JviGjRPYqeoUplWay9RvDBY+U3V+2YwrCt/f5NUyZ5l8LuxqQ6/I37nVfn1HC/xMMDsAMUTB4LKQh6pFZMXHnRV6nLd7tfwIEPguD76cXFVMznUVas4GjvkRDfUZb9s+aZPGF4lVb31DNH6wCPCcdMUfRl5xGbu0n+TLfinxryTSLZ8rErI5avOO4YnhoviqLORGU1wV/PujVWV6gfCsC3txQNBrGRPiiLTkmbAP1OJgOt67Oe3ici5c/HLvD4qPodjWAH4G+0Z04Pv5ukZQghbjOMrcgMw51mPAETIqdFO+CfHvDViFVwCICTum97OIxKxi2M2MvLkTRKTVak8ol/oTC8IeW/xwVQAbQziqKQJhPO0YWqgxUZ/z+Pouh6otiVrCq1KUkuyfC2aK8OgxbgzoznYyIIP45vZ6MRyHAmxz6kdjvSLFG1eyijlu2BEn3BAf84gF/HwlyWnWQWbMIKjbal5JJcRVGTBOBWIMQVhhNK04g8b649NiFFESK8nymK+jLHNUmu6PHR19yeFyHEuywI7jUXX4FfUZVhRMtJJDqdn7L5fEq+ny7j+uvPhkkFW0BQv/9Mnz9jImAcALms5SkZo/qZ8t/t9pcwTWMH/OMAvumXN0dUUIzVT6GiYNWtMlj5PjNKqzw9asXnagcSsFK3n05/M1ZjqEYxJcmzlZZovo/JoDSTUsxAlZoQBrUBUdzn52dvPB6DFCczuKRqk2XYPThwxruINI6jKHo3mUzupWs0y5gqzYE3l4F1HLhfaxR2ori8Gauh53mZVkVYFQLIMFn6Wp8v1IX6DKy8eKzU5c/Onun8/Inm85C5PhZRrUO3t3myuKYqjKiwKfB6vDuRnyQ/zIZDVHhQNgjHFwoRSBenH8c/aHcqfrPA0nQr/lqYOerG5zqqymSx3K+f+85hWOJSQSPo71hllWqhPECgLvDK6/m+/+PM97+gfRRF8SQIUqgZqec9aC/Qn9TtCj9Nv5ldXNxrro2pguF5EwqCW3iXwjC8Nqo0q10ujoW0ORjcRbBMvUdhyzBfCBP5nQP+UWN5vcFVuh2hcry8nNN4jKQTVRdzPr/URiQbkCPR6bzLBoNfgiC4nU6nUC08TWuAIdwXz88i6/X+ovt78PlNHj7sCwZ7OYFdqVjIynrM23S7vs76YiCXdxirfo7hccKqL334kIoD/nrYOMbWXhiGNxX17u2xAsgwWuE6vGK9WU+W/xg++HMhxPe6jCD64OivDIpJnbswcE274uKy3f7+YTxGtQUOXim7Qa3m7EGCDo/JAjXMJqUtGvNFSiJ+N6Uw/BsmngP+MUJ5cUy5UVlzqAOnFJZ1Yay40M8L+oJpeCLP9YE+fTpjF2a3221ZSSZm5hT+HVO3izzdEbXb7wzXY0hJguSWEd3etuijPHOirv4OjwXgx6V2iWJ3KAhy7XZM4zF2DEzaDjxO4urqfXZ//5sD/ikAH6C4vMxq3IMKzP1+HEwmnZx+bPr56ycS7AAAUK3GcE0KMcqfo8AIYA5yTr1yeZq+fDyfKcg+hWFPJ7ibUdzzMAy/0dUXys8s3s2kUUjDN4qi3kTFFMxJhISZkQP+KQB/ebSWqyEAHIoX//jooTSIXk0Byol2gyIYdCY6nb+/vLx4s+HwVyt3NqRut2VMMHPFr5N0VQI6wM3PV9ldsDNgxPb7kfbXl/rTFR5UlWYVG/io35mzsxT4dVaXA/5pAH+dUZarFSgvyb32rABYj34cf5iNRr/YvBhNTwYbASQzCXo/ST7MiL50Pe/prlx1mekE/LyiwhsM6ouLubVD2QntdlYYq0tQbVhlwzNiCgImwCkK9Gj02QF/HUjsf9umzEXTT181KnvlNttgh1BUB500EgTBjVSRlAfojMZjGLscLwCX54G63Th6eBB5nCBJeuLhoaONZK6iJkucGAazaXPIZHXDRkGwrEW+DztDlUZhOoUCPu8kXygIbjiGoPseOuDvP5ibv6FK8oC+DVBiJV2WimcWWzIZjEDe32g8hmrA/HdEekUURclkMhlKnzxTEhTPBs9SaYPKiGT6sXkSoqlSFWNS74zYgVnPc1mqpG0wsweIM8n+aLfbseQdsU//wweffv4ZMskj2Q74zWF1aC2bpPAJUp4PrODYLQDAMugKYKrxq6RuBvaqyQXXJgpP4VggXJweqJLI+Wf1VGQzR6BO/pwHgAmA3QUTkFmY+N2MhPi7Zm1iIqKd4+MfGpo3ft8k6QXzeTRttSZLuDRmRWN+FE8ETAyVWKL1ftHp/JANBthhqk5M4ZXZTloB+ABO5YaEsel5kmAmhPgpQ7AqyxDgglcGVInltTKrC9Ci5/IuZgnOrfgbI+lgbyxzdTqdLg0G8ohCrbJgRcQFPZkjsx91UIrJXqzCoC+uk5lpX7wZaJpr2rGdAF4IL4puxNMTklhgLGPiseqicm9VrU5cMgC2pDy5/UGqVSvdygH/YPG7tRc3VRtO+0M0t5emqSrIqgCpqM9JEvpEvdlw+HuSJKEs6oSft9s96XYZj4e1hVurC7vyhKuq2W9OUjNTq6qw7EKBWGnIIok9TTltMReaA/7W8HOwHVVXFC4MZTNvFis9pyBiNe+YapP2pWOyFOl/1TtKVU3LZSepKF8+Jpny0WOy1Z+ssnhgnVK31MSTdAcH/IPF69ovXq0qLI/Q5n5v+2ng47+8vLQMwxVNitNQ1ImIeTkP/LJUHU1NIDM/1gY+JmT1aYvFy5TyDYzCV3ZVB74j/7kD/tr42d8boij6ZkmSCSdh1B3hYw6sMqNLJp8IMRTTKUhqXBpElSIvVz/mbCxOXuEglYwCmwayQVeoEizu49TFql2Cq7YVtOTlnyd3hTrg7y+ON3mzVaUC61IUi2clSe/y+fnm4fn53qAP8+rMAM4rLshUwcHgY54QonYQVo8wyZh+wBXVqozQuuOEmBG67KzbVTtD4ZUS4hsUwMILOOBvAq8DvUeu2OfnDyCJmeX+9L/hNjTPn8pXWOMkFFZnMAGYFgxgjfUEYM8Mcme/zwaDP3UeLlIGoZPbpT82kWST+AT3C2O8ZIfwLxzwNxH9ft/Tonb7yqD8mm9r6tF1ejC3B4uR3ZB1ZDOmBQDUZsUD9LGqf1uKTdsvS6Av+tSV1+o+lQP+foN407drwops2jf6YkpC9T1Fup/JtCyAbNfEh+E7nZosTrpst//r4fz8L6sWZp3eX3Z9LnpxeGcyk2Dc4W9Nv/gJteMy3WNN200NY9U+hlOBSvHqB9Tt+jn5TFEDfpf18XHVR12rDO1YJ7TY+nypoK11wBx/olW7Bccn5ISBf9+t+CeE7iVDNct0s1/fBpPfbreT8Xg80iQwMDBhB0DHR9vi8Di1AuNxtWfg1tTsr6oAYdMoVoG8yRc9d8BvIqbjaQPXIwxNGJmc7VQ+gM1keBYemlQHkKDHw6OD5O86t6gvhPjO8u8Xxia7JxePBPoaKXNWlm1n1PbpgP814j6ke/v92B+NbmazGdx5VfSAOn0aP8/dl3mj8vE6/OMqNmU5saVGZjW5wOtIeLWr1ujNAX8d0R5+W1uVKA58qBmbdHW2WikNh7KC2cJKr7wnuBuG5GUQBNfT6RRqkDQsdeLHVKtCmEBQXaroBpWFrtYQ+bKjhha6ccBfQ7J72xTgm81QfLWeBckvv0gUW9SZlbrDKhAHgMyTBNngnMhzb5XCfpamKVQNqW7kNXqKrChMGtgETXebbYi7NqDngL8N8b59H8182+o961UP5ZY0k0SqR4Z2T08teG3yKmuLBzbbObJcx54DY41UoK8SbXkCl7pywP8qyR7IzeYZVM1fuSs6natsMEBEF6qJCVyzJHfdqloXYWWjmrO9qjw/qnRgRc3L5q+/vKUD/rYkud/9bBrQsrOnnuj2VtjBJz10mfFk1MAnSQNWpUpscJunIS5KTk3U/ITCJaLd2LXpgL/fgN3l29n+cQ5iYZLA3akM0Iooq0FHMD0pADMOejDLhNcBczn3vuGoNT/oX5twgBzwGwr5BJqZ1ASzupmiBsex0slR9ht1doozaaHq4BTzLrVaj6ViT0UcoMTL3wdZOuDvw1fYv3dQRDfPe6TBoIjIqvec6/o1nDBuGqs2pwe6+ouRd7uxarJtETngb1uih9KfWc8G6sx8Xpwpq3zt8igdORyV7ndPYRhTmg4ojkMa4UQ2mQC+YJzWJsRUVETwff/DmkG1rUjYAX8rYjz4Tlq6Xg5UmFrOvMnhl6v+4yMMXRwGsanxrHJpLy/nVfUwdylVB/xdSveN+q5M+l58FzvEX9TNWeSyF7m0qlgTdgKuW+MFQfDNdDqFkYmzsd5PF5PBl9EJsGvwOVavJjEH/FcT9Ss/qJpLY75E5UmHsoG6FxFWqDGCrq8v5AmHOABOVVJTRZ7UBIGOzxlZdYPskBA4vRy7g7IJ+v2Ynp7OG5xsyH1u1T5wwH9lPB7g41TOrDpkDXq9rK0j6RHNAmOcr/s1XByPTzLZlvwc8LclyUPsxwCuph7wMaBVFQ14hHn9SWvIPX3aCWwEUJ+5D5u6YO4U9bVxdixPB/wdC3ivuy+v2FzKAyrOKkDm3CA9Ye71qeJgZfJBbssSy5fzdFbky25Dpg7425DicfYBcNaVGe/4cXyjz5Hls6jsMt/4P/9smdenjsO/UxanA/5xgrbJqGxPS9l3T4R68++zy8uRpjtjJccqjvo4j/IM29kMJxQWV+Gnh12A5G5e9VfV+/ka/b/JWBfaOOBvJLaDvMku2Wfy6zGgqhLhmBzQ6TlIxYCG/s58m5k+Aohr5qMvlCYxj+SRJ6cb1dekAPOirp8/N04Z3JbkHfC3Jcl976d8TE7d29ouww51UaCAiO7u+PgfmXiCyWAVmlrss752vWrbnIW5dek64G9dpAfboVJtsoxr4NsDafm+/9NsNvtv/QtWlVpJkoghEljiOBbzOWrdc017W7cvlQoxDGHsIAhibaPSWqMP4IDfSEwn1Air9GwWGqmHdYNntyaD2zRkTa+QnR1WV0IEtsMyN+pWP4ID/lbFeXCdVVEJVLEndYgb694Ask9JEpl5vXlebXHCIQTQoTDExPm3rFuJq1lSyasKzwH/VcW9Jw8rauJzfXmbeowXZX2/aoXmVZ6LT6lS4YX7ko8Ksm0GVqdYFXozgTjgv5no3+bBeXK4evwmvnJPuzLB1xlRFN3QZPJkZV7ZHiRzAoTaJrArQtj2wE4niQP+2+DvLZ9a5zPnamSYDIotyaeaF7q3GXFloLKPPj9szUgJRNJKzyC8yXFLBqfnzUoVnRcrItST6LYgPQf8LQjxSLrgQrDQ69k4VSt14XaE8Qn/Jiok8IX/4+fs7sTPecWvig3shbgc8PfiM7zpS7So2w3XoAebL8urfhXtoHpQy337mye0rClCB/w1BXaEzU2VgnXx+sQRqCS+n9LjY8t/eLiazWbw+2ftdvvdeDyWtQRXXKxqVRHV+tZusqqvjX/vgL+x6I7uRrMOPv4NdaXwx5erGyuXZ1Ex2acguJZpiMYpinEc90cXF/Oa3QQqUlHG5JXF6YD/ygJ/g8dtUqpPrfwA8dOTZ/jubW9NPhydcsiVF7icCLs164bN6YuvFrjiF3HAfwMkvvIjbdblqsfbBz3ISaA9Nfcy2URPBiHEj5qeAOCWffaKU486+mZSSulcWvNQCU10UymNr3A54L+CkPf5EUKIn7IsQ+YVqzUtSpK4ovIyA7vKpVk1RLQTQohr45AIk75gB7eq3KxmYautitEBf6viPMjObMAtqkZKb8fEqAp4oT1WfJ9ub4k+fgRYzUhwlaemsAkKkVUlk28919apOgeJ0Td9abMMSGH8Fj5+6P84AIJdmzxRZM6ttgFQZaH6apa4vjUBuBV/a6I8/I6SJOlJenFBD1aenutrP5xMkjRNh7ocIPR2rOp1MYCqEuH42ZyiqL/kNMQqIW61rIhb8Q8fp1sbgTzxXBeE0hx5pA0C2KAhcFQWz2OfP36PFb3s9lSr9iAMw5s0TZGB9aSPBjJXeo4QNzNkd7QTuBV/a/A56I7MVdX20detwljB7WoMZgAMEwYTx6QyNBFSrcu0yc1N2zjgN5XUcbUDQNkorauksGzE8NbcGNlaXJoEublNPDF2gMyj6+uAPn0akyKrYTfYqW/fAf+4AN10NFwk9osQ4vuaM2mr+TeF6iG9NaVCsurpHd/3r40KyHwaoVkjH6s6V1rmCegysJp+Pddu6xJAgAl/wL7Eqox/A5BQaXgFjqnbPTciuvDa4PdRyWcPisPLyxmNx+pkxLpV/I0Szt2Kv3Xs7EWH26QChBQEPV0OHIOTKYjh46NI0xQENVwtiuMOjUZMVwbZDGoPJg8MYfb/s/7OqtarJZfbX8UBfy9wuvWX2ISf0+glZEmRs7MnUoc+m1lU/Ez8bfL5Q+p2+QA45u6sPFi6oa3Q6J2rGjngbyy6k77R9q2DaQmwz+TpKe32PR84rWvvgK5c8gBZ3JyqCC2qMnds6kSFTbHRh3DA30hsR3RT9anoWLVN12RZJcFBb4MBVBnT82KS4Zq4RFcJEa5QjieYbbdyBq4D/irxH//vq0CqdHRFVoM3Rq7WOrJrnz/rUbvd0/mzDH5MCLNo7N5J0QF/7z7JXr2QXezVPN0cL3pO/X5Enz/DaGXDFl4e4AreII7+qiAWTkGZTkOLsrCVFXxdqTngryuxw2+f177cwlCwwpvJ5+d+kvw0Gw5RN4dZmSg9cpXr6iqTC7sG1CePhPiOsuyfW3iXtbpwwF9LXEfYWB3lWc+aLA8ZQacXzb9BdNWmKZsMTuwOHJxCO6z6uGLR6Vxng8Evu47OLvtaDvhHiOWvHBKX/y4OaXt4aCWyEuAQBi0MzoUL3huoPlmW/WGcYuhRHHeNFZ7vW5WS+JVDWH27A/5qGZ1aCz7aE6s0QM76ehUpDT/DhdU8pjj26exMTZiyj79OhlCVoHrZVdXQ3qzNAw/TJlXfar+dA/6pwXpxvHbdS25Rxam3/fey+loYhrGO4prGcPnQN1ATPO+J7u6g/pgFqaq/gCpNCHVqseLDYhL82l/RAX9tkR3dDXWnGC6eVqi4O4sHwxV2AheR9SgIvrVsBzPflld0JqqtK1S7r3Xvl9uYu05TAlUrOktC6eZQW4bDqiN9qqod265OTlo3M7rQ/04yqtb9hA7460rseNrDDQm9uapEOEYpdI186N9o10IKoqQiPD21FtIHC5YlVBNVdFadn2X6+H2Koqs1Uw93InEH/J2I9ag6zcuKBEHwzXQ6RSkSGL12ogirQXX1L+2aOkrdqZgIul4PXKxbNWjNr+KAf1QY3fJgEGn9/BlAZq9LWU1R2VJfcPaVT9SbjUb/kx/4vGgLlN2ky19158Vj/x9IvBdOkaLhxQAAAABJRU5ErkJggg=='
            />
            <image
                id='image2'
                width='110'
                height='64'
                xlinkHref='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG4AAABACAYAAAD7/UK9AAAPMklEQVR4Xu2dCZMlRRWFMwUUUFZBNkElCPn/v8YAiUFgRMYZ2WYcAZE0voxzM25l5VL1uvrFNPM6gnC6X72qzLuce+6SZQyXnxspgXgjV31ZdIgppV+EEJ6IMf53Jo+U0q9CCH+MMX4wu/by+fVKAMU9HUJIMcbvr/dRl7sfKYELVB4pzTPe66K4Mwr7yEetFJdS+kMI4W6M8eGRD7rc61gJtBT3XIzx/rGPudztaAlshkrYZ4zxp9kCUkpPhBB+F2P8x+zay+enS2CT4qSMd0IIn2xR3unLuXxzqwSy4rZ4U0rp9yGEO1vyva0Pv1x3ugRMcSjlyxACSfhrMcbbp9/y8s1zSGArVL4cY0SxzZ+U0qsxxrvnWPCj+Iw91aej1r9VcU/HGL8bKO6FGOM3Ry3qpt0npfQSaBVjfHCutbfSgdeUx00Z5LkWefRzRLbY5xc9spVSelbKmNZwj17flvu1FPdIL3jLpmbXSHEvxRjvDVDklRDCd+f0otm6/ectxT0VQng7xnhrsKn3lBo8kta4RwA39dpNMa7e3Jb04aYK5Kas+yTFNRRJny5cWkPnUzv9uGfrgnJK6aleoi3qi5IyeSExf9zzvpTScyEE5HjnXKpDcX+qS1kppTeoNaaUXg4hfO2ZlwI79H+V16WUXgghoPQc9OmYX7xwqcqjwswQKlHcKPGexT61iD77OdQ3ZZT/uwrLVIrx+oj4bfXYoriUEvT3+8e9pdMKHUIP0ISW1yNRDgQqF+Uq4TVwt4DClNJvlJA2Z1OIiyEEoPFs1YORdbLe2VpAhBjjJ3Yf7eG9GONftlr+0ddtlWMrj6OfRu+tmaP14paGjlDc7tLX0VUKa0PFGD/eK9gJMWOwChJSG/W7Hv4EqyTvuwewJAtKjN3acGbwggG8hYoJY3qjYjLX4KHFSluCkddyXTeJ99+7ykb3KuYq18sbUFwxThkJCFVquTJi4mEx/qNIia3fFAd7fDWEAJF4qMVA87sKehxmU/ay4om3vkHr7BQvbBkbMY7hoM+xDrkpSsTruu6aUqJAe//nNlDk2zOSBd7VrWc2WDWlQIx/BZGHe5zYJAm15V4LHDdlejal/O5h3eppLU6wQczMU2N7rfgq0Lb3u5IF5OrJGbHZe+8JkVoVQWb3b+ZxjerIqJKS2WQI4T8hBPK+RUPVsySNsL8bQvjgKrnd3vyyJ4TWFLfCxCu+CnLdA1Cn7MdiHPHtW5ETYhwlHEYYPmrAAfnMT5bvSTGQGh+c+T5KHJKYmVWNBD5q7M6s2/psNRpMvjedchPJIoSUXmbtBKfuuf4eMQ5FwH7A5bdCCLd5sA+0KaW3Qwj/1IabDdajMfyoDTYMD4SA8R3SKE4pvWkNWZ8XWkholAF5Pon8kO673LJpMHboA8UBd+Qeqw2ZUgR1PNTiIUTm3wTjlNKfQwgfbRGIvLQrvFYc3Fs+O/owi2I9e7/jcy3iYk1gjJWLqCzk2UopJp4O8q2K1waVeBSKI/n+m/K7H1wHgL+/Uye0KSXi1d+lOOjuvdH4ni06hPB8jPGzARTmIneV6w3nXhqeBclaFAREqpjSHhkNHoQxdgsJrfBwXQjRu68pDqXhdWyWWEWMgjX6BHI1mi5BwEinbi9vzc87NT7tEU6NDmK07Iv9YajMm6zOR1hMkiwYADqky390KDHFURHJMEntEouTIinllEOMyt/4DAWTTHL9pn5ep3100nSYkYBSRTggXqWUqFEWMiY4hIRl0tVJdYhXVIg+H8VSGdGLFVNFhgXV9hhlNn4tykMeo2a/lWKKJ9mAjTxmmJRKsNlj+XcPdnqV+NkmxHoRKDEW2NucJDcEjNFmpBkVFFCsJrnvK98DcpEfxWyL+YVIKCbj1b2iPEUMZJQP2IyqLi15QE7YPHDAwjMsePIghWFVXwxiUlF8QzC0i+IpA7OzZF3zjNx7CtWDteM1LHARFkIIkI6PrZpSx8XaA+tcby80enY6M9y83i3JnywcBTebotoc5GERM+R5WNxuSNhSJde6OMO+yp0G85J4Vy4At+KgDNdT/EVOmlKiEboyYutw1EYwo/VblNTzuEXfSjHua40gFEUIHr7RhrFSEuxMUy1hZ5BWNU77e7Fm6PmMlFh83VMD7VTimzOREq4RkxVrnHmJvOqZuhym/ZMPA5lPhhB+KWPyXgzrfgA0CuVyGnWy4hrQhmexqe4Zt1NKQBIapbOWwCzOZFK0JRfcs2FBP8+mKtQ1IJ/eOE9BIYSKTFy2VEIs7agZqcuHkTEolJvOW+5Z79fICdBAjPuyhdXK74Ak8q/u4Q59l67ysA/nqjXGZHM1Q8G+ZdEIbwGHI8XVsdErrvU9V+Uow00waCXbuVdpBmcpEOvZUwGZrBdFkm5tLhH6PA7qC+6TbLMBrJNFM7JAXDA3529v1g8Ri7KjWkAE0JBpcu1Bghbuu0rY5ZkosXjeFph1HgIrZrx8UxNXFs+kG2f/mufeJQcfGjBiZFdQyYaJgMlGhzwfY/P33+plPfiGnCwq/7Io/kZpZzXGMGJ6Ru+tPKSYhzdThM7WNBtTcKdf6RGWGADrIl+aHenyJagJPLMu4Oqe8lNKU0B1hnOXKxKv7CAMxoz384MBl+Eq3QODI03hOx4KV0V33acU6wesF6WDTIuUpyhON/q1TuosqgXOC37EymSdJN9sHiJjkIflUqT2Qbl4sBTHxjeNufm5zpTS+xQDBlNY74cQ/trw7mZLSowye7X+DargcRYLITjEY9ZLDKZHd0vex1Zy2Uy/v6jfCTVca/OoDyz57jWeZ57Xq+t6qORhX7lKAWUwD5+8fagumGINxDy6Crxio7ytwSfhW4iELBYD8PMcxStm9xgxwposjHKmXsGgNQwlJVFpQga5yuInuyV0vJW660p+zpAJJ7uGrExxHMy3dg6xB4iiUoDnELcW08wNJsrigAksluoBlrZoR5jl8C6wEMK/XLDv9rk2kIpMWiyOSiHce0GzVfXgxQNWYMjeVCED+8YwUUQe5XBxE6iD5r+uqe86Xy25oZSx+H1mdKd87gdiWThQCXZb7Q2YYxF89gydg4bXLSr5VR+vsEF5FEaAYIpwVf34UflNtwLTYYPAEs/AWhE08zPEGLzfx8fFfWUQi6Nk8igMcFVkEJnCMInVq3fA6HM8yug9BAmScm1nCRajCw0vQWmUfm7bCJ0UWcb4asanJBrII9Ek2UXhpU83GjSaJcAzy/TfF4xZ7K29nzCAFxHPSvsIBWjdzcOdUnizqOzX1ioKOGJGsXlVlG6gGM6CnJsQWl6XoYpHq82B15VZElkXVH/RNLVz0PJYIIXPbXJska9tSbB9aUmv6ih02rWIEHzzLUg20OSLwA76IFEorFmKMw9TSlQqS5YqKa+leJ7H0TXlDUHJrxMxhtlosG6e9p41m01xZbJL8QAh+c5AYWZSEHQXaCqxT/HFknPg89PKClk0UEZasGhk1qPgEkbp/3liIOFhjcBSmbjusTP93ei5HQ3LibbuhRJhl4vkV99jzW9VU8orlirvhkgRG3u54CiW4/0FamfIkmN6JVzrFID1xAoCOJBHjCissRIksAL+IxzqbzXzzEHfEnpZJAtdXGuCGrRBct9voCCMjy79hw3YyWUrrRMF8W/SGNIbS0/I3UpvUaEB5KCg/DwzN1L2SecBaxnWRr21YVum5mR1eIi5PVYGPGYYkaCAAe9dCAmosGJytiZ5K8q+a28iwivU1um+bkMeRkDHkPBGhJjfXKtYVAqygknizOrUzKzCYjFMz+P+/oAm+y4v56ni5aK+CYxLPq0zgsgmz5FKHrdMjvrfzXlsh5Blstg69GHMLE8qC79XZZyGpxLwgS/KTZ9aNyGEgNK/rVhe7i5og54cFIOQheIV3BeLL8m1PoP97RorcFWP/AYlsdFsKFJmmQAbVTZqFlnJAgSynK4Fq+zxyuMbrZIXlkhaAO77WcluMjyAL74DjGKBXkF2yKScaHGBH0UTK1cDPZZqbGGfrSTbhnwUn1sFBfI7utLNWZRGGOB6lHRyI3dLPGtdU8c4H4/yYI3rv2Ep1PLwFOJYVjBBvVU/dC2MAh2OEmMQwCBJPlACUeB+xEmgBHIEOytwZkeYtQk8BLbXahEZ8VgM7ja8wgoFGBEUHXhfvZzH1SyRB0ZVxhFqgzV4byGBZ6odCNw1b+mPWSEkFGI1OCg/SSxwZQdDELC1YIAEiqwImNIXjKqwtpqNOSqe30Cr31f9OVhrjPErKRmlL+b41YUgvuXKvFXu5UUgBdczcoBh4BHeCHKXXt6I4j/U91k/pAUFUm/0hQM+M5JmuR/XrKojCg+L3HCrR+l+q7N3ve8DlSwmF4urKSQUyeJawq1LPItA74I/SkaZKLmM+4k+YxSZziuO8jsWzY81VP0MTPO0q/PEDG+qF7IfhOCntoiVmdQoRvLs1Yi91l6ORMmLcjys2jKQKdbMGvPQkhADQxkSsa3KHF1XEvDeBLMxr8oK2RgxcDVdJSXkjF+eiBJQCLCLh+AJ5E4l57HCrhuYRSDZ01w+lam5YNXPjWR4k5GBFnWd0jdHc1ojw1j9fy3MWk4diMutL4dUo3ztpHHEZowbDQv5Me6KSrfGrstZ8kbpzEMMcZROei77CPqg+wsjcF5po+25CuMavAgI6M7Ppe2jWmqtOKCOH1IXK2UBl3kPeo7FuzyrIkPz0L9SxqCLsGqaujDRPfW01wtXrNI9pDXo2q16C98Lw5JAmM+0fp2HvcU4XMeS8SR+iEvWhF29vsNqksr3QAGUsni/iu+9uf3lkXmRpELPXXee8pXF7HL4U8aGlzXJ0VYFqCRXUpGt37PreufjiAeLUo8WXCaeO8L2pbEs5KvOPo7eXGSDsY2hHH8YhTVnj/JrduN0uZ+2NyeUPFYVoI5cpke0jlJcrp40Tpz6+iEC4b/S11I8wlOJTcST3AaqTrdAHHxbJ3uxLN/iGoLnJ1dr7P2SDl4xLLwZ9odHZ+LgOwIenuoZGZd60GPjPpS1ciriKkiLDoH2szhvwBuY5LXIa0HiqsoPCJDz2FMm5Joxbo+mRaN/sHMDWkg5BiRywWag60a9c3wTq6RDXMOYJeO0f6gHGjzxd/I8Yo0vgVndkWEg4BfUIA5yxgHvAa6bk2giTlyDUS4YpdZezq3V3twyCmccQOdiOq3UFNtN5St74P8BxqesAO6EuqQAAAAASUVORK5CYII='
            />
        </defs>
    </svg>
);

export default SystemRolesSVG;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useState} from 'react';
import {FormattedMessage, useIntl} from 'react-intl';
import {useDispatch, useSelector} from 'react-redux';

import {savePreferences} from 'mattermost-redux/actions/preferences';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {PreferenceType} from '@mattermost/types/preferences';
import {makeGetCategory} from 'mattermost-redux/selectors/entities/preferences';

import AlertBanner from 'components/alert_banner';
import LoadingWrapper from 'components/widgets/loading/loading_wrapper';
import FormattedMarkdownMessage from 'components/formatted_markdown_message';

import {format} from 'utils/markdown';

import {LicenseLinks, Preferences, Unique} from 'utils/constants';

import {GlobalState} from 'types/store';
import store from 'stores/redux_store.jsx';

interface TrialBannerProps {
    isDisabled: boolean;
    gettingTrialError: string | null;
    gettingTrialResponseCode: number | null;
    requestLicense: (e?: React.MouseEvent<HTMLButtonElement>, reload?: boolean) => Promise<void>;
    gettingTrial: boolean;
    enterpriseReady: boolean;
    upgradingPercentage: number;
    handleUpgrade: () => Promise<void>;
    upgradeError: string | null;
    restartError: string | null;

    handleRestart: () => Promise<void>;

    openEEModal: () => void;

    restarting: boolean;
}

export const EmbargoedEntityTrialError = () => {
    return (
        <FormattedMessage
            id='admin.license.trial-request.embargoed'
            defaultMessage='We were unable to process the request due to limitations for embargoed countries. <link>Learn more in our documentation</link>, or reach out to legal@mattermost.com for questions around export limitations.'
            values={{
                link: (text: string) => (
                    <a href={LicenseLinks.EMBARGOED_COUNTRIES}>
                        {text}
                    </a>
                ),
            }}
        />
    );
};

enum TrialLoadStatus {
    NotStarted = 'NOT_STARTED',
    Started = 'STARTED',
    Success = 'SUCCESS',
    Failed = 'FAILED',
    Embargoed = 'EMBARGOED',
}

const TrialBanner = ({
    isDisabled,
    gettingTrialError,
    gettingTrialResponseCode,
    requestLicense,
    gettingTrial,
    enterpriseReady,
    upgradingPercentage,
    handleUpgrade,
    upgradeError,
    restartError,
    handleRestart,
    restarting,
    openEEModal,
}: TrialBannerProps) => {
    let trialButton;
    let upgradeTermsMessage;
    let content;
    let gettingTrialErrorMsg;

    const {formatMessage} = useIntl();
    const state = store.getState();
    const getCategory = makeGetCategory();
    const preferences = getCategory(state, Preferences.UNIQUE);
    const restartedAfterUpgradePrefValue = preferences.find((pref: PreferenceType) => pref.name === Unique.REQUEST_TRIAL_AFTER_SERVER_UPGRADE);
    const clickedUpgradeAndStartTrialBtn = preferences.find((pref: PreferenceType) => pref.name === Unique.CLICKED_UPGRADE_AND_TRIAL_BTN);

    const restartedAfterUpgradePrefs = restartedAfterUpgradePrefValue?.value === 'true';
    const clickedUpgradeAndTrialBtn = clickedUpgradeAndStartTrialBtn?.value === 'true';

    const userId = useSelector((state: GlobalState) => getCurrentUserId(state));

    const [status, setLoadStatus] = useState(TrialLoadStatus.NotStarted);

    const dispatch = useDispatch();

    const btnText = (status: TrialLoadStatus): string => {
        switch (status) {
        case TrialLoadStatus.Started:
            return formatMessage({id: 'start_trial.modal.gettingTrial', defaultMessage: 'Getting Trial...'});
        case TrialLoadStatus.Success:
            return formatMessage({id: 'start_trial.modal.loaded', defaultMessage: 'Loaded!'});
        case TrialLoadStatus.Failed:
            return formatMessage({id: 'start_trial.modal.failed', defaultMessage: 'Failed'});
        case TrialLoadStatus.Embargoed:
            return formatMessage({id: 'admin.license.trial-request.embargoed'});
        default:
            return formatMessage({id: 'admin.license.trial-request.startTrial', defaultMessage: 'Start trial'});
        }
    };

    useEffect(() => {
        async function savePrefsAndRequestTrial() {
            await savePrefsRestartedAfterUpgrade();
            handleRestart();
        }
        if (upgradingPercentage === 100 && clickedUpgradeAndTrialBtn) {
            if (!restarting) {
                savePrefsAndRequestTrial();
            }
        }
    }, [upgradingPercentage, clickedUpgradeAndTrialBtn]);

    useEffect(() => {
        if (gettingTrial && !gettingTrialError && gettingTrialResponseCode !== 200) {
            setLoadStatus(TrialLoadStatus.Started);
        } else if (gettingTrialError) {
            setLoadStatus(TrialLoadStatus.Failed);
        } else if (gettingTrialResponseCode === 451) {
            setLoadStatus(TrialLoadStatus.Embargoed);
        }
    }, [gettingTrial, gettingTrialError, gettingTrialResponseCode]);

    useEffect(() => {
        // validating the percentage in 0 we make sure to only remove the prefs value on component load after restart
        if (restartedAfterUpgradePrefs && clickedUpgradeAndTrialBtn && upgradingPercentage === 0) {
            // remove the values from the preferences
            const category = Preferences.UNIQUE;
            const reqLicense = Unique.REQUEST_TRIAL_AFTER_SERVER_UPGRADE;
            const clickedBtn = Unique.CLICKED_UPGRADE_AND_TRIAL_BTN;
            dispatch(savePreferences(userId, [{category, name: reqLicense, user_id: userId, value: ''}, {category, name: clickedBtn, user_id: userId, value: ''}]));

            requestLicense();
        }
    }, [restartedAfterUpgradePrefs, clickedUpgradeAndTrialBtn]);

    const onHandleUpgrade = () => {
        if (!handleUpgrade) {
            return;
        }
        handleUpgrade();
        const category = Preferences.UNIQUE;
        const name = Unique.CLICKED_UPGRADE_AND_TRIAL_BTN;
        dispatch(savePreferences(userId, [{category, name, user_id: userId, value: 'true'}]));
    };

    const savePrefsRestartedAfterUpgrade = () => {
        // save in the preferences that this customer wanted to request trial just after the upgrade
        const category = Preferences.UNIQUE;
        const name = Unique.REQUEST_TRIAL_AFTER_SERVER_UPGRADE;
        dispatch(savePreferences(userId, [{category, name, user_id: userId, value: 'true'}]));
    };

    const eeModalTerms = (
        <a
            role='button'
            onClick={openEEModal}
        >
            <FormattedMarkdownMessage
                id='admin.license.enterprise.upgrade.eeLicenseLink'
                defaultMessage='Enterprise Edition License'
            />
        </a>
    );
    if (enterpriseReady && !restartedAfterUpgradePrefs) {
        if (gettingTrialError) {
            gettingTrialErrorMsg =
                gettingTrialResponseCode === 451 ? (
                    <div className='trial-error'>
                        <EmbargoedEntityTrialError/>
                    </div>
                ) : (
                    <p className='trial-error'>
                        <FormattedMessage
                            id='admin.trial_banner.trial-request.error'
                            defaultMessage='Trial license could not be retrieved. Visit <link>{trialInfoLink}</link> to request a license.'
                            values={{
                                link: (msg: React.ReactNode) => (
                                    <a
                                        href={LicenseLinks.TRIAL_INFO_LINK}
                                        target='_blank'
                                        rel='noreferrer'
                                    >
                                        {msg}
                                    </a>
                                ),
                                trialInfoLink: LicenseLinks.TRIAL_INFO_LINK,
                            }}
                        />
                    </p>
                );
        }
        trialButton = (
            <button
                type='button'
                className='btn btn-primary'
                onClick={requestLicense}
                disabled={isDisabled || gettingTrialError !== null || gettingTrialResponseCode === 451}
            >
                {btnText(status)}
            </button>
        );
        content = (
            <>
                <FormattedMessage
                    id='admin.license.trial-request.title'
                    defaultMessage='Experience Mattermost Enterprise Edition for free for the next 30 days. No obligation to buy or credit card required. '
                />
                <FormattedMessage
                    id='admin.license.trial-request.accept-terms'
                    defaultMessage='By clicking <strong>Start trial</strong>, I agree to the <linkEvaluation>Mattermost Software Evaluation Agreement</linkEvaluation>, <linkPrivacy>Privacy Policy</linkPrivacy>, and receiving product emails.'
                    values={{
                        strong: (msg: React.ReactNode) => <strong>{msg}</strong>,
                        linkEvaluation: (msg: React.ReactNode) => (
                            <a
                                href='https://mattermost.com/software-evaluation-agreement'
                                target='_blank'
                                rel='noreferrer'
                            >
                                {msg}
                            </a>
                        ),
                        linkPrivacy: (msg: React.ReactNode) => (
                            <a
                                href='https://mattermost.com/privacy-policy/'
                                target='_blank'
                                rel='noreferrer'
                            >
                                {msg}
                            </a>
                        ),
                    }}
                />
            </>
        );
        upgradeTermsMessage = null;
    } else {
        gettingTrialErrorMsg = null;
        trialButton = (
            <button
                type='button'
                onClick={onHandleUpgrade}
                className='btn btn-primary'
            >
                <LoadingWrapper
                    loading={upgradingPercentage > 0}
                    text={upgradingPercentage === 100 && restarting ? (
                        <FormattedMessage
                            id='admin.license.enterprise.restarting'
                            defaultMessage='Restarting'
                        />
                    ) : (
                        <FormattedMessage
                            id='admin.license.enterprise.upgrading'
                            defaultMessage='Upgrading {percentage}%'
                            values={{percentage: upgradingPercentage}}
                        />)}
                >
                    <FormattedMessage
                        id='admin.license.trialUpgradeAndRequest.submit'
                        defaultMessage='Upgrade Server And Start trial'
                    />
                </LoadingWrapper>
            </button>
        );

        content = (
            <>
                <FormattedMessage
                    id='admin.license.upgrade-and-trial-request.title'
                    defaultMessage='Upgrade to Enterprise Edition and Experience Mattermost Enterprise Edition for free for the next 30 days. No obligation to buy or credit card required. '
                />
            </>
        );

        upgradeTermsMessage = (
            <>
                <p className='upgrade-legal-terms'>
                    <FormattedMessage
                        id='admin.license.upgrade-and-trial-request.accept-terms-initial-part'
                        defaultMessage='By selecting <strong>Upgrade Server And Start trial</strong>, I agree to the <linkEvaluation>Mattermost Software Evaluation Agreement</linkEvaluation>, <linkPrivacy>Privacy Policy</linkPrivacy>, and receiving product emails. '
                        values={{
                            strong: (msg: React.ReactNode) => <strong>{msg}</strong>,
                            linkEvaluation: (msg: React.ReactNode) => (
                                <a
                                    href='https://mattermost.com/software-evaluation-agreement/'
                                    target='_blank'
                                    rel='noreferrer'
                                >
                                    {msg}
                                </a>
                            ),
                            linkPrivacy: (msg: React.ReactNode) => (
                                <a
                                    href='https://mattermost.com/privacy-policy/'
                                    target='_blank'
                                    rel='noreferrer'
                                >
                                    {msg}
                                </a>
                            ),
                        }}
                    />
                    <FormattedMessage
                        id='admin.license.upgrade-and-trial-request.accept-terms-final-part'
                        defaultMessage='Also, I agree to the terms of the Mattermost {eeModalTerms}. Upgrading will download the binary and update your Team Edition instance.'
                        values={{eeModalTerms}}
                    />
                </p>
                {upgradeError && (
                    <div className='upgrade-error'>
                        <div className='form-group has-error'>
                            <label className='control-label'>
                                <span
                                    dangerouslySetInnerHTML={{
                                        __html: format(upgradeError),
                                    }}
                                />
                            </label>
                        </div>
                    </div>
                )}
                {restartError && (
                    <div className='col-sm-12'>
                        <div className='form-group has-error'>
                            <label className='control-label'>
                                {restartError}
                            </label>
                        </div>
                    </div>
                )}
            </>
        );
    }
    return (
        <AlertBanner
            mode='info'
            title={
                <FormattedMessage
                    id='licensingPage.infoBanner.startTrialTitle'
                    defaultMessage='Free 30 day trial!'
                />
            }
            message={
                <div className='banner-start-trial'>
                    <p className='license-trial-legal-terms'>
                        {content}
                    </p>
                    <div className='trial'>
                        {trialButton}
                    </div>
                    {upgradeTermsMessage}
                    {gettingTrialErrorMsg}
                </div>
            }
        />
    );
};

export default TrialBanner;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {batchActions} from 'redux-batched-actions';

import {FileInfo} from '@mattermost/types/files';
import {ServerError} from '@mattermost/types/errors';

import {FileTypes} from 'mattermost-redux/action_types';
import {getLogErrorAction} from 'mattermost-redux/actions/errors';
import {forceLogoutIfNecessary} from 'mattermost-redux/actions/helpers';
import {DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';
import {Client4} from 'mattermost-redux/client';
import {FilePreviewInfo} from 'components/file_preview/file_preview';

import {localizeMessage} from 'utils/utils';

export interface UploadFile {
    file: File;
    name: string;
    type: string;
    rootId: string;
    channelId: string;
    clientId: string;
    onProgress: (filePreviewInfo: FilePreviewInfo) => void;
    onSuccess: (data: any, channelId: string, rootId: string) => void;
    onError: (err: string | ServerError, clientId: string, channelId: string, rootId: string) => void;
}

export function uploadFile({file, name, type, rootId, channelId, clientId, onProgress, onSuccess, onError}: UploadFile) {
    return (dispatch: DispatchFunc, getState: GetStateFunc): XMLHttpRequest => {
        dispatch({type: FileTypes.UPLOAD_FILES_REQUEST});

        const xhr = new XMLHttpRequest();

        xhr.open('POST', Client4.getFilesRoute(), true);

        const client4Headers = Client4.getOptions({method: 'POST'}).headers;
        Object.keys(client4Headers).forEach((client4Header) => {
            const client4HeaderValue = client4Headers[client4Header];
            if (client4HeaderValue) {
                xhr.setRequestHeader(client4Header, client4HeaderValue);
            }
        });

        xhr.setRequestHeader('Accept', 'application/json');

        const formData = new FormData();
        formData.append('channel_id', channelId);
        formData.append('client_ids', clientId);
        formData.append('files', file, name); // appending file in the end for steaming support

        if (onProgress && xhr.upload) {
            xhr.upload.onprogress = (event) => {
                const percent = Math.floor((event.loaded / event.total) * 100);
                const filePreviewInfo = {
                    clientId,
                    name,
                    percent,
                    type,
                } as FilePreviewInfo;
                onProgress(filePreviewInfo);
            };
        }

        if (onSuccess) {
            xhr.onload = () => {
                if (xhr.status === 201 && xhr.readyState === 4) {
                    const response = JSON.parse(xhr.response);
                    const data = response.file_infos.map((fileInfo: FileInfo, index: number) => {
                        return {
                            ...fileInfo,
                            clientId: response.client_ids[index],
                        };
                    });

                    dispatch(batchActions([
                        {
                            type: FileTypes.RECEIVED_UPLOAD_FILES,
                            data,
                            channelId,
                            rootId,
                        },
                        {
                            type: FileTypes.UPLOAD_FILES_SUCCESS,
                        },
                    ]));

                    onSuccess(response, channelId, rootId);
                }
            };
        }

        if (onError) {
            xhr.onerror = () => {
                if (xhr.readyState === 4 && xhr.responseText.length !== 0) {
                    const errorResponse = JSON.parse(xhr.response);

                    forceLogoutIfNecessary(errorResponse, dispatch, getState);

                    const uploadFailureAction = {
                        type: FileTypes.UPLOAD_FILES_FAILURE,
                        clientIds: [clientId],
                        channelId,
                        rootId,
                        error: errorResponse,
                    };

                    dispatch(batchActions([uploadFailureAction, getLogErrorAction(errorResponse)]));
                    onError(errorResponse, clientId, channelId, rootId);
                } else {
                    const errorMessage = xhr.status === 0 || !xhr.status ?
                        localizeMessage('file_upload.generic_error', 'There was a problem uploading your files.') :
                        localizeMessage('channel_loader.unknown_error', 'We received an unexpected status code from the server.') + ' (' + xhr.status + ')';

                    dispatch({
                        type: FileTypes.UPLOAD_FILES_FAILURE,
                        clientIds: [clientId],
                        channelId,
                        rootId,
                    });

                    onError({message: errorMessage}, clientId, channelId, rootId);
                }
            };
        }

        xhr.send(formData);

        return xhr;
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ChangeEvent, PureComponent, DragEvent, MouseEvent, TouchEvent, RefObject} from 'react';
import {defineMessages, FormattedMessage, injectIntl, IntlShape} from 'react-intl';
import classNames from 'classnames';
import {PaperclipIcon} from '@mattermost/compass-icons/components';

import {FilePreviewInfo} from '../file_preview/file_preview';

import dragster from 'utils/dragster';
import Constants from 'utils/constants';
import DelayedAction from 'utils/delayed_action';
import {t} from 'utils/i18n';
import {
    isIosChrome,
    isMobileApp,
} from 'utils/user_agent';
import {getTable} from 'utils/paste';
import {
    clearFileInput,
    cmdOrCtrlPressed,
    isKeyPressed,
    generateId,
    isFileTransfer,
    isUriDrop,
    localizeMessage,
    isTextDroppableEvent,
} from 'utils/utils';

import {FileInfo, FileUploadResponse} from '@mattermost/types/files';
import {ServerError} from '@mattermost/types/errors';

import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import Menu from 'components/widgets/menu/menu';
import KeyboardShortcutSequence, {KEYBOARD_SHORTCUTS} from 'components/keyboard_shortcuts/keyboard_shortcuts_sequence';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';

import {FilesWillUploadHook, PluginComponent} from 'types/store/plugins';

import {UploadFile} from 'actions/file_actions';

const holders = defineMessages({
    limited: {
        id: t('file_upload.limited'),
        defaultMessage: 'Uploads limited to {count, number} files maximum. Please use additional posts for more files.',
    },
    filesAbove: {
        id: t('file_upload.filesAbove'),
        defaultMessage: 'Files above {max}MB could not be uploaded: {filenames}',
    },
    fileAbove: {
        id: t('file_upload.fileAbove'),
        defaultMessage: 'File above {max}MB could not be uploaded: {filename}',
    },
    zeroBytesFiles: {
        id: t('file_upload.zeroBytesFiles'),
        defaultMessage: 'You are uploading empty files: {filenames}',
    },
    zeroBytesFile: {
        id: t('file_upload.zeroBytesFile'),
        defaultMessage: 'You are uploading an empty file: {filename}',
    },
    pasted: {
        id: t('file_upload.pasted'),
        defaultMessage: 'Image Pasted at ',
    },
    uploadFile: {
        id: t('file_upload.upload_files'),
        defaultMessage: 'Upload files',
    },
});

const OVERLAY_TIMEOUT = 500;

const customStyles = {
    left: 'inherit',
    right: 0,
    bottom: '100%',
    top: 'auto',
};

export type Props = {
    channelId: string;

    /**
     * Current root post's ID
     */
    rootId?: string;

    /**
     * Number of files to attach
     */
    fileCount: number;

    /**
     * Function to get file upload targeted input
     */
    getTarget: () => HTMLInputElement | null;

    intl: IntlShape;

    locale: string;

    /**
     * Function to be called when file upload input is clicked
     */
    onClick?: () => void;

    /**
     * Function to be called when file upload is complete
     */
    onFileUpload: (fileInfos: FileInfo[], clientIds: string[], channelId: string, currentRootId: string) => void;

    /**
     * Function to be called when file upload input's change event is fired
     */
    onFileUploadChange: () => void;

    /**
     * Function to be called when upload fails
     */
    onUploadError: (err: string | ServerError, clientId?: string, channelId?: string, currentRootId?: string) => void;

    /**
     * Function to be called when file upload starts
     */
    onUploadStart: (clientIds: string[], channelId: string) => void;

    /**
     * Type of the object which the uploaded file is attached to
     */
    postType: string;

    /**
     * The maximum uploaded file size.
     */
    maxFileSize: number;

    /**
     * Whether or not file upload is allowed.
     */
    canUploadFiles: boolean;

    /**
     * Plugin file upload methods to be added
     */
    pluginFileUploadMethods: PluginComponent[];
    pluginFilesWillUploadHooks: FilesWillUploadHook[];

    /**
     * Function called when xhr fires progress event.
     */
    onUploadProgress: (filePreviewInfo: FilePreviewInfo) => void;
    actions: {

        /**
         * Function to be called to upload file
         */
        uploadFile: ({file, name, type, rootId, channelId, clientId, onProgress, onSuccess, onError}: UploadFile) => XMLHttpRequest;
    };
};

type State = {
    requests: Record<string, XMLHttpRequest>;
    menuOpen: boolean;
};

export class FileUpload extends PureComponent<Props, State> {
    fileInput: RefObject<HTMLInputElement>;
    unbindDragsterEvents?: () => void;

    static defaultProps = {
        pluginFileUploadMethods: [],
        pluginFilesWillUploadHooks: [],
    };

    constructor(props: Props) {
        super(props);
        this.state = {
            requests: {},
            menuOpen: false,
        };
        this.fileInput = React.createRef();
    }

    componentDidMount() {
        if (this.props.postType === 'post') {
            this.registerDragEvents('.row.main', '.center-file-overlay');
        } else if (this.props.postType === 'comment') {
            this.registerDragEvents('.post-right__container', '.right-file-overlay');
        } else if (this.props.postType === 'thread') {
            this.registerDragEvents('.ThreadPane', '.right-file-overlay');
        }

        document.addEventListener('paste', this.pasteUpload);
        document.addEventListener('keydown', this.keyUpload);
    }

    componentWillUnmount() {
        document.removeEventListener('paste', this.pasteUpload);
        document.removeEventListener('keydown', this.keyUpload);

        this.unbindDragsterEvents?.();
    }

    fileUploadSuccess = (data: FileUploadResponse, channelId: string, currentRootId: string) => {
        if (data) {
            this.props.onFileUpload(data.file_infos, data.client_ids, channelId, currentRootId);

            const requests = Object.assign({}, this.state.requests);
            for (let j = 0; j < data.client_ids.length; j++) {
                Reflect.deleteProperty(requests, data.client_ids[j]);
            }
            this.setState({requests});
        }
    }

    fileUploadFail = (err: string | ServerError, clientId: string, channelId: string, currentRootId: string) => {
        this.props.onUploadError(err, clientId, channelId, currentRootId);
    }

    pluginUploadFiles = (files: File[]) => {
        // clear any existing errors
        this.props.onUploadError('');
        this.uploadFiles(files);
    }

    checkPluginHooksAndUploadFiles = (files: FileList | File[]) => {
        // clear any existing errors
        this.props.onUploadError('');

        let sortedFiles = Array.from(files).sort((a, b) => a.name.localeCompare(b.name, this.props.locale, {numeric: true}));

        const willUploadHooks = this.props.pluginFilesWillUploadHooks;
        for (const h of willUploadHooks) {
            const result = h.hook?.(sortedFiles, this.pluginUploadFiles);

            // Display an error message if there is one but don't reject the upload
            if (result?.message) {
                this.props.onUploadError(result.message);
            }

            sortedFiles = result?.files || [];
        }

        if (sortedFiles && sortedFiles.length) {
            this.uploadFiles(sortedFiles);
        }
    }

    uploadFiles = (sortedFiles: File[]) => {
        const {channelId, rootId} = this.props;

        const uploadsRemaining = Constants.MAX_UPLOAD_FILES - this.props.fileCount;
        let numUploads = 0;

        // keep track of how many files have been too large
        const tooLargeFiles: File[] = [];
        const zeroFiles: File[] = [];
        const clientIds: string[] = [];

        for (let i = 0; i < sortedFiles.length && numUploads < uploadsRemaining; i++) {
            if (sortedFiles[i].size > this.props.maxFileSize) {
                tooLargeFiles.push(sortedFiles[i]);
                continue;
            }
            if (sortedFiles[i].size === 0) {
                zeroFiles.push(sortedFiles[i]);
            }

            // generate a unique id that can be used by other components to refer back to this upload
            const clientId = generateId();

            const request = this.props.actions.uploadFile({
                file: sortedFiles[i],
                name: sortedFiles[i].name,
                type: sortedFiles[i].type,
                rootId: rootId || '',
                channelId,
                clientId,
                onProgress: this.props.onUploadProgress,
                onSuccess: this.fileUploadSuccess,
                onError: this.fileUploadFail,
            });

            this.setState({requests: {...this.state.requests, [clientId]: request}});
            clientIds.push(clientId);

            numUploads += 1;
        }

        this.props.onUploadStart(clientIds, channelId);

        const {formatMessage} = this.props.intl;
        const errors = [];
        if (sortedFiles.length > uploadsRemaining) {
            errors.push(formatMessage(holders.limited, {count: Constants.MAX_UPLOAD_FILES}));
        }

        if (tooLargeFiles.length > 1) {
            const tooLargeFilenames = tooLargeFiles.map((file) => file.name).join(', ');

            errors.push(formatMessage(holders.filesAbove, {max: (this.props.maxFileSize / 1048576), filenames: tooLargeFilenames}));
        } else if (tooLargeFiles.length > 0) {
            errors.push(formatMessage(holders.fileAbove, {max: (this.props.maxFileSize / 1048576), filename: tooLargeFiles[0].name}));
        }

        if (zeroFiles.length > 1) {
            const zeroFilenames = zeroFiles.map((file) => file.name).join(', ');

            errors.push(formatMessage(holders.zeroBytesFiles, {filenames: zeroFilenames}));
        } else if (zeroFiles.length > 0) {
            errors.push(formatMessage(holders.zeroBytesFile, {filename: zeroFiles[0].name}));
        }

        if (errors.length > 0) {
            this.props.onUploadError(errors.join(', '));
        }
    }

    handleChange = (e: ChangeEvent<HTMLInputElement>) => {
        if (e.target.files && e.target.files.length > 0) {
            this.checkPluginHooksAndUploadFiles(e.target.files);

            clearFileInput(e.target);
        }

        this.props.onFileUploadChange();
    }

    handleDrop = (e: DragEvent<HTMLInputElement>) => {
        if (!this.props.canUploadFiles) {
            this.props.onUploadError(localizeMessage('file_upload.disabled', 'File attachments are disabled.'));
            return;
        }

        this.props.onUploadError('');

        const items = e.dataTransfer.items || [];
        const droppedFiles = e.dataTransfer.files;
        const files: File[] = [];
        Array.from(droppedFiles).forEach((file, index) => {
            const item = items[index];
            if (item && item.webkitGetAsEntry && (item.webkitGetAsEntry() === null || (item.webkitGetAsEntry() as FileSystemEntry).isDirectory)) {
                return;
            }
            files.push(file);
        });

        const types = e.dataTransfer.types;
        if (types) {
            if (isUriDrop(e.dataTransfer)) {
                return;
            }

            // For non-IE browsers
            if (types.includes && !types.includes('Files')) {
                return;
            }
        }

        if (files.length === 0) {
            this.props.onUploadError(localizeMessage('file_upload.drag_folder', 'Folders cannot be uploaded. Please drag all files separately.'));
            return;
        }

        if (files.length) {
            this.checkPluginHooksAndUploadFiles(files);
        }

        this.props.onFileUploadChange();
    }

    registerDragEvents = (containerSelector: string, overlaySelector: string) => {
        const overlay = document.querySelector(overlaySelector);

        const dragTimeout = new DelayedAction(() => {
            overlay?.classList.add('hidden');
        });

        const enter = (e: CustomEvent) => {
            const files = e.detail.dataTransfer;
            if (!isUriDrop(files) && isFileTransfer(files)) {
                overlay?.classList.remove('hidden');
            }
            e.detail.preventDefault();
        };

        const leave = (e: CustomEvent) => {
            const files = e.detail.dataTransfer;

            if (!isUriDrop(files) && isFileTransfer(files)) {
                overlay?.classList.add('hidden');
            }

            dragTimeout.cancel();

            e.detail.preventDefault();
        };

        const over = (e: CustomEvent) => {
            dragTimeout.fireAfter(OVERLAY_TIMEOUT);
            if (!isTextDroppableEvent(e.detail)) {
                e.detail.preventDefault();
            }
        };
        const dropWithHiddenClass = (e: CustomEvent) => {
            overlay?.classList.add('hidden');
            dragTimeout.cancel();

            this.handleDrop(e.detail);

            if (!isTextDroppableEvent(e.detail)) {
                e.detail.preventDefault();
            }
        };

        const drop = (e: CustomEvent) => {
            this.handleDrop(e.detail);

            if (!isTextDroppableEvent(e.detail)) {
                e.detail.preventDefault();
            }
        };

        const noop = () => {}; // eslint-disable-line no-empty-function
        let dragsterActions = {};
        if (this.props.canUploadFiles) {
            dragsterActions = {
                enter,
                leave,
                over,
                drop: dropWithHiddenClass,
            };
        } else {
            dragsterActions = {
                enter: noop,
                leave: noop,
                over: noop,
                drop,
            };
        }

        this.unbindDragsterEvents = dragster(containerSelector, dragsterActions);
    }

    containsEventTarget = (targetElement: HTMLInputElement | null, eventTarget: EventTarget | null) => targetElement && targetElement.contains(eventTarget as Node);

    pasteUpload = (e: ClipboardEvent) => {
        const {formatMessage} = this.props.intl;

        if (!e.clipboardData || !e.clipboardData.items || getTable(e.clipboardData)) {
            return;
        }

        const textarea = this.props.getTarget();
        if (!this.containsEventTarget(textarea, e.target)) {
            return;
        }

        this.props.onUploadError('');

        const items = [];
        for (let i = 0; i < e.clipboardData.items.length; i++) {
            const item = e.clipboardData.items[i];

            if (item.kind !== 'file') {
                continue;
            }

            items.push(item);
        }

        if (items && items.length > 0) {
            if (!this.props.canUploadFiles) {
                this.props.onUploadError(localizeMessage('file_upload.disabled', 'File attachments are disabled.'));
                return;
            }

            e.preventDefault();

            const files = [];

            for (let i = 0; i < items.length; i++) {
                const file = items[i].getAsFile();

                if (!file) {
                    continue;
                }

                const now = new Date();
                const hour = now.getHours().toString().padStart(2, '0');
                const minute = now.getMinutes().toString().padStart(2, '0');

                let ext = '';
                if (file.name && file.name.includes('.')) {
                    ext = file.name.substr(file.name.lastIndexOf('.'));
                } else if (items[i].type.includes('/')) {
                    ext = '.' + items[i].type.split('/')[1].toLowerCase();
                }

                const name = file.name || formatMessage(holders.pasted) + now.getFullYear() + '-' + (now.getMonth() + 1) + '-' + now.getDate() + ' ' + hour + '-' + minute + ext;

                const newFile: File = new File([file], name, {type: file.type});
                files.push(newFile);
            }

            if (files.length > 0) {
                this.checkPluginHooksAndUploadFiles(files);
                this.props.onFileUploadChange();
            }
        }
    }

    keyUpload = (e: KeyboardEvent) => {
        if (cmdOrCtrlPressed(e) && !e.shiftKey && isKeyPressed(e, Constants.KeyCodes.U)) {
            e.preventDefault();

            if (!this.props.canUploadFiles) {
                this.props.onUploadError(localizeMessage('file_upload.disabled', 'File attachments are disabled.'));
                return;
            }
            const postTextbox = this.props.postType === 'post' && document.activeElement?.id === 'post_textbox';
            const commentTextbox = this.props.postType === 'comment' && document.activeElement?.id === 'reply_textbox';
            const threadTextbox = this.props.postType === 'thread' && document.activeElement?.id === 'reply_textbox';
            if (postTextbox || commentTextbox || threadTextbox) {
                this.fileInput.current?.focus();
                this.fileInput.current?.click();
            }
        }
    }

    cancelUpload = (clientId: string) => {
        const requests = Object.assign({}, this.state.requests);
        const request = requests[clientId];

        if (request) {
            request.abort();

            Reflect.deleteProperty(requests, clientId);
            this.setState({requests});
        }
    }

    handleMaxUploadReached = (e: MouseEvent<HTMLInputElement>) => {
        if (e) {
            e.preventDefault();
        }

        const {onUploadError} = this.props;
        const {formatMessage} = this.props.intl;

        onUploadError(formatMessage(holders.limited, {count: Constants.MAX_UPLOAD_FILES}));
    }

    handleLocalFileUploaded = (e: MouseEvent<HTMLInputElement>) => {
        const uploadsRemaining = Constants.MAX_UPLOAD_FILES - this.props.fileCount;
        if (uploadsRemaining > 0) {
            if (this.props.onClick) {
                this.props.onClick();
            }
        } else {
            this.handleMaxUploadReached(e);
        }
        this.setState({menuOpen: false});
    }

    simulateInputClick = (e: MouseEvent<HTMLButtonElement | HTMLAnchorElement> | TouchEvent) => {
        e.preventDefault();
        e.stopPropagation();
        this.fileInput.current?.click();
    }

    render() {
        const {formatMessage} = this.props.intl;
        let multiple = true;
        if (isMobileApp()) {
            // iOS WebViews don't upload videos properly in multiple mode
            multiple = false;
        }

        let accept = '';
        if (isIosChrome()) {
            // iOS Chrome can't upload videos at all
            accept = 'image/*';
        }

        const uploadsRemaining = Constants.MAX_UPLOAD_FILES - this.props.fileCount;

        let bodyAction;
        const buttonAriaLabel = formatMessage({id: 'accessibility.button.attachment', defaultMessage: 'attachment'});
        const iconAriaLabel = formatMessage({id: 'generic_icons.attach', defaultMessage: 'Attachment Icon'});

        if (this.props.pluginFileUploadMethods.length === 0) {
            bodyAction = (
                <div>
                    <OverlayTrigger
                        delayShow={Constants.OVERLAY_TIME_DELAY}
                        placement='top'
                        trigger={['hover', 'focus']}
                        overlay={
                            <Tooltip id='upload-tooltip'>
                                <KeyboardShortcutSequence
                                    shortcut={KEYBOARD_SHORTCUTS.filesUpload}
                                    hoistDescription={true}
                                    isInsideTooltip={true}
                                />
                            </Tooltip>
                        }
                    >
                        <button
                            type='button'
                            id='fileUploadButton'
                            aria-label={buttonAriaLabel}
                            className={classNames('style--none AdvancedTextEditor__action-button', {
                                disabled: uploadsRemaining <= 0,
                            })}
                            onClick={this.simulateInputClick}
                            onTouchEnd={this.simulateInputClick}
                        >
                            <PaperclipIcon
                                size={18}
                                color={'currentColor'}
                                aria-label={iconAriaLabel}
                            />
                        </button>
                    </OverlayTrigger>
                    <input
                        id='fileUploadInput'
                        tabIndex={-1}
                        aria-label={formatMessage(holders.uploadFile)}
                        ref={this.fileInput}
                        type='file'
                        onChange={this.handleChange}
                        onClick={this.handleLocalFileUploaded}
                        multiple={multiple}
                        accept={accept}
                    />
                </div>
            );
        } else {
            const pluginFileUploadMethods = this.props.pluginFileUploadMethods.map((item) => {
                return (
                    <li
                        key={item.pluginId + '_fileuploadpluginmenuitem'}
                        onClick={() => {
                            if (item.action) {
                                item.action(this.checkPluginHooksAndUploadFiles);
                            }
                            this.setState({menuOpen: false});
                        }}
                    >
                        <a href='#'>
                            <span className='mr-2'>
                                {item.icon}
                            </span>
                            {item.text}
                        </a>
                    </li>
                );
            });
            bodyAction = (
                <div>
                    <input
                        tabIndex={-1}
                        aria-label={formatMessage(holders.uploadFile)}
                        ref={this.fileInput}
                        type='file'
                        className='file-attachment-menu-item-input'
                        onChange={this.handleChange}
                        onClick={this.handleLocalFileUploaded}
                        multiple={multiple}
                        accept={accept}
                    />
                    <MenuWrapper>
                        <OverlayTrigger
                            delayShow={Constants.OVERLAY_TIME_DELAY}
                            placement='top'
                            trigger={['hover', 'focus']}
                            overlay={
                                <Tooltip id='upload-tooltip'>
                                    <KeyboardShortcutSequence
                                        shortcut={KEYBOARD_SHORTCUTS.filesUpload}
                                        hoistDescription={true}
                                        isInsideTooltip={true}
                                    />
                                </Tooltip>
                            }
                        >
                            <button
                                type='button'
                                id='fileUploadButton'
                                aria-label={buttonAriaLabel}
                                className='style--none AdvancedTextEditor__action-button'
                            >
                                <PaperclipIcon
                                    size={18}
                                    color={'currentColor'}
                                    aria-label={iconAriaLabel}
                                />
                            </button>
                        </OverlayTrigger>
                        <Menu
                            id='fileUploadOptions'
                            openLeft={true}
                            openUp={true}
                            ariaLabel={formatMessage({id: 'file_upload.menuAriaLabel', defaultMessage: 'Upload type selector'})}
                            customStyles={customStyles}
                        >
                            <li>
                                <a
                                    href='#'
                                    onClick={this.simulateInputClick}
                                    onTouchEnd={this.simulateInputClick}
                                >
                                    <span className='mr-2'>
                                        <i className='fa fa-laptop'/>
                                    </span>
                                    <FormattedMessage
                                        id='yourcomputer'
                                        defaultMessage='Your computer'
                                    />
                                </a>
                            </li>
                            {pluginFileUploadMethods}
                        </Menu>
                    </MenuWrapper>
                </div>
            );
        }

        if (!this.props.canUploadFiles) {
            return null;
        }

        return (

            <div className={uploadsRemaining <= 0 ? ' style--none btn-file__disabled' : 'style--none'}>
                {bodyAction}
            </div>
        );
    }
}

const wrappedComponent = injectIntl(FileUpload, {forwardRef: true});
wrappedComponent.displayName = 'injectIntl(FileUpload)';
export default wrappedComponent;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

type Options = {
    enter?: (event: CustomEvent) => void;
    leave?: (event: CustomEvent) => void;
    over?: (event: CustomEvent) => void;
    drop?: (event: CustomEvent) => void;
}

export default function dragster(query: string, options: Options) {
    const preventDefault = (e: Event) => {
        e.preventDefault();
    };

    const defaults = {
        enter: preventDefault,
        leave: preventDefault,
        over: preventDefault,
        drop: preventDefault,
    };

    const settings = Object.assign(defaults, options);
    const node = document.querySelector(query);

    if (!node) {
        return () => {};
    }

    let first = false;
    let second = false;

    const dragenter = (event: Event) => {
        if (first) {
            second = true;
            return;
        }

        first = true;
        const enterEvent = new CustomEvent('dragster:enter', {detail: event});
        node.dispatchEvent(enterEvent);
    };

    const dragleave = (event: Event) => {
        if (second) {
            second = false;
        } else if (first) {
            first = false;
        }
        if (!first && !second) {
            const leaveEvent = new CustomEvent('dragster:leave', {detail: event});
            node.dispatchEvent(leaveEvent);
        }
    };

    const dragover = (event: Event) => {
        const overEvent = new CustomEvent('dragster:over', {detail: event});
        node.dispatchEvent(overEvent);
    };

    const drop = (event: Event) => {
        if (second) {
            second = false;
        } else if (first) {
            first = false;
        }
        if (!first && !second) {
            const dropEvent = new CustomEvent('dragster:drop', {detail: event});
            node.dispatchEvent(dropEvent);
        }
    };

    node.addEventListener('dragenter', dragenter);
    node.addEventListener('dragleave', dragleave);
    node.addEventListener('dragover', dragover);
    node.addEventListener('drop', drop);

    node.addEventListener('dragster:enter', settings.enter);
    node.addEventListener('dragster:leave', settings.leave);
    node.addEventListener('dragster:over', settings.over);
    node.addEventListener('dragster:drop', settings.drop);

    const unbindEvents = () => {
        node.removeEventListener('dragenter', dragenter);
        node.removeEventListener('dragleave', dragleave);
        node.removeEventListener('dragover', dragover);
        node.removeEventListener('drop', drop);

        node.removeEventListener('dragster:enter', settings.enter);
        node.removeEventListener('dragster:leave', settings.leave);
        node.removeEventListener('dragster:over', settings.over);
        node.removeEventListener('dragster:drop', settings.drop);
    };

    return unbindEvents;
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {getConfig} from 'mattermost-redux/selectors/entities/general';

import {uploadFile} from 'actions/file_actions';
import {getCurrentLocale} from 'selectors/i18n';
import {canUploadFiles} from 'utils/file_utils';

import {FilesWillUploadHook} from 'types/store/plugins';
import {GlobalState} from 'types/store';

import FileUpload, {Props} from './file_upload';

function mapStateToProps(state: GlobalState) {
    const config = getConfig(state);
    const maxFileSize = parseInt(config.MaxFileSize || '', 10);

    return {
        maxFileSize,
        canUploadFiles: canUploadFiles(config),
        locale: getCurrentLocale(state),
        pluginFileUploadMethods: state.plugins.components.FileUploadMethod,
        pluginFilesWillUploadHooks: state.plugins.components.FilesWillUploadHook as unknown as FilesWillUploadHook[],
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<any>, Props['actions']>({
            uploadFile,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps, null, {forwardRef: true})(FileUpload);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {createSelector} from 'reselect';

import {getUsers} from 'mattermost-redux/selectors/entities/common';
import {getTeammateNameDisplaySetting} from 'mattermost-redux/selectors/entities/preferences';

import {GlobalState} from '@mattermost/types/store';
import {Typing} from '@mattermost/types/typing';
import {UserProfile} from '@mattermost/types/users';
import {IDMappedObjects} from '@mattermost/types/utilities';

import {displayUsername} from 'mattermost-redux/utils/user_utils';

const getUsersTypingImpl = (profiles: IDMappedObjects<UserProfile>, teammateNameDisplay: string, channelId: string, parentPostId: string, typing: Typing): string[] => {
    const id = channelId + parentPostId;

    if (typing[id]) {
        const users = Object.keys(typing[id]);

        if (users.length) {
            return users.map((userId) => {
                return displayUsername(profiles[userId], teammateNameDisplay);
            });
        }
    }

    return [];
};

export function makeGetUsersTypingByChannelAndPost(): (state: GlobalState, props: {channelId: string; postId: string}) => string[] {
    return createSelector(
        'makeGetUsersTypingByChannelAndPost',
        getUsers,
        getTeammateNameDisplaySetting,
        (state: GlobalState, options: {channelId: string; postId: string}) => options.channelId,
        (state: GlobalState, options: {channelId: string; postId: string}) => options.postId,
        (state: GlobalState) => state.entities.typing,
        getUsersTypingImpl,
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {GlobalState} from '@mattermost/types/store';

import {getMissingProfilesByIds, getStatusesByIds} from 'mattermost-redux/actions/users';

import {General, Preferences, WebsocketEvents} from 'mattermost-redux/constants';

import {getConfig, isPerformanceDebuggingEnabled} from 'mattermost-redux/selectors/entities/general';
import {getBool} from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentUserId, getStatusForUserId} from 'mattermost-redux/selectors/entities/users';

import {DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';

function getTimeBetweenTypingEvents(state: GlobalState) {
    const config = getConfig(state);

    return config.TimeBetweenUserTypingUpdatesMilliseconds === undefined ? 0 : parseInt(config.TimeBetweenUserTypingUpdatesMilliseconds, 10);
}

export function userStartedTyping(userId: string, channelId: string, rootId: string, now: number) {
    return (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();

        if (
            isPerformanceDebuggingEnabled(state) &&
            getBool(state, Preferences.CATEGORY_PERFORMANCE_DEBUGGING, Preferences.NAME_DISABLE_TYPING_MESSAGES)
        ) {
            return;
        }

        dispatch({
            type: WebsocketEvents.TYPING,
            data: {
                id: channelId + rootId,
                userId,
                now,
            },
        });

        // Ideally this followup loading would be done by someone else
        dispatch(fillInMissingInfo(userId));

        setTimeout(() => {
            dispatch(userStoppedTyping(userId, channelId, rootId, now));
        }, getTimeBetweenTypingEvents(state));
    };
}

function fillInMissingInfo(userId: string) {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();
        const currentUserId = getCurrentUserId(state);

        if (userId !== currentUserId) {
            const result = await dispatch(getMissingProfilesByIds([userId]));
            if (result.data && result.data.length > 0) {
                // Already loaded the user status
                return {data: false};
            }
        }

        const status = getStatusForUserId(state, userId);
        if (status !== General.ONLINE) {
            dispatch(getStatusesByIds([userId]));
        }

        return {data: true};
    };
}

export function userStoppedTyping(userId: string, channelId: string, rootId: string, now: number) {
    return {
        type: WebsocketEvents.STOP_TYPING,
        data: {
            id: channelId + rootId,
            userId,
            now,
        },
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback} from 'react';
import {FormattedMessage} from 'react-intl';

import {WebSocketMessage} from '@mattermost/client';

import {SocketEvents} from 'utils/constants';
import {useWebSocket} from 'utils/use_websocket';

type Props = {
    channelId: string;
    postId: string;
    typingUsers: string[];
    userStartedTyping: (userId: string, channelId: string, rootId: string, now: number) => void;
    userStoppedTyping: (userId: string, channelId: string, rootId: string, now: number) => void;
}

export default function MsgTyping(props: Props) {
    const {userStartedTyping, userStoppedTyping} = props;
    useWebSocket({
        handler: useCallback((msg: WebSocketMessage) => {
            if (msg.event === SocketEvents.TYPING) {
                const channelId = msg.broadcast.channel_id;
                const rootId = msg.data.parent_id;
                const userId = msg.data.user_id;

                if (props.channelId === channelId && props.postId === rootId) {
                    userStartedTyping(userId, channelId, rootId, Date.now());
                }
            } else if (msg.event === SocketEvents.POSTED) {
                const post = JSON.parse(msg.data.post);

                const channelId = post.channel_id;
                const rootId = post.root_id;
                const userId = post.user_id;

                if (props.channelId === channelId && props.postId === rootId) {
                    userStoppedTyping(userId, channelId, rootId, Date.now());
                }
            }
        }, [props.channelId, props.postId, userStartedTyping, userStoppedTyping]),
    });

    const getTypingText = () => {
        let users: string[] = [];
        let numUsers = 0;
        if (props.typingUsers) {
            users = [...props.typingUsers];
            numUsers = users.length;
        }

        if (numUsers === 0) {
            return '';
        }
        if (numUsers === 1) {
            return (
                <FormattedMessage
                    id='msg_typing.isTyping'
                    defaultMessage='{user} is typing...'
                    values={{
                        user: users[0],
                    }}
                />
            );
        }
        const last = users.pop();
        return (
            <FormattedMessage
                id='msg_typing.areTyping'
                defaultMessage='{users} and {last} are typing...'
                values={{
                    users: (users.join(', ')),
                    last,
                }}
            />
        );
    };

    return (
        <span className='msg-typing'>{getTypingText()}</span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {makeGetUsersTypingByChannelAndPost} from 'mattermost-redux/selectors/entities/typing';

import {GlobalState} from 'types/store';

import {userStartedTyping, userStoppedTyping} from './actions';
import MsgTyping from './msg_typing';

type OwnProps = {
    channelId: string;
    postId: string;
};

function makeMapStateToProps() {
    const getUsersTypingByChannelAndPost = makeGetUsersTypingByChannelAndPost();

    return function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
        const typingUsers = getUsersTypingByChannelAndPost(state, {channelId: ownProps.channelId, postId: ownProps.postId});

        return {
            typingUsers,
        };
    };
}

const mapDispatchToProps = {
    userStartedTyping,
    userStoppedTyping,
};

export default connect(makeMapStateToProps, mapDispatchToProps)(MsgTyping);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactFragment} from 'react';
import {FormattedMessage} from 'react-intl';

import {ServerError} from '@mattermost/types/errors';

import {isErrorInvalidSlashCommand} from 'utils/post_utils';

interface MessageSubmitErrorProps {
    error: ServerError;
    handleSubmit: (e: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => void;
    submittedMessage?: string;
}

class MessageSubmitError extends React.PureComponent<MessageSubmitErrorProps> {
    public renderSlashCommandError = (): string | ReactFragment => {
        if (!this.props.submittedMessage) {
            return this.props.error.message;
        }

        const command = this.props.submittedMessage.split(' ')[0];
        return (
            <React.Fragment>
                <FormattedMessage
                    id='message_submit_error.invalidCommand'
                    defaultMessage="Command with a trigger of ''{command}'' not found. "
                    values={{
                        command,
                    }}
                />
                <a
                    href='#'
                    onClick={this.props.handleSubmit}
                >
                    <FormattedMessage
                        id='message_submit_error.sendAsMessageLink'
                        defaultMessage='Click here to send as a message.'
                    />
                </a>
            </React.Fragment>
        );
    }

    public render(): JSX.Element | null {
        const error = this.props.error;

        if (!error) {
            return null;
        }

        let errorContent: string | ReactFragment = error.message;
        if (isErrorInvalidSlashCommand(error)) {
            errorContent = this.renderSlashCommandError();
        }

        return (
            <div className='has-error'>
                <label className='control-label'>
                    {errorContent}
                </label>
            </div>
        );
    }
}

export default MessageSubmitError;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useState} from 'react';

import Constants from 'utils/constants';

import SuggestionList from './suggestion_list';

type Props = React.ComponentProps<typeof SuggestionList> & {
    inputRef: React.RefObject<HTMLTextAreaElement>;
    open: boolean;
}

export default function RhsSuggestionList(props: Props): JSX.Element {
    const [position, setPosition] = useState<Props['position']>('top');

    useEffect(() => {
        const input = props.inputRef.current;

        if (input && props.open) {
            const inputTop = input.getBoundingClientRect().top ?? 0;
            const newPosition = (inputTop < Constants.SUGGESTION_LIST_SPACE_RHS) ? 'bottom' : 'top';

            if (newPosition !== position) {
                // This potentially causes a second render when the list position changes, but that's better
                // than checking the bounding rectangle while rendering.
                setPosition(newPosition);
            }
        }
    }, [props.inputRef, props.open]);

    return (
        <SuggestionList
            {...props}
            position={position}
        />
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {memo} from 'react';
import styled, {css} from 'styled-components';

/** eslint-disable no-confusing-arrow */

type TexteditorActionsProps = {
    placement: 'top' | 'bottom';
    show?: boolean;
}

const TexteditorActions = styled.span<TexteditorActionsProps>`
    position: absolute;
    z-index: 2;
    display: flex;
    place-items: center;
    gap: 4px;

    /* define the position based on the placement prop */
    ${({placement}) => (placement === 'top' ? css`
        top: 7px;
        right: 7px;
    ` : css`
        right: 7px;
        bottom: 7px;
    `)}

    opacity: ${({show = true}) => (show ? 1 : 0)};
    transition: opacity 0.3s linear;
    visibility: ${({show = true}) => (show ? 'visible' : 'hidden')};

    .btn-file__disabled {
        opacity: 0.1;

        &:hover,
        &:active {
            opacity: 0.1;
        }
    }
`;

export default memo(TexteditorActions);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo} from 'react';
import classNames from 'classnames';
import {FormatLetterCaseIcon} from '@mattermost/compass-icons/components';
import {useIntl} from 'react-intl';

import KeyboardShortcutSequence, {KEYBOARD_SHORTCUTS} from 'components/keyboard_shortcuts/keyboard_shortcuts_sequence';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import Constants from 'utils/constants';

import {IconContainer} from '../formatting_bar/formatting_icon';

interface ToggleFormattingBarProps {
    onClick: React.MouseEventHandler;
    active: boolean;
    disabled: boolean;
}

const ToggleFormattingBar = (props: ToggleFormattingBarProps): JSX.Element => {
    const {onClick, active, disabled} = props;
    const {formatMessage} = useIntl();
    const buttonAriaLabel = formatMessage({id: 'accessibility.button.formatting', defaultMessage: 'formatting'});
    const iconAriaLabel = formatMessage({id: 'generic_icons.format_letter_case', defaultMessage: 'Format letter Case Icon'});

    const tooltip = (
        <Tooltip id='toggleFormattingBarButtonTooltip'>
            <KeyboardShortcutSequence
                shortcut={KEYBOARD_SHORTCUTS.msgShowFormatting}
                hoistDescription={true}
                isInsideTooltip={true}
            />
        </Tooltip>
    );

    return (
        <OverlayTrigger
            placement='top'
            delayShow={Constants.OVERLAY_TIME_DELAY}
            trigger={Constants.OVERLAY_DEFAULT_TRIGGER}
            overlay={tooltip}
        >
            <IconContainer
                type='button'
                id='toggleFormattingBarButton'
                onClick={onClick}
                disabled={disabled}
                aria-label={buttonAriaLabel}
                className={classNames({active})}
            >
                <FormatLetterCaseIcon
                    size={18}
                    color={'currentColor'}
                    aria-label={iconAriaLabel}
                />
            </IconContainer>
        </OverlayTrigger>
    );
};

export default memo(ToggleFormattingBar);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useLayoutEffect, useState} from 'react';
import {Instance} from '@popperjs/core';

import {debounce} from 'lodash';

import {MarkdownMode} from 'utils/markdown/apply_markdown';

type WideMode = 'wide' | 'normal' | 'narrow';

export function useGetLatest<T>(val: T) {
    const ref = React.useRef<T>(val);
    ref.current = val;
    return React.useCallback(() => ref.current, []);
}

const useResponsiveFormattingBar = (ref: React.RefObject<HTMLDivElement>): WideMode => {
    const [wideMode, setWideMode] = useState<WideMode>('wide');
    const handleResize = debounce(() => {
        if (ref.current?.clientWidth === undefined) {
            return;
        }

        if (ref.current.clientWidth > 640) {
            setWideMode('wide');
        }

        if (ref.current.clientWidth >= 424 && ref.current.clientWidth <= 640) {
            setWideMode('normal');
        }

        if (ref.current.clientWidth < 424) {
            setWideMode('narrow');
        }
    }, 10);

    useLayoutEffect(() => {
        if (!ref.current) {
            return () => {};
        }

        let sizeObserver: ResizeObserver | null = new ResizeObserver(handleResize);

        sizeObserver.observe(ref.current);

        return () => {
            sizeObserver!.disconnect();
            sizeObserver = null;
        };
    }, [handleResize, ref]);

    return wideMode;
};

const MAP_WIDE_MODE_TO_CONTROLS_QUANTITY: {[key in WideMode]: number} = {
    wide: 9,
    normal: 5,
    narrow: 3,
};

export const useFormattingBarControls = (
    formattingBarRef: React.RefObject<HTMLDivElement>,
): {
    controls: MarkdownMode[];
    hiddenControls: MarkdownMode[];
    wideMode: WideMode;
} => {
    const wideMode = useResponsiveFormattingBar(formattingBarRef);

    const allControls: MarkdownMode[] = ['bold', 'italic', 'strike', 'heading', 'link', 'code', 'quote', 'ul', 'ol'];

    const controlsLength = MAP_WIDE_MODE_TO_CONTROLS_QUANTITY[wideMode];

    const controls = allControls.slice(0, controlsLength);
    const hiddenControls = allControls.slice(controlsLength);

    return {
        controls,
        hiddenControls,
        wideMode,
    };
};

export const useUpdateOnVisibilityChange = (update: Instance['update'] | null, isVisible: boolean) => {
    const updateComponent = async () => {
        if (!update) {
            return;
        }
        await update();
    };

    useEffect(() => {
        if (!isVisible) {
            return;
        }
        updateComponent();
    }, [isVisible]);
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import classNames from 'classnames';
import React, {memo, useCallback, useEffect, useRef, useState} from 'react';
import {useIntl} from 'react-intl';
import styled from 'styled-components';
import {useFloating, offset} from '@floating-ui/react-dom';
import {CSSTransition} from 'react-transition-group';
import {DotsHorizontalIcon} from '@mattermost/compass-icons/components';

import {ApplyMarkdownOptions} from 'utils/markdown/apply_markdown';
import ToggleFormattingBar from '../toggle_formatting_bar/toggle_formatting_bar';

import FormattingIcon, {IconContainer} from './formatting_icon';

import {useFormattingBarControls, useGetLatest} from './hooks';

/** eslint-disable no-confusing-arrow */

type SeparatorProps = {
    show: boolean;
}

const Separator = styled.div<SeparatorProps>`
    display: ${({show}) => (show ? 'block' : 'none')};
    position: relative;
    width: 1px;
    height: 24px;
    background: rgba(var(--center-channel-color-rgb), 0.32);
`;

type FormattingBarContainerProps = {
    open: boolean;
}

const FormattingBarContainer = styled.div<FormattingBarContainerProps>`
    display: flex;
    height: 48px;
    max-height: ${(props) => (props.open ? '100px' : 0)};
    padding-left: 7px;
    background: rgba(var(--center-channel-color-rgb), 0.04);
    align-items: center;
    gap: 4px;
    transform-origin: top;
    transition: max-height 0.25s ease;

    &.wide ${Separator} {
        display: block;
    }
`;

const HiddenControlsContainer = styled.div`
    padding: 5px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
    border-radius: 4px;
    border: 1px solid rgba(var(--center-channel-color-rgb), 0.16);
    background: var(--center-channel-bg);
    z-index: -1;

    transition: transform 250ms ease, opacity 250ms ease;
    transform: scale(0);
    opacity: 0;
    display: flex;

    &.scale-enter {
        transform: scale(0);
        opacity: 0;
        z-index: 20;
    }

    &.scale-enter-active {
        transform: scale(1);
        opacity: 1;
        z-index: 20;
    }

    &.scale-enter-done {
        transform: scale(1);
        opacity: 1;
        z-index: 20;
    }

    &.scale-exit {
        transform: scale(1);
        opacity: 1;
        z-index: 20;
    }

    &.scale-exit-active {
        transform: scale(0);
        opacity: 0;
        z-index: 20;
    }

    &.scale-exit-done {
        transform: scale(0);
        opacity: 0;
        z-index: -1;
    }
`;

interface FormattingBarProps {

    /**
     * prop that determines if the FormattingBar is visible
     */
    isOpen: boolean;

    /**
     * prop that determines if the Formatting Controls are visible
     */
    showFormattingControls: boolean;

    /**
     * the current inputValue
     * This is needed to apply the markdown to the correct place
     */
    getCurrentMessage: () => string;

    /**
     * The textbox element tied to the advanced texteditor
     * NOTE: Since the only thing we need from that is the current selection
     *       range we should probably refactor this and only pass down the
     *       selectionStart and selectionEnd values
     */
    getCurrentSelection: () => {start: number; end: number};

    /**
     * the handler function that applies the markdown to the value
     */
    applyMarkdown: (options: ApplyMarkdownOptions) => void;

    /**
     * disable formatting controls when the texteditor is in preview state
     */
    disableControls: boolean;
    extraControls: JSX.Element;
    toggleAdvanceTextEditor: () => void;

    /**
     * location of the advanced text editor in the UI (center channel / RHS)
     */
    location: string;

    /*
     * controls that enhance the message,
     * e.g: message priority picker
     */
    additionalControls?: React.ReactNodeArray;
}

const FormattingBar = (props: FormattingBarProps): JSX.Element => {
    const {
        isOpen,
        showFormattingControls,
        applyMarkdown,
        getCurrentSelection,
        getCurrentMessage,
        disableControls,
        extraControls,
        toggleAdvanceTextEditor,
        location,
        additionalControls,
    } = props;
    const [showHiddenControls, setShowHiddenControls] = useState(false);
    const formattingBarRef = useRef<HTMLDivElement>(null);
    const {controls, hiddenControls, wideMode} = useFormattingBarControls(formattingBarRef);

    const {formatMessage} = useIntl();
    const HiddenControlsButtonAriaLabel = formatMessage({id: 'accessibility.button.hidden_controls_button', defaultMessage: 'show hidden formatting options'});

    const {x, y, reference, floating, strategy, update, refs: {reference: buttonRef, floating: floatingRef}} = useFloating<HTMLButtonElement>({
        placement: 'top',
        middleware: [offset({mainAxis: 4})],
    });

    // this little helper hook always returns the latest refs and does not mess with the popper placement calculation
    const getLatest = useGetLatest({
        showHiddenControls,
        buttonRef,
        floatingRef,
    });

    useEffect(() => {
        const handleClickOutside: EventListener = (event) => {
            const {floatingRef, buttonRef} = getLatest();
            const target = event.composedPath?.()?.[0] || event.target;
            if (target instanceof Node) {
                if (
                    floatingRef !== null &&
                    buttonRef !== null &&
                    !floatingRef.current?.contains(target) &&
                    !buttonRef.current?.contains(target)
                ) {
                    setShowHiddenControls(false);
                }
            }
        };

        document.addEventListener('mousedown', handleClickOutside);

        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, [getLatest, setShowHiddenControls]);

    useEffect(() => {
        if (!isOpen) {
            setShowHiddenControls(false);
        }
    }, [isOpen]);

    useEffect(() => {
        update?.();
    }, [wideMode, update, showHiddenControls]);

    const hasHiddenControls = wideMode !== 'wide';

    const toggleHiddenControls = useCallback((event?) => {
        if (event) {
            event.preventDefault();
        }
        setShowHiddenControls(!showHiddenControls);
    }, [showHiddenControls]);

    /**
     * wrapping this factory in useCallback prevents it from constantly getting a new
     * function signature as if we would define it directly in the props of
     * the FormattingIcon component. This should improve render-performance
     */
    const makeFormattingHandler = useCallback((mode) => () => {
        // if the formatting is disabled just return without doing anything
        if (disableControls) {
            return;
        }

        // get the current selection values and return early (doing nothing) when we don't get valid values
        const {start, end} = getCurrentSelection();

        if (start === null || end === null) {
            return;
        }

        const value = getCurrentMessage();

        applyMarkdown({
            markdownMode: mode,
            selectionStart: start,
            selectionEnd: end,
            message: value,
        });

        // if hidden controls are currently open close them
        if (showHiddenControls) {
            toggleHiddenControls();
        }
    }, [getCurrentSelection, getCurrentMessage, applyMarkdown, showHiddenControls, toggleHiddenControls, disableControls]);

    const hiddenControlsContainerStyles: React.CSSProperties = {
        position: strategy,
        top: y ?? 0,
        left: x ?? 0,
    };

    return (
        <FormattingBarContainer
            open={isOpen}
            ref={formattingBarRef}
        >
            <ToggleFormattingBar
                onClick={toggleAdvanceTextEditor}
                active={showFormattingControls}
                disabled={false}
            />
            {additionalControls}
            <Separator show={true}/>
            {showFormattingControls && controls.map((mode) => {
                const insertSeparator = mode === 'heading' || mode === 'ol';
                return (
                    <React.Fragment key={mode}>
                        <FormattingIcon
                            mode={mode}
                            className='control'
                            onClick={makeFormattingHandler(mode)}
                            disabled={disableControls}
                        />
                        {insertSeparator && <Separator show={wideMode === 'wide'}/>}
                    </React.Fragment>
                );
            })}

            {hasHiddenControls && showFormattingControls && (
                <>
                    <IconContainer
                        id={'HiddenControlsButton' + location}
                        ref={reference}
                        className={classNames({active: showHiddenControls})}
                        onClick={toggleHiddenControls}
                        aria-label={HiddenControlsButtonAriaLabel}
                    >
                        <DotsHorizontalIcon
                            color={'currentColor'}
                            size={18}
                        />
                    </IconContainer>
                    <Separator show={true}/>
                </>
            )}
            <CSSTransition
                timeout={250}
                classNames='scale'
                in={showHiddenControls}
            >
                <HiddenControlsContainer
                    ref={floating}
                    style={hiddenControlsContainerStyles}
                >
                    {hiddenControls.map((mode) => {
                        return (
                            <FormattingIcon
                                key={mode}
                                mode={mode}
                                className='control'
                                onClick={makeFormattingHandler(mode)}
                                disabled={disableControls}
                            />
                        );
                    })}
                </HiddenControlsContainer>
            </CSSTransition>
            {extraControls}
        </FormattingBarContainer>
    );
};

export default memo(FormattingBar);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo} from 'react';
import classNames from 'classnames';
import {useIntl} from 'react-intl';
import {EyeOutlineIcon} from '@mattermost/compass-icons/components';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import KeyboardShortcutSequence, {KEYBOARD_SHORTCUTS} from 'components/keyboard_shortcuts/keyboard_shortcuts_sequence';
import Constants from 'utils/constants';

import {IconContainer} from '../formatting_bar/formatting_icon';

interface ShowFormatProps {
    onClick: (event: React.MouseEvent) => void;
    active: boolean;
}

const ShowFormatting = (props: ShowFormatProps): JSX.Element => {
    const {formatMessage} = useIntl();
    const {onClick, active} = props;
    const buttonAriaLabel = formatMessage({id: 'accessibility.button.preview', defaultMessage: 'preview'});
    const iconAriaLabel = formatMessage({id: 'generic_icons.preview', defaultMessage: 'Eye Icon'});

    const tooltip = (
        <Tooltip id='PreviewInputTextButtonTooltip'>
            <KeyboardShortcutSequence
                shortcut={KEYBOARD_SHORTCUTS.msgMarkdownPreview}
                hoistDescription={true}
                isInsideTooltip={true}
            />
        </Tooltip>
    );

    return (
        <OverlayTrigger
            placement='left'
            delayShow={Constants.OVERLAY_TIME_DELAY}
            trigger={Constants.OVERLAY_DEFAULT_TRIGGER}
            overlay={tooltip}
        >
            <IconContainer
                type='button'
                id='PreviewInputTextButton'
                onClick={onClick}
                aria-label={buttonAriaLabel}
                className={classNames({active})}
            >
                <EyeOutlineIcon
                    size={18}
                    color={'currentColor'}
                    aria-label={iconAriaLabel}
                />
            </IconContainer>
        </OverlayTrigger>
    );
};

export default memo(ShowFormatting);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {FormEvent, memo} from 'react';
import {useIntl} from 'react-intl';
import styled from 'styled-components';
import {SendIcon} from '@mattermost/compass-icons/components';

import {t} from 'utils/i18n';

type SendButtonProps = {
    handleSubmit: (e: React.FormEvent) => void;
    disabled: boolean;
}

const SendButtonContainer = styled.button`
    display: flex;
    height: 32px;
    padding: 0 16px;
    border: none;
    background: var(--button-bg);
    border-radius: 4px;
    color: var(--button-color);
    cursor: pointer;
    place-content: center;
    place-items: center;
    transition: color 150ms;

    &--disabled,
    &[disabled] {
        background: rgba(var(--center-channel-color-rgb), 0.08);

        svg {
            fill: rgba(var(--center-channel-color-rgb), 0.32);
        }
    }

    .android &,
    .ios & {
        display: flex;
    }
`;

const SendButton = ({disabled, handleSubmit}: SendButtonProps) => {
    const {formatMessage} = useIntl();

    const sendMessage = (e: React.FormEvent) => {
        e.stopPropagation();
        e.preventDefault();
        handleSubmit(e);
    };

    return (
        <SendButtonContainer
            data-testid='SendMessageButton'
            tabIndex={0}
            aria-label={formatMessage({
                id: 'create_post.send_message',
                defaultMessage: 'Send a message',
            })}
            disabled={disabled}
            onClick={sendMessage}
        >
            <SendIcon
                size={18}
                color='currentColor'
                aria-label={formatMessage({
                    id: t('create_post.icon'),
                    defaultMessage: 'Create a post',
                })}
            />
        </SendButtonContainer>
    );
};

export default memo(SendButton);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {CSSProperties, useCallback, useRef, useState} from 'react';
import classNames from 'classnames';
import {FormattedMessage, useIntl} from 'react-intl';
import {EmoticonHappyOutlineIcon} from '@mattermost/compass-icons/components';

import {PostDraft} from 'types/store/draft';

import EmojiPickerOverlay from 'components/emoji_picker/emoji_picker_overlay';
import FilePreview from 'components/file_preview';
import FileUpload from 'components/file_upload';
import MsgTyping from 'components/msg_typing';
import Textbox, {TextboxElement} from 'components/textbox';
import TextboxClass from 'components/textbox/textbox';
import MessageSubmitError from 'components/message_submit_error';
import {FilePreviewInfo} from 'components/file_preview/file_preview';
import {SendMessageTour} from 'components/tours/onboarding_tour';
import {FileUpload as FileUploadClass} from 'components/file_upload/file_upload';
import OverlayTrigger from 'components/overlay_trigger';
import KeyboardShortcutSequence, {KEYBOARD_SHORTCUTS} from 'components/keyboard_shortcuts/keyboard_shortcuts_sequence';

import * as Utils from 'utils/utils';
import {ApplyMarkdownOptions} from 'utils/markdown/apply_markdown';
import Constants, {Locations} from 'utils/constants';

import {Channel} from '@mattermost/types/channels';
import {ServerError} from '@mattermost/types/errors';
import {FileInfo} from '@mattermost/types/files';
import {Emoji} from '@mattermost/types/emojis';
import RhsSuggestionList from '../suggestion/rhs_suggestion_list';
import Tooltip from '../tooltip';

import TexteditorActions from './texteditor_actions';
import FormattingBar from './formatting_bar';
import ShowFormat from './show_formatting';
import SendButton from './send_button';
import {IconContainer} from './formatting_bar/formatting_icon';

import './advanced_text_editor.scss';

type Props = {

    /**
     * location of the advanced text editor in the UI (center channel / RHS)
     */
    location: string;
    currentUserId: string;
    message: string;
    showEmojiPicker: boolean;
    uploadsProgressPercent: { [clientID: string]: FilePreviewInfo };
    currentChannel?: Channel;
    errorClass: string | null;
    serverError: (ServerError & { submittedMessage?: string }) | null;
    postError?: React.ReactNode;
    isFormattingBarHidden: boolean;
    draft: PostDraft;
    showSendTutorialTip?: boolean;
    handleSubmit: (e: React.FormEvent) => void;
    removePreview: (id: string) => void;
    setShowPreview: (newPreviewValue: boolean) => void;
    shouldShowPreview: boolean;
    maxPostSize: number;
    canPost: boolean;
    applyMarkdown: (params: ApplyMarkdownOptions) => void;
    useChannelMentions: boolean;
    badConnection: boolean;
    currentChannelTeammateUsername?: string;
    canUploadFiles: boolean;
    enableEmojiPicker: boolean;
    enableGifPicker: boolean;
    handleBlur: () => void;
    handlePostError: (postError: React.ReactNode) => void;
    emitTypingEvent: () => void;
    handleMouseUpKeyUp: (e: React.MouseEvent<TextboxElement> | React.KeyboardEvent<TextboxElement>) => void;
    handleSelect: (e: React.SyntheticEvent<TextboxElement>) => void;
    handleKeyDown: (e: React.KeyboardEvent<TextboxElement>) => void;
    postMsgKeyPress: (e: React.KeyboardEvent<TextboxElement>) => void;
    handleChange: (e: React.ChangeEvent<TextboxElement>) => void;
    toggleEmojiPicker: () => void;
    handleGifClick: (gif: string) => void;
    handleEmojiClick: (emoji: Emoji) => void;
    hideEmojiPicker: () => void;
    toggleAdvanceTextEditor: () => void;
    handleUploadProgress: (filePreviewInfo: FilePreviewInfo) => void;
    handleUploadError: (err: string | ServerError, clientId?: string, channelId?: string) => void;
    handleFileUploadComplete: (fileInfos: FileInfo[], clientIds: string[], channelId: string, rootId?: string) => void;
    handleUploadStart: (clientIds: string[], channelId: string) => void;
    handleFileUploadChange: () => void;
    getFileUploadTarget: () => HTMLInputElement | null;
    fileUploadRef: React.RefObject<FileUploadClass>;
    prefillMessage?: (message: string, shouldFocus?: boolean) => void;
    channelId: string;
    postId: string;
    textboxRef: React.RefObject<TextboxClass>;
    isThreadView?: boolean;
    additionalControls?: React.ReactNodeArray;
    labels?: React.ReactNode;
}

const AdvanceTextEditor = ({
    location,
    message,
    showEmojiPicker,
    uploadsProgressPercent,
    currentChannel,
    channelId,
    postId,
    errorClass,
    serverError,
    postError,
    isFormattingBarHidden,
    draft,
    badConnection,
    handleSubmit,
    removePreview,
    showSendTutorialTip,
    setShowPreview,
    shouldShowPreview,
    maxPostSize,
    canPost,
    applyMarkdown,
    useChannelMentions,
    currentChannelTeammateUsername,
    currentUserId,
    canUploadFiles,
    enableEmojiPicker,
    enableGifPicker,
    handleBlur,
    handlePostError,
    emitTypingEvent,
    handleMouseUpKeyUp,
    handleSelect,
    handleKeyDown,
    postMsgKeyPress,
    handleChange,
    toggleEmojiPicker,
    handleGifClick,
    handleEmojiClick,
    hideEmojiPicker,
    toggleAdvanceTextEditor,
    handleUploadProgress,
    handleUploadError,
    handleFileUploadComplete,
    handleUploadStart,
    handleFileUploadChange,
    getFileUploadTarget,
    fileUploadRef,
    prefillMessage,
    textboxRef,
    isThreadView,
    additionalControls,
    labels,
}: Props) => {
    const readOnlyChannel = !canPost;
    const {formatMessage} = useIntl();
    const ariaLabelMessageInput = Utils.localizeMessage(
        'accessibility.sections.centerFooter',
        'message input complimentary region',
    );
    const emojiPickerRef = useRef<HTMLButtonElement>(null);

    const [scrollbarWidth, setScrollbarWidth] = useState(0);
    const [renderScrollbar, setRenderScrollbar] = useState(false);

    const handleHeightChange = useCallback((height: number, maxHeight: number) => {
        setRenderScrollbar(height > maxHeight);

        window.requestAnimationFrame(() => {
            if (textboxRef.current) {
                setScrollbarWidth(Utils.scrollbarWidth(textboxRef.current.getInputBox()));
            }
        });
    }, [textboxRef.current]);

    const handleShowFormat = useCallback(() => {
        setShowPreview(!shouldShowPreview);
    }, [shouldShowPreview, setShowPreview]);

    let serverErrorJsx = null;
    if (serverError) {
        serverErrorJsx = (
            <MessageSubmitError
                error={serverError}
                submittedMessage={serverError.submittedMessage}
                handleSubmit={handleSubmit}
            />
        );
    }

    let attachmentPreview = null;
    if (!readOnlyChannel && (draft.fileInfos.length > 0 || draft.uploadsInProgress.length > 0)) {
        attachmentPreview = (
            <div>
                <FilePreview
                    fileInfos={draft.fileInfos}
                    onRemove={removePreview}
                    uploadsInProgress={draft.uploadsInProgress}
                    uploadsProgressPercent={uploadsProgressPercent}
                />
            </div>
        );
    }

    const getFileCount = () => {
        return draft.fileInfos.length + draft.uploadsInProgress.length;
    };

    let postType = 'post';
    if (postId) {
        postType = isThreadView ? 'thread' : 'comment';
    }

    const fileUploadJSX = readOnlyChannel ? null : (
        <FileUpload
            ref={fileUploadRef}
            fileCount={getFileCount()}
            getTarget={getFileUploadTarget}
            onFileUploadChange={handleFileUploadChange}
            onUploadStart={handleUploadStart}
            onFileUpload={handleFileUploadComplete}
            onUploadError={handleUploadError}
            onUploadProgress={handleUploadProgress}
            rootId={postId}
            channelId={channelId}
            postType={postType}
        />
    );

    const getEmojiPickerRef = () => {
        return emojiPickerRef.current;
    };

    let emojiPicker = null;
    const emojiButtonAriaLabel = formatMessage({
        id: 'emoji_picker.emojiPicker',
        defaultMessage: 'Emoji Picker',
    }).toLowerCase();

    if (enableEmojiPicker && !readOnlyChannel) {
        const emojiPickerTooltip = (
            <Tooltip id='upload-tooltip'>
                <KeyboardShortcutSequence
                    shortcut={KEYBOARD_SHORTCUTS.msgShowEmojiPicker}
                    hoistDescription={true}
                    isInsideTooltip={true}
                />
            </Tooltip>
        );
        emojiPicker = (
            <>
                <EmojiPickerOverlay
                    show={showEmojiPicker}
                    target={getEmojiPickerRef}
                    onHide={hideEmojiPicker}
                    onEmojiClick={handleEmojiClick}
                    onGifClick={handleGifClick}
                    enableGifPicker={enableGifPicker}
                    topOffset={-7}
                />
                <OverlayTrigger
                    placement='top'
                    delayShow={Constants.OVERLAY_TIME_DELAY}
                    trigger={Constants.OVERLAY_DEFAULT_TRIGGER}
                    overlay={emojiPickerTooltip}
                >
                    <IconContainer
                        id={'emojiPickerButton'}
                        ref={emojiPickerRef}
                        onClick={toggleEmojiPicker}
                        type='button'
                        aria-label={emojiButtonAriaLabel}
                        disabled={shouldShowPreview}
                        className={classNames({active: showEmojiPicker})}
                    >
                        <EmoticonHappyOutlineIcon
                            color={'currentColor'}
                            size={18}
                        />
                    </IconContainer>
                </OverlayTrigger>
            </>
        );
    }

    const disableSendButton = Boolean(readOnlyChannel || (!message.trim().length && !draft.fileInfos.length));
    const sendButton = readOnlyChannel ? null : (
        <SendButton
            disabled={disableSendButton}
            handleSubmit={handleSubmit}
        />
    );

    const showFormatJSX = disableSendButton ? null : (
        <ShowFormat
            onClick={handleShowFormat}
            active={shouldShowPreview}
        />
    );

    const extraControls = (
        <>
            {fileUploadJSX}
            {emojiPicker}
        </>
    );

    let createMessage;
    if (currentChannel && !readOnlyChannel) {
        createMessage = formatMessage(
            {
                id: 'create_post.write',
                defaultMessage: 'Write to {channelDisplayName}',
            },
            {channelDisplayName: currentChannel.display_name},
        );
    } else if (readOnlyChannel) {
        createMessage = Utils.localizeMessage(
            'create_post.read_only',
            'This channel is read-only. Only members with permission can post here.',
        );
    } else {
        createMessage = Utils.localizeMessage('create_comment.addComment', 'Reply to this thread...');
    }

    const messageValue = readOnlyChannel ? '' : message;

    /**
     * by getting the value directly from the textbox we eliminate all unnecessary
     * re-renders for the FormattingBar component. The previous method of always passing
     * down the current message value that came from the parents state was not optimal,
     * although still working as expected
     */
    const getCurrentValue = useCallback(() => textboxRef.current?.getInputBox().value, [textboxRef]);
    const getCurrentSelection = useCallback(() => {
        const input = textboxRef.current?.getInputBox();

        return {
            start: input.selectionStart,
            end: input.selectionEnd,
        };
    }, [textboxRef]);

    let textboxId = 'textbox';

    switch (location) {
    case Locations.CENTER:
        textboxId = 'post_textbox';
        break;
    case Locations.RHS_COMMENT:
        textboxId = 'reply_textbox';
        break;
    case Locations.MODAL:
        textboxId = 'modal_textbox';
        break;
    }

    const formattingBar = readOnlyChannel ? null : (
        <FormattingBar
            applyMarkdown={applyMarkdown}
            getCurrentMessage={getCurrentValue}
            getCurrentSelection={getCurrentSelection}
            isOpen={true}
            disableControls={shouldShowPreview}
            additionalControls={additionalControls}
            extraControls={extraControls}
            toggleAdvanceTextEditor={toggleAdvanceTextEditor}
            showFormattingControls={!isFormattingBarHidden}
            location={location}
        />
    );

    return (
        <div
            className={classNames('AdvancedTextEditor', {
                'AdvancedTextEditor__attachment-disabled': !canUploadFiles,
                scroll: renderScrollbar,
            })}
            style={
                renderScrollbar && scrollbarWidth ? ({
                    '--detected-scrollbar-width': `${scrollbarWidth}px`,
                } as CSSProperties) : undefined
            }
        >
            <div
                id={'speak-'}
                aria-live='assertive'
                className='sr-only'
            >
                {
                    <FormattedMessage
                        id='channelView.login.successfull'
                        defaultMessage='Login Successfull'
                    />
                }
            </div>
            <div
                className={'AdvancedTextEditor__body'}
                disabled={readOnlyChannel}
            >
                <div
                    role='application'
                    id='advancedTextEditorCell'
                    data-a11y-sort-order='2'
                    aria-label={
                        Utils.localizeMessage(
                            'channelView.login.successfull',
                            'Login Successfull',
                        ) + ' ' + ariaLabelMessageInput
                    }
                    tabIndex={-1}
                    className='AdvancedTextEditor__cell a11y__region'
                >
                    {labels}
                    <Textbox
                        hasLabels={Boolean(labels)}
                        suggestionList={RhsSuggestionList}
                        onChange={handleChange}
                        onKeyPress={postMsgKeyPress}
                        onKeyDown={handleKeyDown}
                        onSelect={handleSelect}
                        onMouseUp={handleMouseUpKeyUp}
                        onKeyUp={handleMouseUpKeyUp}
                        onComposition={emitTypingEvent}
                        onHeightChange={handleHeightChange}
                        handlePostError={handlePostError}
                        value={messageValue}
                        onBlur={handleBlur}
                        emojiEnabled={enableEmojiPicker}
                        createMessage={createMessage}
                        channelId={channelId}
                        id={textboxId}
                        ref={textboxRef!}
                        disabled={readOnlyChannel}
                        characterLimit={maxPostSize}
                        preview={shouldShowPreview}
                        badConnection={badConnection}
                        listenForMentionKeyClick={true}
                        useChannelMentions={useChannelMentions}
                        rootId={postId}
                    />
                    {attachmentPreview}
                    <TexteditorActions
                        placement='top'
                    >
                        {showFormatJSX}
                    </TexteditorActions>
                    {formattingBar}
                    <TexteditorActions
                        placement='bottom'
                    >
                        {sendButton}
                    </TexteditorActions>
                </div>
                {showSendTutorialTip && currentChannel && prefillMessage &&
                    <SendMessageTour
                        prefillMessage={prefillMessage}
                        currentChannel={currentChannel}
                        currentUserId={currentUserId}
                        currentChannelTeammateUsername={currentChannelTeammateUsername}
                    />}
            </div>
            <div
                id='postCreateFooter'
                role='form'
                className={classNames('AdvancedTextEditor__footer', {
                    'AdvancedTextEditor__footer--has-error': postError || serverError,
                })}
            >
                {postError && <label className={classNames('post-error', {errorClass})}>{postError}</label>}
                {serverErrorJsx}
                <MsgTyping
                    channelId={channelId}
                    postId={postId}
                />
            </div>
        </div>
    );
};

export default AdvanceTextEditor;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo} from 'react';
import {MessageDescriptor, useIntl} from 'react-intl';
import styled from 'styled-components';
import {
    FormatBoldIcon,
    FormatItalicIcon,
    LinkVariantIcon,
    FormatStrikethroughVariantIcon,
    CodeTagsIcon,
    FormatHeaderIcon,
    FormatQuoteOpenIcon,
    FormatListBulletedIcon,
    FormatListNumberedIcon,
} from '@mattermost/compass-icons/components';
import IconProps from '@mattermost/compass-icons/components/props';

import KeyboardShortcutSequence, {
    KeyboardShortcutDescriptor,
    KEYBOARD_SHORTCUTS,
} from 'components/keyboard_shortcuts/keyboard_shortcuts_sequence';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';

import {MarkdownMode} from 'utils/markdown/apply_markdown';
import Constants from 'utils/constants';
import {t} from 'utils/i18n';

export const IconContainer = styled.button`
    display: flex;
    width: 32px;
    height: 32px;
    place-items: center;
    place-content: center;
    border: none;
    background: transparent;
    padding: 0;
    border-radius: 4px;
    color: rgba(var(--center-channel-color-rgb), 0.56);

    &:hover {
        background: rgba(var(--center-channel-color-rgb), 0.08);
        color: rgba(var(--center-channel-color-rgb), 0.72);
        fill: currentColor;
    }

    &:active,
    &.active,
    &.active:hover {
        background: rgba(var(--button-bg-rgb), 0.08);
        color: var(--button-bg);
        fill: currentColor;
    }

    &[disabled] {
        pointer-events: none;
        cursor: not-allowed;
        color: rgba(var(--center-channel-color-rgb), 0.32);

        &:hover,
        &:active,
        &.active,
        &.active:hover {
            background: inherit;
            color: inherit;
            fill: inherit;
        }
    }
`;

interface FormattingIconProps {
    mode: MarkdownMode;
    onClick?: () => void;
    className?: string;
    disabled?: boolean;
}

const MAP_MARKDOWN_MODE_TO_ICON: Record<FormattingIconProps['mode'], React.FC<IconProps>> = {
    bold: FormatBoldIcon,
    italic: FormatItalicIcon,
    link: LinkVariantIcon,
    strike: FormatStrikethroughVariantIcon,
    code: CodeTagsIcon,
    heading: FormatHeaderIcon,
    quote: FormatQuoteOpenIcon,
    ul: FormatListBulletedIcon,
    ol: FormatListNumberedIcon,
};

const MAP_MARKDOWN_MODE_TO_ARIA_LABEL: Record<FormattingIconProps['mode'], MessageDescriptor> = {
    bold: {id: t('accessibility.button.bold'), defaultMessage: 'bold'},
    italic: {id: t('accessibility.button.italic'), defaultMessage: 'italic'},
    link: {id: t('accessibility.button.link'), defaultMessage: 'link'},
    strike: {id: t('accessibility.button.strike'), defaultMessage: 'strike through'},
    code: {id: t('accessibility.button.code'), defaultMessage: 'code'},
    heading: {id: t('accessibility.button.heading'), defaultMessage: 'heading'},
    quote: {id: t('accessibility.button.quote'), defaultMessage: 'quote'},
    ul: {id: t('accessibility.button.bulleted_list'), defaultMessage: 'bulleted list'},
    ol: {id: t('accessibility.button.numbered_list'), defaultMessage: 'numbered list'},
};

const MAP_MARKDOWN_MODE_TO_KEYBOARD_SHORTCUTS: Record<FormattingIconProps['mode'], KeyboardShortcutDescriptor> = {
    bold: KEYBOARD_SHORTCUTS.msgMarkdownBold,
    italic: KEYBOARD_SHORTCUTS.msgMarkdownItalic,
    link: KEYBOARD_SHORTCUTS.msgMarkdownLink,
    strike: KEYBOARD_SHORTCUTS.msgMarkdownStrike,
    code: KEYBOARD_SHORTCUTS.msgMarkdownCode,
    heading: KEYBOARD_SHORTCUTS.msgMarkdownH3,
    quote: KEYBOARD_SHORTCUTS.msgMarkdownQuote,
    ul: KEYBOARD_SHORTCUTS.msgMarkdownUl,
    ol: KEYBOARD_SHORTCUTS.msgMarkdownOl,
};

const FormattingIcon = (props: FormattingIconProps): JSX.Element => {
    /**
     * by passing in the otherProps spread we guarantee that accessibility
     * properties like aria-label, etc. get added to the DOM
     */
    const {mode, onClick, ...otherProps} = props;

    /* get the correct Icon from the IconMap */
    const Icon = MAP_MARKDOWN_MODE_TO_ICON[mode];
    const {formatMessage} = useIntl();
    const ariaLabelDefinition = MAP_MARKDOWN_MODE_TO_ARIA_LABEL[mode];
    const buttonAriaLabel = formatMessage(ariaLabelDefinition);

    const bodyAction = (
        <IconContainer
            type='button'
            id={`FormattingControl_${mode}`}
            onClick={onClick}
            aria-label={buttonAriaLabel}
            {...otherProps}
        >
            <Icon
                color={'currentColor'}
                size={18}
            />
        </IconContainer>
    );

    /* get the correct tooltip from the ShortcutsMap */
    const shortcut = MAP_MARKDOWN_MODE_TO_KEYBOARD_SHORTCUTS[mode];
    const tooltip = (
        <Tooltip id='upload-tooltip'>
            <KeyboardShortcutSequence
                shortcut={shortcut}
                hoistDescription={true}
                isInsideTooltip={true}
            />
        </Tooltip>
    );

    return (
        <OverlayTrigger
            delayShow={Constants.OVERLAY_TIME_DELAY}
            placement='top'
            trigger={['hover', 'focus']}
            overlay={tooltip}
        >
            {bodyAction}
        </OverlayTrigger>
    );
};

export default memo(FormattingIcon);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useState} from 'react';
import classNames from 'classnames';

import {useIntl} from 'react-intl';
import {
    AlertOutlineIcon,
    CheckIcon,
    CloseIcon,
    InformationOutlineIcon,
} from '@mattermost/compass-icons/components';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import Constants from 'utils/constants';

import './alert_banner.scss';

export type ModeType = 'danger' | 'warning' | 'info' | 'success';

export type AlertBannerProps = {
    mode: ModeType;
    title?: React.ReactNode;
    message?: React.ReactNode;
    children?: React.ReactNode;
    className?: string;
    hideIcon?: boolean;
    actionButtonLeft?: React.ReactNode;
    actionButtonRight?: React.ReactNode;
    closeBtnTooltip?: React.ReactNode;
    onDismiss?: () => void;
    variant?: 'sys' | 'app';
}

const AlertBanner = ({
    mode,
    title,
    message,
    className,
    variant = 'sys',
    onDismiss,
    actionButtonLeft,
    actionButtonRight,
    closeBtnTooltip,
    hideIcon,
    children,
}: AlertBannerProps) => {
    const {formatMessage} = useIntl();
    const [tooltipId] = useState(`alert_banner_close_btn_tooltip_${Math.random()}`);

    const bannerIcon = useCallback(() => {
        if (mode === 'danger' || mode === 'warning') {
            return (
                <AlertOutlineIcon
                    size={24}
                />);
        } else if (mode === 'success') {
            return (
                <CheckIcon
                    size={24}
                />);
        }
        return (
            <InformationOutlineIcon
                size={24}
            />);
    }, [mode]);

    return (
        <div
            className={classNames(
                'AlertBanner',
                mode,
                className,
                `AlertBanner--${variant}`,
            )}
        >
            {!hideIcon && (
                <div className='AlertBanner__icon'>
                    {bannerIcon()}
                </div>
            )}
            <div className='AlertBanner__body'>
                {title && <div className='AlertBanner__title'>{title}</div>}
                {message && (
                    <div
                        className={classNames({
                            AlertBanner__message: Boolean(title),
                        })}
                    >
                        {message}
                    </div>
                )}
                {children}
                {(actionButtonLeft || actionButtonRight) && (
                    <div className='AlertBanner__actionButtons'>
                        {actionButtonLeft}
                        {actionButtonRight}
                    </div>
                )}
            </div>
            {onDismiss && (
                <OverlayTrigger
                    trigger={['hover', 'focus']}
                    delayShow={Constants.OVERLAY_TIME_DELAY}
                    placement='left'
                    overlay={closeBtnTooltip || (
                        <Tooltip id={tooltipId}>
                            {formatMessage({id: 'alert_banner.tooltipCloseBtn', defaultMessage: 'Close'})}
                        </Tooltip>
                    )}
                >
                    <button
                        className='AlertBanner__closeButton'
                        onClick={onDismiss}
                    >
                        <CloseIcon
                            size={18}
                        />
                    </button>
                </OverlayTrigger>
            )}
        </div>
    );
};

export default AlertBanner;

export default __webpack_public_path__ + "files/877d78882f3d31cbbd77cf4c998d4864.svg";
export default __webpack_public_path__ + "files/6c02c0a94bc222d7b9ff517af9d1ca40.svg";
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionTypes} from 'utils/constants';

export function incrementAnnouncementBarCount() {
    return {
        type: ActionTypes.TRACK_ANNOUNCEMENT_BAR,
    };
}

export function decrementAnnouncementBarCount() {
    return {
        type: ActionTypes.DISMISS_ANNOUNCEMENT_BAR,
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {CSSProperties} from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

import {UserProfile} from '@mattermost/types/users';
import {AnalyticsRow} from '@mattermost/types/admin';
import {ActionResult} from 'mattermost-redux/types/actions';
import {WarnMetricStatus} from '@mattermost/types/config';

import {getSiteURL} from 'utils/url';
import {t} from 'utils/i18n';
import {Constants, ModalIdentifiers, WarnMetricTypes} from 'utils/constants';

import {trackEvent} from 'actions/telemetry_actions';
import * as AdminActions from 'actions/admin_actions.jsx';

const StatTypes = Constants.StatTypes;

import * as Utils from 'utils/utils';

import LoadingWrapper from 'components/widgets/loading/loading_wrapper';
import ErrorLink from 'components/error_page/error_link';

type Props = {
    user: UserProfile;
    telemetryId?: string;
    show: boolean;
    closeParentComponent?: () => Promise<void>;
    stats?: Record<string, number | AnalyticsRow[]>;
    warnMetricStatus: WarnMetricStatus;
    actions: {
        closeModal: (modalId: string) => void;
        getStandardAnalytics: () => void;
        sendWarnMetricAck: (warnMetricId: string, forceAck: boolean) => Promise<ActionResult>;
    };
}

type State = {
    serverError: string | null;
    gettingTrial: boolean;
    gettingTrialError: string | null;
    saving: boolean;
}

const containerStyles: CSSProperties = {
    display: 'flex',
    opacity: '0.56',
    flexWrap: 'wrap',
};

export default class WarnMetricAckModal extends React.PureComponent<Props, State> {
    public constructor(props: Props) {
        super(props);
        this.state = {
            saving: false,
            serverError: null,
            gettingTrial: false,
            gettingTrialError: null,
        };
    }

    componentDidMount() {
        AdminActions.getStandardAnalytics();
    }

    onContactUsClick = async (e: any) => {
        if (this.state.saving) {
            return;
        }

        this.setState({saving: true, serverError: null});

        let forceAck = false;
        if (e && e.target && e.target.dataset && e.target.dataset.forceack) {
            forceAck = true;
            trackEvent('admin', 'click_warn_metric_mailto', {metric: this.props.warnMetricStatus.id});
        } else {
            trackEvent('admin', 'click_warn_metric_contact_us', {metric: this.props.warnMetricStatus.id});
        }

        const {error} = await this.props.actions.sendWarnMetricAck(this.props.warnMetricStatus.id, forceAck);
        if (error) {
            this.setState({serverError: error, saving: false});
        } else {
            this.onHide();
        }
    }

    onHide = () => {
        this.setState({serverError: null, saving: false});

        this.setState({gettingTrialError: null, gettingTrial: false});
        this.props.actions.closeModal(ModalIdentifiers.WARN_METRIC_ACK);
        if (this.props.closeParentComponent) {
            this.props.closeParentComponent();
        }
    }

    renderContactUsError = () => {
        const {serverError} = this.state;
        if (!serverError) {
            return '';
        }

        const mailRecipient = 'support-advisor@mattermost.com';
        const mailSubject = 'Mattermost Contact Us request';
        let mailBody = 'Mattermost Contact Us request.';
        if (this.props.warnMetricStatus.id === WarnMetricTypes.SYSTEM_WARN_METRIC_NUMBER_OF_ACTIVE_USERS_500) {
            mailBody = 'Mattermost Contact Us request.\r\nMy team now has 500 users, and I am considering Mattermost Enterprise Edition.';
        } else if (this.props.warnMetricStatus.id === WarnMetricTypes.SYSTEM_WARN_METRIC_NUMBER_OF_POSTS_2M) {
            mailBody = 'Mattermost Contact Us request.\r\nI am interested in learning more about improving performance with Elasticsearch.';
        }

        mailBody += '\r\n';
        mailBody += 'Contact ' + this.props.user.first_name + ' ' + this.props.user.last_name;
        mailBody += '\r\n';
        mailBody += 'Email ' + this.props.user.email;
        mailBody += '\r\n';

        if (this.props.stats && this.props.stats[StatTypes.TOTAL_USERS]) {
            mailBody += 'Registered Users ' + this.props.stats[StatTypes.TOTAL_USERS];
            mailBody += '\r\n';
        }
        mailBody += 'Site URL ' + getSiteURL();
        mailBody += '\r\n';

        mailBody += 'Telemetry Id ' + this.props.telemetryId;
        mailBody += '\r\n';

        mailBody += 'If you have any additional inquiries, please contact support@mattermost.com';

        const mailToLinkText = 'mailto:' + mailRecipient + '?cc=' + this.props.user.email + '&subject=' + encodeURIComponent(mailSubject) + '&body=' + encodeURIComponent(mailBody);

        return (
            <div className='form-group has-error'>
                <br/>
                <label className='control-label'>
                    <FormattedMessage
                        id='warn_metric_ack_modal.mailto.message'
                        defaultMessage='Support could not be reached. Please {link}.'
                        values={{
                            link: (
                                <WarnMetricAckErrorLink
                                    url={mailToLinkText}
                                    messageId={t('warn_metric_ack_modal.mailto.link')}
                                    forceAck={true}
                                    defaultMessage='email us'
                                    onClickHandler={this.onContactUsClick}
                                />
                            ),
                        }}
                    />
                </label>
            </div>
        );
    }

    render() {
        let headerTitle;
        if (this.props.warnMetricStatus.id === WarnMetricTypes.SYSTEM_WARN_METRIC_NUMBER_OF_ACTIVE_USERS_500) {
            headerTitle = (
                <FormattedMessage
                    id='warn_metric_ack_modal.number_of_users.header.title'
                    defaultMessage='Scaling with Mattermost'
                />
            );
        } else if (this.props.warnMetricStatus.id === WarnMetricTypes.SYSTEM_WARN_METRIC_NUMBER_OF_POSTS_2M) {
            headerTitle = (
                <FormattedMessage
                    id='warn_metric_ack_modal.number_of_posts.header.title'
                    defaultMessage='Improve Performance'
                />
            );
        }

        let descriptionText;
        const learnMoreLink = 'https://mattermost.com/pl/default-admin-advisory';

        if (this.props.warnMetricStatus.id === WarnMetricTypes.SYSTEM_WARN_METRIC_NUMBER_OF_ACTIVE_USERS_500) {
            descriptionText = (
                <FormattedMessage
                    id='warn_metric_ack_modal.number_of_active_users.description'
                    defaultMessage='Mattermost strongly recommends that deployments of over {limit}} users take advantage of features such as user management, server clustering, and performance monitoring. Contact us to learn more and let us know how we can help.'
                    values={{
                        limit: this.props.warnMetricStatus.limit,
                    }}
                />
            );
        } else if (this.props.warnMetricStatus.id === WarnMetricTypes.SYSTEM_WARN_METRIC_NUMBER_OF_POSTS_2M) {
            descriptionText = (
                <FormattedMessage
                    id='warn_metric_ack_modal.number_of_posts.description'
                    defaultMessage='Your Mattermost system has a large number of messages. The default Mattermost database search starts to show performance degradation at around 2.5 million posts. With over 5 million posts, Elasticsearch can help avoid significant performance issues, such as timeouts, with search and at-mentions. Contact us to learn more and let us know how we can help.'
                    values={{
                        limit: this.props.warnMetricStatus.limit,
                    }}
                />
            );
        }

        const subText = (
            <div
                style={containerStyles}
                className='help__format-text'
            >
                <FormattedMessage
                    id='warn_metric_ack_modal.subtext'
                    defaultMessage='By clicking Acknowledge, you will be sharing your information with Mattermost Inc. {link}'
                    values={{
                        link: (
                            <ErrorLink
                                url={learnMoreLink}
                                messageId={t('warn_metric_ack_modal.learn_more.link')}
                                defaultMessage='Learn more'
                            />
                        ),
                    }}
                />
            </div>
        );

        const error = this.renderContactUsError();
        const footer = (
            <Modal.Footer>
                <button
                    className='btn btn-primary save-button'
                    data-dismiss='modal'
                    disabled={this.state.saving}
                    autoFocus={true}
                    onClick={this.onContactUsClick}
                >
                    <LoadingWrapper
                        loading={this.state.saving}
                        text={Utils.localizeMessage('admin.warn_metric.sending-email', 'Sending email')}
                    >
                        <FormattedMessage
                            id='warn_metric_ack_modal.contact_support'
                            defaultMessage='Acknowledge'
                        />
                    </LoadingWrapper>
                </button>
            </Modal.Footer>
        );

        return (
            <Modal
                dialogClassName='a11y__modal'
                show={this.props.show}
                keyboard={false}
                onHide={this.onHide}
                onExited={this.onHide}
                role='dialog'
                aria-labelledby='warnMetricAckHeaderModalLabel'
            >
                <Modal.Header closeButton={true}>
                    <Modal.Title
                        componentClass='h1'
                        id='warnMetricAckHeaderModalLabel'
                    >
                        {headerTitle}
                    </Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    <div>
                        {descriptionText}
                        <br/>
                        {error}
                        <br/>
                        {subText}
                    </div>
                </Modal.Body>
                {footer}
            </Modal>
        );
    }
}

type ErrorLinkProps = {
    defaultMessage: string;
    messageId: string;
    onClickHandler: (e: React.MouseEvent<HTMLAnchorElement>) => Promise<void>;
    url: string;
    forceAck: boolean;
}

const WarnMetricAckErrorLink: React.FC<ErrorLinkProps> = ({defaultMessage, messageId, onClickHandler, url, forceAck}: ErrorLinkProps) => {
    return (
        <a
            href={url}
            rel='noopener noreferrer'
            target='_blank'
            data-forceAck={forceAck}
            onClick={
                (e) => {
                    onClickHandler(e);
                }
            }
        >
            <FormattedMessage
                id={messageId}
                defaultMessage={defaultMessage}
            />
        </a>
    );
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';
import {connect} from 'react-redux';

import {Action, ActionResult} from 'mattermost-redux/types/actions';
import {getStandardAnalytics, sendWarnMetricAck} from 'mattermost-redux/actions/admin';

import {getCurrentUser} from 'mattermost-redux/selectors/entities/common';
import {getConfig} from 'mattermost-redux/selectors/entities/general';

import {closeModal} from 'actions/views/modals';
import {GlobalState} from 'types/store';

import {isModalOpen} from '../../selectors/views/modals';
import {ModalIdentifiers} from '../../utils/constants';

import WarnMetricAckModal from './warn_metric_ack_modal';

type Props = {
    closeParentComponent: () => Promise<void>;
};

function mapStateToProps(state: GlobalState, ownProps: Props) {
    const config = getConfig(state);

    return {
        stats: state.entities.admin.analytics,
        user: getCurrentUser(state),
        telemetryId: config.DiagnosticId,
        show: isModalOpen(state, ModalIdentifiers.WARN_METRIC_ACK),
        closeParentComponent: ownProps.closeParentComponent,
    };
}

type Actions = {
    closeModal: (modalId: string) => void;
    getStandardAnalytics: () => void;
    sendWarnMetricAck: (warnMetricId: string, forceAck: boolean) => Promise<ActionResult>;
};

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, Actions>(
            {
                closeModal,
                getStandardAnalytics,
                sendWarnMetricAck,
            },
            dispatch,
        ),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(WarnMetricAckModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {FormattedMessage} from 'react-intl';

import {WarnMetricStatus} from '@mattermost/types/config';

import {Constants, AnnouncementBarTypes, ModalIdentifiers} from 'utils/constants';
import {isStringContainingUrl} from 'utils/url';

import FormattedMarkdownMessage from 'components/formatted_markdown_message';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import WarnMetricAckModal from 'components/warn_metric_ack_modal';
import ToggleModalButton from 'components/toggle_modal_button';

import {trackEvent} from 'actions/telemetry_actions.jsx';

type Props = {
    showCloseButton: boolean;
    color: string;
    textColor: string;
    type: string;
    message: React.ReactNode;
    tooltipMsg?: React.ReactNode;
    handleClose?: (e?: any) => void;
    showModal?: boolean;
    announcementBarCount?: number;
    onButtonClick?: (e?: any) => void;
    modalButtonText?: string;
    modalButtonDefaultText?: string;
    showLinkAsButton: boolean;
    icon?: React.ReactNode;
    warnMetricStatus?: WarnMetricStatus;
    actions: {
        incrementAnnouncementBarCount: () => void;
        decrementAnnouncementBarCount: () => void;
    };
    showCTA?: boolean;
}

type State = {
    showTooltip: boolean;
    isStringContainingUrl: boolean;
}

const OVERLAY_ANNOUNCEMENT_HIDE_DELAY = 600;

export default class AnnouncementBar extends React.PureComponent<Props, State> {
    messageRef: React.RefObject<HTMLDivElement>;
    constructor(props: Props) {
        super(props);

        this.messageRef = React.createRef();

        this.state = {
            showTooltip: false,
            isStringContainingUrl: false,
        };
    }

    static defaultProps = {
        showCloseButton: false,
        color: '',
        textColor: '',
        type: AnnouncementBarTypes.CRITICAL,
        showLinkAsButton: false,
        isTallBanner: false,
        showCTA: true,
    }

    enableToolTipIfNeeded = () => {
        const elm = this.messageRef.current;
        if (elm) {
            const enable = elm.offsetWidth < elm.scrollWidth;
            this.setState({showTooltip: enable});
            if (typeof this.props.message == 'string') {
                this.setState({isStringContainingUrl: isStringContainingUrl(this.props.message)});
            }
            return;
        }
        this.setState({showTooltip: false});
    }

    componentDidMount() {
        this.props.actions.incrementAnnouncementBarCount();
        document.body.classList.add('announcement-bar--fixed');
    }

    componentDidUpdate() {
        if (this.props.announcementBarCount === 1) {
            document.body.classList.add('announcement-bar--fixed');
        }
    }

    componentWillUnmount() {
        if (this.props.announcementBarCount === 1) {
            document.body.classList.remove('announcement-bar--fixed');
        }
        this.props.actions.decrementAnnouncementBarCount();
    }

    handleClose = (e: any) => {
        e.preventDefault();
        if (this.props.handleClose) {
            this.props.handleClose();
        }
    }

    render() {
        if (!this.props.message) {
            return null;
        }

        let barClass = 'announcement-bar';
        const barStyle = {backgroundColor: '', color: ''};
        const linkStyle = {color: ''};
        if (this.props.color && this.props.textColor) {
            barStyle.backgroundColor = this.props.color;
            barStyle.color = this.props.textColor;
            linkStyle.color = this.props.textColor;
        } else if (this.props.type === AnnouncementBarTypes.DEVELOPER) {
            barClass = 'announcement-bar announcement-bar-critical';
        } else if (this.props.type === AnnouncementBarTypes.CRITICAL) {
            barClass = 'announcement-bar announcement-bar-critical';
        } else if (this.props.type === AnnouncementBarTypes.SUCCESS) {
            barClass = 'announcement-bar announcement-bar-success';
        } else if (this.props.type === AnnouncementBarTypes.ADVISOR) {
            barClass = 'announcement-bar announcement-bar-advisor';
        } else if (this.props.type === AnnouncementBarTypes.ADVISOR_ACK) {
            barClass = 'announcement-bar announcement-bar-advisor-ack';
        } else if (this.props.type === AnnouncementBarTypes.GENERAL) {
            barClass = 'announcement-bar announcement-bar-general';
        }

        let closeButton;
        if (this.props.showCloseButton) {
            closeButton = (
                <a
                    href='#'
                    className='announcement-bar__close'
                    style={linkStyle}
                    onClick={this.handleClose}
                >
                    {''}
                </a>
            );
        }

        let message = this.props.message;
        if (typeof message == 'string') {
            message = (
                <FormattedMarkdownMessage id={this.props.message as string}/>
            );
        }
        const announcementTooltip = this.state.showTooltip ? (
            <Tooltip id='announcement-bar__tooltip'>
                {this.props.tooltipMsg ? this.props.tooltipMsg : message}
            </Tooltip>
        ) : <></>;

        const announcementIcon = () => {
            return this.props.showLinkAsButton &&
            (this.props.showCloseButton ? <div className='content__icon'>{'\uF5D6'}</div> : <div className='content__icon'>{'\uF02A'}</div>);
        };

        return (
            <div
                className={barClass}
                style={barStyle}
                // eslint-disable-next-line react/no-unknown-property
                css={{gridArea: 'announcement'}}
            >
                <OverlayTrigger
                    delayShow={Constants.OVERLAY_TIME_DELAY}
                    placement='bottom'
                    overlay={announcementTooltip}
                    delayHide={this.state.isStringContainingUrl ? OVERLAY_ANNOUNCEMENT_HIDE_DELAY : 0}
                >
                    <div className='announcement-bar__text'>
                        {this.props.icon ? this.props.icon : announcementIcon()}
                        <span
                            ref={this.messageRef}
                            onMouseEnter={this.enableToolTipIfNeeded}
                        >
                            {message}
                        </span>
                        {
                            !this.props.showLinkAsButton && this.props.showCTA &&
                            <span className='announcement-bar__link'>
                                {this.props.showModal &&
                                <FormattedMessage
                                    id={this.props.modalButtonText}
                                    defaultMessage={this.props.modalButtonDefaultText}
                                >
                                    {(linkmessage) => (
                                        <ToggleModalButton
                                            ariaLabel={linkmessage as unknown as string}
                                            className={'color--link--adminack'}
                                            dialogType={WarnMetricAckModal}
                                            onClick={() => trackEvent('admin', 'click_warn_metric_learn_more')}
                                            modalId={ModalIdentifiers.WARN_METRIC_ACK}
                                            dialogProps={{
                                                warnMetricStatus: this.props.warnMetricStatus,
                                                closeParentComponent: this.props.handleClose,
                                            }}
                                        >
                                            {linkmessage}
                                        </ToggleModalButton>
                                    )}
                                </FormattedMessage>
                                }
                            </span>
                        }
                        {
                            this.props.showLinkAsButton && this.props.showCTA &&
                            <button
                                className='upgrade-button'
                                onClick={this.props.onButtonClick}
                            >
                                <FormattedMessage
                                    id={this.props.modalButtonText}
                                    defaultMessage={this.props.modalButtonDefaultText}
                                />
                            </button>
                        }
                    </div>
                </OverlayTrigger>
                {closeButton}
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {GenericAction} from 'mattermost-redux/types/actions';

import {incrementAnnouncementBarCount, decrementAnnouncementBarCount} from 'actions/views/announcement_bar';
import {getAnnouncementBarCount} from 'selectors/views/announcement_bar';
import {GlobalState} from 'types/store';

import AnnouncementBar from './announcement_bar';

function mapStateToProps(state: GlobalState) {
    return {
        announcementBarCount: getAnnouncementBarCount(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            incrementAnnouncementBarCount,
            decrementAnnouncementBarCount,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(AnnouncementBar);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {trackEvent} from 'actions/telemetry_actions.jsx';
import Markdown from 'components/markdown';

import alertIcon from 'images/icons/round-white-info-icon.svg';

import AnnouncementBar from './default_announcement_bar';

const localStoragePrefix = '__announcement__';

type AnnouncementBarProps = React.ComponentProps<typeof AnnouncementBar>;

interface Props extends Partial<AnnouncementBarProps> {
    allowDismissal: boolean;
    text: React.ReactNode;
    onDismissal?: () => void;
}

type State = {
    dismissed: boolean;
}

export default class TextDismissableBar extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            dismissed: true,
        };
    }

    static getDerivedStateFromProps(props: Props) {
        const dismissed = localStorage.getItem(localStoragePrefix + props.text?.toString());
        return {
            dismissed: (dismissed === 'true'),
        };
    }

    handleDismiss = () => {
        if (!this.props.allowDismissal) {
            return;
        }
        trackEvent('signup', 'click_dismiss_bar');

        localStorage.setItem(localStoragePrefix + this.props.text?.toString(), 'true');
        this.setState({
            dismissed: true,
        });
        if (this.props.onDismissal) {
            this.props.onDismissal();
        }
    }

    render() {
        if (this.state.dismissed) {
            return null;
        }
        const {allowDismissal, text, ...extraProps} = this.props;
        return (
            <AnnouncementBar
                {...extraProps}
                showCloseButton={allowDismissal}
                handleClose={this.handleDismiss}
                message={
                    <>
                        <img
                            className='advisor-icon'
                            src={alertIcon}
                        />
                        {typeof text === 'string' ? (
                            <Markdown
                                message={text}
                                options={{
                                    singleline: true,
                                    mentionHighlight: false,
                                }}
                            />
                        ) : text}
                    </>
                }
            />
        );
    }
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage, injectIntl, IntlShape} from 'react-intl';
import {Link} from 'react-router-dom';

import {daysToLicenseExpire, isLicenseExpired, isLicenseExpiring, isLicensePastGracePeriod, isTrialLicense} from 'utils/license_utils';
import {AnnouncementBarTypes, AnnouncementBarMessages, WarnMetricTypes, Preferences, ConfigurationBanners, TELEMETRY_CATEGORIES} from 'utils/constants';
import {t} from 'utils/i18n';

import PurchaseLink from 'components/announcement_bar/purchase_link/purchase_link';

import ackIcon from 'images/icons/check-circle-outline.svg';
import alertIcon from 'images/icons/round-white-info-icon.svg';

import warningIcon from 'images/icons/warning-icon.svg';

import {trackEvent} from 'actions/telemetry_actions';

import {DispatchFunc} from 'mattermost-redux/types/actions';

import {ClientConfig, WarnMetricStatus} from '@mattermost/types/config';
import {PreferenceType} from '@mattermost/types/preferences';

import AnnouncementBar from '../default_announcement_bar';
import TextDismissableBar from '../text_dismissable_bar';
import RenewalLink from '../renewal_link/';

type Props = {
    config?: Partial<ClientConfig>;
    intl: IntlShape;
    license?: any;
    canViewSystemErrors: boolean;
    dismissedExpiringTrialLicense?: boolean;
    dismissedExpiringLicense?: boolean;
    dismissedExpiredLicense?: boolean;
    dismissedNumberOfActiveUsersWarnMetricStatus?: boolean;
    dismissedNumberOfActiveUsersWarnMetricStatusAck?: boolean;
    dismissedNumberOfPostsWarnMetricStatus?: boolean;
    dismissedNumberOfPostsWarnMetricStatusAck?: boolean;
    siteURL: string;
    currentUserId: string;
    warnMetricsStatus?: Record<string, WarnMetricStatus>;
    actions: {
        dismissNotice: (notice: string) => void;
        savePreferences: (userId: string, preferences: PreferenceType[]) => (dispatch: DispatchFunc) => Promise<{
            data: boolean;
        }>;
    };
};

const ConfigurationAnnouncementBar = (props: Props) => {
    const dismissExpiringLicense = () => {
        props.actions.dismissNotice(AnnouncementBarMessages.LICENSE_EXPIRING);
    };

    const dismissExpiredLicense = () => {
        trackEvent(
            TELEMETRY_CATEGORIES.SELF_HOSTED_LICENSE_EXPIRED,
            'dismissed_license_expired_banner',
        );

        props.actions.savePreferences(props.currentUserId, [{
            category: Preferences.CONFIGURATION_BANNERS,
            user_id: props.currentUserId,
            name: ConfigurationBanners.LICENSE_EXPIRED,
            value: 'true',
        }]);
    };

    const dismissExpiringTrialLicense = () => {
        props.actions.dismissNotice(AnnouncementBarMessages.TRIAL_LICENSE_EXPIRING);
    };

    const dismissNumberOfActiveUsersWarnMetric = () => {
        props.actions.dismissNotice(AnnouncementBarMessages.WARN_METRIC_STATUS_NUMBER_OF_USERS);
    };

    const dismissNumberOfPostsWarnMetric = () => {
        props.actions.dismissNotice(AnnouncementBarMessages.WARN_METRIC_STATUS_NUMBER_OF_POSTS);
    };

    const dismissNumberOfActiveUsersWarnMetricAck = () => {
        props.actions.dismissNotice(AnnouncementBarMessages.WARN_METRIC_STATUS_NUMBER_OF_USERS_ACK);
    };

    const dismissNumberOfPostsWarnMetricAck = () => {
        props.actions.dismissNotice(AnnouncementBarMessages.WARN_METRIC_STATUS_NUMBER_OF_POSTS_ACK);
    };

    const renewLinkTelemetry = {success: 'renew_license_banner_success', error: 'renew_license_banner_fail'};

    const getNoticeForWarnMetric = (warnMetricStatus: any) => {
        if (!warnMetricStatus ||
            (warnMetricStatus.id !== WarnMetricTypes.SYSTEM_WARN_METRIC_NUMBER_OF_ACTIVE_USERS_500 &&
            warnMetricStatus.id !== WarnMetricTypes.SYSTEM_WARN_METRIC_NUMBER_OF_POSTS_2M)) {
            return null;
        }

        let message: JSX.Element | string = '';
        let type = '';
        let showModal = false;
        let dismissFunc;
        let isDismissed = null;
        let canCloseBar = false;

        if (warnMetricStatus.acked) {
            message = (
                <>
                    <img
                        className='advisor-icon'
                        src={ackIcon}
                    />
                    <FormattedMessage
                        id='announcement_bar.warn_metric_status_ack.text'
                        defaultMessage='Thank you for contacting Mattermost. We will follow up with you soon.'
                    />
                </>
            );

            if (warnMetricStatus.id === WarnMetricTypes.SYSTEM_WARN_METRIC_NUMBER_OF_ACTIVE_USERS_500) {
                dismissFunc = dismissNumberOfActiveUsersWarnMetricAck;
                isDismissed = props.dismissedNumberOfActiveUsersWarnMetricStatusAck;
            } else if (warnMetricStatus.id === WarnMetricTypes.SYSTEM_WARN_METRIC_NUMBER_OF_POSTS_2M) {
                dismissFunc = dismissNumberOfPostsWarnMetricAck;
                isDismissed = props.dismissedNumberOfPostsWarnMetricStatusAck;
            }

            type = AnnouncementBarTypes.ADVISOR_ACK;
            showModal = false;
            canCloseBar = true;
        } else {
            if (warnMetricStatus.id === WarnMetricTypes.SYSTEM_WARN_METRIC_NUMBER_OF_ACTIVE_USERS_500) {
                message = (
                    <>
                        <img
                            className='advisor-icon'
                            src={alertIcon}
                        />
                        <FormattedMessage
                            id='announcement_bar.number_active_users_warn_metric_status.text'
                            defaultMessage='You now have over {limit} users. We strongly recommend using advanced features for large-scale servers.'
                            values={{
                                limit: warnMetricStatus.limit,
                            }}
                        />
                    </>
                );
                dismissFunc = dismissNumberOfActiveUsersWarnMetric;
                isDismissed = props.dismissedNumberOfActiveUsersWarnMetricStatus;
            } else if (warnMetricStatus.id === WarnMetricTypes.SYSTEM_WARN_METRIC_NUMBER_OF_POSTS_2M) {
                message = (
                    <>
                        <img
                            className='advisor-icon'
                            src={alertIcon}
                        />
                        <FormattedMessage
                            id='announcement_bar.number_of_posts_warn_metric_status.text'
                            defaultMessage='You now have over {limit} posts. We strongly recommend using advanced features for large-scale servers.'
                            values={{
                                limit: warnMetricStatus.limit,
                            }}
                        />
                    </>
                );
                dismissFunc = dismissNumberOfPostsWarnMetric;
                isDismissed = props.dismissedNumberOfPostsWarnMetricStatus;
            }
            type = AnnouncementBarTypes.ADVISOR;
            showModal = true;
            canCloseBar = false;
        }
        return {
            Message: message,
            DismissFunc: dismissFunc,
            IsDismissed: isDismissed,
            Type: type,
            ShowModal: showModal,
            CanCloseBar: canCloseBar,
        };
    };

    // System administrators
    if (props.canViewSystemErrors) {
        if ((isLicensePastGracePeriod(props.license) || isLicenseExpired(props.license)) && !props.dismissedExpiredLicense) {
            const message = (<>
                <img
                    className='advisor-icon'
                    src={warningIcon}
                />
                <FormattedMessage
                    id='announcement_bar.error.license_expired'
                    defaultMessage='Enterprise license is expired and some features may be disabled.'
                />
            </>);
            return (
                <AnnouncementBar
                    type={AnnouncementBarTypes.CRITICAL}
                    message={
                        <div className='announcement-bar__configuration'>
                            {message}
                            <RenewalLink telemetryInfo={renewLinkTelemetry}/>
                        </div>
                    }
                    tooltipMsg={message}
                    handleClose={dismissExpiredLicense}
                    showCloseButton={true}
                />
            );
        }

        const daysUntilLicenseExpires = daysToLicenseExpire(props.license);
        if (isTrialLicense(props.license) && typeof daysUntilLicenseExpires !== 'undefined' && daysUntilLicenseExpires <= 14 && !props.dismissedExpiringTrialLicense) {
            const purchaseLicense = (
                <PurchaseLink
                    buttonTextElement={
                        <FormattedMessage
                            id='announcement_bar.error.purchase_a_license_now'
                            defaultMessage='Purchase a License Now'
                        />
                    }
                />
            );

            let message = (
                <>
                    <img
                        className='advisor-icon'
                        src={alertIcon}
                    />
                    <FormattedMessage
                        id='announcement_bar.error.trial_license_expiring'
                        defaultMessage='There are {days} days left on your free trial.'
                        tagName='strong'
                        values={{
                            days: daysUntilLicenseExpires,
                        }}
                    />
                </>
            );

            let announcementBarType = AnnouncementBarTypes.ANNOUNCEMENT;

            if (daysUntilLicenseExpires < 1) {
                message = (
                    <>
                        <img
                            className='advisor-icon'
                            src={warningIcon}
                        />
                        <FormattedMessage
                            id='announcement_bar.error.trial_license_expiring_last_day'
                            tagName='strong'
                            defaultMessage={'This is the last day of your free trial. Purchase a license now to continue using Mattermost Professional and Enterprise features.'}
                        />
                    </>
                );
                announcementBarType = AnnouncementBarTypes.CRITICAL;
            }

            return (
                <AnnouncementBar
                    showCloseButton={true}
                    handleClose={dismissExpiringTrialLicense}
                    type={announcementBarType}
                    message={
                        <div className='announcement-bar__configuration'>
                            {message}
                            {purchaseLicense}
                        </div>
                    }
                    tooltipMsg={message}
                />
            );
        }

        if (!isTrialLicense(props.license) && isLicenseExpiring(props.license) && !props.dismissedExpiringLicense) {
            const message = (<>
                <img
                    className='advisor-icon'
                    src={alertIcon}
                />
                <FormattedMessage
                    id='announcement_bar.error.license_expiring'
                    defaultMessage='Enterprise license expires on {date, date, long}.'
                    values={{
                        date: new Date(parseInt(props.license?.ExpiresAt, 10)),
                    }}
                />
            </>);
            return (
                <AnnouncementBar
                    showCloseButton={true}
                    handleClose={dismissExpiringLicense}
                    type={AnnouncementBarTypes.ANNOUNCEMENT}
                    message={
                        <div className='announcement-bar__configuration'>
                            {message}
                            <RenewalLink telemetryInfo={renewLinkTelemetry}/>
                        </div>
                    }
                    tooltipMsg={message}
                />
            );
        }

        if (props.license?.IsLicensed === 'false' &&
                props.warnMetricsStatus) {
            for (const status of Object.values(props.warnMetricsStatus)) {
                const notice = getNoticeForWarnMetric(status);
                if (!notice || notice.IsDismissed) {
                    continue;
                }

                return (
                    <AnnouncementBar
                        showCloseButton={notice.CanCloseBar}
                        handleClose={notice.DismissFunc}
                        type={notice.Type}
                        showModal={notice.ShowModal}
                        modalButtonText={t('announcement_bar.error.warn_metric_status.link')}
                        modalButtonDefaultText='Learn more'
                        warnMetricStatus={status}
                        message={notice.Message}
                    />
                );
            }
        }
    } else {
        // Regular users
        if (isLicensePastGracePeriod(props.license)) { //eslint-disable-line no-lonely-if
            return (
                <AnnouncementBar
                    type={AnnouncementBarTypes.CRITICAL}
                    message={
                        <>
                            <img
                                className='advisor-icon'
                                src={warningIcon}
                            />
                            <FormattedMessage
                                id={AnnouncementBarMessages.LICENSE_PAST_GRACE}
                                defaultMessage='Enterprise license is expired and some features may be disabled. Please contact your System Administrator for details.'
                            />
                        </>
                    }
                />
            );
        }
    }

    const {formatMessage} = props.intl;

    if (props.config?.SendEmailNotifications !== 'true' &&
            props.config?.EnablePreviewModeBanner === 'true'
    ) {
        const emailMessage = formatMessage({
            id: AnnouncementBarMessages.PREVIEW_MODE,
            defaultMessage: 'Preview Mode: Email notifications have not been configured',
        });

        return (
            <TextDismissableBar
                allowDismissal={true}
                text={emailMessage}
                type={AnnouncementBarTypes.SUCCESS}
            />
        );
    }

    if (props.canViewSystemErrors && props.config?.SiteURL === '') {
        let id;
        let defaultMessage;
        if (props.config?.EnableSignUpWithGitLab === 'true') {
            id = t('announcement_bar.error.site_url_gitlab.full');
            defaultMessage = 'Please configure your <linkSite>site URL</linkSite> either on the <linkConsole>System Console<linkConsole> or, if you\'re using GitLab Mattermost, in gitlab.rb.';
        } else {
            id = t('announcement_bar.error.site_url.full');
            defaultMessage = 'Please configure your <linkSite>site URL</linkSite> on the <linkConsole>System Console</linkConsole>.';
        }

        const values = {
            linkSite: (msg: string) => (
                <a
                    href={props.siteURL}
                    target='_blank'
                    rel='noreferrer'
                >
                    {msg}
                </a>
            ),
            linkConsole: (msg: string) => (
                <Link to='/admin_console/environment/web_server'>
                    {msg}
                </Link>
            ),
        };
        const siteURLMessage = formatMessage({id, defaultMessage}, values);

        return (
            <TextDismissableBar
                allowDismissal={true}
                text={siteURLMessage}
                type={AnnouncementBarTypes.ANNOUNCEMENT}
            />
        );
    }

    return null;
};

export default injectIntl(ConfigurationAnnouncementBar);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {GenericAction} from 'mattermost-redux/types/actions';
import {get as getPreference} from 'mattermost-redux/selectors/entities/preferences';
import {savePreferences} from 'mattermost-redux/actions/preferences';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';

import {GlobalState} from 'types/store';

import {AnnouncementBarMessages, ConfigurationBanners, Preferences} from 'utils/constants';
import {dismissNotice} from 'actions/views/notice';
import {getSiteURL} from 'utils/url';

import ConfigurationBar from './configuration_bar';

function mapStateToProps(state: GlobalState) {
    const currentUserId = getCurrentUserId(state);
    return {
        siteURL: getSiteURL(),
        dismissedExpiringTrialLicense: Boolean(state.views.notice.hasBeenDismissed[AnnouncementBarMessages.TRIAL_LICENSE_EXPIRING]),
        dismissedExpiredLicense: Boolean(getPreference(state, Preferences.CONFIGURATION_BANNERS, ConfigurationBanners.LICENSE_EXPIRED) === 'true'),
        dismissedExpiringLicense: Boolean(state.views.notice.hasBeenDismissed[AnnouncementBarMessages.LICENSE_EXPIRING]),
        dismissedNumberOfActiveUsersWarnMetricStatus: Boolean(state.views.notice.hasBeenDismissed[AnnouncementBarMessages.WARN_METRIC_STATUS_NUMBER_OF_USERS]),
        dismissedNumberOfActiveUsersWarnMetricStatusAck: Boolean(state.views.notice.hasBeenDismissed[AnnouncementBarMessages.WARN_METRIC_STATUS_NUMBER_OF_USERS_ACK]),
        dismissedNumberOfPostsWarnMetricStatus: Boolean(state.views.notice.hasBeenDismissed[AnnouncementBarMessages.WARN_METRIC_STATUS_NUMBER_OF_POSTS]),
        dismissedNumberOfPostsWarnMetricStatusAck: Boolean(state.views.notice.hasBeenDismissed[AnnouncementBarMessages.WARN_METRIC_STATUS_NUMBER_OF_POSTS_ACK]),
        currentUserId,
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            dismissNotice,
            savePreferences,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(ConfigurationBar);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {FormattedMessage} from 'react-intl';

import {AnnouncementBarTypes} from 'utils/constants';

import AnnouncementBar from '../default_announcement_bar';

interface Props {
    buildHash?: string;
}

interface State {
    buildHashOnAppLoad?: string;
}

export default class VersionBar extends React.PureComponent <Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            buildHashOnAppLoad: props.buildHash,
        };
    }

    static getDerivedStateFromProps(props: Props, state: State) {
        if (!state.buildHashOnAppLoad && props.buildHash) {
            return {
                buildHashOnAppLoad: props.buildHash,
            };
        }

        return null;
    }

    reloadPage = () => {
        window.location.reload();
    }

    render() {
        const {buildHashOnAppLoad} = this.state;
        const {buildHash} = this.props;

        if (!buildHashOnAppLoad) {
            return null;
        }

        if (buildHashOnAppLoad !== buildHash) {
            return (
                <AnnouncementBar
                    type={AnnouncementBarTypes.ANNOUNCEMENT}
                    message={
                        <React.Fragment>
                            <FormattedMessage
                                id='version_bar.new'
                                defaultMessage='A new version of Mattermost is available.'
                            />
                            <a
                                onClick={this.reloadPage}
                                style={{marginLeft: '.5rem'}}
                            >
                                <FormattedMessage
                                    id='version_bar.refresh'
                                    defaultMessage='Refresh the app now'
                                />
                            </a>
                            {'.'}
                        </React.Fragment>
                    }
                />
            );
        }

        return null;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {GlobalState} from '@mattermost/types/store';

import VersionBar from './version_bar';

function mapStateToProps(state: GlobalState) {
    return {
        buildHash: state.entities.general.config.BuildHash,
    };
}

export default connect(mapStateToProps)(VersionBar);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {isEmpty} from 'lodash';

import {CloudCustomer, Subscription} from '@mattermost/types/cloud';

import {getHistory} from 'utils/browser_history';
import {isCustomerCardExpired} from 'utils/cloud_utils';
import {AnnouncementBarTypes} from 'utils/constants';
import {t} from 'utils/i18n';

import AnnouncementBar from '../default_announcement_bar';

type Props = {
    userIsAdmin: boolean;
    isCloud: boolean;
    subscription?: Subscription;
    customer?: CloudCustomer;
    isStarterFree: boolean;
    actions: {
        getCloudSubscription: () => void;
        getCloudCustomer: () => void;
    };
};

class PaymentAnnouncementBar extends React.PureComponent<Props> {
    async componentDidMount() {
        if (isEmpty(this.props.customer)) {
            await this.props.actions.getCloudCustomer();
        }
    }

    isMostRecentPaymentFailed = () => {
        return this.props.subscription?.last_invoice?.status === 'failed';
    }

    shouldShowBanner = () => {
        const {userIsAdmin, isCloud, subscription} = this.props;

        // Prevents banner flashes if the subscription hasn't been loaded yet
        if (subscription === null) {
            return false;
        }

        if (this.props.isStarterFree) {
            return false;
        }

        if (!isCloud) {
            return false;
        }

        if (!userIsAdmin) {
            return false;
        }

        if (!isCustomerCardExpired(this.props.customer) && !this.isMostRecentPaymentFailed()) {
            return false;
        }

        return true;
    }

    updatePaymentInfo = () => {
        getHistory().push('/admin_console/billing/payment_info');
    }

    render() {
        if (isEmpty(this.props.customer) || isEmpty(this.props.subscription)) {
            return null;
        }

        if (!this.shouldShowBanner()) {
            return null;
        }

        return (
            <AnnouncementBar
                type={AnnouncementBarTypes.CRITICAL}
                showCloseButton={false}
                onButtonClick={this.updatePaymentInfo}
                modalButtonText={t('admin.billing.subscription.updatePaymentInfo')}
                modalButtonDefaultText={'Update payment info'}
                message={this.isMostRecentPaymentFailed() ? t('admin.billing.subscription.mostRecentPaymentFailed') : t('admin.billing.subscription.creditCardExpired')}
                showLinkAsButton={true}
                isTallBanner={true}
            />

        );
    }
}

export default PaymentAnnouncementBar;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {savePreferences} from 'mattermost-redux/actions/preferences';
import {getLicense} from 'mattermost-redux/selectors/entities/general';
import {GenericAction} from 'mattermost-redux/types/actions';
import {getStandardAnalytics} from 'mattermost-redux/actions/admin';
import {getCloudSubscription, getCloudCustomer} from 'mattermost-redux/actions/cloud';

import {isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';
import {
    getCloudSubscription as selectCloudSubscription,
    getCloudCustomer as selectCloudCustomer,
    getSubscriptionProduct,
} from 'mattermost-redux/selectors/entities/cloud';
import {CloudProducts} from 'utils/constants';

import {openModal} from 'actions/views/modals';

import {GlobalState} from 'types/store';

import PaymentAnnouncementBar from './payment_announcement_bar';

function mapStateToProps(state: GlobalState) {
    const subscription = selectCloudSubscription(state);
    const customer = selectCloudCustomer(state);
    const subscriptionProduct = getSubscriptionProduct(state);
    return {
        userIsAdmin: isCurrentUserSystemAdmin(state),
        isCloud: getLicense(state).Cloud === 'true',
        subscription,
        customer,
        isStarterFree: subscriptionProduct?.sku === CloudProducts.STARTER,
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators(
            {
                savePreferences,
                getStandardAnalytics,
                openModal,
                getCloudSubscription,
                getCloudCustomer,
            },
            dispatch,
        ),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(PaymentAnnouncementBar);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {isEmpty} from 'lodash';

import {FormattedMessage} from 'react-intl';

import {PreferenceType} from '@mattermost/types/preferences';
import {UserProfile} from '@mattermost/types/users';
import {AnalyticsRow} from '@mattermost/types/admin';
import {Subscription} from '@mattermost/types/cloud';

import {trackEvent} from 'actions/telemetry_actions';

import {t} from 'utils/i18n';
import PricingModal from 'components/pricing_modal';

import {ModalData} from 'types/actions';

import {
    Preferences,
    CloudBanners,
    AnnouncementBarTypes,
    ModalIdentifiers,
    TELEMETRY_CATEGORIES,
    TrialPeriodDays,
} from 'utils/constants';
import {getLocaleDateFromUTC} from 'utils/utils';

import AnnouncementBar from '../default_announcement_bar';

type Props = {
    userIsAdmin: boolean;
    isFreeTrial: boolean;
    currentUser: UserProfile;
    preferences: PreferenceType[];
    daysLeftOnTrial: number;
    isCloud: boolean;
    analytics?: Record<string, number | AnalyticsRow[]>;
    subscription?: Subscription;
    actions: {
        savePreferences: (userId: string, preferences: PreferenceType[]) => void;
        getStandardAnalytics: () => void;
        getCloudSubscription: () => void;
        openModal: <P>(modalData: ModalData<P>) => void;
    };
};

const MAX_DAYS_BANNER = 'max_days_banner';
const THREE_DAYS_BANNER = '3_days_banner';
class CloudTrialAnnouncementBar extends React.PureComponent<Props> {
    async componentDidMount() {
        if (isEmpty(this.props.analytics)) {
            await this.props.actions.getStandardAnalytics();
        }

        if (!isEmpty(this.props.subscription) && !isEmpty(this.props.analytics) && this.shouldShowBanner()) {
            const {daysLeftOnTrial} = this.props;
            if (this.isDismissable()) {
                trackEvent(
                    TELEMETRY_CATEGORIES.CLOUD_ADMIN,
                    `bannerview_trial_${daysLeftOnTrial}_days`,
                );
            } else {
                trackEvent(
                    TELEMETRY_CATEGORIES.CLOUD_ADMIN,
                    'bannerview_trial_limit_ended',
                );
            }
        }
    }

    handleClose = async () => {
        const {daysLeftOnTrial} = this.props;
        let dismissValue = '';
        if (daysLeftOnTrial > TrialPeriodDays.TRIAL_WARNING_THRESHOLD) {
            dismissValue = MAX_DAYS_BANNER;
        } else if (daysLeftOnTrial <= TrialPeriodDays.TRIAL_WARNING_THRESHOLD && daysLeftOnTrial >= TrialPeriodDays.TRIAL_1_DAY) {
            dismissValue = THREE_DAYS_BANNER;
        }
        trackEvent(
            TELEMETRY_CATEGORIES.CLOUD_ADMIN,
            `dismissed_banner_trial_${daysLeftOnTrial}_days`,
        );
        await this.props.actions.savePreferences(this.props.currentUser.id, [{
            category: Preferences.CLOUD_TRIAL_BANNER,
            user_id: this.props.currentUser.id,
            name: CloudBanners.TRIAL,
            value: `${dismissValue}`,
        }]);
    }

    shouldShowBanner = () => {
        const {isFreeTrial, userIsAdmin, isCloud} = this.props;
        return isFreeTrial && userIsAdmin && isCloud;
    }

    isDismissable = () => {
        const {daysLeftOnTrial} = this.props;
        let dismissable = true;

        if (daysLeftOnTrial <= TrialPeriodDays.TRIAL_1_DAY) {
            dismissable = false;
        }
        return dismissable;
    }

    showModal = () => {
        const {daysLeftOnTrial} = this.props;
        if (this.isDismissable()) {
            trackEvent(
                TELEMETRY_CATEGORIES.CLOUD_ADMIN,
                `click_subscribe_from_trial_banner_${daysLeftOnTrial}_days`,
            );
        } else {
            trackEvent(
                TELEMETRY_CATEGORIES.CLOUD_ADMIN,
                'click_subscribe_from_banner_trial_ended',
            );
        }
        this.props.actions.openModal({
            modalId: ModalIdentifiers.PRICING_MODAL,
            dialogType: PricingModal,
        });
    }

    render() {
        const {daysLeftOnTrial, preferences} = this.props;

        if (isEmpty(this.props.analytics)) {
            // If the analytics aren't yet loaded, return null to avoid a flash of the banner
            return null;
        }

        if (!this.shouldShowBanner()) {
            return null;
        }

        if ((preferences.some((pref) => pref.name === CloudBanners.TRIAL && pref.value === MAX_DAYS_BANNER) && daysLeftOnTrial > TrialPeriodDays.TRIAL_WARNING_THRESHOLD) ||
            ((daysLeftOnTrial <= TrialPeriodDays.TRIAL_WARNING_THRESHOLD && daysLeftOnTrial >= TrialPeriodDays.TRIAL_1_DAY) &&
            preferences.some((pref) => pref.name === CloudBanners.TRIAL && pref.value === THREE_DAYS_BANNER))) {
            return null;
        }

        const trialMoreThan3DaysMsg = (
            <FormattedMessage
                id='admin.billing.subscription.cloudTrial.moreThan3Days'
                defaultMessage='Your trial has started! There are {daysLeftOnTrial} days left'
                values={{daysLeftOnTrial}}
            />
        );

        const trialLessThan3DaysMsg = (
            <FormattedMessage
                id='admin.billing.subscription.cloudTrial.daysLeftOnTrial'
                defaultMessage='There are {daysLeftOnTrial} days left on your free trial'
                values={{daysLeftOnTrial}}
            />
        );

        const userEndTrialDate = getLocaleDateFromUTC((this.props.subscription?.trial_end_at as number / 1000), 'MMMM Do YYYY');
        const userEndTrialHour = getLocaleDateFromUTC((this.props.subscription?.trial_end_at as number / 1000), 'HH:mm:ss', this.props.currentUser.timezone?.automaticTimezone as string);

        const trialLastDaysMsg = (
            <FormattedMessage
                id='admin.billing.subscription.cloudTrial.lastDay'
                defaultMessage='This is the last day of your free trial. Your access will expire on {userEndTrialDate} at {userEndTrialHour}.'
                values={{userEndTrialHour, userEndTrialDate}}
            />
        );

        let bannerMessage;
        let icon;
        switch (daysLeftOnTrial) {
        case TrialPeriodDays.TRIAL_WARNING_THRESHOLD:
        case TrialPeriodDays.TRIAL_2_DAYS:
            bannerMessage = trialLessThan3DaysMsg;
            break;
        case TrialPeriodDays.TRIAL_1_DAY:
        case TrialPeriodDays.TRIAL_0_DAYS:
            bannerMessage = trialLastDaysMsg;
            break;
        default:
            bannerMessage = trialMoreThan3DaysMsg;
            icon = <i className='icon-check-outline-circle'/>;
            break;
        }

        const dismissable = this.isDismissable();

        return (
            <AnnouncementBar
                type={dismissable ? AnnouncementBarTypes.ADVISOR : AnnouncementBarTypes.CRITICAL}
                showCloseButton={dismissable}
                handleClose={this.handleClose}
                onButtonClick={this.showModal}
                modalButtonText={t('admin.billing.subscription.cloudTrial.subscribeButton')}
                modalButtonDefaultText={'Upgrade Now'}
                message={bannerMessage}
                showLinkAsButton={true}
                icon={icon}
            />
        );
    }
}

export default CloudTrialAnnouncementBar;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {savePreferences} from 'mattermost-redux/actions/preferences';
import {getLicense} from 'mattermost-redux/selectors/entities/general';
import {GenericAction} from 'mattermost-redux/types/actions';
import {getStandardAnalytics} from 'mattermost-redux/actions/admin';
import {makeGetCategory} from 'mattermost-redux/selectors/entities/preferences';
import {getCloudSubscription} from 'mattermost-redux/actions/cloud';

import {getCurrentUser, isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';

import {openModal} from 'actions/views/modals';

import {GlobalState} from 'types/store';

import {Preferences, TrialPeriodDays} from 'utils/constants';

import {getRemainingDaysFromFutureTimestamp} from 'utils/utils';

import CloudTrialAnnouncementBar from './cloud_trial_announcement_bar';

function mapStateToProps(state: GlobalState) {
    const getCategory = makeGetCategory();

    const subscription = state.entities.cloud.subscription;
    const isCloud = getLicense(state).Cloud === 'true';
    let isFreeTrial = false;
    let daysLeftOnTrial = 0;

    if (isCloud && subscription?.is_free_trial === 'true') {
        isFreeTrial = true;
        daysLeftOnTrial = Math.min(
            getRemainingDaysFromFutureTimestamp(subscription.trial_end_at),
            TrialPeriodDays.TRIAL_30_DAYS,
        );
    }

    return {
        isFreeTrial,
        daysLeftOnTrial,
        analytics: state.entities.admin.analytics,
        userIsAdmin: isCurrentUserSystemAdmin(state),
        currentUser: getCurrentUser(state),
        isCloud,
        subscription,
        preferences: getCategory(state, Preferences.CLOUD_TRIAL_BANNER),
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators(
            {
                savePreferences,
                getStandardAnalytics,
                openModal,
                getCloudSubscription,
            },
            dispatch,
        ),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(CloudTrialAnnouncementBar);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {FormattedMessage} from 'react-intl';
import {useSelector, useDispatch} from 'react-redux';

import {t} from 'utils/i18n';

import AnnouncementBar from '../default_announcement_bar';
import {
    AnnouncementBarTypes,
    Preferences,
    CloudBanners,
    CloudProducts,
} from 'utils/constants';
import {GlobalState} from 'types/store';
import useGetLimits from 'components/common/hooks/useGetLimits';
import useGetSubscription from 'components/common/hooks/useGetSubscription';
import useOpenPricingModal from 'components/common/hooks/useOpenPricingModal';
import {isSystemAdmin} from 'mattermost-redux/utils/user_utils';
import {makeGetCategory} from 'mattermost-redux/selectors/entities/preferences';
import {savePreferences} from 'mattermost-redux/actions/preferences';
import {
    getCurrentUser,
} from 'mattermost-redux/selectors/entities/users';
import {
    getSubscriptionProduct,
} from 'mattermost-redux/selectors/entities/cloud';

const CloudTrialEndAnnouncementBar: React.FC = () => {
    const limits = useGetLimits();
    const subscription = useGetSubscription();
    const getCategory = makeGetCategory();
    const dispatch = useDispatch();
    const preferences = useSelector((state: GlobalState) =>
        getCategory(state, Preferences.CLOUD_TRIAL_END_BANNER),
    );
    const currentUser = useSelector((state: GlobalState) =>
        getCurrentUser(state),
    );
    const subscriptionProduct = useSelector((state: GlobalState) => getSubscriptionProduct(state));

    const openPricingModal = useOpenPricingModal();

    const shouldShowBanner = () => {
        if (!subscription || !subscriptionProduct) {
            return false;
        }

        // Make sure limits are loaded before showing banner
        if (!limits || !limits[1]) {
            return false;
        }

        if (!preferences) {
            return false;
        }
        if (preferences.some((pref) => pref.name === CloudBanners.HIDE && pref.value === 'true')) {
            return false;
        }

        // Don't show this banner for professional or enterprise installations
        if (subscriptionProduct?.sku !== CloudProducts.STARTER) {
            return false;
        }

        const isFreeTrial = subscription.is_free_trial === 'true';
        if (isFreeTrial) {
            return false;
        }

        const trialEnd = new Date(subscription.trial_end_at);
        const now = new Date();

        // trial_end_at values will be 0 for all freemium subscriptions after June 15
        // Subscriptions created prior to that will almost always have a trial_end_at value, guaranteed.
        if (subscription.trial_end_at === 0 || trialEnd > now || trialEnd < new Date('2022-06-15')) {
            return false;
        }
        if (!isSystemAdmin(currentUser.roles)) {
            return false;
        }
        return true;
    };

    if (!shouldShowBanner()) {
        return null;
    }

    const handleClose = () => {
        dispatch(
            savePreferences(currentUser.id, [
                {
                    category: Preferences.CLOUD_TRIAL_END_BANNER,
                    user_id: currentUser.id,
                    name: CloudBanners.HIDE,
                    value: 'true',
                },
            ]),
        );
    };

    const message = {
        id: t('free.banner.downgraded'),
        defaultMessage:
            'Your workspace now has restrictions and some data has been archived',
    };

    return (
        <AnnouncementBar
            type={AnnouncementBarTypes.CRITICAL}
            showCloseButton={true}
            onButtonClick={() => openPricingModal({trackingLocation: 'cloud_trial_ended_announcement_bar'})}
            modalButtonText={t('more.details')}
            modalButtonDefaultText={'More details'}
            message={<FormattedMessage {...message}/>}
            showLinkAsButton={true}
            isTallBanner={true}
            icon={<i className='icon icon-alert-outline'/>}
            handleClose={handleClose}
        />
    );
};

export default CloudTrialEndAnnouncementBar;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {FC} from 'react';

const StartTrialModalSvg: FC = () => (
    <svg
        width='512'
        height='156'
        viewBox='0 0 512 156'
        display='inline-block'
        fill='none'
        xmlns='http://www.w3.org/2000/svg'
    >
        <g
            clipPath='url(#clip0)'
            style={{transform: 'translate(135px, 10px)'}}
        >
            <path
                d='M117.504 138.565C156.52 138.565 188.158 107.604 188.158 69.4C188.158 31.1964 156.52 0.235336 117.504 0.235336C78.4886 0.235336 46.851 31.1964 46.851 69.4C46.851 107.604 78.4886 138.565 117.504 138.565Z'
                fill='#E8E9ED'
                stroke='#E8E9ED'
                strokeWidth='0.5'
            />
            <path
                d='M97.7842 49.8971C100.351 52.3506 101.639 55.4564 101.639 59.2294C101.639 63.0023 100.351 66.1155 97.7842 68.5616C95.2171 71.0151 92.0367 72.2974 88.2504 72.4309H17.4471C12.4417 72.2974 8.28436 70.6148 4.96759 67.3682C1.65839 64.129 0 60.0596 0 55.1599C0 50.2603 1.65839 46.1909 4.96759 42.9443C8.27679 39.7051 12.4417 38.015 17.4471 37.8816C17.5834 31.3957 19.8476 25.9995 24.2473 21.7003C28.6394 17.4011 34.1522 15.1848 40.7781 15.0514C46.3212 15.044 51.1525 16.6302 55.2796 19.8101C59.4066 22.9901 62.1403 27.0891 63.4958 32.1222C65.7902 30.5359 68.4331 29.7354 71.4091 29.7354C75.3316 29.8688 78.6106 31.2253 81.2458 33.8048C83.8811 36.3843 85.2668 39.6013 85.4031 43.4335C85.4031 44.4935 85.2668 45.4867 84.9942 46.4133C86.0771 46.1465 87.1524 46.013 88.2428 46.013C92.0291 46.1539 95.2096 47.4436 97.7842 49.8971Z'
                fill='#FFBC1F'
            />
            <path
                d='M101.639 59.2301C101.639 55.4572 100.351 52.3514 97.7842 49.8979C95.2171 47.4518 92.0367 46.1621 88.2504 46.0286C87.1675 46.0286 86.0847 46.1621 85.0018 46.4289C85.2744 45.5024 85.4107 44.5091 85.4107 43.4491C85.2744 39.6095 83.8886 36.3999 81.2534 33.8204C78.6181 31.2409 75.3316 29.8696 71.4091 29.7361C68.4331 29.7361 65.7978 30.5293 63.4958 32.1229C62.1403 27.0899 59.4066 22.9908 55.2796 19.8109C51.1525 16.631 46.3212 15.0447 40.7781 15.0447C34.1522 15.1782 28.6394 17.3945 24.2473 21.6937C19.8476 26.0003 17.5834 31.3965 17.4471 37.875C12.4417 38.0084 8.28436 39.6984 4.96759 42.9377C1.65839 46.1917 0 50.2611 0 55.1607C0 55.1607 0.21203 42.6412 18.5906 39.6169C19.2797 22.4572 34.5687 17.7503 40.9296 17.7503C47.2905 17.7503 57.7028 20.7745 63.0338 34.3986C74.2563 27.505 86.804 35.9033 83.3661 48.5266C98.9958 45.1614 101.639 59.2301 101.639 59.2301Z'
                fill='#F5AB00'
            />
            <path
                d='M225.894 63.9064C227.346 65.2949 228.075 67.0526 228.075 69.1878C228.075 71.323 227.346 73.0848 225.894 74.4691C224.441 75.8576 222.641 76.5834 220.498 76.6589H180.429C177.596 76.5834 175.243 75.6311 173.366 73.7938C171.493 71.9606 170.555 69.6576 170.555 66.8848C170.555 64.112 171.493 61.809 173.366 59.9716C175.239 58.1385 177.596 57.182 180.429 57.1065C180.506 53.436 181.787 50.3821 184.277 47.9491C186.763 45.5161 189.882 44.2618 193.632 44.1863C196.769 44.1821 199.503 45.0798 201.839 46.8794C204.175 48.679 205.722 50.9988 206.489 53.8471C207.787 52.9494 209.283 52.4963 210.967 52.4963C213.187 52.5718 215.043 53.3395 216.534 54.7993C218.025 56.2591 218.81 58.0797 218.887 60.2485C218.887 60.8484 218.81 61.4105 218.655 61.9348C219.268 61.7838 219.877 61.7083 220.494 61.7083C222.637 61.788 224.436 62.5179 225.894 63.9064Z'
                fill='#FFBC1F'
            />
            <path
                d='M228.075 69.189C228.075 67.0538 227.346 65.2961 225.894 63.9076C224.441 62.5233 222.641 61.7934 220.498 61.7179C219.885 61.7179 219.272 61.7934 218.66 61.9444C218.814 61.42 218.891 60.8579 218.891 60.2581C218.814 58.0851 218.03 56.2687 216.538 54.8089C215.047 53.3491 213.187 52.573 210.967 52.4975C209.283 52.4975 207.792 52.9464 206.489 53.8483C205.722 50.9999 204.175 48.6802 201.839 46.8806C199.503 45.081 196.769 44.1833 193.632 44.1833C189.882 44.2588 186.763 45.513 184.277 47.9461C181.787 50.3833 180.506 53.4372 180.429 57.1035C177.596 57.179 175.243 58.1354 173.366 59.9686C171.493 61.8102 170.555 64.1132 170.555 66.886C170.555 66.886 170.675 59.8008 181.076 58.0893C181.466 48.3781 190.118 45.7144 193.718 45.7144C197.318 45.7144 203.21 47.4259 206.227 55.1361C212.579 51.2349 219.68 55.9877 217.734 63.1316C226.579 61.2271 228.075 69.189 228.075 69.189Z'
                fill='#F5AB00'
            />
            <path
                d='M199.061 63.0908L190.387 73.9565H194.064V92.2097H203.809V73.9702V73.9565H207.74L199.061 63.0908Z'
                fill='#386FE5'
            />
            <path
                d='M49.3268 40.2811L28.7566 65.8203H37.4771V108.225H60.5857V65.8523V65.8203H69.9079L49.3268 40.2811Z'
                fill='#386FE5'
            />
            <mask
                id='mask0'
                mask-type='alpha'
                maskUnits='userSpaceOnUse'
                x='47'
                y='0'
                width='141'
                height='139'
            >
                <path
                    d='M117.504 138.315C156.387 138.315 187.908 107.46 187.908 69.4C187.908 31.3395 156.387 0.485336 117.504 0.485336C78.6216 0.485336 47.101 31.3395 47.101 69.4C47.101 107.46 78.6216 138.315 117.504 138.315Z'
                    fill='#E8E9ED'
                />
            </mask>
            <g mask='url(#mask0)'>
                <path
                    d='M54.6396 94.6503C55.2591 91.4217 56.4956 88.343 57.7274 85.2854C59.0477 82.0077 60.3799 78.7019 62.2527 75.6864C66.6201 68.6627 73.7333 63.594 81.3871 60.2062C89.0408 56.8185 96.3645 54.9034 104.554 53.0679C101.87 55.8961 101.052 59.4968 99.4475 63.0227C95.702 71.2498 92.4826 79.6945 89.2656 88.1323C84.4358 100.792 79.6084 113.45 74.7833 126.107C64.3096 120.069 56.785 109.348 54.7855 97.6119L54.6396 94.6503Z'
                    fill='white'
                />
                <path
                    d='M134.964 53.3651C139.63 54.8775 146.923 57.5418 146.923 57.5418C146.923 57.5418 163.665 104.783 167.375 127.544C167.485 128.214 167.583 128.949 167.268 129.544C166.806 130.419 165.689 130.686 164.778 131.105C162.69 132.061 161.369 134.102 159.561 135.5C158.002 136.701 156.107 137.401 154.244 138.075C137.659 144.026 119.647 149.004 102.522 144.759C101.438 144.49 100.319 144.162 99.4936 143.422C98.776 142.769 98.3383 141.861 97.9437 140.974C92.7272 129.267 82.4831 105.083 82.5835 87.973C82.7007 68.2037 93.6456 56.1534 93.825 55.8983C94.2531 55.2919 110.271 51.1947 120.135 50.9817C120.144 50.9864 131.041 52.0914 134.964 53.3651Z'
                    fill='white'
                />
                <mask
                    id='mask1'
                    mask-type='alpha'
                    maskUnits='userSpaceOnUse'
                    x='82'
                    y='50'
                    width='86'
                    height='97'
                >
                    <path
                        d='M134.964 53.3651C139.63 54.8775 146.923 57.5418 146.923 57.5418C146.923 57.5418 163.665 104.783 167.375 127.544C167.485 128.214 167.583 128.949 167.268 129.544C166.806 130.419 165.689 130.686 164.778 131.105C162.69 132.061 161.369 134.102 159.561 135.5C158.002 136.701 156.107 137.401 154.244 138.075C137.659 144.026 119.647 149.004 102.522 144.759C101.438 144.49 100.319 144.162 99.4936 143.422C98.776 142.769 98.3383 141.861 97.9437 140.974C92.7272 129.267 82.4831 105.083 82.5835 87.973C82.7007 68.2037 93.6456 56.1534 93.825 55.8983C94.2531 55.2919 110.271 51.1947 120.135 50.9817C120.144 50.9864 131.041 52.0914 134.964 53.3651Z'
                        fill='white'
                    />
                </mask>
                <g mask='url(#mask1)'>
                    <rect
                        x='82.3802'
                        y='50.9582'
                        width='85.148'
                        height='82.6451'
                        fill='url(#pattern0)'
                    />
                    <rect
                        x='82.3802'
                        y='50.9582'
                        width='74.6241'
                        height='95.5218'
                        fill='url(#pattern1)'
                    />
                </g>
                <path
                    d='M84.3219 100.889C83.7064 98.6605 83.0902 96.4317 82.4731 94.2028C82.4443 94.1173 82.3831 94.0459 82.3021 94.0033C82.221 93.9607 82.1264 93.9502 82.0377 93.974C81.949 93.9977 81.873 94.0539 81.8254 94.1309C81.7778 94.2079 81.7622 94.2998 81.7818 94.3878C82.3989 96.6166 83.0152 98.8462 83.6307 101.077C83.6582 101.164 83.7195 101.237 83.8013 101.281C83.8832 101.325 83.9793 101.336 84.0692 101.311C84.1591 101.287 84.2358 101.229 84.283 101.151C84.3302 101.072 84.3441 100.978 84.3219 100.889Z'
                    fill='#1D1400'
                />
                <path
                    d='M81.4944 92.3346L81.3222 91.5573C81.2934 91.4718 81.2321 91.4004 81.1511 91.3578C81.0701 91.3152 80.9755 91.3047 80.8868 91.3284C80.7981 91.3522 80.7221 91.4083 80.6745 91.4853C80.6268 91.5623 80.6113 91.6543 80.6309 91.7422L80.8031 92.5219C80.8294 92.6108 80.89 92.6863 80.9722 92.7322C81.0544 92.7781 81.1516 92.7908 81.2432 92.7677C81.3317 92.7386 81.4057 92.6777 81.4501 92.5973C81.4945 92.5169 81.506 92.423 81.4824 92.3346H81.4944Z'
                    fill='#1D1400'
                />
            </g>
            <path
                d='M145.561 57.0946C150.823 58.7334 168.01 64.4273 172.009 68.5853C186.157 83.2952 191.928 122.918 192.376 126.608C193.021 131.789 191.558 143.465 186.157 146.742C183.198 148.538 174.437 142.762 169.893 138.08C163.562 131.555 160.483 114.845 159.213 105.932C156.884 89.586 145.561 57.0946 145.561 57.0946Z'
                fill='white'
            />
            <path
                d='M122.065 51.2391L151.268 49.5137C151.268 49.5137 152.225 45.5547 149.439 40.9612C147.829 38.3062 144.949 36.8617 143.06 33.2C141.247 29.6882 141.479 25.6262 140.752 22.0277C139.199 14.3392 133.5 8.19112 130.639 6.88004C123.782 3.73578 122.065 51.2391 122.065 51.2391Z'
                fill='#1D1400'
            />
            <path
                d='M112.684 49.5534C108.962 52.611 111.155 68.55 119.529 68.55C128.702 68.55 128.075 46.3084 128.737 46.175C131.78 45.592 134.904 43.9953 136.843 36.9014C137.121 35.89 137.126 35.2626 137.305 34.305C137.398 33.8157 138.111 27.1572 137.912 19.8667C137.824 16.5515 134.456 6.36955 122.289 8.95894C107.077 12.1945 109.696 26.6352 111.177 29.7326C112.045 31.547 113.275 36.0258 113.48 38.4255C113.731 41.317 113.1 49.2092 112.684 49.5534Z'
                fill='#CB8E00'
            />
            <path
                opacity='0.3'
                d='M128.711 46.154C128.045 46.2766 127.369 46.3393 126.69 46.3413C124.979 46.3388 123.29 45.9587 121.749 45.2292H121.73C121.694 45.2131 121.657 45.1991 121.62 45.1871C120.955 44.9857 120.61 45.9573 121.24 46.2476C122.483 46.8343 123.629 47.5997 124.641 48.5186C125.678 49.4739 126.494 50.6364 127.032 51.9274C127.373 52.5704 127.651 53.2429 127.865 53.9362C128.403 49.7407 128.468 46.2593 128.726 46.1868L128.711 46.154Z'
                fill='black'
            />
            <path
                d='M111.636 7.62455C117.415 2.56985 125.549 4.52243 129.096 6.05827C135.188 8.69917 137.037 14.8332 137.037 14.8332C135.626 16.5446 136.236 18.0828 134.667 20.1828C132.835 22.6388 130.584 20.5855 126.838 23.5565C125.306 24.7888 124.061 26.3279 123.186 28.0704C123.186 28.0704 121.926 25.6004 120.395 25.6215C118.642 25.6473 117.585 27.2604 118.07 28.8992C118.422 30.0815 119.804 32.8114 119.804 32.8114L114.32 46.5544C113.754 47.9729 112.686 49.1455 111.311 49.8587C109.936 50.5719 108.346 50.7785 106.829 50.4408L74.2858 40.2167C77.3545 33.3382 82.4706 32.4743 86.3811 29.1872C90.208 25.961 91.1839 22.6622 94.3817 20.1992C98.1536 17.2914 104.042 15.6011 105.697 13.9856C110.402 9.39217 107.977 10.825 111.636 7.62455Z'
                fill='#1D1400'
            />
            <mask
                id='mask2'
                mask-type='alpha'
                maskUnits='userSpaceOnUse'
                x='74'
                y='4'
                width='64'
                height='47'
            >
                <path
                    d='M111.636 7.62455C117.415 2.56985 125.549 4.52243 129.096 6.05827C135.188 8.69917 137.037 14.8332 137.037 14.8332C135.626 16.5446 136.236 18.0828 134.667 20.1828C132.835 22.6388 130.584 20.5855 126.838 23.5565C125.306 24.7888 124.061 26.3279 123.186 28.0704C123.186 28.0704 121.926 25.6004 120.395 25.6215C118.642 25.6473 117.585 27.2604 118.07 28.8992C118.422 30.0815 119.804 32.8114 119.804 32.8114L114.32 46.5544C113.754 47.9729 112.686 49.1455 111.311 49.8587C109.936 50.5719 108.346 50.7785 106.829 50.4408L74.2858 40.2167C77.3545 33.3382 82.4706 32.4743 86.3811 29.1872C90.208 25.961 91.1839 22.6622 94.3817 20.1992C98.1536 17.2914 104.042 15.6011 105.697 13.9856C110.402 9.39217 107.977 10.825 111.636 7.62455Z'
                    fill='#1D1400'
                />
            </mask>
            <g mask='url(#mask2)'>
                <rect
                    x='74.2472'
                    y='4.36786'
                    width='53.3371'
                    height='46.3562'
                    fill='url(#pattern2)'
                />
            </g>
            <path
                d='M132.08 67.6581C130.776 64.1323 129.927 60.5385 131.051 56.9494C132.534 52.171 134.321 51.9509 138.868 49.6916C143.414 47.4323 144.18 46.1517 146.954 41.3288C147.607 40.1909 148.289 40.4321 148.425 41.2937C148.545 42.0522 148.425 43.6349 148.425 43.6349C148.425 43.6349 150.339 37.7818 151.056 37.5477C152.436 37.0958 152.783 39.9545 152.97 40.5913C153.792 43.4125 153.209 44.8055 151.295 49.9562C150.049 53.3065 147.325 57.3357 144.228 59.2555C143.032 59.9953 141.597 60.8733 141.513 62.7673C141.482 63.4931 142.018 64.1229 142.446 64.7152C144.94 68.1545 164.998 91.3138 167.923 94.0601C177.452 103.008 185.67 109.709 189.564 122.061C191.274 127.49 189.803 141.493 188.368 144.537C185.02 151.631 172.822 142.196 167.799 135.874C156.636 121.822 136.519 79.6803 132.08 67.6581Z'
                fill='#CB8E00'
            />
            <mask
                id='mask3'
                mask-type='alpha'
                maskUnits='userSpaceOnUse'
                x='130'
                y='37'
                width='61'
                height='111'
            >
                <path
                    d='M132.08 67.6581C130.776 64.1323 129.927 60.5385 131.051 56.9494C132.534 52.171 134.321 51.9509 138.868 49.6916C143.414 47.4323 144.18 46.1517 146.954 41.3288C147.607 40.1909 148.289 40.4321 148.425 41.2937C148.545 42.0522 148.425 43.6349 148.425 43.6349C148.425 43.6349 150.339 37.7818 151.056 37.5477C152.436 37.0958 152.783 39.9545 152.97 40.5913C153.792 43.4125 153.209 44.8055 151.295 49.9562C150.049 53.3065 147.325 57.3357 144.228 59.2555C143.032 59.9953 141.597 60.8733 141.513 62.7673C141.482 63.4931 142.018 64.1229 142.446 64.7152C144.94 68.1545 164.998 91.3138 167.923 94.0601C177.452 103.008 185.67 109.709 189.564 122.061C191.274 127.49 189.803 141.493 188.368 144.537C185.02 151.631 172.822 142.196 167.799 135.874C156.636 121.822 136.519 79.6803 132.08 67.6581Z'
                    fill='#674600'
                />
            </mask>
            <g mask='url(#mask3)'>
                <rect
                    x='130.456'
                    y='37.3792'
                    width='37.5512'
                    height='76.0897'
                    fill='url(#pattern3)'
                />
            </g>
            <path
                d='M190.041 122.059C186.147 109.706 177.451 103.006 167.922 94.0577C167.343 93.5146 166.099 92.1848 164.454 90.3539C164.353 90.464 164.255 90.588 164.155 90.684C160.768 94.3644 156.587 97.0053 151.885 98.7542C150.256 99.3606 147.247 99.9553 145.561 100.18C152.669 114.298 161.043 129.515 166.762 136.703C171.785 143.024 185.499 151.619 188.845 144.525C190.28 141.491 191.751 127.488 190.041 122.059Z'
                fill='white'
            />
            <path
                d='M95.0299 134.636C97.426 135.825 99.7521 137.144 101.997 138.588C105.286 140.749 114.824 140.187 114.824 140.187C114.824 140.187 119.692 150.238 120.194 146.827C120.455 145.05 119.677 143.999 119.445 142.226C120.436 143.502 121.036 144.186 121.526 145.715C122.017 147.244 121.84 148.62 121.619 150.163C121.452 151.322 122.045 151.844 122.665 151.898C123.861 151.999 124.1 150.664 124.698 150.475C129.802 148.836 128.749 146.981 129.201 142.409C129.163 147.976 128.845 147.508 126.532 150.709C126.068 151.35 126.932 152.113 129.163 150.863C130.916 149.849 132.103 148.756 132.911 146.181C133.787 143.51 133.582 140.612 132.337 138.085C129.57 132.543 127.367 130.698 121.11 129.949C114.853 129.2 107.63 128.65 103.172 130.183C101.44 130.78 95.0299 134.636 95.0299 134.636Z'
                fill='#CB8E00'
            />
            <path
                d='M182.266 107.644C176.867 101.505 171.325 95.4961 165.639 89.6165C165.572 89.5567 165.484 89.524 165.393 89.525C165.303 89.5259 165.216 89.5603 165.15 89.6214C165.084 89.6825 165.045 89.7657 165.039 89.8542C165.033 89.9428 165.062 90.0301 165.12 90.0988C170.804 95.9846 176.347 101.994 181.747 108.126C182.049 108.47 182.568 107.986 182.266 107.644Z'
                fill='#1D1400'
            />
            <path
                d='M160.311 126.231L160.472 126.388C160.54 126.452 160.631 126.487 160.725 126.487C160.82 126.487 160.911 126.452 160.979 126.388C161.045 126.321 161.083 126.232 161.083 126.139C161.083 126.047 161.045 125.957 160.979 125.891L160.819 125.734C160.786 125.7 160.746 125.672 160.702 125.653C160.658 125.634 160.611 125.623 160.562 125.623C160.514 125.622 160.466 125.63 160.422 125.648C160.377 125.666 160.336 125.692 160.302 125.725C160.268 125.759 160.241 125.799 160.223 125.842C160.205 125.886 160.196 125.933 160.197 125.98C160.198 126.027 160.209 126.074 160.228 126.117C160.248 126.16 160.276 126.199 160.311 126.231Z'
                fill='white'
            />
            <path
                d='M160.381 126.746C155.218 118.275 150.381 109.625 145.872 100.796C145.666 100.393 145.047 100.746 145.253 101.152C149.759 109.973 154.595 118.623 159.761 127.102C159.809 127.182 159.888 127.24 159.981 127.264C160.073 127.287 160.171 127.274 160.253 127.227C160.335 127.18 160.395 127.102 160.419 127.012C160.443 126.922 160.429 126.826 160.381 126.746Z'
                fill='#1D1400'
            />
            <path
                d='M148.121 43.8619C147.681 45.0332 147.098 46.148 146.385 47.1818C146.126 47.5564 146.748 47.9099 147.004 47.5353C147.748 46.4482 148.355 45.2778 148.815 44.0492C148.972 43.6231 148.281 43.4405 148.121 43.8619Z'
                fill='black'
            />
            <path
                d='M145.975 48.7621H146.095C146.19 48.7621 146.281 48.7251 146.348 48.6593C146.416 48.5934 146.453 48.5041 146.453 48.4109C146.453 48.3178 146.416 48.2285 146.348 48.1626C146.281 48.0968 146.19 48.0598 146.095 48.0598H145.975C145.88 48.0598 145.789 48.0968 145.721 48.1626C145.654 48.2285 145.616 48.3178 145.616 48.4109C145.616 48.5041 145.654 48.5934 145.721 48.6593C145.789 48.7251 145.88 48.7621 145.975 48.7621Z'
                fill='black'
            />
            <path
                d='M151.529 42.2161C151.112 44.3131 150.312 46.319 149.166 48.137C148.927 48.5233 149.544 48.8745 149.785 48.4906C150.964 46.6214 151.789 44.5593 152.22 42.4034C152.311 41.9609 151.617 41.7713 151.529 42.2161Z'
                fill='black'
            />
            <path
                d='M148.965 49.4646C149.06 49.4646 149.151 49.4276 149.219 49.3617C149.286 49.2959 149.324 49.2065 149.324 49.1134C149.324 49.0203 149.286 48.9309 149.219 48.8651C149.151 48.7992 149.06 48.7622 148.965 48.7622C148.87 48.7622 148.779 48.7992 148.711 48.8651C148.644 48.9309 148.606 49.0203 148.606 49.1134C148.606 49.2065 148.644 49.2959 148.711 49.3617C148.779 49.4276 148.87 49.4646 148.965 49.4646Z'
                fill='black'
            />
            <path
                d='M119.709 139.555L119.039 138.129C118.845 137.719 118.226 138.075 118.42 138.482C118.641 138.951 118.865 139.426 119.089 139.908C119.283 140.318 119.9 139.962 119.709 139.555Z'
                fill='#1D1400'
            />
            <path
                d='M127.446 136.165C128.286 138.026 128.609 140.021 128.661 142.043C128.697 142.846 128.683 143.649 128.621 144.45C128.503 145.635 127.774 146.384 126.946 147.178C126.614 147.494 127.123 147.99 127.453 147.674C128.113 147.049 128.81 146.379 129.128 145.515C129.482 144.579 129.398 143.446 129.388 142.472C129.364 140.177 129.02 137.932 128.068 135.82C127.881 135.408 127.264 135.764 127.449 136.174L127.446 136.165Z'
                fill='#1D1400'
            />
            <path
                d='M124.781 142.397C125.072 143.671 125.139 144.985 124.982 146.281C124.93 146.728 125.647 146.726 125.7 146.281C125.86 144.921 125.783 143.544 125.473 142.21C125.372 141.77 124.679 141.957 124.781 142.397Z'
                fill='#1D1400'
            />
            <path
                d='M124.59 139.15C124.398 138.299 124.309 137.429 124.325 136.558C124.325 136.106 123.607 136.106 123.607 136.558C123.592 137.492 123.69 138.425 123.899 139.337C124 139.777 124.691 139.59 124.59 139.15Z'
                fill='#1D1400'
            />
            <path
                d='M128.768 27.8247H128.701C128.445 27.8247 128.198 27.9246 128.016 28.1024C127.835 28.2802 127.733 28.5214 127.733 28.7729C127.733 29.0243 127.835 29.2655 128.016 29.4433C128.198 29.6212 128.445 29.7211 128.701 29.7211H128.768C129.025 29.7211 129.272 29.6212 129.453 29.4433C129.635 29.2655 129.737 29.0243 129.737 28.7729C129.737 28.5214 129.635 28.2802 129.453 28.1024C129.272 27.9246 129.025 27.8247 128.768 27.8247Z'
                fill='black'
            />
            <path
                d='M135.585 29.4471H135.516C135.259 29.4471 135.013 29.5469 134.832 29.7245C134.65 29.9021 134.548 30.143 134.548 30.3942C134.548 30.6453 134.65 30.8862 134.832 31.0638C135.013 31.2414 135.259 31.3412 135.516 31.3412H135.585C135.842 31.3412 136.088 31.2414 136.269 31.0638C136.451 30.8862 136.553 30.6453 136.553 30.3942C136.553 30.143 136.451 29.9021 136.269 29.7245C136.088 29.5469 135.842 29.4471 135.585 29.4471Z'
                fill='black'
            />
            <path
                d='M126.41 37.379C127.381 38.4247 128.504 39.3255 129.742 40.0527C129.117 40.8768 127.752 40.9237 126.943 40.2728C126.135 39.6219 125.876 38.4607 126.14 37.4633'
                fill='black'
            />
            <path
                d='M131.811 36.8033C132.529 36.6465 134.153 36.6231 134.267 35.6514C134.346 34.9772 133.631 34.0805 133.411 33.4788C133.007 32.4336 132.778 31.3316 132.732 30.2151C132.732 29.6954 131.895 29.693 131.904 30.2151C131.963 31.669 132.303 33.0988 132.904 34.4293C132.997 34.6424 133.289 35.0287 133.301 35.2628C133.332 35.8622 133.244 35.5578 132.823 35.7451C132.462 35.9066 131.976 35.9301 131.586 36.0143C131.065 36.1267 131.287 36.911 131.806 36.7963L131.811 36.8033Z'
                fill='black'
            />
            <path
                opacity='0.3'
                d='M142.445 64.7129C139.192 62.5027 138.618 59.0939 142.445 57.0945C146.272 55.0951 150.671 51.4241 150.671 51.4241C150.671 51.4241 148.568 57.043 144.227 59.2485C139.886 61.4539 142.445 64.7129 142.445 64.7129Z'
                fill='black'
            />
        </g>
        <defs>
            <pattern
                id='pattern0'
                patternContentUnits='objectBoundingBox'
                width='1'
                height='1'
            >
                <use
                    transform='scale(0.00280899)'
                />
            </pattern>
            <pattern
                id='pattern1'
                patternContentUnits='objectBoundingBox'
                width='1'
                height='1'
            >
                <use
                    transform='scale(0.00320513 0.00245098)'
                />
            </pattern>
            <pattern
                id='pattern2'
                patternContentUnits='objectBoundingBox'
                width='1'
                height='1'
            >
                <use
                    transform='scale(0.0044843 0.00505051)'
                />
            </pattern>
            <pattern
                id='pattern3'
                patternContentUnits='objectBoundingBox'
                width='1'
                height='1'
            >
                <use
                    transform='scale(0.00636943 0.00307692)'
                />
            </pattern>
            <clipPath id='clip0'>
                <rect
                    width='236'
                    height='156'
                    fill='white'
                />
            </clipPath>
        </defs>
    </svg>
);

export default StartTrialModalSvg;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useState} from 'react';
import {useSelector, useDispatch} from 'react-redux';
import {Modal, Button} from 'react-bootstrap';
import {FormattedMessage, useIntl} from 'react-intl';

import {isModalOpen} from 'selectors/views/modals';
import {GlobalState} from 'types/store';
import {ModalIdentifiers} from 'utils/constants';
import {closeModal, openModal} from 'actions/views/modals';
import {getLicenseConfig} from 'mattermost-redux/actions/general';
import {requestTrialLicense} from 'actions/admin_actions';
import {getStandardAnalytics} from 'mattermost-redux/actions/admin';
import {DispatchFunc} from 'mattermost-redux/types/actions';
import {makeAsyncComponent} from 'components/async_load';

import StartTrialModalSvg from './start_trial_modal_svg';

const TrialBenefitsModal = makeAsyncComponent('TrialBenefisModal', React.lazy(() => import('components/trial_benefits_modal/trial_benefits_modal')));

import './start_trial_modal.scss';

enum TrialLoadStatus {
    NotStarted = 'NOT_STARTED',
    Started = 'STARTED',
    Success = 'SUCCESS',
    Failed = 'FAILED'
}

type Props = {
    onClose?: () => void;
}

function StartTrialModal(props: Props): JSX.Element | null {
    const [status, setLoadStatus] = useState(TrialLoadStatus.NotStarted);
    const dispatch = useDispatch<DispatchFunc>();

    useEffect(() => {
        dispatch(getStandardAnalytics());
    }, []);

    const {formatMessage} = useIntl();
    const show = useSelector((state: GlobalState) => isModalOpen(state, ModalIdentifiers.START_TRIAL_MODAL));
    const stats = useSelector((state: GlobalState) => state.entities.admin.analytics);

    const openTrialBenefitsModal = async () => {
        await dispatch(openModal({
            modalId: ModalIdentifiers.TRIAL_BENEFITS_MODAL,
            dialogType: TrialBenefitsModal,
            dialogProps: {trialJustStarted: true},
        }));
    };

    const requestLicense = async () => {
        setLoadStatus(TrialLoadStatus.Started);
        let users = 0;
        if (stats && (typeof stats.TOTAL_USERS === 'number')) {
            users = stats.TOTAL_USERS;
        }
        const requestedUsers = Math.max(users, 30);
        const {error} = await dispatch(requestTrialLicense(requestedUsers, true, true, 'license'));
        if (error) {
            setLoadStatus(TrialLoadStatus.Failed);
        }

        setLoadStatus(TrialLoadStatus.Success);
        await dispatch(getLicenseConfig());
        await dispatch(closeModal(ModalIdentifiers.START_TRIAL_MODAL));
        openTrialBenefitsModal();
    };

    const btnText = (status: TrialLoadStatus): string => {
        switch (status) {
        case TrialLoadStatus.Started:
            return formatMessage({id: 'start_trial.modal.loading', defaultMessage: 'Loading...'});
        case TrialLoadStatus.Success:
            return formatMessage({id: 'start_trial.modal.loaded', defaultMessage: 'Loaded!'});
        case TrialLoadStatus.Failed:
            return formatMessage({id: 'start_trial.modal.failed', defaultMessage: 'Failed'});
        default:
            return formatMessage({id: 'start_trial.modal_btn.start', defaultMessage: 'Start 30-day trial'});
        }
    };

    if (!show) {
        return null;
    }

    const handleOnClose = () => {
        if (props.onClose) {
            props.onClose();
        }
        dispatch(closeModal(ModalIdentifiers.START_TRIAL_MODAL));
    };

    return (
        <Modal
            className='StartTrialModal'
            dialogClassName='a11y__modal'
            show={show}
            id='startTrialModal'
            role='dialog'
            onHide={handleOnClose}
        >
            <Modal.Header closeButton={true}/>
            <Modal.Body>
                <StartTrialModalSvg/>
                <div className='title'>
                    <FormattedMessage
                        id='start_trial.modal_title'
                        defaultMessage='Start your free Enterprise trial now'
                    />
                </div>
                <div className='description'>
                    <FormattedMessage
                        id='start_trial.modal_body'
                        defaultMessage='Access all platform features including advanced security and enterprise compliance.'
                    />
                </div>
                <div className='buttons'>
                    <Button
                        className='dismiss-btn'
                        onClick={handleOnClose}
                    >
                        <FormattedMessage
                            id='start_trial.modal_btn.nottnow'
                            defaultMessage='Not now'
                        />
                    </Button>
                    <Button
                        className='confirm-btn'
                        onClick={requestLicense}
                    >
                        {btnText(status)}
                    </Button>
                </div>
                <div className='disclaimer'>
                    <span>
                        <FormattedMessage
                            id='start_trial.modal.disclaimer'
                            defaultMessage='By clicking Start free 30-day trial, I agree to the <linkEvaluation>Mattermost Software Evaluation Agreement</linkEvaluation>, <linkPrivacy>privacy policy</linkPrivacy> and receiving product emails.'
                            values={{
                                linkEvaluation: (msg: React.ReactNode) => (
                                    <a
                                        href='https://mattermost.com/software-evaluation-agreement'
                                        target='_blank'
                                        rel='noreferrer'
                                    >
                                        {msg}
                                    </a>
                                ),
                                linkPrivacy: (msg: React.ReactNode) => (
                                    <a
                                        href='https://mattermost.com/privacy-policy/'
                                        target='_blank'
                                        rel='noreferrer'
                                    >
                                        {msg}
                                    </a>
                                ),
                            }}
                        />
                    </span>
                </div>
            </Modal.Body>
        </Modal>
    );
}

export default StartTrialModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useEffect} from 'react';
import {useSelector, useDispatch} from 'react-redux';

import {DispatchFunc} from 'mattermost-redux/types/actions';
import {getStandardAnalytics} from 'mattermost-redux/actions/admin';
import {PreferenceType} from '@mattermost/types/preferences';

import {getConfig, getLicense} from 'mattermost-redux/selectors/entities/general';
import {makeGetCategory} from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentUser, isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';
import {savePreferences} from 'mattermost-redux/actions/preferences';

import {openModal} from 'actions/views/modals';
import {GlobalState} from 'types/store';

import {
    Preferences,
    Constants,
    TELEMETRY_CATEGORIES,
    ModalIdentifiers,
} from 'utils/constants';

import StartTrialModal from 'components/start_trial_modal';

import {trackEvent} from 'actions/telemetry_actions';
import {isModalOpen} from 'selectors/views/modals';

const ShowStartTrialModal = () => {
    const isUserAdmin = useSelector((state: GlobalState) => isCurrentUserSystemAdmin(state));

    const dispatch = useDispatch<DispatchFunc>();
    const getCategory = makeGetCategory();

    const userThreshold = 10;
    const stats = useSelector((state: GlobalState) => state.entities.admin.analytics);
    const isBenefitsModalOpened = useSelector((state: GlobalState) => isModalOpen(state, ModalIdentifiers.TRIAL_BENEFITS_MODAL));

    const installationDate = useSelector((state: GlobalState) => getConfig(state).InstallationDate);
    const currentUser = useSelector((state: GlobalState) => getCurrentUser(state));
    const preferences = useSelector<GlobalState, PreferenceType[]>((state) => getCategory(state, Preferences.START_TRIAL_MODAL));

    const prevTrialLicense = useSelector((state: GlobalState) => state.entities.admin.prevTrialLicense);
    const currentLicense = useSelector(getLicense);
    const isLicensed = (license: any) => {
        if (!license?.IsLicensed) {
            return false;
        }
        return license.IsLicensed === 'true';
    };
    const isPrevLicensed = isLicensed(prevTrialLicense);
    const isCurrentLicensed = isLicensed(currentLicense);

    // Show this modal if the instance is currently not licensed and has never had a trial license loaded before
    const isLicensedOrPreviousLicensed = (isCurrentLicensed || isPrevLicensed);
    useEffect(() => {
        if (!stats?.TOTAL_USERS) {
            dispatch(getStandardAnalytics());
        }
    }, [!stats?.TOTAL_USERS]);

    const handleOnClose = () => {
        trackEvent(
            TELEMETRY_CATEGORIES.SELF_HOSTED_START_TRIAL_AUTO_MODAL,
            'close_start_trial_auto_modal',
        );
        dispatch(savePreferences(currentUser.id, [
            {
                category: Preferences.START_TRIAL_MODAL,
                user_id: currentUser.id,
                name: Constants.TRIAL_MODAL_AUTO_SHOWN,
                value: 'true',
            },
        ]));
    };

    useEffect(() => {
        const installationDatePlus6Hours = (6 * 60 * 60 * 1000) + Number(installationDate);
        const now = new Date().getTime();
        const hasEnvMoreThan6Hours = now > installationDatePlus6Hours;
        const hasEnvMoreThan10Users = Number(stats?.TOTAL_USERS) > userThreshold;
        const hadAdminDismissedModal = preferences.some((pref: PreferenceType) => pref.name === Constants.TRIAL_MODAL_AUTO_SHOWN && pref.value === 'true');
        if (isUserAdmin && !isBenefitsModalOpened && hasEnvMoreThan10Users && hasEnvMoreThan6Hours && !hadAdminDismissedModal && !isLicensedOrPreviousLicensed) {
            dispatch(openModal({
                modalId: ModalIdentifiers.START_TRIAL_MODAL,
                dialogType: StartTrialModal,
                dialogProps: {onClose: handleOnClose},
            }));
            trackEvent(
                TELEMETRY_CATEGORIES.SELF_HOSTED_START_TRIAL_AUTO_MODAL,
                'trigger_start_trial_auto_modal',
            );
        }
    }, [stats?.TOTAL_USERS]);

    return null;
};
export default ShowStartTrialModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import useGetSubscription from './useGetSubscription';

export const useDelinquencySubscription = () => {
    const subscription = useGetSubscription();

    const isDelinquencySubscription = (): boolean => {
        if (!subscription) {
            return false;
        }

        if (!subscription.delinquent_since) {
            return false;
        }

        return true;
    };

    const isDelinquencySubscriptionHigherThan90Days = (): boolean => {
        if (!isDelinquencySubscription()) {
            return false;
        }

        if (!subscription) {
            return false;
        }

        const delinquencyDate = new Date((subscription.delinquent_since || 0) * 1000);

        const oneDay = 24 * 60 * 60 * 1000; // hours*minutes*seconds*milliseconds
        const today = new Date();
        const diffDays = Math.round(
            Math.abs((today.valueOf() - delinquencyDate.valueOf()) / oneDay),
        );

        return diffDays > 90;
    };

    return {isDelinquencySubscription, isDelinquencySubscriptionHigherThan90Days, subscription};
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useSelector} from 'react-redux';

import {FormattedMessage} from 'react-intl';

import {t} from 'utils/i18n';
import {
    AnnouncementBarTypes, TELEMETRY_CATEGORIES,
} from 'utils/constants';

import AnnouncementBar from '../default_announcement_bar';
import useGetSubscription from 'components/common/hooks/useGetSubscription';
import useOpenCloudPurchaseModal from 'components/common/hooks/useOpenCloudPurchaseModal';
import {trackEvent} from 'actions/telemetry_actions';
import {useDelinquencySubscription} from 'components/common/hooks/useDelinquencySubscription';
import {GlobalState} from 'types/store';
import {getCurrentUser} from 'mattermost-redux/selectors/entities/users';
import {isSystemAdmin} from 'mattermost-redux/utils/user_utils';

const CloudDelinquencyAnnouncementBar = () => {
    const subscription = useGetSubscription();
    const openPurchaseModal = useOpenCloudPurchaseModal({});
    const {isDelinquencySubscription} = useDelinquencySubscription();
    const currentUser = useSelector((state: GlobalState) =>
        getCurrentUser(state),
    );

    const getBannerType = () => {
        const delinquencyDate = new Date(
            (subscription?.delinquent_since || 0) * 1000,
        );

        const oneDay = 24 * 60 * 60 * 1000; // hours*minutes*seconds*milliseconds
        const today = new Date();
        const diffDays = Math.round(
            Math.abs((today.valueOf() - delinquencyDate.valueOf()) / oneDay),
        );
        if (diffDays > 90) {
            return AnnouncementBarTypes.CRITICAL;
        }
        return AnnouncementBarTypes.ADVISOR;
    };

    if (!isDelinquencySubscription() || !isSystemAdmin(currentUser.roles)) {
        return null;
    }

    const message = {
        id: t('cloud_delinquency.banner.title'),
        defaultMessage:
            'Update your billing information now to keep paid features.',
    };

    return (
        <AnnouncementBar
            type={getBannerType()}
            showCloseButton={false}
            onButtonClick={() => {
                trackEvent(TELEMETRY_CATEGORIES.CLOUD_DELINQUENCY, 'click_update_billing');
                openPurchaseModal({
                    trackingLocation:
                        'cloud_delinquency_announcement_bar',
                });
            }
            }
            modalButtonText={t('cloud_delinquency.banner.buttonText')}
            modalButtonDefaultText={'Update billing now'}
            message={<FormattedMessage {...message}/>}
            showLinkAsButton={true}
            isTallBanner={true}
            icon={<i className='icon icon-alert-outline'/>}
        />
    );
};

export default CloudDelinquencyAnnouncementBar;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback} from 'react';
import {useHistory} from 'react-router-dom';

import {trackEvent} from 'actions/telemetry_actions';

import './three_days_left_trial_modal.scss';

export type LearnMoreActionButtonProps = {
    id: string;
    route: string;
    message: string;
    telemetryCategory: string;
    telemetryId: string;
    onClick?: () => void;
    styleLink?: boolean; // show as a anchor link
}

const LearnMoreActionButton = (
    {
        id,
        route,
        message,
        onClick,
        styleLink = false,
        telemetryId,
        telemetryCategory,
    }: LearnMoreActionButtonProps) => {
    const history = useHistory();

    const redirect = useCallback(() => {
        if (route.indexOf('http://') === 0 || route.indexOf('https://') === 0) {
            window.open(route);
        } else {
            history.push(route);
        }

        if (onClick) {
            onClick();
        }

        trackEvent(
            telemetryCategory,
            telemetryId + '_section_opened_' + id,
        );
    }, [route, onClick]);

    return (
        <a
            className={`LearnMoreActionButton ${styleLink ? '' : 'learn-more-button'}`}
            onClick={redirect}
        >
            {message}
        </a>
    );
};

export default LearnMoreActionButton;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {TELEMETRY_CATEGORIES} from 'utils/constants';

import LearnMoreActionButton from './learn_more_action_button';

import './three_days_left_trial_modal.scss';

export type ThreeDaysLeftTrialCardProps = {
    id: string;
    title: string;
    description: string | JSX.Element;
    svgWrapperClassName: string;
    svgElement: React.ReactNode;
    buttonLabel?: string;
    pageURL?: string;
    isCloud?: boolean;
    onClose?: () => void;
}

const ThreeDaysLeftTrialCard = (
    {
        id,
        title,
        description,
        svgWrapperClassName,
        svgElement,
        buttonLabel,
        pageURL,
        onClose,
    }: ThreeDaysLeftTrialCardProps) => {
    return (
        <div
            id={`threeDaysLeftTrialCard-${id}`}
            className='three-days-left-card slide-container'
        >
            <div className={`${svgWrapperClassName} svg-wrapper`}>
                {svgElement}
            </div>
            <div className='content-wrapper'>
                <div className='title'>
                    {title}
                </div>
                <div className='description'>
                    {description}
                    {(pageURL && buttonLabel) && (
                        <LearnMoreActionButton
                            id={id}
                            route={pageURL}
                            message={buttonLabel}
                            onClick={onClose}
                            telemetryCategory={TELEMETRY_CATEGORIES.CLOUD_THREE_DAYS_LEFT_MODAL}
                            telemetryId={'three_days_left_trial'}
                        />
                    )}
                </div>
            </div>
        </div>
    );
};

export default ThreeDaysLeftTrialCard;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useMemo} from 'react';
import {useSelector, useDispatch} from 'react-redux';
import {useIntl} from 'react-intl';

import {isModalOpen} from 'selectors/views/modals';
import {GlobalState} from 'types/store';

import {closeModal} from 'actions/views/modals';

import {DispatchFunc} from 'mattermost-redux/types/actions';

import {ConsolePages, DocLinks, ModalIdentifiers} from 'utils/constants';

import GenericModal from 'components/generic_modal';
import GuestAccessSvg from 'components/common/svg_images_components/guest_access_svg';
import MonitorImacLikeSVG from 'components/common/svg_images_components/monitor_imaclike_svg';
import SystemRolesSVG from 'components/admin_console/feature_discovery/features/images/system_roles_svg';
import useOpenPricingModal from 'components/common/hooks/useOpenPricingModal';
import WorkspaceLimitsPanel from 'components/cloud_usage_modal/workspace_limits_panel';
import useGetUsage from 'components/common/hooks/useGetUsage';
import useGetLimits from 'components/common/hooks/useGetLimits';

import ThreeDaysLeftTrialCard, {ThreeDaysLeftTrialCardProps} from './three_days_left_trial_modal_card';

import './three_days_left_trial_modal.scss';

type Props = {
    onExited?: () => void;
    limitsOverpassed: boolean;
}

function ThreeDaysLeftTrialModal(props: Props): JSX.Element | null {
    const dispatch = useDispatch<DispatchFunc>();
    const {formatMessage} = useIntl();
    const openPricingModal = useOpenPricingModal();
    const show = useSelector((state: GlobalState) => isModalOpen(state, ModalIdentifiers.THREE_DAYS_LEFT_TRIAL_MODAL));
    const usage = useGetUsage();
    const [limits] = useGetLimits();

    // move this to the show three days left so it is easier to test
    const handleOnClose = async () => {
        if (props.onExited) {
            props.onExited();
        }
        await dispatch(closeModal(ModalIdentifiers.THREE_DAYS_LEFT_TRIAL_MODAL));
    };

    const handleOpenPricingModal = async () => {
        await dispatch(closeModal(ModalIdentifiers.THREE_DAYS_LEFT_TRIAL_MODAL));
        openPricingModal({trackingLocation: 'three_days_left_trial_modal'});
    };

    const buttonLabel = formatMessage({id: 'three_days_left_trial_modal.learnMore', defaultMessage: 'Learn more'});

    const steps: ThreeDaysLeftTrialCardProps[] = useMemo(() => [
        {
            id: 'useSso',
            title: formatMessage({id: 'three_days_left_trial.modal.useSsoTitle', defaultMessage: 'Single Sign on (with OpenID, SAML, Google, 0365)'}),
            description: formatMessage({id: 'three_days_left_trial.modal.useSsoDescription', defaultMessage: 'Collaborate with users outside of your organization while tightly controlling their access to channels and team members.'}),
            svgWrapperClassName: 'guestAccessSvg',
            svgElement: (
                <GuestAccessSvg
                    width={130}
                    height={90}
                />
            ),
            pageURL: DocLinks.ONBOARD_SSO,
            buttonLabel,
        },
        {
            id: 'ldap',
            title: formatMessage({id: 'three_days_left_trial.modal.ldapTitle', defaultMessage: 'Synchronize your Active Directory/LDAP groups'}),
            description: formatMessage({id: 'three_days_left_trial.modal.ldapDescription', defaultMessage: 'Use AD/LDAP groups to organize and apply actions to multiple users at once. Manage team and channel memberships, permissions and more.'}),
            svgWrapperClassName: 'personMacSvg',
            svgElement: (
                <MonitorImacLikeSVG
                    width={130}
                    height={90}
                />
            ),
            pageURL: DocLinks.ONBOARD_LDAP,
            buttonLabel,
        },
        {
            id: 'systemConsole',
            title: formatMessage({id: 'three_days_left_trial.modal.systemConsoleTitle', defaultMessage: 'Provide controlled access to the System Console'}),
            description: formatMessage({id: 'three_days_left_trial.modal.systemConsoleDescription', defaultMessage: 'Use System Roles to give designated users read and/or write access to select sections of System Console.'}),
            svgWrapperClassName: 'personBoxSvg',
            svgElement: (
                <SystemRolesSVG
                    width={130}
                    height={90}
                />
            ),
            pageURL: ConsolePages.LICENSE,
            buttonLabel,
        },
    ], []);

    let headerText = formatMessage({id: 'three_days_left_trial.modal.title', defaultMessage: 'Your trial ends soon'});
    let headerSubtitleText = formatMessage({id: 'three_days_left_trial.modal.subtitle', defaultMessage: 'There is still time to explore what our paid plans can help you accomplish.'});

    let content: React.ReactNode = useMemo(
        () =>
            steps.map(({id, ...rest}) => (
                <ThreeDaysLeftTrialCard
                    {...rest}
                    id={id}
                    key={id}
                />
            )),
        [],
    );

    if (props.limitsOverpassed) {
        headerText = formatMessage({id: 'three_days_left_trial.modal.titleLimitsOverpassed', defaultMessage: 'Upgrade before the trial ends'});
        headerSubtitleText = formatMessage({id: 'three_days_left_trial.modal.subtitleLimitsOverpassed', defaultMessage: 'There are 3 days left on your trial. Upgrade to our Professional or Enterprise plan to avoid exceeding your data limits on the Free plan.'});
        content = (
            <div className='workspace-limits-panel'>
                <p className='limits-title'>
                    {formatMessage({id: 'three_days_left_trial.modal.limitsTitle', defaultMessage: 'Limits'})}
                </p>
                <WorkspaceLimitsPanel
                    showIcons={true}
                    limits={limits}
                    usage={usage}
                />
            </div>
        );
    }

    if (!show) {
        return null;
    }

    return (
        <GenericModal
            className='ThreeDaysLeftTrialModal'
            id='threeDaysLeftTrialModal'
            onExited={handleOnClose}
            modalHeaderText={headerText}
            compassDesign={true}
        >
            <div className='header-subtitle-text'>
                {headerSubtitleText}
            </div>
            <div className='content-container'>
                {content}
            </div>
            <div className='divisory-line'/>
            <div className='footer-content'>
                <button
                    onClick={handleOpenPricingModal}
                    className='open-view-plans-modal-btn'
                >
                    {formatMessage({id: 'three_days_left_trial.modal.viewPlans', defaultMessage: 'View plan options'})}
                </button>
            </div>
        </GenericModal>
    );
}

export default ThreeDaysLeftTrialModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useEffect} from 'react';
import {useSelector, useDispatch} from 'react-redux';

import moment from 'moment';

import {DispatchFunc} from 'mattermost-redux/types/actions';

import {get as getPreference} from 'mattermost-redux/selectors/entities/preferences';
import {isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';
import {getCloudSubscription} from 'mattermost-redux/selectors/entities/cloud';
import {getLicense} from 'mattermost-redux/selectors/entities/general';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/common';
import {savePreferences} from 'mattermost-redux/actions/preferences';

import useGetHighestThresholdCloudLimit from 'components/common/hooks/useGetHighestThresholdCloudLimit';

import {openModal, closeModal} from 'actions/views/modals';

import {GlobalState} from 'types/store';

import {
    Preferences,
    TELEMETRY_CATEGORIES,
    ModalIdentifiers,
    CloudBanners,
} from 'utils/constants';

import ThreeDaysLeftTrialModal from 'components/three_days_left_trial_modal/three_days_left_trial_modal';
import useGetLimits from 'components/common/hooks/useGetLimits';
import useGetUsage from 'components/common/hooks/useGetUsage';

import {trackEvent} from 'actions/telemetry_actions';

const ShowThreeDaysLeftTrialModal = () => {
    const license = useSelector(getLicense);
    const isCloud = license?.Cloud === 'true';
    const isUserAdmin = useSelector((state: GlobalState) => isCurrentUserSystemAdmin(state));
    const subscription = useSelector(getCloudSubscription);
    const isFreeTrial = subscription?.is_free_trial === 'true';

    const dispatch = useDispatch<DispatchFunc>();
    const hadAdminDismissedModal = useSelector((state: GlobalState) => getPreference(state, Preferences.CLOUD_TRIAL_BANNER, CloudBanners.THREE_DAYS_LEFT_TRIAL_MODAL_DISMISSED)) === 'true';

    const trialEndDate = new Date(subscription?.trial_end_at || 0);

    const today = moment();
    const formattedEndDate = moment(Number(trialEndDate || 0));
    const diffDays = formattedEndDate.diff(today, 'days');

    // the trial will end in three days or left
    const trialEndInThreeDaysOrLess = diffDays <= 3;

    // validate the logic for the limits and pass that to the modal as a property
    const someLimitNeedsAttention = Boolean(useGetHighestThresholdCloudLimit(useGetUsage(), useGetLimits()[0]));

    const currentUserId = useSelector(getCurrentUserId);

    const handleOnClose = async () => {
        trackEvent(
            TELEMETRY_CATEGORIES.CLOUD_ADMIN,
            'dismissed_three_days_left_trial_modal',
        );

        await dispatch(savePreferences(currentUserId, [{
            category: Preferences.CLOUD_TRIAL_BANNER,
            user_id: currentUserId,
            name: CloudBanners.THREE_DAYS_LEFT_TRIAL_MODAL_DISMISSED,
            value: 'true',
        }]));
        dispatch(closeModal(ModalIdentifiers.THREE_DAYS_LEFT_TRIAL_MODAL));
    };

    useEffect(() => {
        if (subscription?.trial_end_at === undefined || subscription.trial_end_at === 0) {
            return;
        }

        if (isCloud && isFreeTrial && isUserAdmin && !hadAdminDismissedModal && trialEndInThreeDaysOrLess) {
            dispatch(openModal({
                modalId: ModalIdentifiers.THREE_DAYS_LEFT_TRIAL_MODAL,
                dialogType: ThreeDaysLeftTrialModal,
                dialogProps: {
                    limitsOverpassed: someLimitNeedsAttention,
                    onExited: handleOnClose,
                },
            }));
            trackEvent(
                TELEMETRY_CATEGORIES.CLOUD_THREE_DAYS_LEFT_MODAL,
                'trigger_cloud_three_days_left_modal',
            );
        }
    }, [subscription?.trial_end_at]);

    return null;
};
export default ShowThreeDaysLeftTrialModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect} from 'react';

import {FormattedMessage} from 'react-intl';
import {useSelector, useDispatch} from 'react-redux';

import {t} from 'utils/i18n';
import {
    AnnouncementBarTypes, CloudProducts, CloudProductToSku, PaidFeatures, Preferences, TELEMETRY_CATEGORIES,
} from 'utils/constants';

import {GlobalState} from 'types/store';
import {makeGetCategory} from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentUser} from 'mattermost-redux/selectors/entities/users';
import {trackEvent} from 'actions/telemetry_actions';
import {getSubscriptionProduct} from 'mattermost-redux/selectors/entities/cloud';
import {NotifyStatus, useGetNotifyAdmin} from 'components/common/hooks/useGetNotifyAdmin';
import {savePreferences} from 'mattermost-redux/actions/preferences';
import {isSystemAdmin} from 'mattermost-redux/utils/user_utils';

import AnnouncementBar from '../default_announcement_bar';
import {useDelinquencySubscription} from 'components/common/hooks/useDelinquencySubscription';

export const BannerPreferenceName = 'notify_upgrade_workspace_banner';

const NotifyAdminDowngradeDelinquencyBar = () => {
    const dispatch = useDispatch();
    const getCategory = makeGetCategory();
    const preferences = useSelector((state: GlobalState) =>
        getCategory(state, Preferences.NOTIFY_ADMIN_REVOKE_DOWNGRADED_WORKSPACE),
    );
    const product = useSelector(getSubscriptionProduct);
    const currentUser = useSelector((state: GlobalState) =>
        getCurrentUser(state),
    );
    const {isDelinquencySubscriptionHigherThan90Days} = useDelinquencySubscription();

    const {notifyAdmin, notifyStatus} = useGetNotifyAdmin({});

    useEffect(() => {
        if (notifyStatus === NotifyStatus.Success) {
            dispatch(savePreferences(currentUser.id, [{
                category: Preferences.NOTIFY_ADMIN_REVOKE_DOWNGRADED_WORKSPACE,
                name: BannerPreferenceName,
                user_id: currentUser.id,
                value: 'adminNotified',
            }]));
        }
    }, [currentUser, dispatch, notifyStatus]);

    const shouldShowBanner = () => {
        if (!isDelinquencySubscriptionHigherThan90Days()) {
            return false;
        }

        if (isSystemAdmin(currentUser.roles)) {
            return false;
        }

        if (!preferences) {
            return false;
        }

        if (preferences.some((pref) => pref.name === BannerPreferenceName)) {
            return false;
        }

        return true;
    };

    if (!shouldShowBanner() || product == null) {
        return null;
    }

    const notifyAdminRequestData = {
        required_feature: PaidFeatures.UPGRADE_DOWNGRADED_WORKSPACE,
        required_plan: CloudProductToSku[product?.sku] || CloudProductToSku[CloudProducts.PROFESSIONAL],
        trial_notification: false,
    };

    const message = (
        <FormattedMessage
            id={t('cloud_delinquency.banner.end_user_notify_admin_title')}
            defaultMessage={'Your workspace has been downgraded. Notify your admin to fix billing issues'}
        />);

    const handleClick = () => {
        trackEvent(TELEMETRY_CATEGORIES.CLOUD_DELINQUENCY, 'click_notify_admin_upgrade_workspace_banner');

        notifyAdmin({
            requestData: notifyAdminRequestData,
            trackingArgs: {
                category: TELEMETRY_CATEGORIES.CLOUD_DELINQUENCY,
                event: 'notify_admin_downgrade_delinquency_bar',
            },
        });
    };

    const handleClose = () => {
        dispatch(savePreferences(currentUser.id, [{
            category: Preferences.NOTIFY_ADMIN_REVOKE_DOWNGRADED_WORKSPACE,
            name: BannerPreferenceName,
            user_id: currentUser.id,
            value: 'dismissBanner',
        }]));
    };

    return (
        <AnnouncementBar
            type={AnnouncementBarTypes.CRITICAL}
            showCloseButton={true}
            onButtonClick={handleClick}
            modalButtonText={t('cloud_delinquency.banner.end_user_notify_admin_button')}
            modalButtonDefaultText={'Notify admin'}
            message={message}
            showLinkAsButton={true}
            isTallBanner={true}
            icon={<i className='icon icon-alert-outline'/>}
            handleClose={handleClose}
        />
    );
};

export default NotifyAdminDowngradeDelinquencyBar;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage, useIntl} from 'react-intl';
import {useDispatch, useSelector} from 'react-redux';

import {getCurrentUser, isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';
import {GlobalState} from 'types/store';
import {getLicense} from 'mattermost-redux/selectors/entities/general';
import AnnouncementBar from 'components/announcement_bar/default_announcement_bar';
import {calculateOverageUserActivated} from 'utils/overage_team';
import {isCurrentLicenseCloud} from 'mattermost-redux/selectors/entities/cloud';
import {savePreferences} from 'mattermost-redux/actions/preferences';
import {makeGetCategory} from 'mattermost-redux/selectors/entities/preferences';
import {PreferenceType} from '@mattermost/types/preferences';
import {LicenseLinks, StatTypes, Preferences, AnnouncementBarTypes} from 'utils/constants';

import './overage_users_banner.scss';

type AdminHasDismissedItArgs = {
    preferenceName: string;
    overagePreferences: PreferenceType[];
    isWarningBanner: boolean;
}

const adminHasDismissed = ({preferenceName, overagePreferences, isWarningBanner}: AdminHasDismissedItArgs): boolean => {
    if (isWarningBanner) {
        return overagePreferences.find((value) => value.name === preferenceName) !== undefined;
    }

    return false;
};

const OverageUsersBanner = () => {
    const {formatMessage} = useIntl();
    const dispatch = useDispatch();
    const stats = useSelector((state: GlobalState) => state.entities.admin.analytics) || {};
    const isAdmin = useSelector(isCurrentUserSystemAdmin);
    const license = useSelector(getLicense);
    const seatsPurchased = parseInt(license.Users, 10);
    const isCloud = useSelector(isCurrentLicenseCloud);
    const getPreferencesCategory = makeGetCategory();
    const currentUser = useSelector((state: GlobalState) => getCurrentUser(state));
    const overagePreferences = useSelector((state: GlobalState) => getPreferencesCategory(state, Preferences.OVERAGE_USERS_BANNER));
    const activeUsers = ((stats || {})[StatTypes.TOTAL_USERS]) as number || 0;
    const {
        isBetween5PercerntAnd10PercentPurchasedSeats,
        isOver10PercerntPurchasedSeats,
    } = calculateOverageUserActivated({
        activeUsers,
        seatsPurchased,
    });
    const prefixPreferences = isOver10PercerntPurchasedSeats ? 'error' : 'warn';
    const prefixLicenseId = (license.Id || '').substring(0, 8);
    const preferenceName = `${prefixPreferences}_overage_seats_${prefixLicenseId}`;

    const overageByUsers = activeUsers - seatsPurchased;

    const isOverageState = isBetween5PercerntAnd10PercentPurchasedSeats || isOver10PercerntPurchasedSeats;

    if (!isAdmin || !isOverageState || isCloud || adminHasDismissed({isWarningBanner: isBetween5PercerntAnd10PercentPurchasedSeats, overagePreferences, preferenceName})) {
        return null;
    }

    const handleClose = () => {
        dispatch(savePreferences(currentUser.id, [{
            category: Preferences.OVERAGE_USERS_BANNER,
            name: preferenceName,
            user_id: currentUser.id,
            value: 'Overage users banner watched',
        }]));
    };

    const handleClick = async (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {
        e.preventDefault();
        window.open(LicenseLinks.CONTACT_SALES, '_blank');
    };

    const message = (
        <FormattedMessage
            id='licensingPage.overageUsersBanner.text'
            defaultMessage='Your workspace user count has exceeded your paid license seat count by {seats, number} {seats, plural, one {seat} other {seats}}. Purchase additional seats to remain compliant.'
            values={{
                seats: overageByUsers,
            }}
        />);

    const cta = formatMessage({
        id: 'licensingPage.overageUsersBanner.cta',
        defaultMessage: 'Contact Sales',
    });

    return (
        <AnnouncementBar
            type={isBetween5PercerntAnd10PercentPurchasedSeats ? AnnouncementBarTypes.ADVISOR : AnnouncementBarTypes.CRITICAL}
            showCloseButton={isBetween5PercerntAnd10PercentPurchasedSeats}
            onButtonClick={handleClick}
            modalButtonText={cta}
            modalButtonDefaultText={cta}
            message={message}
            showLinkAsButton={true}
            isTallBanner={true}
            icon={<i className='icon icon-alert-outline'/>}
            handleClose={handleClose}
        />
    );
};

export default OverageUsersBanner;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {ClientLicense, ClientConfig, WarnMetricStatus} from '@mattermost/types/config';
import withGetCloudSubscription from '../common/hocs/cloud/with_get_cloud_subscription';

import ConfigurationAnnouncementBar from './configuration_bar';
import VersionBar from './version_bar';
import TextDismissableBar from './text_dismissable_bar';
import AnnouncementBar from './default_announcement_bar';

import PaymentAnnouncementBar from './payment_announcement_bar';
import CloudTrialAnnouncementBar from './cloud_trial_announcement_bar';
import CloudTrialEndAnnouncementBar from './cloud_trial_ended_announcement_bar';
import AutoStartTrialModal from './show_start_trial_modal/show_start_trial_modal';
import CloudDelinquencyAnnouncementBar from './cloud_delinquency';
import ShowThreeDaysLeftTrialModal from './show_tree_days_left_trial_modal/show_three_days_left_trial_modal';
import NotifyAdminDowngradeDelinquencyBar from './notify_admin_downgrade_delinquency_bar';
import OverageUsersBanner from './overage_users_banner';

type Props = {
    license?: ClientLicense;
    config?: Partial<ClientConfig>;
    canViewSystemErrors: boolean;
    isCloud: boolean;
    userIsAdmin: boolean;
    subscription?: Subscription;
    latestError?: {
        error: any;
    };
    warnMetricsStatus?: Record<string, WarnMetricStatus>;
    actions: {
        dismissError: (index: number) => void;
        getCloudSubscription: () => void;
        getCloudCustomer: () => void;
    };
};

class AnnouncementBarController extends React.PureComponent<Props> {
    render() {
        let adminConfiguredAnnouncementBar = null;
        if (this.props.config?.EnableBanner === 'true' && this.props.config.BannerText?.trim()) {
            adminConfiguredAnnouncementBar = (
                <TextDismissableBar
                    color={this.props.config.BannerColor}
                    textColor={this.props.config.BannerTextColor}
                    allowDismissal={this.props.config.AllowBannerDismissal === 'true'}
                    text={this.props.config.BannerText}
                />
            );
        }

        let errorBar = null;
        if (this.props.latestError) {
            errorBar = (
                <AnnouncementBar
                    type={this.props.latestError.error.type}
                    message={this.props.latestError.error.message}
                    showCloseButton={true}
                    handleClose={this.props.actions.dismissError}
                />
            );
        }

        let paymentAnnouncementBar = null;
        let cloudTrialAnnouncementBar = null;
        let cloudTrialEndAnnouncementBar = null;
        let cloudDelinquencyAnnouncementBar = null;
        let notifyAdminDowngradeDelinquencyBar = null;
        if (this.props.license?.Cloud === 'true') {
            paymentAnnouncementBar = (
                <PaymentAnnouncementBar/>
            );
            cloudTrialAnnouncementBar = (
                <CloudTrialAnnouncementBar/>
            );
            cloudTrialEndAnnouncementBar = (
                <CloudTrialEndAnnouncementBar/>
            );
            cloudDelinquencyAnnouncementBar = (
                <CloudDelinquencyAnnouncementBar/>
            );
            notifyAdminDowngradeDelinquencyBar = (
                <NotifyAdminDowngradeDelinquencyBar/>
            );
        }

        return (
            <>
                {adminConfiguredAnnouncementBar}
                {errorBar}
                {paymentAnnouncementBar}
                {cloudTrialAnnouncementBar}
                {cloudTrialEndAnnouncementBar}
                {cloudDelinquencyAnnouncementBar}
                {notifyAdminDowngradeDelinquencyBar}
                {this.props.license?.Cloud !== 'true' && <OverageUsersBanner/>}
                <AutoStartTrialModal/>
                <ShowThreeDaysLeftTrialModal/>
                <VersionBar/>
                <ConfigurationAnnouncementBar
                    config={this.props.config}
                    license={this.props.license}
                    canViewSystemErrors={this.props.canViewSystemErrors}
                    warnMetricsStatus={this.props.warnMetricsStatus}
                />
            </>
        );
    }
}

export default withGetCloudSubscription(AnnouncementBarController);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {Permissions} from 'mattermost-redux/constants';
import {haveISystemPermission} from 'mattermost-redux/selectors/entities/roles';
import {getConfig, getLicense, warnMetricsStatus as getWarnMetricsStatus} from 'mattermost-redux/selectors/entities/general';
import {getDisplayableErrors} from 'mattermost-redux/selectors/errors';
import {dismissError} from 'mattermost-redux/actions/errors';
import {getStandardAnalytics} from 'mattermost-redux/actions/admin';
import {GenericAction} from 'mattermost-redux/types/actions';
import {getCloudSubscription, getCloudCustomer} from 'mattermost-redux/actions/cloud';
import {isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';

import {dismissNotice} from 'actions/views/notice';
import {GlobalState} from 'types/store';

import AnnouncementBarController from './announcement_bar_controller';

function mapStateToProps(state: GlobalState) {
    const canViewSystemErrors = haveISystemPermission(state, {permission: Permissions.MANAGE_SYSTEM});
    const license = getLicense(state);
    const config = getConfig(state);
    const errors = getDisplayableErrors(state);
    const warnMetricsStatus = getWarnMetricsStatus(state);
    const isCloud = license.Cloud === 'true';
    const subscription = state.entities.cloud?.subscription;
    const userIsAdmin = isCurrentUserSystemAdmin(state);

    let latestError = null;
    if (errors && errors.length >= 1) {
        latestError = errors[0];
    }

    return {
        license,
        config,
        canViewSystemErrors,
        latestError,
        warnMetricsStatus,
        isCloud,
        subscription,
        userIsAdmin,
    };
}

//
function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    const dismissFirstError = dismissError.bind(null, 0);
    return {
        actions: bindActionCreators({
            getStandardAnalytics,
            dismissError: dismissFirstError,
            dismissNotice,
            getCloudSubscription,
            getCloudCustomer,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(AnnouncementBarController);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {GlobalState} from '@mattermost/types/store';

export function getDisplayableErrors(state: GlobalState) {
    return state.errors.filter((error) => error.displayable);
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {trackEvent} from 'actions/telemetry_actions';
import './purchase_link.scss';

export interface Props {
    buttonTextElement: JSX.Element;
    eventID?: string;
}

const PurchaseLink: React.FC<Props> = (props: Props) => {
    const handlePurchaseLinkClick = async (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {
        e.preventDefault();
        trackEvent('admin', props.eventID || 'in_trial_purchase_license');
        window.open('https://customers.mattermost.com/signup', '_blank');
    };

    return (
        <button
            id={props.eventID}
            className={'annnouncementBar__purchaseNow'}
            onClick={(e) => handlePurchaseLinkClick(e)}
        >
            {props.buttonTextElement}
        </button>
    );
};

export default PurchaseLink;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

const NoInternetConnectionSvg: React.FC = () => {
    return (
        <svg
            width='311'
            height='216'
            viewBox='0 0 311 216'
            fill='none'
            xmlns='http://www.w3.org/2000/svg'
        >
            <g clipPath='url(#clip0)'>
                <path
                    d='M61.9647 216C96.1868 216 123.929 213.897 123.929 211.302C123.929 208.707 96.1868 206.604 61.9647 206.604C27.7425 206.604 0 208.707 0 211.302C0 213.897 27.7425 216 61.9647 216Z'
                    fill='#3D3C40'
                    fillOpacity='0.08'
                />
                <path
                    d='M47.3647 47.9266C58.1484 43.348 71.5797 46.2489 84.6968 48.2623C84.8189 45.8241 86.2984 42.8567 84.7486 41.1556C82.8656 39.089 83.039 36.9175 84.172 34.7336C87.0694 29.1489 82.9183 23.2065 78.7269 18.2655C77.7822 17.1543 76.5882 16.2813 75.242 15.7172C73.8958 15.1532 72.4353 14.9141 70.9792 15.0193L63.2149 15.5729C61.3256 15.7076 59.5225 16.4151 58.047 17.6008C56.5715 18.7864 55.4939 20.3936 54.9584 22.2072C53.1044 24.7242 52.1122 27.2343 52.7369 29.7312C49.96 31.6256 49.4934 33.9123 50.7413 36.4901C51.7994 38.1132 51.7881 39.6932 50.6931 41.2294C49.2551 43.188 48.1537 45.3718 47.4341 47.6915L47.3647 47.9266Z'
                    fill='#152235'
                />
                <path
                    d='M303.63 186.728H83.8449C81.8904 186.728 80.0159 185.953 78.6339 184.574C77.2518 183.194 76.4754 181.323 76.4754 179.372C156.148 170.129 234.322 170.129 311 179.372C311 181.323 310.224 183.194 308.842 184.574C307.459 185.953 305.585 186.728 303.63 186.728Z'
                    fill='#0D1521'
                />
                <path
                    d='M311 179.805L76.4754 179.372L103.656 133.718L103.786 133.501V32.8841C103.786 31.6628 104.027 30.4535 104.495 29.3252C104.963 28.1968 105.649 27.1716 106.514 26.308C107.379 25.4445 108.406 24.7595 109.537 24.2922C110.667 23.8248 111.879 23.5844 113.102 23.5845H273.073C274.296 23.5844 275.508 23.8248 276.638 24.2922C277.768 24.7595 278.795 25.4445 279.66 26.308C280.526 27.1716 281.212 28.1968 281.68 29.3252C282.148 30.4535 282.389 31.6628 282.389 32.8841V134.194L311 179.805Z'
                    fill='#152235'
                />
                <path
                    d='M112.89 30.0757C112.085 30.0766 111.314 30.396 110.745 30.9639C110.176 31.5318 109.856 32.3018 109.855 33.1049V124.846C109.856 125.649 110.176 126.419 110.745 126.987C111.314 127.555 112.085 127.875 112.89 127.876H274.586C275.39 127.875 276.162 127.555 276.73 126.987C277.299 126.419 277.619 125.649 277.62 124.846V33.1049C277.619 32.3018 277.299 31.5318 276.731 30.964C276.162 30.3961 275.39 30.0766 274.586 30.0757H112.89Z'
                    fill='white'
                />
                <path
                    d='M113.567 139.992C113.318 139.993 113.075 140.064 112.866 140.198C112.657 140.332 112.49 140.523 112.386 140.748L104.01 158.923C103.919 159.121 103.879 159.338 103.894 159.555C103.91 159.773 103.979 159.983 104.097 160.166C104.214 160.349 104.376 160.5 104.568 160.605C104.759 160.709 104.974 160.764 105.192 160.764H281.317C281.539 160.764 281.757 160.707 281.951 160.6C282.144 160.492 282.307 160.336 282.424 160.148C282.54 159.96 282.606 159.745 282.616 159.524C282.626 159.303 282.579 159.083 282.48 158.885L273.377 140.71C273.269 140.494 273.103 140.312 272.898 140.185C272.692 140.058 272.455 139.991 272.214 139.992H113.567Z'
                    fill='#0D1521'
                />
                <path
                    d='M193.087 28.5612C194.165 28.5612 195.038 27.6893 195.038 26.6138C195.038 25.5384 194.165 24.6665 193.087 24.6665C192.01 24.6665 191.137 25.5384 191.137 26.6138C191.137 27.6893 192.01 28.5612 193.087 28.5612Z'
                    fill='white'
                />
                <path
                    d='M175.776 164.226C175.49 164.226 175.212 164.321 174.985 164.494C174.758 164.668 174.595 164.911 174.52 165.187L172.419 172.976C172.367 173.168 172.36 173.37 172.399 173.566C172.438 173.761 172.521 173.945 172.643 174.103C172.764 174.261 172.92 174.39 173.099 174.478C173.278 174.566 173.475 174.612 173.675 174.612H213.628C213.835 174.612 214.04 174.562 214.224 174.468C214.408 174.373 214.567 174.235 214.687 174.067C214.808 173.898 214.886 173.703 214.915 173.498C214.945 173.293 214.924 173.085 214.857 172.889L212.156 165.1C212.067 164.845 211.901 164.623 211.681 164.467C211.461 164.31 211.197 164.226 210.927 164.226H175.776Z'
                    fill='#0D1521'
                />
                <path
                    d='M282.389 131.987V133.718H103.656L103.79 133.502V131.987H282.389Z'
                    fill='#0D1521'
                />
                <path
                    d='M277.404 60.584C294.163 60.584 307.749 47.0218 307.749 30.292C307.749 13.5622 294.163 0 277.404 0C260.644 0 247.058 13.5622 247.058 30.292C247.058 47.0218 260.644 60.584 277.404 60.584Z'
                    fill='#0058CC'
                />
                <path
                    d='M289.975 43.4908H264.832C264.372 43.4903 263.931 43.3078 263.606 42.9833C263.281 42.6587 263.098 42.2187 263.098 41.7598V26.6138C263.099 26.1548 263.281 25.7149 263.606 25.3903C263.932 25.0658 264.372 24.8833 264.832 24.8828H289.975C290.435 24.8833 290.876 25.0658 291.201 25.3903C291.526 25.7149 291.709 26.1548 291.709 26.6138V41.7598C291.709 42.2187 291.526 42.6587 291.201 42.9833C290.876 43.3078 290.435 43.4903 289.975 43.4908ZM264.832 26.6138V41.7598H289.976L289.975 26.6138L264.832 26.6138Z'
                    fill='white'
                />
                <path
                    d='M285.207 26.6134H269.601V19.6895C269.601 14.6745 272.882 11.0347 277.404 11.0347C281.925 11.0347 285.207 14.6745 285.207 19.6895L285.207 26.6134ZM271.335 24.8824H283.473V19.6895C283.473 15.6129 280.977 12.7656 277.404 12.7656C273.83 12.7656 271.335 15.6129 271.335 19.6895L271.335 24.8824Z'
                    fill='white'
                />
                <path
                    d='M277.404 35.4849C278.361 35.4849 279.138 34.7099 279.138 33.7539C279.138 32.7979 278.361 32.0229 277.404 32.0229C276.446 32.0229 275.67 32.7979 275.67 33.7539C275.67 34.7099 276.446 35.4849 277.404 35.4849Z'
                    fill='white'
                />
                <path
                    d='M256.22 96.7577H131.255C130.642 96.757 130.054 96.5133 129.62 96.0803C129.186 95.6472 128.942 95.06 128.941 94.4476V63.5035C128.942 62.891 129.186 62.3038 129.62 61.8708C130.054 61.4377 130.642 61.1941 131.255 61.1934H256.22C256.834 61.1941 257.422 61.4377 257.856 61.8708C258.289 62.3038 258.534 62.891 258.534 63.5035V94.4476C258.534 95.06 258.289 95.6472 257.856 96.0803C257.422 96.5133 256.834 96.757 256.22 96.7577ZM131.255 62.1174C130.887 62.1178 130.534 62.264 130.274 62.5238C130.014 62.7837 129.867 63.136 129.867 63.5035V94.4476C129.867 94.8151 130.014 95.1674 130.274 95.4272C130.534 95.6871 130.887 95.8332 131.255 95.8336H256.22C256.588 95.8332 256.941 95.6871 257.201 95.4272C257.462 95.1674 257.608 94.8151 257.609 94.4476V63.5035C257.608 63.136 257.462 62.7837 257.201 62.5238C256.941 62.264 256.588 62.1178 256.22 62.1174L131.255 62.1174Z'
                    fill='#3D3C40'
                    fillOpacity='0.16'
                />
                <path
                    d='M150.672 87.1982C155.878 87.1982 160.099 82.9851 160.099 77.7881C160.099 72.591 155.878 68.3779 150.672 68.3779C145.466 68.3779 141.246 72.591 141.246 77.7881C141.246 82.9851 145.466 87.1982 150.672 87.1982Z'
                    fill='#3D3C40'
                    fillOpacity='0.16'
                />
                <path
                    d='M172.443 71.5147C172.237 71.5143 172.032 71.5546 171.841 71.6333C171.65 71.712 171.477 71.8275 171.331 71.9731C171.185 72.1188 171.069 72.2918 170.99 72.4822C170.91 72.6727 170.87 72.8768 170.87 73.083C170.87 73.2892 170.91 73.4933 170.99 73.6838C171.069 73.8742 171.185 74.0472 171.331 74.1929C171.477 74.3385 171.65 74.454 171.841 74.5327C172.032 74.6113 172.237 74.6517 172.443 74.6514H246.51C246.927 74.6514 247.326 74.4861 247.621 74.192C247.915 73.8979 248.081 73.499 248.081 73.083C248.081 72.667 247.915 72.2681 247.621 71.974C247.326 71.6799 246.927 71.5147 246.51 71.5147H172.443Z'
                    fill='#3D3C40'
                    fillOpacity='0.16'
                />
                <path
                    d='M172.443 80.9248C172.027 80.9248 171.627 81.09 171.332 81.3842C171.038 81.6783 170.872 82.0772 170.872 82.4932C170.872 82.9091 171.038 83.308 171.332 83.6022C171.627 83.8963 172.027 84.0615 172.443 84.0615H204.314C204.731 84.0615 205.131 83.8963 205.425 83.6022C205.72 83.308 205.886 82.9091 205.886 82.4932C205.886 82.0772 205.72 81.6783 205.425 81.3842C205.131 81.09 204.731 80.9248 204.314 80.9248H172.443Z'
                    fill='#3D3C40'
                    fillOpacity='0.16'
                />
                <path
                    d='M103.348 81.5594L80.2478 93.8193L79.9554 83.6027C87.4953 82.3462 94.6687 80.1586 101.302 76.5971L103.718 70.6385C103.981 69.9892 104.409 69.4194 104.959 68.9851C105.51 68.5508 106.164 68.2668 106.858 68.161C107.551 68.0553 108.26 68.1314 108.916 68.382C109.571 68.6325 110.15 69.0489 110.595 69.5901C111.247 70.382 111.572 71.3916 111.506 72.4143C111.44 73.437 110.987 74.3963 110.239 75.098L103.348 81.5594Z'
                    fill='#A1616A'
                />
                <path
                    d='M46.9042 152.343C46.7357 151.726 46.6999 151.081 46.7992 150.449C46.8985 149.817 47.1307 149.214 47.4804 148.678L52.555 140.904C53.7552 139.065 55.5969 137.737 57.7227 137.177C59.8485 136.617 62.1069 136.865 64.0596 137.874C61.9269 141.497 62.2243 144.677 64.7962 147.439C60.8036 149.385 57.1134 151.896 53.8402 154.895C53.2426 155.302 52.5563 155.56 51.8385 155.648C51.1208 155.737 50.3922 155.653 49.7136 155.403C49.035 155.153 48.426 154.745 47.9374 154.213C47.4487 153.681 47.0944 153.04 46.9042 152.343Z'
                    fill='#2F2E41'
                />
                <path
                    d='M104.401 142.178C103.633 143.456 102.549 144.515 101.253 145.254C99.9568 145.993 98.4923 146.387 96.9998 146.398L63.2878 146.653L61.8257 138.188L76.7388 133.809L64.165 124.177L77.9084 108.122L102.871 131.347C104.33 132.705 105.278 134.521 105.556 136.492C105.835 138.464 105.427 140.471 104.401 142.178Z'
                    fill='#152235'
                />
                <path
                    d='M58.0243 200.072H50.1291C43.0404 151.566 35.8248 102.925 57.1471 84.7705L82.2946 88.8571L79.0781 110.166L65.0422 126.221L58.0243 200.072Z'
                    fill='#152235'
                />
                <path
                    d='M64.9645 211.06C64.3465 211.228 63.6997 211.264 63.0668 211.165C62.4339 211.065 61.8292 210.834 61.2925 210.485L52.72 209.334C50.8779 208.136 49.5473 206.298 48.9863 204.176C48.4254 202.054 48.674 199.799 49.6841 197.85C53.3144 199.979 56.499 199.682 59.2665 197.114C61.2219 201.056 64.4436 200.815 67.5205 204.136C67.9279 204.732 68.1867 205.417 68.2752 206.134C68.3637 206.85 68.2794 207.578 68.0293 208.255C67.7792 208.932 67.3706 209.54 66.8375 210.028C66.3044 210.516 65.6623 210.87 64.9645 211.06Z'
                    fill='#0058CC'
                />
                <path
                    d='M76.7388 52.3693L62.1181 48.8664C64.5464 43.9047 64.7463 38.3837 63.5802 32.5199L73.5222 32.228C73.8337 39.5198 74.7762 46.3321 76.7388 52.3693Z'
                    fill='#965962'
                />
                <path
                    d='M80.7571 97.646C70.1137 104.886 62.5935 97.8937 56.8546 87.1056C57.6521 80.5043 56.3609 72.6044 53.9695 64.0206C52.9059 60.2345 53.303 56.188 55.0823 52.6799C56.8616 49.1718 59.8937 46.4571 63.5802 45.0718L76.154 50.326C86.8306 59.0134 88.932 68.4237 84.9264 78.3486L80.7571 97.646Z'
                    fill='#0058CC'
                />
                <path
                    d='M50.1291 59.6667L38.4326 65.7966L59.194 78.0565L62.0828 85.1698C62.2756 85.6445 62.3695 86.1535 62.3588 86.6657C62.3482 87.1779 62.2331 87.6826 62.0206 88.1489C61.8082 88.6153 61.5028 89.0336 61.1232 89.3783C60.7435 89.7229 60.2975 89.9868 59.8123 90.1538C59.2608 90.3437 58.6728 90.4035 58.0943 90.3286C57.5157 90.2537 56.9624 90.0461 56.4777 89.7221C55.9929 89.3982 55.5899 88.9665 55.3001 88.4611C55.0104 87.9556 54.8417 87.3901 54.8075 86.8088L54.5154 81.8512L28.1279 73.1586C27.2388 72.8657 26.4282 72.3747 25.7574 71.7228C25.0865 71.0709 24.5731 70.2751 24.256 69.3958C23.7938 68.114 23.7702 66.7154 24.1891 65.4189C24.608 64.1224 25.4456 63.0011 26.5709 62.2304L47.7898 47.6987L50.1291 59.6667Z'
                    fill='#A1616A'
                />
                <path
                    d='M61.8257 60.8345C56.9475 58.7004 52.5117 61.0186 46.9126 62.8778L46.0354 47.407C51.595 44.449 56.8957 43.6514 61.8257 45.9475L61.8257 60.8345Z'
                    fill='#0058CC'
                />
                <path
                    d='M67.6611 39.8912C72.8166 39.8912 76.9959 35.7192 76.9959 30.5728C76.9959 25.4264 72.8166 21.2544 67.6611 21.2544C62.5057 21.2544 58.3264 25.4264 58.3264 30.5728C58.3264 35.7192 62.5057 39.8912 67.6611 39.8912Z'
                    fill='#A1616A'
                />
                <path
                    d='M78.8285 29.3971C69.5863 30.3007 62.5438 28.7918 58.0429 24.4956V21.0356H78.0441L78.8285 29.3971Z'
                    fill='#152235'
                />
            </g>
            <defs>
                <clipPath id='clip0'>
                    <rect
                        width='311'
                        height='216'
                        fill='white'
                    />
                </clipPath>
            </defs>
        </svg>
    );
};

export default NoInternetConnectionSvg;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import FormattedMarkdownMessage from 'components/formatted_markdown_message';

import GenericModal from 'components/generic_modal';

import './no_internet_connection.scss';
import NoInternetConnectionSvg from './no-internet-connection-svg';

type NoInternetConnectionProps = {
    onExited: () => void;
};
const NoInternetConnection: React.FC<NoInternetConnectionProps> = (props: NoInternetConnectionProps) => {
    return (
        <GenericModal
            onExited={props.onExited}
            modalHeaderText=''
        >
            <div className='noInternetConnection__container'>
                <div className='noInternetConnection__image'>
                    <NoInternetConnectionSvg/>
                </div>
                <span className='noInternetConnection__noAccessToInternet'>
                    <FormattedMessage
                        id='announcement_bar.warn.no_internet_connection'
                        defaultMessage='Looks like you do not have access to the internet.'
                    />
                </span>
                <span className='noInternetConnection__contactSupport'>
                    <FormattedMessage
                        id='announcement_bar.warn.contact_support_text'
                        defaultMessage='To renew your license, contact support at support@mattermost.com.'
                    />
                </span>
                <span className='noInternetConnection__emailUs'>
                    <FormattedMarkdownMessage
                        id='announcement_bar.warn.email_support'
                        defaultMessage='[Contact support](!{email}).'
                        values={{email: 'mailto:support@mattermost.com'}}
                    />
                </span>
            </div>
        </GenericModal>
    );
};

export default NoInternetConnection;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useState} from 'react';
import {FormattedMessage} from 'react-intl';

import {Client4} from 'mattermost-redux/client';

import {trackEvent} from 'actions/telemetry_actions';

import {ModalData} from 'types/actions';

import {
    LicenseLinks,
    ModalIdentifiers,
} from 'utils/constants';

import NoInternetConnection from '../no_internet_connection/no_internet_connection';

import './renew_link.scss';

export interface RenewalLinkProps {
    telemetryInfo?: {success: string; error: string};
    actions: {
        openModal: <P>(modalData: ModalData<P>) => void;
    };
    isDisabled?: boolean;
    customBtnText?: JSX.Element;
}

const RenewalLink = (props: RenewalLinkProps) => {
    const [renewalLink, setRenewalLink] = useState('');
    const [manualInterventionRequired, setManualInterventionRequired] = useState(false);
    useEffect(() => {
        Client4.getRenewalLink().then(({renewal_link: renewalLinkParam}) => {
            try {
                if (renewalLinkParam && (/^http[s]?:\/\//).test(renewalLinkParam)) {
                    setRenewalLink(renewalLinkParam);
                }
            } catch (error) {
                console.error('No link returned', error); // eslint-disable-line no-console
            }
        }).catch(() => {
            setManualInterventionRequired(true);
        });
    }, []);

    const handleLinkClick = async (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {
        e.preventDefault();
        try {
            const {status} = await Client4.ping();
            if (status === 'OK' && renewalLink !== '') {
                if (props.telemetryInfo?.success) {
                    trackEvent('renew_license', props.telemetryInfo.success);
                }
                window.open(renewalLink, '_blank');
            } else if (manualInterventionRequired) {
                window.open(LicenseLinks.CONTACT_SALES, '_blank');
            } else {
                showConnectionErrorModal();
            }
        } catch (error) {
            showConnectionErrorModal();
        }
    };

    const showConnectionErrorModal = () => {
        if (props.telemetryInfo?.error) {
            trackEvent('renew_license', props.telemetryInfo.error);
        }
        props.actions.openModal({
            modalId: ModalIdentifiers.NO_INTERNET_CONNECTION,
            dialogType: NoInternetConnection,
        });
    };

    let btnText = props.customBtnText ? props.customBtnText : (
        <FormattedMessage
            id='announcement_bar.warn.renew_license_now'
            defaultMessage='Renew license now'
        />
    );

    if (manualInterventionRequired) {
        btnText = (
            <FormattedMessage
                id='announcement_bar.warn.renew_license_contact_sales'
                defaultMessage='Contact sales'
            />
        );
    }

    return (
        <button
            className='btn btn-primary annnouncementBar__renewLicense'
            disabled={props.isDisabled}
            onClick={(e) => handleLinkClick(e)}
        >
            {btnText}
        </button>
    );
};

export default RenewalLink;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {GenericAction} from 'mattermost-redux/types/actions';

import {openModal} from 'actions/views/modals';

import RenewalLink from './renewal_link';

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators(
            {
                openModal,
            },
            dispatch,
        ),
    };
}

export default connect(null, mapDispatchToProps)(RenewalLink);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useState} from 'react';
import {FormattedMessage} from 'react-intl';
import {useDispatch, useSelector} from 'react-redux';

import {Placement} from 'tippy.js';

import {setNewChannelWithBoardPreference} from 'mattermost-redux/actions/boards';
import {Preferences} from 'mattermost-redux/constants';

import {showNewChannelWithBoardPulsatingDot} from 'selectors/plugins';

import {TourTip, useMeasurePunchouts} from '@mattermost/components';

type Props = {
    pulsatingDotPlacement?: Omit<Placement, 'auto'| 'auto-end'>;
    pulsatingDotTranslate?: {x: number; y: number};
}

const NewChannelWithBoardTourTip = ({
    pulsatingDotPlacement = 'left',
    pulsatingDotTranslate,
}: Props): JSX.Element | null => {
    const dispatch = useDispatch();
    const showTip = useSelector(showNewChannelWithBoardPulsatingDot);

    const title = (
        <FormattedMessage
            id='newChannelWithBoard.tutorialTip.title'
            defaultMessage='Access linked boards from the App Bar'
        />
    );

    const screen = (
        <FormattedMessage
            id='newChannelWithBoard.tutorialTip.description'
            defaultMessage='The board you just created can be quickly accessed by clicking on the Boards icon in the App bar. You can view the boards that are linked to this channel in the right-hand sidebar and open one in full view.'
        />
    );

    const [tipOpened, setTipOpened] = useState(showTip);

    const handleDismiss = useCallback((e: React.MouseEvent) => {
        e.stopPropagation();
        setTipOpened(false);
        dispatch(setNewChannelWithBoardPreference({[Preferences.NEW_CHANNEL_WITH_BOARD_TOUR_SHOWED]: true}));
    }, []);

    const handleOpen = useCallback((e: React.MouseEvent) => {
        e.stopPropagation();
        e.preventDefault();

        if (tipOpened) {
            dispatch(setNewChannelWithBoardPreference({[Preferences.NEW_CHANNEL_WITH_BOARD_TOUR_SHOWED]: true}));
            setTipOpened(false);
        } else {
            setTipOpened(true);
        }
    }, []);

    const overlayPunchOut = useMeasurePunchouts(['app-bar-icon-focalboard'], [], {y: -2, height: 4, x: 0, width: 0});

    if (!showTip) {
        return null;
    }

    return (
        <TourTip
            show={true}
            screen={screen}
            title={title}
            overlayPunchOut={overlayPunchOut}
            placement='right-start'
            pulsatingDotPlacement={pulsatingDotPlacement}
            step={1}
            singleTip={true}
            showOptOut={false}
            interactivePunchOut={true}
            handleDismiss={handleDismiss}
            handleOpen={handleOpen}
            handlePrevious={handleDismiss}
            offset={[-30, 5]}
            pulsatingDotTranslate={pulsatingDotTranslate}
        />
    );
};

export default NewChannelWithBoardTourTip;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useState, useRef} from 'react';
import styled, {css} from 'styled-components';
import AutoSizer from 'react-virtualized-auto-sizer';
import {VariableSizeList, ListChildComponentProps} from 'react-window';
import InfiniteLoader from 'react-window-infinite-loader';
import {useHistory} from 'react-router-dom';
import {useIntl} from 'react-intl';

import {SendIcon} from '@mattermost/compass-icons/components';

import {UserProfile} from '@mattermost/types/users';
import {Group} from '@mattermost/types/groups';
import {ServerError} from '@mattermost/types/errors';

import * as Utils from 'utils/utils';

import Avatar from 'components/widgets/users/avatar';
import LoadingSpinner from 'components/widgets/loading/loading_spinner';
import SimpleTooltip from 'components/widgets/simple_tooltip';
import NoResultsIndicator from 'components/no_results_indicator';
import {NoResultsVariant} from 'components/no_results_indicator/types';

import {Load} from '../user_group_popover';

const USERS_PER_PAGE = 100;

// These constants must be changed if user list style is modified
export const VIEWPORT_SCALE_FACTOR = 0.4;
const ITEM_HEIGHT = 40;
const MARGIN = 8;
const getItemHeight = (isCap: boolean) => (isCap ? ITEM_HEIGHT + MARGIN : ITEM_HEIGHT);
export const getListHeight = (num: number) => (num * ITEM_HEIGHT) + (2 * MARGIN);

// Reasonable extrema for the user list
const MIN_LIST_HEIGHT = 120;
export const MAX_LIST_HEIGHT = 800;

export type GroupMember = {
    user: UserProfile;
    displayName: string;
}

export type Props = {

    /**
     * The group corresponding to the parent popover
     */
    group: Group;

    /**
     * Function to call if parent popover should be hidden
     */
    hide: () => void;

    /**
     * Function to call to show a profile popover and hide parent popover
     */
    showUserOverlay: (user: UserProfile) => void;

    /**
     * State of current search
     */
    searchState: Load;

    /**
     * @internal
     */
    members: GroupMember[];
    teamUrl: string;
    searchTerm: string;

    actions: {
        getUsersInGroup: (groupId: string, page: number, perPage: number) => Promise<{ data: UserProfile[] }>;
        openDirectChannelToUserId: (userId?: string) => Promise<{ error: ServerError }>;
        closeRightHandSide: () => void;
    };
}

const GroupMemberList = (props: Props) => {
    const {
        group,
        actions,
        members,
        hide,
        teamUrl,
        searchTerm,
        searchState,
        showUserOverlay,
    } = props;

    const history = useHistory();

    const {formatMessage} = useIntl();

    const [nextPage, setNextPage] = useState(Math.floor(members.length / USERS_PER_PAGE));
    const [nextPageLoadState, setNextPageLoadState] = useState(Load.DONE);
    const [currentDMLoading, setCurrentDMLoading] = useState<string | undefined>(undefined);

    const infiniteLoaderRef = useRef<InfiniteLoader | null>(null);
    const variableSizeListRef = useRef<VariableSizeList | null>(null);
    const [hasMounted, setHasMounted] = useState(false);

    useEffect(() => {
        if (hasMounted) {
            if (infiniteLoaderRef.current) {
                infiniteLoaderRef.current.resetloadMoreItemsCache();
            }
            if (variableSizeListRef.current) {
                variableSizeListRef.current.resetAfterIndex(0);
            }
        }
        setHasMounted(true);
    }, [members.length, hasMounted]);

    const loadNextPage = async () => {
        setNextPageLoadState(Load.LOADING);
        const res = await actions.getUsersInGroup(group.id, nextPage, USERS_PER_PAGE);
        if (res.data) {
            setNextPage(nextPage + 1);
            setNextPageLoadState(Load.DONE);
        } else {
            setNextPageLoadState(Load.FAILED);
        }
    };

    const showDirectChannel = (user: UserProfile) => {
        if (currentDMLoading !== undefined) {
            return;
        }
        setCurrentDMLoading(user.id);
        actions.openDirectChannelToUserId(user.id).then((result: { error: ServerError }) => {
            if (!result.error) {
                actions.closeRightHandSide();
                setCurrentDMLoading(undefined);
                hide?.();
                history.push(`${teamUrl}/messages/@${user.username}`);
            }
        });
    };

    const isSearching = searchTerm !== '';
    const hasNextPage = !isSearching && members.length < group.member_count;
    const itemCount = !isSearching && hasNextPage ? members.length + 1 : members.length;

    const loadMoreItems = isSearching || nextPageLoadState === Load.LOADING ? () => {} : loadNextPage;

    const maxListHeight = Math.min(MAX_LIST_HEIGHT, Math.max(MIN_LIST_HEIGHT, Utils.getViewportSize().h * VIEWPORT_SCALE_FACTOR));

    const isUserLoaded = (index: number) => {
        return isSearching || !hasNextPage || index < members.length;
    };

    const Item = ({index, style}: ListChildComponentProps) => {
        // Remove explicit height provided by VariableSizeList
        style.height = undefined;

        if (isUserLoaded(index)) {
            const user = members[index].user;
            const name = members[index].displayName;

            return (
                <UserListItem
                    className='group-member-list_item'
                    first={index === 0}
                    last={index === group.member_count - 1}
                    style={style}
                    key={user.id}
                    role='listitem'
                >
                    <UserButton onClick={() => showUserOverlay(user)}>
                        <Avatar
                            username={user.username}
                            size={'sm'}
                            url={Utils.imageURLForUser(user?.id ?? '')}
                            className={'avatar-post-preview'}
                            tabIndex={-1}
                        />
                        <Username className='overflow--ellipsis text-nowrap'>{name}</Username>
                        <Gap className='group-member-list_gap'/>
                    </UserButton>
                    <DMContainer className='group-member-list_dm-button'>
                        <SimpleTooltip
                            id={`name-${user.id}`}
                            content={formatMessage({id: 'group_member_list.sendMessageTooltip', defaultMessage: 'Send message'})}
                        >
                            <DMButton
                                className='btn-icon'
                                aria-label={formatMessage(
                                    {id: 'group_member_list.sendMessageButton', defaultMessage: 'Send message to {user}'},
                                    {user: name})}
                                onClick={() => showDirectChannel(user)}
                            >
                                <SendIcon/>
                            </DMButton>
                        </SimpleTooltip>
                    </DMContainer>
                </UserListItem>
            );
        }

        return (
            <LoadingItem
                style={style}
                first={index === 0}
                last={index === members.length}
            >
                <LoadingSpinner/>
            </LoadingItem>
        );
    };

    const renderContent = () => {
        if (searchState === Load.LOADING) {
            return (
                <LargeLoadingItem>
                    <LoadingSpinner/>
                </LargeLoadingItem>
            );
        } else if (searchState === Load.FAILED) {
            return (
                <LoadFailedItem>
                    <span>{Utils.localizeMessage('group_member_list.searchError', 'There was a problem getting results. Clear your search term and try again.')}</span>
                </LoadFailedItem>
            );
        } else if (isSearching && members.length === 0) {
            return (
                <NoResultsItem>
                    <NoResultsIndicator
                        variant={NoResultsVariant.ChannelSearch}
                        titleValues={{channelName: `"${searchTerm}"`}}
                    />
                </NoResultsItem>
            );
        } else if (nextPageLoadState === Load.FAILED) {
            return (
                <LoadFailedItem>
                    <span>
                        {Utils.localizeMessage('group_member_list.loadError', 'Oops! Something went wrong while loading this group.')}
                        {' '}
                        <RetryButton
                            onClick={loadMoreItems}
                        >
                            {Utils.localizeMessage('group_member_list.retryLoadButton', 'Retry')}
                        </RetryButton>
                    </span>
                </LoadFailedItem>
            );
        }
        return (<AutoSizer>
            {({height, width}) => (
                <InfiniteLoader
                    ref={infiniteLoaderRef}
                    isItemLoaded={isUserLoaded}
                    itemCount={itemCount}
                    loadMoreItems={loadMoreItems}
                    threshold={5}
                >
                    {({onItemsRendered, ref}) => (
                        <VariableSizeList
                            itemCount={itemCount}
                            onItemsRendered={onItemsRendered}
                            ref={ref}
                            itemSize={(index) => getItemHeight(index === 0 || index === group.member_count - 1 || index === members.length + 1)}
                            height={height}
                            width={width}
                        >
                            {Item}
                        </VariableSizeList>)}
                </InfiniteLoader>
            )}
        </AutoSizer>);
    };

    return (
        <UserList
            style={{height: Math.min(maxListHeight, getListHeight(group.member_count))}}
            role='list'
        >
            {renderContent()}
        </UserList>
    );
};

const UserList = styled.div`
    display: flex;
    padding: 0;
    margin: 0;
    border-top: 1px solid rgba(var(--center-channel-color-rgb), 0.08);
    box-sizing: content-box;
    position: relative;
`;

const UserListItem = styled.div<{first?: boolean; last?: boolean}>`
    ${(props) => props.first && css `
        margin-top: ${MARGIN}px;
    `}

    ${(props) => props.last && css `
        margin-bottom: ${MARGIN}px;
    `}

    &:hover {
        background: rgba(var(--center-channel-color-rgb), 0.08);
    }

    .group-member-list_gap,
    .group-member-list_dm-button {
        display: none;
    }

    &:hover .group-member-list_gap,
    &:focus-within .group-member-list_gap {
        display: initial;
    }

    &:hover .group-member-list_dm-button,
    &:focus-within .group-member-list_dm-button {
        display: flex;
    }
`;

const UserButton = styled.button`
    display: flex;
    width: 100%;
    padding: 8px 20px;
    border: none;
    background: unset;
    text-align: unset;
`;

// A gap to make space for the DM button to be positioned on
const Gap = styled.span`
    width: 24px;
    flex: 0 0 auto;
    margin-left: 4px;
`;

const Username = styled.span`
    padding-left: 12px;
    flex: 1 1 auto;
`;

const DMContainer = styled.div`
    height: 100%;
    position: absolute;
    right: 20px;
    top: 0;
    align-items: center;
`;

const DMButton = styled.button`
    width: 24px;
    height: 24px;

    svg {
        width: 16px;
    }
`;

const LoadingItem = styled.div<{first?: boolean; last?: boolean}>`
    ${(props) => props.first && css `
        padding-top: ${MARGIN}px;
    `}

    ${(props) => props.last && css `
        padding-bottom: ${MARGIN}px;
    `}

    display: flex;
    justify-content: center;
    align-items: center;
    height: ${ITEM_HEIGHT}px;
    box-sizing: content-box;
`;

const LargeLoadingItem = styled.div`
    display: flex;
    align-self: stretch;
    justify-content: center;
    align-items: center;
    width: 100%;
`;

const LoadFailedItem = styled(LargeLoadingItem)`
    padding: 16px;
    color: rgba(var(--center-channel-color-rgb), 0.72);
    text-align: center;
    font-size: 12px;
`;

const NoResultsItem = styled.div`
    align-self: stretch;
    overflow-y: scroll;
    overflow-y: overlay;
`;

const RetryButton = styled.button`
    background: none;
    padding: 0;
    border: none;
    font-weight: 600;
    color: var(--link-color);
`;

export default React.memo(GroupMemberList);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';

import {ActionFunc, GenericAction} from 'mattermost-redux/types/actions';
import {ServerError} from '@mattermost/types/errors';
import {UserProfile} from '@mattermost/types/users';
import {Group} from '@mattermost/types/groups';

import {GlobalState} from 'types/store';

import {getProfilesInGroup, searchProfilesInGroup} from 'mattermost-redux/selectors/entities/users';
import {getProfilesInGroup as getUsersInGroup} from 'mattermost-redux/actions/users';
import {getCurrentRelativeTeamUrl} from 'mattermost-redux/selectors/entities/teams';
import {getTeammateNameDisplaySetting} from 'mattermost-redux/selectors/entities/preferences';
import {openDirectChannelToUserId} from 'actions/channel_actions';
import {closeRightHandSide} from 'actions/views/rhs';

import {createSelector} from 'reselect';
import {displayUsername} from 'mattermost-redux/utils/user_utils';

import GroupMemberList, {GroupMember} from './group_member_list';

type Actions = {
    getUsersInGroup: (groupId: string, page: number, perPage: number) => Promise<{data: UserProfile[]}>;
    openDirectChannelToUserId: (userId?: string) => Promise<{error: ServerError}>;
    closeRightHandSide: () => void;
};

type OwnProps = {
    group: Group;
};

const sortProfileList = (
    profiles: UserProfile[],
    teammateNameDisplaySetting: string,
) => {
    const groupMembers: GroupMember[] = [];
    profiles.forEach((profile) => {
        groupMembers.push({
            user: profile,
            displayName: displayUsername(profile, teammateNameDisplaySetting),
        });
    });

    groupMembers.sort((a, b) => {
        return a.displayName.localeCompare(b.displayName);
    });

    return groupMembers;
};

const getProfilesSortedByDisplayName = createSelector(
    'getProfilesSortedByDisplayName',
    getProfilesInGroup,
    getTeammateNameDisplaySetting,
    sortProfileList,
);

const searchProfilesSortedByDisplayName = createSelector(
    'searchProfilesSortedByDisplayName',
    searchProfilesInGroup,
    getTeammateNameDisplaySetting,
    sortProfileList,
);

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const searchTerm = state.views.search.popoverSearch;

    let members: GroupMember[] = [];
    if (searchTerm) {
        members = searchProfilesSortedByDisplayName(state, ownProps.group.id, searchTerm);
    } else {
        members = getProfilesSortedByDisplayName(state, ownProps.group.id);
    }

    return {
        members,
        searchTerm,
        teamUrl: getCurrentRelativeTeamUrl(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc | GenericAction>, Actions>({
            getUsersInGroup,
            openDirectChannelToUserId,
            closeRightHandSide,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(GroupMemberList);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useCallback, useState} from 'react';
import styled from 'styled-components';
import {FormattedMessage} from 'react-intl';
import {debounce} from 'lodash';

import {CloseIcon, MagnifyIcon} from '@mattermost/compass-icons/components';

import {ModalData} from 'types/actions';
import {UserProfile} from '@mattermost/types/users';
import {Group} from '@mattermost/types/groups';
import {ActionResult} from 'mattermost-redux/types/actions';

import * as Utils from 'utils/utils';
import Constants, {ModalIdentifiers} from 'utils/constants';

import {QuickInput} from 'components/quick_input/quick_input';
import Popover from 'components/widgets/popover';
import ViewUserGroupModal from 'components/view_user_group_modal';
import UserGroupsModal from 'components/user_groups_modal';
import GroupMemberList from 'components/user_group_popover/group_member_list';

import './user_group_popover.scss';

export enum Load {
    DONE,
    LOADING,
    FAILED,
}

export type Props = {

    /**
     * The group corresponding to the parent popover
     */
    group: Group;

    /**
     * Function to call if parent popover should be hidden
     */
    hide: () => void;

    /**
     * Function to call to show a profile popover and hide parent popover
     */
    showUserOverlay: (user: UserProfile) => void;

    /**
     * @internal
     */
    searchTerm: string;

    actions: {
        setPopoverSearchTerm: (term: string) => void;
        searchProfiles: (term: string, options: any) => Promise<ActionResult>;
        openModal: <P>(modalData: ModalData<P>) => void;
    };
}

const UserGroupPopover = (props: Props) => {
    const {
        group,
        actions,
        hide,
        searchTerm,
        showUserOverlay,
    } = props;

    const [searchState, setSearchState] = useState(Load.DONE);

    const doSearch = useCallback(debounce(async (term) => {
        const res = await actions.searchProfiles(term, {in_group_id: group.id});
        if (res.data) {
            setSearchState(Load.DONE);
        } else {
            setSearchState(Load.FAILED);
        }
    }, Constants.SEARCH_TIMEOUT_MILLISECONDS), [actions.searchProfiles]);

    useEffect(() => {
        // Unset the popover search term on mount and unmount
        // This is to prevent some odd rendering issues when quickly opening and closing popovers

        actions.setPopoverSearchTerm('');

        return () => {
            actions.setPopoverSearchTerm('');
        };
    }, []);

    useEffect(() => {
        if (searchTerm) {
            setSearchState(Load.LOADING);
            doSearch(searchTerm);
        } else {
            setSearchState(Load.DONE);
            doSearch.cancel();
        }
    }, [searchTerm, doSearch]);

    const openGroupsModal = () => {
        actions.openModal({
            modalId: ModalIdentifiers.USER_GROUPS,
            dialogType: UserGroupsModal,
            dialogProps: {
                backButtonAction: openGroupsModal,
            },
        });
    };

    const openViewGroupModal = () => {
        hide();
        actions.openModal({
            modalId: ModalIdentifiers.VIEW_USER_GROUP,
            dialogType: ViewUserGroupModal,
            dialogProps: {
                groupId: group.id,
                backButtonCallback: openGroupsModal,
                backButtonAction: openViewGroupModal,
            },
        });
    };

    const handleSearch = (event: React.ChangeEvent<HTMLInputElement>) => {
        actions.setPopoverSearchTerm(event.target.value);
    };

    const handleClear = () => {
        actions.setPopoverSearchTerm('');
    };

    return (
        <Popover
            {...props}
            id='user-group-popover'
        >
            <Body role='dialog'>
                <Header>
                    <Heading>
                        <Title
                            className='overflow--ellipsis text-nowrap'
                        >
                            {group.display_name}
                        </Title>
                        <CloseButton
                            className='btn-icon'
                            aria-label={Utils.localizeMessage('user_group_popover.close', 'Close')}
                            onClick={hide}
                        >
                            <CloseIcon/>
                        </CloseButton>
                    </Heading>
                    <Subtitle>
                        <span className='overflow--ellipsis text-nowrap'>{'@'}{group.name}</span>
                        <Dot>{'  '}</Dot>
                        <FormattedMessage
                            id='user_group_popover.memberCount'
                            defaultMessage='{member_count} {member_count, plural, one {Member} other {Members}}'
                            values={{
                                member_count: group.member_count,
                            }}
                            tagName={NoShrink}
                        />
                    </Subtitle>
                    <HeaderButton
                        aria-label={Utils.localizeMessage('user_group_popover.openGroupModal', 'View full group info')}
                        onClick={openViewGroupModal}
                        className='user-group-popover_header-button'
                    />
                </Header>
                {group.member_count > 10 ? (
                    <SearchBar>
                        <MagnifyIcon/>
                        <QuickInput
                            type='text'
                            className='user-group-popover_search-bar'
                            placeholder={Utils.localizeMessage('user_group_popover.searchGroupMembers', 'Search members')}
                            value={searchTerm}
                            onChange={handleSearch}
                            clearable={true}
                            onClear={handleClear}
                        />
                    </SearchBar>
                ) : null}
                <GroupMemberList
                    group={group}
                    hide={hide}
                    searchState={searchState}
                    showUserOverlay={showUserOverlay}
                />
            </Body>
        </Popover>);
};

const Body = styled.div`
    width: 264px;
`;

const Header = styled.div`
    padding: 16px 20px;
    position: relative;

    &:hover {
        background: rgba(var(--center-channel-color-rgb), 0.08);
    }
`;

const HeaderButton = styled.button`
    padding: 0;
    background: none;
    border: none;
    display: block;
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    width: 100%;
    height: 100%;
`;

const Title = styled.span`
    flex: 1 1 auto;
`;

const CloseButton = styled.button`
    width: 28px;
    height: 28px;
    flex: 0 0 auto;
    margin-left: 4px;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    right: -4px;
    top: -2px;

    /* Place this button above the main header button */
    z-index: 9;

    svg {
        width: 18px;
    }
`;

const Heading = styled.div`
    font-weight: 600;
    font-size: 16px;
    display: flex;
    align-items: center;
    font-family: 'Metropolis', sans-serif;
`;

const Subtitle = styled.div`
    font-size: 12px;
    color: rgba(var(--center-channel-color-rgb), 0.64);
    display: flex;
`;

const NoShrink = styled.span`
    flex: 0 0 auto;
`;

const Dot = styled(NoShrink)`
    padding: 0 6px;
`;

const SearchBar = styled.div`
    margin: 4px 12px 12px 12px;
    padding: 0 1px;
    height: 32px;
    position: relative;
    display: flex;
    align-items: center;
    border: 1px solid rgba(var(--center-channel-color-rgb), 0.16);
    border-radius: 4px;
    overflow: hidden;

    &:hover {
        border-color: rgba(var(--center-channel-color-rgb), 0.48);
    }

    &:focus-within {
        border-color: var(--button-bg);
        box-shadow: inset 0 0 0 1px var(--button-bg);
    }

    & > div {
        display: flex;
        align-items: center;
        flex: 1;
    }

    input {
        width: 100%;
        font-size: 12px;
        border: none;
        padding: 0;
        color: var(--center-channel-color);
        background: var(--center-channel-bg);
        flex: 1;
    }

    input.a11y--focused {
        box-shadow: none;
    }

    svg {
        width: 18px;
        height: 100%;
        margin: 0 6px;
        color: rgba(var(--center-channel-color-rgb), 0.64);
    }

    .input-clear {
        width: 36px;
        position: relative;
        right: 0;
    }

    .icon {
        display: flex;
        font-size: 14px;
    }
`;

export default React.memo(UserGroupPopover);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';

import {ActionFunc, ActionResult, GenericAction} from 'mattermost-redux/types/actions';

import {GlobalState} from 'types/store';
import {ModalData} from 'types/actions';

import {openModal} from 'actions/views/modals';
import {setPopoverSearchTerm} from 'actions/views/search';
import {searchProfiles} from 'mattermost-redux/actions/users';

import {getIsMobileView} from 'selectors/views/browser';

import UserGroupPopover from './user_group_popover';

type Actions = {
    setPopoverSearchTerm: (term: string) => void;
    openModal: <P>(modalData: ModalData<P>) => void;
    searchProfiles: (term: string, options: any) => Promise<ActionResult>;
};

function mapStateToProps(state: GlobalState) {
    return {
        searchTerm: state.views.search.popoverSearch,
        isMobileView: getIsMobileView(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc | GenericAction>, Actions>({
            setPopoverSearchTerm,
            openModal,
            searchProfiles,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(UserGroupPopover);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useRef, useState} from 'react';
import {Overlay} from 'react-bootstrap';

import {Client4} from 'mattermost-redux/client';
import {UserProfile} from '@mattermost/types/users';
import {Group} from '@mattermost/types/groups';

import ProfilePopover from 'components/profile_popover';
import UserGroupPopover from 'components/user_group_popover';

import {popOverOverlayPosition} from 'utils/position_utils';
import {getViewportSize} from 'utils/utils';

import {MAX_LIST_HEIGHT, getListHeight, VIEWPORT_SCALE_FACTOR} from 'components/user_group_popover/group_member_list/group_member_list';

const HEADER_HEIGHT_ESTIMATE = 130;

type Props = {

    /**
     * The group corresponding to this mention
     */
    group: Group;

    /**
     * Props to be passed through from AtMention to ProfilePopover
     */
    isRHS?: boolean;
    channelId?: string;
    hasMention?: boolean;
}

const AtMentionGroup = (props: Props) => {
    const {
        group,
        isRHS,
        channelId,
        hasMention,
    } = props;

    const ref = useRef<HTMLAnchorElement>(null);

    const [show, setShow] = useState(false);
    const [showUser, setShowUser] = useState<UserProfile | undefined>();
    const [target, setTarget] = useState<HTMLAnchorElement | undefined>();
    const [placement, setPlacement] = useState('');

    const handleClick = (e: React.MouseEvent) => {
        const targetBounds = ref.current?.getBoundingClientRect();

        if (targetBounds) {
            const approximatePopoverHeight = Math.min(
                (getViewportSize().h * VIEWPORT_SCALE_FACTOR) + HEADER_HEIGHT_ESTIMATE,
                getListHeight(group.member_count) + HEADER_HEIGHT_ESTIMATE,
                MAX_LIST_HEIGHT,
            );
            const placement = popOverOverlayPosition(targetBounds, window.innerHeight, approximatePopoverHeight);
            setTarget(e.target as HTMLAnchorElement);
            setShow(!show);
            setShowUser(undefined);
            setPlacement(placement);
        }
    };

    const hide = () => {
        setShow(false);
    };

    const showUserOverlay = (user: UserProfile) => {
        hide();
        setShowUser(user);
    };

    const hideUserOverlay = () => {
        setShowUser(undefined);
    };

    return (
        <>
            <Overlay
                placement={placement}
                show={show}
                target={target}
                rootClose={true}
                onHide={hide}
            >
                <UserGroupPopover
                    group={group}
                    hide={hide}
                    showUserOverlay={showUserOverlay}
                />
            </Overlay>
            <Overlay
                placement={placement}
                show={showUser !== undefined}
                target={target}
                onHide={hideUserOverlay}
                rootClose={true}
            >
                {showUser ? (
                    <ProfilePopover
                        className='user-profile-popover'
                        userId={showUser.id}
                        src={Client4.getProfilePictureUrl(showUser.id, showUser.last_picture_update)}
                        isRHS={isRHS}
                        channelId={channelId}
                        hasMention={hasMention}
                        hide={hideUserOverlay}
                    />
                ) : <span/>
                }
            </Overlay>
            <a
                onClick={handleClick}
                ref={ref}
            >
                {'@' + group.name}
            </a>
        </>
    );
};

export default React.memo(AtMentionGroup);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Overlay} from 'react-bootstrap';

import {Client4} from 'mattermost-redux/client';
import {displayUsername} from 'mattermost-redux/utils/user_utils';
import {UserProfile} from '@mattermost/types/users';
import {Group} from '@mattermost/types/groups';

import ProfilePopover from 'components/profile_popover';

import {popOverOverlayPosition} from 'utils/position_utils';
import {getUserOrGroupFromMentionName} from 'utils/post_utils';

import AtMentionGroup from 'components/at_mention/at_mention_group';

const spaceRequiredForPopOver = 300;

type Props = {
    currentUserId: string;
    mentionName: string;
    teammateNameDisplay: string;
    usersByUsername: Record<string, UserProfile>;
    groupsByName: Record<string, Group>;
    children?: React.ReactNode;
    channelId?: string;
    hasMention?: boolean;
    disableHighlight?: boolean;
    disableGroupHighlight?: boolean;
    isRHS?: boolean;
}

type State = {
    show: boolean;
    target?: HTMLButtonElement;
    placement?: string;
}

export default class AtMention extends React.PureComponent<Props, State> {
    buttonRef: React.RefObject<HTMLButtonElement>;

    static defaultProps: Partial<Props> = {
        isRHS: false,
        hasMention: false,
        disableHighlight: false,
        disableGroupHighlight: false,
    }

    constructor(props: Props) {
        super(props);

        this.state = {
            show: false,
        };

        this.buttonRef = React.createRef();
    }

    handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
        const targetBounds = this.buttonRef.current?.getBoundingClientRect();

        if (targetBounds) {
            const placement = popOverOverlayPosition(targetBounds, window.innerHeight, spaceRequiredForPopOver);
            this.setState({target: e.target as HTMLButtonElement, show: !this.state.show, placement});
        }
    }

    hideOverlay = () => {
        this.setState({show: false});
    }

    render() {
        const user = getUserOrGroupFromMentionName(this.props.usersByUsername, this.props.mentionName) as UserProfile | '';

        if (!this.props.disableGroupHighlight && !user) {
            const group = getUserOrGroupFromMentionName(this.props.groupsByName, this.props.mentionName) as Group | '';
            if (group && group.allow_reference) {
                return (<span>
                    <AtMentionGroup group={group}/>
                </span>);
            }
        }

        if (!user) {
            return <React.Fragment>{this.props.children}</React.Fragment>;
        }

        const suffix = this.props.mentionName.substring(user.username.length);
        const displayName = displayUsername(user, this.props.teammateNameDisplay);

        const highlightMention = !this.props.disableHighlight && user.id === this.props.currentUserId;

        return (
            <>
                <span
                    className={highlightMention ? 'mention--highlight' : undefined}
                >
                    <Overlay
                        placement={this.state.placement}
                        show={this.state.show}
                        target={this.state.target}
                        rootClose={true}
                        onHide={this.hideOverlay}
                    >
                        <ProfilePopover
                            className='user-profile-popover'
                            userId={user.id}
                            src={Client4.getProfilePictureUrl(user.id, user.last_picture_update)}
                            isRHS={this.props.isRHS}
                            hasMention={this.props.hasMention}
                            hide={this.hideOverlay}
                            channelId={this.props.channelId}
                        />
                    </Overlay>
                    <button
                        className='mention-link style--link'
                        onClick={this.handleClick}
                        ref={this.buttonRef}
                        aria-haspopup='dialog'
                    >
                        {'@' + displayName}
                    </button>
                </span>
                {suffix}
            </>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getTeammateNameDisplaySetting} from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentUserId, getUsersByUsername} from 'mattermost-redux/selectors/entities/users';
import {getAllGroupsForReferenceByName} from 'mattermost-redux/selectors/entities/groups';

import {GlobalState} from 'types/store';

import AtMention from './at_mention';

function mapStateToProps(state: GlobalState) {
    return {
        currentUserId: getCurrentUserId(state),
        teammateNameDisplay: getTeammateNameDisplaySetting(state),
        usersByUsername: getUsersByUsername(state),
        groupsByName: getAllGroupsForReferenceByName(state),
    };
}

export default connect(mapStateToProps)(AtMention);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import PropTypes from 'prop-types';
import React from 'react';

import SuggestionBox from 'components/suggestion/suggestion_box';
import SuggestionList from 'components/suggestion/suggestion_list';

export default class AutocompleteSelector extends React.PureComponent {
    static propTypes = {
        providers: PropTypes.array.isRequired,
        value: PropTypes.string.isRequired,
        onSelected: PropTypes.func,
        label: PropTypes.node,
        labelClassName: PropTypes.string,
        inputClassName: PropTypes.string,
        helpText: PropTypes.node,
        placeholder: PropTypes.string,
        footer: PropTypes.node,
        disabled: PropTypes.bool,
        toggleFocus: PropTypes.func,
        listComponent: PropTypes.elementType,
        listPosition: PropTypes.string,
    };

    static defaultProps = {
        value: '',
        id: '',
        labelClassName: '',
        inputClassName: '',
        listComponent: SuggestionList,
        listPosition: 'top',
    };

    constructor(props) {
        super(props);

        this.state = {
            input: '',
        };
    }

    onChange = (e) => {
        if (!e || !e.target) {
            return;
        }

        this.setState({input: e.target.value});
    }

    handleSelected = (selected) => {
        this.setState({input: ''});

        if (this.props.onSelected) {
            this.props.onSelected(selected);
        }

        requestAnimationFrame(() => {
            if (this.suggestionRef) {
                this.suggestionRef.blur();
            }
        });
    }

    setSuggestionRef = (ref) => {
        this.suggestionRef = ref;
    }

    onFocus = () => {
        this.setState({focused: true});

        if (this.props.toggleFocus) {
            this.props.toggleFocus(true);
        }
    }

    onBlur = () => {
        this.setState({focused: false});

        if (this.props.toggleFocus) {
            this.props.toggleFocus(false);
        }
    }

    render() {
        const {
            providers,
            placeholder,
            footer,
            label,
            labelClassName,
            helpText,
            inputClassName,
            value,
            disabled,
            listComponent,
            listPosition,
        } = this.props;

        const {focused} = this.state;
        let {input} = this.state;

        if (!focused) {
            input = value;
        }

        let labelContent;
        if (label) {
            labelContent = (
                <label
                    className={'control-label ' + labelClassName}
                >
                    {label}
                </label>
            );
        }

        let helpTextContent;
        if (helpText) {
            helpTextContent = (
                <div className='help-text'>
                    {helpText}
                </div>
            );
        }

        return (
            <div
                data-testid='autoCompleteSelector'
                className='form-group'
            >
                {labelContent}
                <div className={inputClassName}>
                    <SuggestionBox
                        placeholder={placeholder}
                        ref={this.setSuggestionRef}
                        listComponent={listComponent}
                        className='form-control'
                        containerClass='select-suggestion-container'
                        value={input}
                        onChange={this.onChange}
                        onItemSelected={this.handleSelected}
                        onFocus={this.onFocus}
                        onBlur={this.onBlur}
                        providers={providers}
                        completeOnTab={true}
                        renderNoResults={true}
                        openOnFocus={true}
                        openWhenEmpty={true}
                        replaceAllInputOnSelect={true}
                        disabled={disabled}
                        listPosition={listPosition}
                    />
                    {helpTextContent}
                    {footer}
                </div>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ChangeEvent, FormEvent, CSSProperties} from 'react';

type Props = {
    id?: string;
    disabled?: boolean;
    value?: string;
    defaultValue?: string;
    onChange?: (e: ChangeEvent<HTMLTextAreaElement>) => void;
    onHeightChange?: (height: number, maxHeight: number) => void;
    onInput?: (e: FormEvent<HTMLTextAreaElement>) => void;
    placeholder?: string;
    forwardedRef?: ((instance: HTMLTextAreaElement | null) => void) | React.MutableRefObject<HTMLTextAreaElement | null> | null;
}

export class AutosizeTextarea extends React.PureComponent<Props> {
    private height: number;

    private textarea?: HTMLTextAreaElement;
    private referenceRef: React.RefObject<HTMLTextAreaElement>;

    constructor(props: Props) {
        super(props);

        this.height = 0;

        this.referenceRef = React.createRef();
    }

    componentDidMount() {
        this.recalculateSize();
    }

    componentDidUpdate() {
        this.recalculateSize();
    }

    private recalculateSize = () => {
        if (!this.referenceRef.current || !this.textarea) {
            return;
        }

        const height = (this.referenceRef.current).scrollHeight;
        const textarea = this.textarea;

        if (height > 0 && height !== this.height) {
            const style = getComputedStyle(textarea);
            const borderWidth = parseInt(style.borderTopWidth || '0', 10) + parseInt(style.borderBottomWidth || '0', 10);

            // Directly change the height to avoid circular rerenders
            textarea.style.height = String(height + borderWidth) + 'px';

            this.height = height;

            window.requestAnimationFrame(() => {
                this.props.onHeightChange?.(height, parseInt(style.maxHeight || '0', 10));
            });
        }
    }

    private setTextareaRef = (textarea: HTMLTextAreaElement) => {
        if (this.props.forwardedRef) {
            if (typeof this.props.forwardedRef === 'function') {
                this.props.forwardedRef(textarea);
            } else {
                this.props.forwardedRef.current = textarea;
            }
        }

        this.textarea = textarea;
    }

    render() {
        const props = {...this.props};

        Reflect.deleteProperty(props, 'onHeightChange');
        Reflect.deleteProperty(props, 'providers');
        Reflect.deleteProperty(props, 'channelId');
        Reflect.deleteProperty(props, 'forwardedRef');

        const {
            value,
            defaultValue,
            placeholder,
            disabled,
            onInput,

            // TODO: The provided `id` is sometimes hard-coded and used to interface with the
            // component, e.g. `post_textbox`, so it can't be changed. This would ideally be
            // abstracted to avoid passing in an `id` prop at all, but we intentionally maintain
            // the old behaviour to address ABC-213.
            id = 'autosize_textarea',
            ...otherProps
        } = props;

        const heightProps = {
            rows: 0,
            height: 0,
        };

        if (this.height <= 0) {
            // Set an initial number of rows so that the textarea doesn't appear too large when its first rendered
            heightProps.rows = 1;
        } else {
            heightProps.height = this.height;
        }

        let textareaPlaceholder = null;
        const placeholderAriaLabel = placeholder ? placeholder.toLowerCase() : '';
        if (!this.props.value && !this.props.defaultValue) {
            textareaPlaceholder = (
                <div
                    {...otherProps as any}
                    id={`${id}_placeholder`}
                    data-testid={`${id}_placeholder`}
                    style={style.placeholder}
                >
                    {placeholder}
                </div>
            );
        }

        return (
            <div>
                {textareaPlaceholder}
                <textarea
                    ref={this.setTextareaRef}
                    data-testid={id}
                    id={id}
                    {...heightProps}
                    {...otherProps}
                    role='textbox'
                    aria-label={placeholderAriaLabel}
                    dir='auto'
                    disabled={disabled}
                    onChange={this.props.onChange}
                    onInput={onInput}
                    value={value}
                    defaultValue={defaultValue}
                />
                <div style={style.container}>
                    <textarea
                        ref={this.referenceRef}
                        id={id + '-reference'}
                        style={style.reference}
                        dir='auto'
                        disabled={true}
                        rows={1}
                        {...otherProps}
                        value={value || defaultValue}
                        aria-hidden={true}
                    />
                </div>
            </div>
        );
    }
}

const style: { [Key: string]: CSSProperties} = {
    container: {height: 0, overflow: 'hidden'},
    reference: {height: 'auto', width: '100%'},
    placeholder: {overflow: 'hidden', textOverflow: 'ellipsis', opacity: 0.5, pointerEvents: 'none', position: 'absolute', whiteSpace: 'nowrap', background: 'none', borderColor: 'transparent'},
};

const forwarded = React.forwardRef<HTMLTextAreaElement>((props, ref) => (
    <AutosizeTextarea
        forwardedRef={ref}
        {...props}
    />
));
forwarded.displayName = 'AutosizeTextarea';

export default forwarded;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import NewChannelWithBoardTourTip from 'components/app_bar/new_channel_with_board_tour_tip';
import KeyboardShortcutSequence, {
    KEYBOARD_SHORTCUTS,
    KeyboardShortcutDescriptor,
} from 'components/keyboard_shortcuts/keyboard_shortcuts_sequence';

import {localizeMessage} from 'utils/utils';
import {Constants, suitePluginIds} from 'utils/constants';
import {t} from 'utils/i18n';

type Props = {
    ariaLabel?: boolean;
    buttonClass?: string;
    buttonId: string;
    iconComponent: React.ReactNode;
    onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;
    tooltipKey: string;
    tooltipText?: React.ReactNode;
    isRhsOpen?: boolean;
    pluginId?: string;
}

type TooltipInfo = {
    class: string;
    id: string;
    messageID: string;
    message: string;
    keyboardShortcut?: KeyboardShortcutDescriptor;
}

const HeaderIconWrapper = (props: Props) => {
    const {
        ariaLabel,
        buttonClass,
        buttonId,
        iconComponent,
        onClick,
        tooltipKey,
        tooltipText,
        isRhsOpen,
        pluginId,
    } = props;

    const toolTips: Record<string, TooltipInfo> = {
        flaggedPosts: {
            class: 'text-nowrap',
            id: 'flaggedTooltip',
            messageID: t('channel_header.flagged'),
            message: 'Saved posts',
        },
        pinnedPosts: {
            class: 'pinned-posts',
            id: 'pinnedPostTooltip',
            messageID: t('channel_header.pinnedPosts'),
            message: 'Pinned posts',
        },
        recentMentions: {
            class: '',
            id: 'recentMentionsTooltip',
            messageID: t('channel_header.recentMentions'),
            message: 'Recent mentions',
            keyboardShortcut: KEYBOARD_SHORTCUTS.navMentions,
        },
        search: {
            class: '',
            id: 'searchTooltip',
            messageID: t('channel_header.search'),
            message: 'Search',
        },
        channelFiles: {
            class: 'channel-files',
            id: 'channelFilesTooltip',
            messageID: t('channel_header.channelFiles'),
            message: 'Channel files',
        },
        openChannelInfo: {
            class: 'channel-info',
            id: 'channelInfoTooltip',
            messageID: t('channel_header.openChannelInfo'),
            message: 'View Info',
        },
        closeChannelInfo: {
            class: 'channel-info',
            id: 'channelInfoTooltip',
            messageID: t('channel_header.closeChannelInfo'),
            message: 'Close info',
        },
        channelMembers: {
            class: 'channel-info',
            id: 'channelMembersTooltip',
            messageID: t('channel_header.channelMembers'),
            message: 'Members',
        },
    };

    function getTooltip(key: string) {
        if (toolTips[key] == null) {
            return null;
        }

        return (
            <Tooltip
                id={toolTips[key].id}
                className={toolTips[key].class}
            >
                <FormattedMessage
                    id={toolTips[key].messageID}
                    defaultMessage={toolTips[key].message}
                />
                {toolTips[key].keyboardShortcut &&
                    <KeyboardShortcutSequence
                        shortcut={toolTips[key].keyboardShortcut!}
                        hideDescription={true}
                        isInsideTooltip={true}
                    />
                }
            </Tooltip>
        );
    }

    let tooltip;
    if (tooltipKey === 'plugin' && tooltipText) {
        tooltip = (
            <Tooltip
                id='pluginTooltip'
                className=''
            >
                <span>{tooltipText}</span>
            </Tooltip>
        );
    } else {
        tooltip = getTooltip(tooltipKey);
    }

    let ariaLabelText;
    if (ariaLabel) {
        ariaLabelText = `${localizeMessage(toolTips[tooltipKey].messageID, toolTips[tooltipKey].message)}`;
    }

    if (tooltip) {
        return (
            <div>
                <OverlayTrigger
                    trigger={['hover', 'focus']}
                    delayShow={Constants.OVERLAY_TIME_DELAY}
                    placement='bottom'
                    overlay={isRhsOpen ? <></> : tooltip}
                >
                    <button
                        id={buttonId}
                        aria-label={ariaLabelText}
                        className={buttonClass || 'channel-header__icon'}
                        onClick={onClick}
                    >
                        {iconComponent}
                    </button>
                </OverlayTrigger>
                {pluginId && pluginId === suitePluginIds.focalboard &&
                    <NewChannelWithBoardTourTip
                        pulsatingDotPlacement={'start'}
                        pulsatingDotTranslate={{x: 0, y: -22}}
                    />
                }
            </div>
        );
    }

    return (
        <>
            <div className='flex-child'>
                <button
                    id={buttonId}
                    className={buttonClass || 'channel-header__icon'}
                    onClick={onClick}
                >
                    {iconComponent}
                </button>
            </div>
            {pluginId && pluginId === suitePluginIds.focalboard &&
                <NewChannelWithBoardTourTip
                    pulsatingDotPlacement={'start'}
                    pulsatingDotTranslate={{x: 0, y: -22}}
                />
            }
        </>
    );
};

export default HeaderIconWrapper;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

import {Client4} from 'mattermost-redux/client';
import {RelationOneToOne} from '@mattermost/types/utilities';
import {ActionResult} from 'mattermost-redux/types/actions';
import {Channel} from '@mattermost/types/channels';
import {UserProfile} from '@mattermost/types/users';

import {displayUsername, filterProfilesStartingWithTerm, isGuest} from 'mattermost-redux/utils/user_utils';
import {localizeMessage} from 'utils/utils';
import ProfilePicture from 'components/profile_picture';
import MultiSelect, {Value} from 'components/multiselect/multiselect';
import AddIcon from 'components/widgets/icons/fa_add_icon';
import GuestBadge from 'components/widgets/badges/guest_badge';
import BotBadge from 'components/widgets/badges/bot_badge';
import InvitationModal from 'components/invitation_modal';
import ToggleModalButton from 'components/toggle_modal_button';

import Constants, {ModalIdentifiers} from 'utils/constants';

const USERS_PER_PAGE = 50;

type UserProfileValue = Value & UserProfile;

export type Props = {
    profilesNotInCurrentChannel: UserProfileValue[];
    profilesInCurrentChannel: UserProfileValue[];
    profilesNotInCurrentTeam: UserProfileValue[];
    userStatuses: RelationOneToOne<UserProfile, string>;
    onExited: () => void;
    channel: Channel;
    teammateNameDisplaySetting: string;

    // skipCommit = true used with onAddCallback will result in users not being committed immediately
    skipCommit?: boolean;

    // onAddCallback takes an array of UserProfiles and should set usersToAdd in state of parent component
    onAddCallback?: (userProfiles?: UserProfileValue[]) => void;

    // Dictionaries of userid mapped users to exclude or include from this list
    excludeUsers?: Record<string, UserProfileValue>;
    includeUsers?: Record<string, UserProfileValue>;
    canInviteGuests?: boolean;
    emailInvitationsEnabled?: boolean;
    actions: {
        addUsersToChannel: (channelId: string, userIds: string[]) => Promise<ActionResult>;
        getProfilesNotInChannel: (teamId: string, channelId: string, groupConstrained: boolean, page: number, perPage?: number) => Promise<ActionResult>;
        getProfilesInChannel: (channelId: string, page: number, perPage: number, sort: string, options: {active?: boolean}) => Promise<ActionResult>;
        getTeamStats: (teamId: string) => void;
        loadStatusesForProfilesList: (users: UserProfile[]) => void;
        searchProfiles: (term: string, options: any) => Promise<ActionResult>;
        closeModal: (modalId: string) => void;
    };
}

type State = {
    values: UserProfileValue[];
    term: string;
    show: boolean;
    saving: boolean;
    loadingUsers: boolean;
    inviteError?: string;
}

export default class ChannelInviteModal extends React.PureComponent<Props, State> {
    private searchTimeoutId = 0;
    private selectedItemRef = React.createRef<HTMLDivElement>();

    public static defaultProps = {
        includeUsers: {},
        excludeUsers: {},
        skipCommit: false,
    };

    constructor(props: Props) {
        super(props);

        this.state = {
            values: [],
            term: '',
            show: true,
            saving: false,
            loadingUsers: true,
        } as State;
    }

    private addValue = (value: UserProfileValue): void => {
        const values: UserProfileValue[] = Object.assign([], this.state.values);
        if (values.indexOf(value) === -1) {
            values.push(value);
        }

        this.setState({values});
    };

    public componentDidMount(): void {
        this.props.actions.getProfilesNotInChannel(this.props.channel.team_id, this.props.channel.id, this.props.channel.group_constrained, 0).then(() => {
            this.setUsersLoadingState(false);
        });
        this.props.actions.getProfilesInChannel(this.props.channel.id, 0, USERS_PER_PAGE, '', {active: true});
        this.props.actions.getTeamStats(this.props.channel.team_id);
        this.props.actions.loadStatusesForProfilesList(this.props.profilesNotInCurrentChannel);
        this.props.actions.loadStatusesForProfilesList(this.props.profilesInCurrentChannel);
    }

    public onHide = (): void => {
        this.setState({show: false});
        this.props.actions.loadStatusesForProfilesList(this.props.profilesNotInCurrentChannel);
        this.props.actions.loadStatusesForProfilesList(this.props.profilesInCurrentChannel);
    };

    public handleInviteError = (err: any): void => {
        if (err) {
            this.setState({
                saving: false,
                inviteError: err.message,
            });
        }
    };

    private handleDelete = (values: UserProfileValue[]): void => {
        this.setState({values});
    };

    private setUsersLoadingState = (loadingState: boolean): void => {
        this.setState({
            loadingUsers: loadingState,
        });
    };

    private handlePageChange = (page: number, prevPage: number): void => {
        if (page > prevPage) {
            this.setUsersLoadingState(true);
            this.props.actions.getProfilesNotInChannel(
                this.props.channel.team_id,
                this.props.channel.id,
                this.props.channel.group_constrained,
                page + 1, USERS_PER_PAGE).then(() => this.setUsersLoadingState(false));

            this.props.actions.getProfilesInChannel(this.props.channel.id, page + 1, USERS_PER_PAGE, '', {active: true});
        }
    };

    public handleSubmit = (): void => {
        const {actions, channel} = this.props;

        const userIds = this.state.values.map((v) => v.id);
        if (userIds.length === 0) {
            return;
        }

        if (this.props.skipCommit && this.props.onAddCallback) {
            this.props.onAddCallback(this.state.values);
            this.setState({
                saving: false,
                inviteError: undefined,
            });
            this.onHide();
            return;
        }

        this.setState({saving: true});

        actions.addUsersToChannel(channel.id, userIds).then((result: any) => {
            if (result.error) {
                this.handleInviteError(result.error);
            } else {
                this.setState({
                    saving: false,
                    inviteError: undefined,
                });
                this.onHide();
            }
        });
    };

    public search = (searchTerm: string): void => {
        const term = searchTerm.trim();
        clearTimeout(this.searchTimeoutId);
        this.setState({
            term,
        });

        if (term) {
            this.setUsersLoadingState(true);
            this.searchTimeoutId = window.setTimeout(
                async () => {
                    const options = {
                        team_id: this.props.channel.team_id,
                        not_in_channel_id: this.props.channel.id,
                        group_constrained: this.props.channel.group_constrained,
                    };
                    await this.props.actions.searchProfiles(term, options);
                    this.setUsersLoadingState(false);
                },
                Constants.SEARCH_TIMEOUT_MILLISECONDS,
            );
        } else {
            return;
        }

        this.searchTimeoutId = window.setTimeout(
            async () => {
                if (!term) {
                    return;
                }

                const options = {
                    team_id: this.props.channel.team_id,
                    not_in_channel_id: this.props.channel.id,
                    group_constrained: this.props.channel.group_constrained,
                };
                await this.props.actions.searchProfiles(term, options);
                this.setUsersLoadingState(false);
            },
            Constants.SEARCH_TIMEOUT_MILLISECONDS,
        );
    };

    private renderAriaLabel = (option: UserProfileValue): string => {
        if (!option) {
            return '';
        }
        return option.username;
    }

    renderOption = (option: UserProfileValue, isSelected: boolean, onAdd: (user: UserProfileValue) => void, onMouseMove: (user: UserProfileValue) => void) => {
        let rowSelected = '';
        if (isSelected) {
            rowSelected = 'more-modal__row--selected';
        }

        const ProfilesInGroup = this.props.profilesInCurrentChannel.map((user) => user.id);

        const userMapping: Record<string, string> = {};

        for (let i = 0; i < ProfilesInGroup.length; i++) {
            userMapping[ProfilesInGroup[i]] = 'Already in channel';
        }

        const displayName = displayUsername(option, this.props.teammateNameDisplaySetting);

        return (
            <div
                key={option.id}
                ref={isSelected ? this.selectedItemRef : option.id}
                className={'more-modal__row clickable ' + rowSelected}
                onClick={() => onAdd(option)}
                onMouseMove={() => onMouseMove(option)}
            >
                <ProfilePicture
                    src={Client4.getProfilePictureUrl(option.id, option.last_picture_update)}
                    status={this.props.userStatuses[option.id]}
                    size='md'
                    username={option.username}
                />
                <div className='more-modal__details'>
                    <div className='more-modal__name'>
                        <span>
                            {displayName}
                            <BotBadge
                                show={Boolean(option.is_bot)}
                            />
                            <GuestBadge show={isGuest(option.roles)}/>
                            {displayName === option.username ?
                                null :
                                <span
                                    className='ml-2 light'
                                    style={{fontSize: '12px'}}
                                >{'@'}{option.username}</span>
                            }
                            <span
                                style={{position: 'absolute', right: 20}}
                                className='light'
                            >{userMapping[option.id]}</span>
                        </span>
                    </div>
                </div>
                <div className='more-modal__actions'>
                    <div className='more-modal__actions--round'>
                        <AddIcon/>
                    </div>
                </div>
            </div>
        );
    };

    public render = (): JSX.Element => {
        let inviteError = null;
        if (this.state.inviteError) {
            inviteError = (<label className='has-error control-label'>{this.state.inviteError}</label>);
        }

        const header = (
            <h1>
                <FormattedMessage
                    id='channel_invite.addNewMembers'
                    defaultMessage='Add people to {channel}'
                    values={{
                        channel: this.props.channel.display_name,
                    }}
                />
            </h1>
        );

        const buttonSubmitText = localizeMessage('multiselect.add', 'Add');
        const buttonSubmitLoadingText = localizeMessage('multiselect.adding', 'Adding...');

        let users = filterProfilesStartingWithTerm(this.props.profilesNotInCurrentChannel.concat(this.props.profilesInCurrentChannel), this.state.term).filter((user) => {
            return user.delete_at === 0 &&
                !this.props.profilesNotInCurrentTeam.includes(user as UserProfileValue) &&
                (this.props.excludeUsers !== undefined && !this.props.excludeUsers[user.id]);
        }).map((user) => user as UserProfileValue);

        if (this.props.includeUsers) {
            const includeUsers = Object.values(this.props.includeUsers);
            users = [...users, ...includeUsers];
        }

        const closeMembersInviteModal = () => {
            this.props.actions.closeModal(ModalIdentifiers.CHANNEL_INVITE);
        };

        const InviteModalLink = ({
            children,
            inviteAsGuest,
        }: {children: React.ReactNode; inviteAsGuest?: boolean}) => {
            return (
                <ToggleModalButton
                    id='inviteGuest'
                    className={`${inviteAsGuest ? 'invite-as-guest' : ''} btn btn-link`}
                    modalId={ModalIdentifiers.INVITATION}
                    dialogType={InvitationModal}
                    dialogProps={{
                        channelToInvite: this.props.channel,
                        initialValue: this.state.term,
                        inviteAsGuest,
                    }}
                    onClick={closeMembersInviteModal}
                >
                    {children}
                </ToggleModalButton>
            );
        };

        const customNoOptionsMessage = (
            <div className='custom-no-options-message'>
                <FormattedMessage
                    id='channel_invite.no_options_message'
                    defaultMessage='No matches found - <InvitationModalLink>Invite them to the team</InvitationModalLink>'
                    values={{
                        InvitationModalLink: (chunks: string) => (
                            <InviteModalLink>
                                {chunks}
                            </InviteModalLink>
                        ),
                    }}
                />
            </div>
        );

        const content = (
            <MultiSelect
                key='addUsersToChannelKey'
                options={users}
                optionRenderer={this.renderOption}
                selectedItemRef={this.selectedItemRef}
                values={this.state.values}
                ariaLabelRenderer={this.renderAriaLabel}
                saveButtonPosition={'bottom'}
                perPage={USERS_PER_PAGE}
                handlePageChange={this.handlePageChange}
                handleInput={this.search}
                handleDelete={this.handleDelete}
                handleAdd={this.addValue}
                handleSubmit={this.handleSubmit}
                handleCancel={closeMembersInviteModal}
                buttonSubmitText={buttonSubmitText}
                buttonSubmitLoadingText={buttonSubmitLoadingText}
                saving={this.state.saving}
                loading={this.state.loadingUsers}
                placeholderText={localizeMessage('multiselect.placeholder', 'Search for people')}
                valueWithImage={true}
                backButtonText={localizeMessage('multiselect.cancel', 'Cancel')}
                backButtonClick={closeMembersInviteModal}
                backButtonClass={'btn-cancel tertiary-button'}
                customNoOptionsMessage={this.props.emailInvitationsEnabled ? customNoOptionsMessage : null}
            />
        );

        const inviteGuestLink = (
            <InviteModalLink inviteAsGuest={true}>
                <FormattedMessage
                    id='channel_invite.invite_guest'
                    defaultMessage='Invite as a Guest'
                />
            </InviteModalLink>
        );

        return (
            <Modal
                id='addUsersToChannelModal'
                dialogClassName='a11y__modal channel-invite'
                show={this.state.show}
                onHide={this.onHide}
                onExited={this.props.onExited}
                role='dialog'
                aria-labelledby='channelInviteModalLabel'
            >
                <Modal.Header
                    id='channelInviteModalLabel'
                    closeButton={true}
                />
                <Modal.Body
                    role='application'
                    className='overflow--visible'
                >
                    <div className='channel-invite__header'>
                        {header}
                    </div>
                    {inviteError}
                    <div className='channel-invite__content'>
                        {content}
                        {(this.props.emailInvitationsEnabled && this.props.canInviteGuests) && inviteGuestLink}
                    </div>
                </Modal.Body>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {getTeamStats} from 'mattermost-redux/actions/teams';
import {getProfilesNotInChannel, getProfilesInChannel, searchProfiles} from 'mattermost-redux/actions/users';
import {getProfilesNotInCurrentChannel, getProfilesInCurrentChannel, getProfilesNotInCurrentTeam, getProfilesNotInTeam, getUserStatuses, makeGetProfilesNotInChannel, makeGetProfilesInChannel} from 'mattermost-redux/selectors/entities/users';
import {getTeammateNameDisplaySetting} from 'mattermost-redux/selectors/entities/preferences';

import {Action, ActionResult} from 'mattermost-redux/types/actions';
import {UserProfile} from '@mattermost/types/users';
import {getConfig, getLicense} from 'mattermost-redux/selectors/entities/general';
import {haveICurrentTeamPermission} from 'mattermost-redux/selectors/entities/roles';
import {getCurrentTeam, getTeam} from 'mattermost-redux/selectors/entities/teams';
import {Permissions} from 'mattermost-redux/constants';

import {Value} from 'components/multiselect/multiselect';

import {addUsersToChannel} from 'actions/channel_actions';
import {loadStatusesForProfilesList} from 'actions/status_actions';

import {closeModal} from 'actions/views/modals';

import {GlobalState} from 'types/store';

import ChannelInviteModal from './channel_invite_modal';

type UserProfileValue = Value & UserProfile;

type OwnProps = {
    channelId?: string;
    teamId?: string;
}

function makeMapStateToProps(initialState: GlobalState, initialProps: OwnProps) {
    let doGetProfilesNotInChannel: (state: GlobalState, channelId: string, filters?: any) => UserProfile[];
    if (initialProps.channelId && initialProps.teamId) {
        doGetProfilesNotInChannel = makeGetProfilesNotInChannel();
    }

    let doGetProfilesInChannel: (state: GlobalState, channelId: string, filters?: any) => UserProfile[];
    if (initialProps.channelId && initialProps.teamId) {
        doGetProfilesInChannel = makeGetProfilesInChannel();
    }

    return (state: GlobalState, props: OwnProps) => {
        let profilesNotInCurrentChannel: UserProfileValue[];
        let profilesInCurrentChannel: UserProfileValue[];
        let profilesNotInCurrentTeam: UserProfileValue[];

        if (props.channelId && props.teamId) {
            profilesNotInCurrentChannel = doGetProfilesNotInChannel(state, props.channelId) as UserProfileValue[];
            profilesInCurrentChannel = doGetProfilesInChannel(state, props.channelId) as UserProfileValue[];
            profilesNotInCurrentTeam = getProfilesNotInTeam(state, props.teamId) as UserProfileValue[];
        } else {
            profilesNotInCurrentChannel = getProfilesNotInCurrentChannel(state) as UserProfileValue[];
            profilesInCurrentChannel = getProfilesInCurrentChannel(state) as UserProfileValue[];
            profilesNotInCurrentTeam = getProfilesNotInCurrentTeam(state) as UserProfileValue[];
        }

        const config = getConfig(state);
        const license = getLicense(state);

        const currentTeam = props.teamId ? getTeam(state, props.teamId) : getCurrentTeam(state);

        const guestAccountsEnabled = config.EnableGuestAccounts === 'true';
        const emailInvitationsEnabled = config.EnableEmailInvitations === 'true';
        const isLicensed = license && license.IsLicensed === 'true';
        const isGroupConstrained = Boolean(currentTeam.group_constrained);
        const canInviteGuests = !isGroupConstrained && isLicensed && guestAccountsEnabled && haveICurrentTeamPermission(state, Permissions.INVITE_GUEST);

        const userStatuses = getUserStatuses(state);

        const teammateNameDisplaySetting = getTeammateNameDisplaySetting(state);

        return {
            profilesNotInCurrentChannel,
            profilesInCurrentChannel,
            profilesNotInCurrentTeam,
            teammateNameDisplaySetting,
            userStatuses,
            canInviteGuests,
            emailInvitationsEnabled,
        };
    };
}

type Actions = {
    addUsersToChannel: (channelId: string, userIds: string[]) => Promise<ActionResult>;
    getProfilesNotInChannel: (teamId: string, channelId: string, groupConstrained: boolean, page: number, perPage?: number) => Promise<ActionResult>;
    getTeamStats: (teamId: string) => void;
    loadStatusesForProfilesList: (users: UserProfile[]) => void;
    searchProfiles: (term: string, options: any) => Promise<ActionResult>;
    closeModal: (modalId: string) => void;
    getProfilesInChannel: (channelId: string, page: number, perPage: number, sort: string, options: {active?: boolean}) => Promise<ActionResult>;
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, Actions>({
            addUsersToChannel,
            getProfilesNotInChannel,
            getProfilesInChannel,
            getTeamStats,
            loadStatusesForProfilesList,
            searchProfiles,
            closeModal,
        }, dispatch),
    };
}

export default connect(makeMapStateToProps, mapDispatchToProps)(ChannelInviteModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState} from 'react';
import {FormattedMessage} from 'react-intl';

import {useDispatch} from 'react-redux';

import {UserProfile} from '@mattermost/types/users';
import {Channel, ChannelMembership} from '@mattermost/types/channels';

import * as UserUtils from 'mattermost-redux/utils/user_utils';
import {ActionResult} from 'mattermost-redux/types/actions';

import {Constants, ModalIdentifiers} from 'utils/constants';
import * as Utils from 'utils/utils';

import {ModalData} from 'types/actions';

import DropdownIcon from 'components/widgets/icons/fa_dropdown_icon';
import Menu from 'components/widgets/menu/menu';
import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import LeaveChannelModal from 'components/leave_channel_modal';

const ROWS_FROM_BOTTOM_TO_OPEN_UP = 2;

interface Props {
    channel: Channel;
    user: UserProfile;
    currentUserId: string;
    channelMember: ChannelMembership;
    canChangeMemberRoles: boolean;
    canRemoveMember: boolean;
    index: number;
    totalUsers: number;
    channelAdminLabel?: JSX.Element;
    channelMemberLabel?: JSX.Element;
    guestLabel?: JSX.Element;
    actions: {
        getChannelStats: (channelId: string) => void;
        updateChannelMemberSchemeRoles: (channelId: string, userId: string, isSchemeUser: boolean, isSchemeAdmin: boolean) => Promise<ActionResult>;
        removeChannelMember: (channelId: string, userId: string) => Promise<ActionResult>;
        getChannelMember: (channelId: string, userId: string) => void;
        openModal: <P>(modalData: ModalData<P>) => void;
    };
}

export default function ChannelMembersDropdown({
    channel,
    user,
    currentUserId,
    channelMember,
    canChangeMemberRoles,
    canRemoveMember,
    index,
    totalUsers,
    channelAdminLabel,
    channelMemberLabel,
    guestLabel,
    actions,
}: Props) {
    const [removing, setRemoving] = useState(false);
    const [serverError, setServerError] = useState<string | null>(null);
    const dispatch = useDispatch();

    const handleRemoveFromChannel = async () => {
        if (removing) {
            return;
        }

        if (user.id === currentUserId) {
            setRemoving(true);
            dispatch(actions.openModal({
                modalId: ModalIdentifiers.LEAVE_PRIVATE_CHANNEL_MODAL,
                dialogType: LeaveChannelModal,
                dialogProps: {
                    channel,
                    callback: () => {
                        actions.getChannelStats(channel.id);
                        setRemoving(false);
                    },
                },
            }));
        } else {
            setRemoving(true);
            const {error} = await actions.removeChannelMember(channel.id, user.id);
            setRemoving(false);
            if (error) {
                setServerError(error.message);
                return;
            }

            actions.getChannelStats(channel.id);
        }
    };

    const handleMakeChannelAdmin = () => {
        updateChannelMemberSchemeRole(true);
    };

    const handleMakeChannelMember = () => {
        updateChannelMemberSchemeRole(false);
    };

    const updateChannelMemberSchemeRole = async (schemeAdmin: boolean) => {
        const {error} = await actions.updateChannelMemberSchemeRoles(channel.id, user.id, true, schemeAdmin);
        if (error) {
            setServerError(error.message);
            return;
        }

        actions.getChannelStats(channel.id);
        actions.getChannelMember(channel.id, user.id);
    };

    const renderRole = (isChannelAdmin: boolean, isGuest: boolean) => {
        if (isChannelAdmin) {
            if (channelAdminLabel) {
                return channelAdminLabel;
            }
            return (
                <FormattedMessage
                    id='channel_members_dropdown.channel_admin'
                    defaultMessage='Channel Admin'
                />
            );
        } else if (isGuest) {
            if (guestLabel) {
                return guestLabel;
            }
            return (
                <FormattedMessage
                    id='channel_members_dropdown.channel_guest'
                    defaultMessage='Channel Guest'
                />
            );
        }

        if (channelMemberLabel) {
            return channelMemberLabel;
        }
        return (
            <FormattedMessage
                id='channel_members_dropdown.channel_member'
                defaultMessage='Channel Member'
            />
        );
    };

    const isChannelAdmin = UserUtils.isChannelAdmin(channelMember.roles) || channelMember.scheme_admin;
    const isGuest = UserUtils.isGuest(user.roles);
    const isMember = !isChannelAdmin && !isGuest;
    const isDefaultChannel = channel.name === Constants.DEFAULT_CHANNEL;
    const currentRole = renderRole(isChannelAdmin, isGuest);

    if (user.remote_id) {
        const sharedTooltip = (
            <Tooltip id='sharedTooltip'>
                <FormattedMessage
                    id='shared_user_indicator.tooltip'
                    defaultMessage='From trusted organizations'
                />
            </Tooltip>
        );

        return (
            <div className='more-modal__shared-actions'>
                <OverlayTrigger
                    delayShow={Constants.OVERLAY_TIME_DELAY}
                    placement='bottom'
                    overlay={sharedTooltip}
                >
                    <span>
                        <FormattedMessage
                            id='channel_members_dropdown.shared_member'
                            defaultMessage='Shared Member'
                        />
                        <i className='shared-user-icon icon-circle-multiple-outline'/>
                    </span>
                </OverlayTrigger>
            </div>
        );
    }

    const canMakeUserChannelMember = canChangeMemberRoles && isChannelAdmin;
    const canMakeUserChannelAdmin = canChangeMemberRoles && isMember;
    const canRemoveUserFromChannel = canRemoveMember && (!channel.group_constrained || user.is_bot) && (!isDefaultChannel || isGuest);
    const removeFromChannelText = user.id === currentUserId ? Utils.localizeMessage('channel_header.leave', 'Leave Channel') : Utils.localizeMessage('channel_members_dropdown.remove_from_channel', 'Remove from Channel');
    const removeFromChannelTestId = user.id === currentUserId ? 'leaveChannel' : 'removeFromChannel';

    if (canMakeUserChannelMember || canMakeUserChannelAdmin || canRemoveUserFromChannel) {
        const removeMenu = (
            <Menu.ItemAction
                data-testid={removeFromChannelTestId}
                show={canRemoveUserFromChannel}
                onClick={handleRemoveFromChannel}
                text={removeFromChannelText}
                isDangerous={true}
            />
        );
        const makeAdminMenu = (
            <Menu.ItemAction
                id={`${user.username}-make-channel-admin`}
                show={canMakeUserChannelAdmin}
                onClick={handleMakeChannelAdmin}
                text={Utils.localizeMessage('channel_members_dropdown.make_channel_admin', 'Make Channel Admin')}
            />
        );
        const makeMemberMenu = (
            <Menu.ItemAction
                id={`${user.username}-make-channel-member`}
                show={canMakeUserChannelMember}
                onClick={handleMakeChannelMember}
                text={Utils.localizeMessage('channel_members_dropdown.make_channel_member', 'Make Channel Member')}
            />
        );
        return (
            <MenuWrapper>
                <button
                    className='dropdown-toggle theme color--link style--none'
                    type='button'
                >
                    <span className='sr-only'>{user.username}</span>
                    <span>{currentRole} </span>
                    <DropdownIcon/>
                </button>
                <Menu
                    openLeft={true}
                    openUp={totalUsers > ROWS_FROM_BOTTOM_TO_OPEN_UP && totalUsers - index <= ROWS_FROM_BOTTOM_TO_OPEN_UP}
                    ariaLabel={Utils.localizeMessage('channel_members_dropdown.menuAriaLabel', 'Change the role of channel member')}
                >
                    {canMakeUserChannelMember ? makeMemberMenu : null}
                    {canMakeUserChannelAdmin ? makeAdminMenu : null}
                    {canRemoveUserFromChannel ? removeMenu : null}
                    {serverError && (
                        <div className='has-error'>
                            <label className='has-error control-label'>{serverError}</label>
                        </div>
                    )}
                </Menu>
            </MenuWrapper>
        );
    }

    if (isDefaultChannel) {
        return (
            <div/>
        );
    }

    return (
        <div>
            {currentRole}
        </div>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, AnyAction, bindActionCreators, Dispatch} from 'redux';

import {getChannelStats, updateChannelMemberSchemeRoles, removeChannelMember, getChannelMember} from 'mattermost-redux/actions/channels';
import {haveIChannelPermission} from 'mattermost-redux/selectors/entities/roles';
import {Permissions} from 'mattermost-redux/constants';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {canManageMembers} from 'utils/channel_utils';
import {GlobalState} from 'types/store';
import {Channel} from '@mattermost/types/channels';
import {openModal} from 'actions/views/modals';

import {Action} from 'mattermost-redux/types/actions';

import ChannelMembersDropdown from './channel_members_dropdown';

interface OwnProps {
    channel: Channel;
}

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const {channel} = ownProps;
    const canChangeMemberRoles = haveIChannelPermission(
        state,
        channel.team_id,
        channel.id,
        Permissions.MANAGE_CHANNEL_ROLES,
    ) && canManageMembers(state, channel);
    const canRemoveMember = canManageMembers(state, channel);

    return {
        currentUserId: getCurrentUserId(state),
        canChangeMemberRoles,
        canRemoveMember,
    };
}

function mapDispatchToProps(dispatch: Dispatch<AnyAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, any>({
            getChannelMember,
            getChannelStats,
            updateChannelMemberSchemeRoles,
            removeChannelMember,
            openModal,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(ChannelMembersDropdown);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useEffect} from 'react';
import {FormattedMessage} from 'react-intl';
import styled from 'styled-components';

import Constants from 'utils/constants';
import {isKeyPressed} from 'utils/utils';

const Title = styled.div`
    flex:1;
    font-family: 'Open Sans', sans-serif;
    font-weight: 600;
    font-size: 14px;
    line-height: 20px;
`;

const Actions = styled.div`
    button + button {
        margin-left: 8px;
    }
`;

const Button = styled.button`
    border: none;
    background: transparent;
    width: fit-content;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: 600;
    line-height: 16px;
    &.add-members, &.manage-members-done {
        background-color: var(--button-bg);
        color: var(--button-color);
        &:hover, &:active, &:focus {
            background: linear-gradient(0deg, rgba(var(--center-channel-color-rgb), 0.16), rgba(var(--center-channel-color-rgb), 0.16)), var(--button-bg);
            color: var(--button-color);
        }
    }
    &.manage-members {
        background: rgba(var(--button-bg-rgb),0.08);
        color: var(--button-bg);
        &:hover, &:focus {
            background: rgba(var(--button-bg-rgb),0.12);
        }
        &:active {
            background: rgba(var(--button-bg-rgb),0.16);
        }
    }
`;

const ButtonIcon = styled.i`
    font-size: 14.4px;
`;

export interface Props {
    className?: string;
    channelType: string;
    membersCount: number;
    canManageMembers: boolean;
    editing: boolean;
    actions: {
        startEditing: () => void;
        stopEditing: () => void;
        inviteMembers: () => void;
    };
}

const ActionBar = ({className, channelType, membersCount, canManageMembers, editing, actions}: Props) => {
    const showManageButton = channelType !== Constants.GM_CHANNEL && membersCount > 1;

    const handleShortcut = useCallback((e) => {
        if (isKeyPressed(e, Constants.KeyCodes.ESCAPE) && editing) {
            actions.stopEditing();
        }
    }, [editing, actions]);

    useEffect(() => {
        document.addEventListener('keydown', handleShortcut);
        return () => {
            document.removeEventListener('keydown', handleShortcut);
        };
    }, [handleShortcut]);

    return (
        <div className={className}>
            <Title>
                {editing ? (
                    <FormattedMessage
                        id='channel_members_rhs.action_bar.managing_title'
                        defaultMessage='Managing Members'
                    />
                ) : (
                    <FormattedMessage
                        id='channel_members_rhs.action_bar.members_count_title'
                        defaultMessage='{members_count} members'
                        values={{members_count: membersCount}}
                    />
                )}

            </Title>

            {canManageMembers && (
                <Actions>
                    {editing ? (
                        <Button
                            onClick={actions.stopEditing}
                            className='manage-members-done'
                        >
                            <FormattedMessage
                                id='channel_members_rhs.action_bar.done_button'
                                defaultMessage='Done'
                            />
                        </Button>
                    ) : (
                        <>
                            {showManageButton && (
                                <Button
                                    className='manage-members'
                                    onClick={actions.startEditing}
                                >
                                    <FormattedMessage
                                        id='channel_members_rhs.action_bar.manage_button'
                                        defaultMessage='Manage'
                                    />
                                </Button>
                            )}
                            <Button
                                onClick={actions.inviteMembers}
                                className='add-members'
                            >
                                <ButtonIcon
                                    className='icon-account-plus-outline'
                                    title='Add Icon'
                                />
                                <FormattedMessage
                                    id='channel_members_rhs.action_bar.add_button'
                                    defaultMessage='Add'
                                />
                            </Button>
                        </>
                    )}

                </Actions>
            )}
        </div>
    );
};

export default styled(ActionBar)`
    display: flex;
    flex-direction: row;
    align-items: center;
    padding: 16px 20px;
`;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';
import styled from 'styled-components';

import Constants from 'utils/constants';
import {Channel} from '@mattermost/types/channels';
import LocalizedIcon from 'components/localized_icon';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import {t} from 'utils/i18n';

interface Props {
    channel: Channel;
    canGoBack: boolean;

    onClose: () => void;
    goBack: () => void;
}

const BackButton = styled.button`
    border: 0;
    background: transparent;
`;

const HeaderTitle = styled.span`
    line-height: 2.4rem;
`;

const Header = ({channel, canGoBack, onClose, goBack}: Props) => {
    const closeSidebarTooltip = (
        <Tooltip id='closeSidebarTooltip'>
            <FormattedMessage
                id='rhs_header.closeSidebarTooltip'
                defaultMessage='Close'
            />
        </Tooltip>
    );

    return (
        <div className='sidebar--right__header'>
            <span className='sidebar--right__title'>

                {canGoBack && (
                    <BackButton
                        className='sidebar--right__back'
                        onClick={goBack}
                    >
                        <i
                            className='icon icon-arrow-back-ios'
                            aria-label='Back Icon'
                        />
                    </BackButton>
                )}

                <HeaderTitle>
                    <FormattedMessage
                        id='channel_members_rhs.header.title'
                        defaultMessage='Members'
                    />
                </HeaderTitle>

                {channel.display_name &&
                    <span
                        className='style--none sidebar--right__title__subtitle'
                    >
                        {channel.display_name}
                    </span>
                }
            </span>

            <OverlayTrigger
                delayShow={Constants.OVERLAY_TIME_DELAY}
                placement='top'
                overlay={closeSidebarTooltip}
            >
                <button
                    id='rhsCloseButton'
                    type='button'
                    className='sidebar--right__close btn-icon'
                    aria-label='Close'
                    onClick={onClose}
                >
                    <LocalizedIcon
                        className='icon icon-close'
                        ariaLabel={{id: t('rhs_header.closeTooltip.icon'), defaultMessage: 'Close Sidebar Icon'}}
                    />
                </button>
            </OverlayTrigger>
        </div>
    );
};

export default Header;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

import styled from 'styled-components';

import Input from '../widgets/inputs/input/input';

interface Props {
    className?: string;
    terms: string;
    onInput: (terms: string) => void;
}

const SearchBar = ({className, terms, onInput}: Props) => {
    const {formatMessage} = useIntl();

    let inputSuffix;
    if (terms.length > 0) {
        inputSuffix = (
            <button
                className='style--none'
                onClick={() => onInput('')}
                aria-label={formatMessage({
                    id: 'channel_members_rhs.search_bar.aria.cancel_search_button',
                    defaultMessage: 'cancel members search',
                })}
            >
                <i className={'icon icon-close-circle'}/>
            </button>
        );
    }

    return (
        <div className={className}>
            <Input
                data-testid='channel-member-rhs-search'
                value={terms}
                onInput={(e) => onInput(e.currentTarget.value)}
                inputPrefix={<i className={'icon icon-magnify'}/>}
                inputSuffix={inputSuffix}
                placeholder={formatMessage({
                    id: 'channel_members_rhs.search_bar.placeholder',
                    defaultMessage: 'Search members',
                })}
                useLegend={false}
            />
        </div>
    );
};

export default styled(SearchBar)`
    display: flex;
    padding: 0px 20px 12px;

    .Input_container .Input_wrapper {
        padding: 0 8px;
    }
`;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {debounce} from 'lodash';
import React, {useCallback, useEffect, useState} from 'react';
import {FormattedMessage, useIntl} from 'react-intl';
import {useHistory} from 'react-router-dom';
import styled from 'styled-components';

import {UserProfile} from '@mattermost/types/users';
import {Channel, ChannelMembership} from '@mattermost/types/channels';
import Constants, {ModalIdentifiers} from 'utils/constants';
import MoreDirectChannels from 'components/more_direct_channels';
import ChannelInviteModal from 'components/channel_invite_modal';
import {ModalData} from 'types/actions';

import {ProfilesInChannelSortBy} from 'mattermost-redux/actions/users';

import AlertBanner from 'components/alert_banner';

import ActionBar from './action_bar';
import Header from './header';
import MemberList from './member_list';
import SearchBar from './search';

const USERS_PER_PAGE = 100;
export interface ChannelMember {
    user: UserProfile;
    membership?: ChannelMembership;
    status?: string;
    displayName: string;
}

const MembersContainer = styled.div`
    flex: 1 1 auto;
    padding: 0 4px 16px;
`;

export interface Props {
    channel: Channel;
    currentUserIsChannelAdmin: boolean;
    membersCount: number;
    searchTerms: string;
    canGoBack: boolean;
    teamUrl: string;
    channelMembers: ChannelMember[];
    canManageMembers: boolean;
    editing: boolean;

    actions: {
        openModal: <P>(modalData: ModalData<P>) => void;
        openDirectChannelToUserId: (userId: string) => Promise<{ data: Channel }>;
        closeRightHandSide: () => void;
        goBack: () => void;
        setChannelMembersRhsSearchTerm: (terms: string) => void;
        loadProfilesAndReloadChannelMembers: (page: number, perParge: number, channelId: string, sort: string) => void;
        loadMyChannelMemberAndRole: (channelId: string) => void;
        setEditChannelMembers: (active: boolean) => void;
        searchProfilesAndChannelMembers: (term: string, options: any) => Promise<{data: UserProfile[]}>;
    };
}

export enum ListItemType {
    Member = 'member',
    FirstSeparator = 'first-separator',
    Separator = 'separator',
}

export interface ListItem {
    type: ListItemType;
    data: ChannelMember | JSX.Element;
}

export default function ChannelMembersRHS({
    channel,
    currentUserIsChannelAdmin,
    searchTerms,
    membersCount,
    canGoBack,
    teamUrl,
    channelMembers,
    canManageMembers,
    editing = false,
    actions,
}: Props) {
    const history = useHistory();

    const [list, setList] = useState<ListItem[]>([]);

    const [page, setPage] = useState(0);
    const [isNextPageLoading, setIsNextPageLoading] = useState(false);
    const {formatMessage} = useIntl();

    const searching = searchTerms !== '';

    const isDefaultChannel = channel.name === Constants.DEFAULT_CHANNEL;

    // show search if there's more than 20 or if the user have an active search.
    const showSearch = searching || membersCount >= 20;

    useEffect(() => {
        return () => {
            actions.setChannelMembersRhsSearchTerm('');
        };
    }, []);

    useEffect(() => {
        const listcp: ListItem[] = [];
        let memberDone = false;

        for (let i = 0; i < channelMembers.length; i++) {
            const member = channelMembers[i];
            if (listcp.length === 0) {
                let text = null;
                if (member.membership?.scheme_admin === true) {
                    text = (
                        <FormattedMessage
                            id='channel_members_rhs.list.channel_admin_title'
                            defaultMessage='CHANNEL ADMINS'
                        />
                    );
                } else {
                    text = (
                        <FormattedMessage
                            id='channel_members_rhs.list.channel_members_title'
                            defaultMessage='MEMBERS'
                        />
                    );
                    memberDone = true;
                }

                listcp.push({
                    type: ListItemType.FirstSeparator,
                    data: <FirstMemberListSeparator>{text}</FirstMemberListSeparator>,
                });
            } else if (!memberDone && member.membership?.scheme_admin === false) {
                listcp.push({
                    type: ListItemType.Separator,
                    data: <MemberListSeparator>
                        <FormattedMessage
                            id='channel_members_rhs.list.channel_members_title'
                            defaultMessage='MEMBERS'
                        />
                    </MemberListSeparator>,
                });
                memberDone = true;
            }

            listcp.push({type: ListItemType.Member, data: member});
        }
        setList(listcp);
    }, [channelMembers]);

    useEffect(() => {
        if (channel.type === Constants.DM_CHANNEL) {
            let rhsAction = actions.closeRightHandSide;
            if (canGoBack) {
                rhsAction = actions.goBack;
            }
            rhsAction();
            return;
        }

        setPage(0);
        setIsNextPageLoading(false);
        actions.setChannelMembersRhsSearchTerm('');
        actions.loadProfilesAndReloadChannelMembers(0, USERS_PER_PAGE, channel.id, ProfilesInChannelSortBy.Admin);
        actions.loadMyChannelMemberAndRole(channel.id);
    }, [channel.id, channel.type]);

    const setSearchTerms = async (terms: string) => {
        actions.setChannelMembersRhsSearchTerm(terms);
    };

    const doSearch = useCallback(debounce(async (terms: string) => {
        await actions.searchProfilesAndChannelMembers(terms, {in_team_id: channel.team_id, in_channel_id: channel.id});
    }, Constants.SEARCH_TIMEOUT_MILLISECONDS), [actions.searchProfilesAndChannelMembers]);

    useEffect(() => {
        if (searchTerms) {
            doSearch(searchTerms);
        }
    }, [searchTerms]);

    const inviteMembers = () => {
        if (channel.type === Constants.GM_CHANNEL) {
            return actions.openModal({
                modalId: ModalIdentifiers.CREATE_DM_CHANNEL,
                dialogType: MoreDirectChannels,
                dialogProps: {isExistingChannel: true},
            });
        }

        return actions.openModal({
            modalId: ModalIdentifiers.CHANNEL_INVITE,
            dialogType: ChannelInviteModal,
            dialogProps: {channel},
        });
    };

    const openDirectMessage = async (user: UserProfile) => {
        // we first prepare the DM channel...
        await actions.openDirectChannelToUserId(user.id);

        // ... and then redirect to it
        history.push(teamUrl + '/messages/@' + user.username);

        await actions.closeRightHandSide();
    };

    const loadMore = async () => {
        setIsNextPageLoading(true);

        await actions.loadProfilesAndReloadChannelMembers(page + 1, USERS_PER_PAGE, channel.id, ProfilesInChannelSortBy.Admin);
        setPage(page + 1);

        setIsNextPageLoading(false);
    };

    return (
        <div
            id='rhsContainer'
            className='sidebar-right__body'
        >

            <Header
                channel={channel}
                canGoBack={canGoBack}
                onClose={actions.closeRightHandSide}
                goBack={actions.goBack}
            />

            <ActionBar
                channelType={channel.type}
                membersCount={membersCount}
                canManageMembers={canManageMembers}
                editing={editing}
                actions={{
                    startEditing: () => actions.setEditChannelMembers(true),
                    stopEditing: () => actions.setEditChannelMembers(false),
                    inviteMembers,
                }}
            />

            {/* Users with user management permissions have special restrictions in the default channel */}
            {(editing && isDefaultChannel && !currentUserIsChannelAdmin) && (
                <AlertContainer>
                    <AlertBanner
                        mode='info'
                        variant='app'
                        message={formatMessage({
                            id: 'channel_members_rhs.default_channel_moderation_restrictions',
                            defaultMessage: 'In this channel, you can only remove guests. Only <link>channel admins</link> can manage other members.',
                        }, {
                            link: (msg: React.ReactNode) => (
                                <a
                                    href='https://docs.mattermost.com/welcome/about-user-roles.html#channel-admin'
                                    target='_blank'
                                    rel='noreferrer'
                                >
                                    {msg}
                                </a>
                            ),
                        })}
                    />
                </AlertContainer>
            )}

            {showSearch && (
                <SearchBar
                    terms={searchTerms}
                    onInput={setSearchTerms}
                />
            )}

            <MembersContainer>
                {channelMembers.length > 0 && (
                    <MemberList
                        searchTerms={searchTerms}
                        members={list}
                        editing={editing}
                        channel={channel}
                        actions={{openDirectMessage, loadMore}}
                        hasNextPage={channelMembers.length < membersCount}
                        isNextPageLoading={isNextPageLoading}
                    />
                )}
            </MembersContainer>
        </div>
    );
}

const MemberListSeparator = styled.div`
    font-weight: 600;
    font-size: 12px;
    line-height: 28px;
    letter-spacing: 0.02em;
    text-transform: uppercase;
    padding: 0px 12px;
    color: rgba(var(--center-channel-color-rgb), 0.56);
    margin-top: 16px;
`;

const FirstMemberListSeparator = styled(MemberListSeparator)`
    margin-top: 0px;
`;

const AlertContainer = styled.div`
    padding: 0 20px 15px;
`;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import styled, {css} from 'styled-components';
import classNames from 'classnames';
import {FormattedMessage} from 'react-intl';

import {UserProfile} from '@mattermost/types/users';
import ProfilePicture from 'components/profile_picture';
import {Client4} from 'mattermost-redux/client';
import ChannelMembersDropdown from 'components/channel_members_dropdown';
import {Channel} from '@mattermost/types/channels';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';

import Constants from 'utils/constants';

import {isGuest} from 'mattermost-redux/utils/user_utils';
import GuestBadge from 'components/widgets/badges/guest_badge';

import {ChannelMember} from './channel_members_rhs';

const Avatar = styled.div`
    flex-basis: fit-content;
    flex-shrink: 0;
`;

const UserInfo = styled.div`
    flex: 1;
    overflow-x: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
`;

const DisplayName = styled.span`
    margin-left: 8px;
    font-size: 14px;
    line-height: 20px;
    color: var(--center-channel-color);
`;

const Username = styled.span`
    margin-left: 8px;
    font-size: 12px;
    line-height: 18px;
    color: rgba(var(--center-channel-color-rgb), 0.56);
`;

const SendMessage = styled.button`
    display: none;
    border: 0;
    background-color: transparent;
    padding: 0;
    width: 24px;
    height: 24px;
    border-radius: 4px;
    &:hover {
        background-color: rgba(var(--center-channel-color-rgb), 0.12);
    }
    .icon {
        font-size: 14.4px;
        color: rgba(var(--center-channel-color-rgb), 0.56);
    };
`;

const RoleChooser = styled.div`
    display: none;
    flex-basis: fit-content;
    flex-shrink: 0;

    &.editing {
        display: block;
    }

    .MenuWrapper {
        padding: 6px 10px;
        border-radius: 4px;
        &.MenuWrapper--open {
            background: rgba(var(--button-bg-rgb), 0.16);
        }
        &:not(.MenuWrapper--open):hover {
            background: rgba(var(--center-channel-text-rgb), 0.08);
        }
    }
`;

interface Props {
    className?: string;
    channel: Channel;
    member: ChannelMember;
    index: number;
    totalUsers: number;
    editing: boolean;
    actions: {
        openDirectMessage: (user: UserProfile) => void;
    };
}

const Member = ({className, channel, member, index, totalUsers, editing, actions}: Props) => {
    return (
        <div
            className={className}
            data-testid={`memberline-${member.user.id}`}
        >
            <Avatar>
                <ProfilePicture
                    isRHS={true}
                    popoverPlacement='left'
                    size='sm'
                    status={member.status}
                    isBot={member.user.is_bot}
                    userId={member.user.id}
                    username={member.displayName}
                    src={Client4.getProfilePictureUrl(member.user.id, member.user.last_picture_update)}
                />
            </Avatar>
            <UserInfo>
                <DisplayName>
                    {member.displayName}
                    <GuestBadge show={isGuest(member.user.roles)}/>
                </DisplayName>
                {member.displayName === member.user.username ?
                    null :
                    <Username>{'@'}{member.user.username}</Username>
                }
            </UserInfo>
            <RoleChooser
                className={classNames({editing}, 'member-role-chooser')}
                data-testid='rolechooser'
            >
                {member.membership && (
                    <ChannelMembersDropdown
                        channel={channel}
                        user={member.user}
                        channelMember={member.membership}
                        index={index}
                        totalUsers={totalUsers}
                        channelAdminLabel={
                            <FormattedMessage
                                id='channel_members_rhs.member.select_role_channel_admin'
                                defaultMessage='Admin'
                            />
                        }
                        channelMemberLabel={
                            <FormattedMessage
                                id='channel_members_rhs.member.select_role_channel_member'
                                defaultMessage='Member'
                            />
                        }
                        guestLabel={
                            <FormattedMessage
                                id='channel_members_rhs.member.select_role_guest'
                                defaultMessage='Guest'
                            />
                        }
                    />
                )}
            </RoleChooser>
            {!editing && (
                <SendMessage onClick={() => actions.openDirectMessage(member.user)}>
                    <OverlayTrigger
                        delayShow={Constants.OVERLAY_TIME_DELAY}
                        placement='left'
                        overlay={
                            <Tooltip>
                                <FormattedMessage
                                    id='channel_members_rhs.member.send_message'
                                    defaultMessage='Send message'
                                />
                            </Tooltip>
                        }
                    >
                        <i className='icon icon-send'/>
                    </OverlayTrigger>
                </SendMessage>
            )}
        </div>
    );
};

export default styled(Member)`
    display: flex;
    flex-direction: row;
    align-items: center;
    padding: 8px 16px;
    border-radius: 4px;

    &:hover {
        background: rgba(var(--center-channel-text-rgb), 0.08);
        color: rgba(var(--center-channel-text-rgb), 0.56);
        ${() => {
        return css`
            ${SendMessage} {
                display: block;
            }
            `;
    }}
    }

    .MenuWrapper {
        font-weight: 600;
        font-size: 11px;
    }
`;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useRef, useState} from 'react';
import AutoSizer from 'react-virtualized-auto-sizer';
import {VariableSizeList, ListChildComponentProps} from 'react-window';
import InfiniteLoader from 'react-window-infinite-loader';

import {UserProfile} from '@mattermost/types/users';
import {Channel} from '@mattermost/types/channels';

import Member from './member';
import {ChannelMember, ListItem, ListItemType} from './channel_members_rhs';

export interface Props {
    channel: Channel;
    members: ListItem[];
    editing: boolean;
    hasNextPage: boolean;
    isNextPageLoading: boolean;
    searchTerms: string;

    actions: {
        openDirectMessage: (user: UserProfile) => void;
        loadMore: () => void;
    };
}

const MemberList = ({
    hasNextPage,
    isNextPageLoading,
    channel,
    members,
    searchTerms,
    editing,
    actions,
}: Props) => {
    const infiniteLoaderRef = useRef<InfiniteLoader | null>(null);
    const variableSizeListRef = useRef<VariableSizeList | null>(null);
    const [hasMounted, setHasMounted] = useState(false);

    useEffect(() => {
        if (hasMounted) {
            if (infiniteLoaderRef.current) {
                infiniteLoaderRef.current.resetloadMoreItemsCache();
            }
            if (variableSizeListRef.current) {
                variableSizeListRef.current.resetAfterIndex(0);
            }
        }
        setHasMounted(true);
    }, [searchTerms, members.length, hasMounted]);

    const itemCount = hasNextPage ? members.length + 1 : members.length;

    const loadMoreItems = isNextPageLoading ? () => {} : actions.loadMore;

    const isItemLoaded = (index: number) => {
        return !hasNextPage || index < members.length;
    };

    const getItemSize = (index: number) => {
        if (!(index in members)) {
            return 0;
        }

        switch (members[index].type) {
        case ListItemType.FirstSeparator:
            return 28;
        case ListItemType.Separator:
            return 16 + 28;
        }

        return 48;
    };

    const Item = ({index, style}: ListChildComponentProps) => {
        if (isItemLoaded(index)) {
            switch (members[index].type) {
            case ListItemType.Member:
                // eslint-disable-next-line no-case-declarations
                const member = members[index].data as ChannelMember;
                return (
                    <div
                        style={style}
                        key={member.user.id}
                    >
                        <Member
                            channel={channel}
                            index={index}
                            totalUsers={members.length}
                            member={member}
                            editing={editing}
                            actions={{openDirectMessage: actions.openDirectMessage}}
                        />
                    </div>
                );
            case ListItemType.Separator:
            case ListItemType.FirstSeparator:
                return (
                    <div
                        key={index}
                        style={style}
                    >
                        {members[index].data}
                    </div>
                );
            default:
                return null;
            }
        }

        return null;
    };

    if (members.length === 0) {
        return null;
    }

    return (
        <AutoSizer>
            {({height, width}) => (
                <InfiniteLoader
                    ref={infiniteLoaderRef}
                    isItemLoaded={isItemLoaded}
                    itemCount={itemCount}
                    loadMoreItems={loadMoreItems}
                >
                    {({onItemsRendered, ref}) => (

                        <VariableSizeList
                            itemCount={itemCount}
                            onItemsRendered={onItemsRendered}
                            ref={(list) => {
                                ref(list);
                                variableSizeListRef.current = list;
                            }}

                            itemSize={getItemSize}
                            height={height}
                            width={width}
                        >
                            {Item}
                        </VariableSizeList>
                    )}
                </InfiniteLoader>
            )}
        </AutoSizer>
    );
};

export default MemberList;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {IgnoreChannelMentions, NotificationLevels, NotificationSections} from 'utils/constants';
import {t} from 'utils/i18n';

type Props = {
    globalNotifyLevel?: string;
    ignoreChannelMentions?: string;
    memberNotifyLevel: string;
    section: string;
    isCollapsed?: boolean;
}

export default function Describe({section, isCollapsed, memberNotifyLevel, globalNotifyLevel, ignoreChannelMentions}: Props) {
    if (memberNotifyLevel === NotificationLevels.DEFAULT && globalNotifyLevel) {
        t('channel_notifications.levels.default');
        t('channel_notifications.levels.all');
        t('channel_notifications.levels.mention');
        t('channel_notifications.levels.none');
        const levelsFormattedMessageId = 'channel_notifications.levels.' + globalNotifyLevel;
        const notifyLevel = (
            <FormattedMessage
                id={levelsFormattedMessageId}
                defaultMessage={globalNotifyLevel}
            />
        );
        return (
            <FormattedMessage
                id='channel_notifications.globalDefault'
                defaultMessage='Global default ({notifyLevel})'
                values={{notifyLevel}}
            />
        );
    } else if (memberNotifyLevel === NotificationLevels.MENTION && section === NotificationSections.MARK_UNREAD) {
        if (isCollapsed) {
            return (
                <FormattedMessage
                    id='channel_notifications.muteChannel.on.title.collapse'
                    defaultMessage='Mute is enabled. Desktop, email and push notifications will not be sent for this channel.'
                />
            );
        }
        return (
            <FormattedMessage
                id='channel_notifications.muteChannel.on.title'
                defaultMessage='On'
            />
        );
    } else if (
        section === NotificationSections.IGNORE_CHANNEL_MENTIONS &&
        ignoreChannelMentions === IgnoreChannelMentions.ON
    ) {
        return (
            <FormattedMessage
                id='channel_notifications.ignoreChannelMentions.on.title'
                defaultMessage='On'
            />
        );
    } else if (
        section === NotificationSections.IGNORE_CHANNEL_MENTIONS &&
        ignoreChannelMentions === IgnoreChannelMentions.OFF
    ) {
        return (
            <FormattedMessage
                id='channel_notifications.ignoreChannelMentions.off.title'
                defaultMessage='Off'
            />
        );
    } else if (memberNotifyLevel === NotificationLevels.MENTION) {
        return (
            <FormattedMessage
                id='channel_notifications.onlyMentions'
                defaultMessage='Only for mentions'
            />
        );
    } else if (
        (section === NotificationSections.DESKTOP || section === NotificationSections.PUSH) &&
        memberNotifyLevel === NotificationLevels.ALL
    ) {
        return (
            <FormattedMessage
                id='channel_notifications.allActivity'
                defaultMessage='For all activity'
            />
        );
    } else if (
        section === NotificationSections.MARK_UNREAD &&
        memberNotifyLevel === NotificationLevels.ALL
    ) {
        return (
            <FormattedMessage
                id='channel_notifications.muteChannel.off.title'
                defaultMessage='Off'
            />
        );
    }

    return (
        <FormattedMessage
            id='channel_notifications.never'
            defaultMessage='Never'
        />
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {NotificationSections} from 'utils/constants';

type Props = {
    section: string;
}

export default function SectionTitle({section}: Props) {
    if (section === NotificationSections.DESKTOP) {
        return (
            <FormattedMessage
                id='channel_notifications.sendDesktop'
                defaultMessage='Send desktop notifications'
            />
        );
    } else if (section === NotificationSections.PUSH) {
        return (
            <FormattedMessage
                id='channel_notifications.push'
                defaultMessage='Send mobile push notifications'
            />
        );
    } else if (section === NotificationSections.MARK_UNREAD) {
        return (
            <FormattedMessage
                id='channel_notifications.muteChannel.settings'
                defaultMessage='Mute Channel'
            />
        );
    } else if (section === NotificationSections.IGNORE_CHANNEL_MENTIONS) {
        return (
            <FormattedMessage
                id='channel_notifications.ignoreChannelMentions'
                defaultMessage='Ignore mentions for @channel, @here and @all'
            />
        );
    }

    return null;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import SettingItemMin from 'components/setting_item_min';

import Describe from './describe';
import SectionTitle from './section_title';

type Props = {
    ignoreChannelMentions?: string;
    onExpandSection: (section: string) => void;
    globalNotifyLevel?: string;
    memberNotifyLevel: string;
    section: string;
}

export default function CollapseView({onExpandSection, globalNotifyLevel, memberNotifyLevel, section, ignoreChannelMentions}: Props) {
    return (
        <SettingItemMin
            title={<SectionTitle section={section}/>}
            describe={
                <Describe
                    section={section}
                    ignoreChannelMentions={ignoreChannelMentions}
                    memberNotifyLevel={memberNotifyLevel}
                    globalNotifyLevel={globalNotifyLevel}
                    isCollapsed={true}
                />
            }
            updateSection={onExpandSection}
            section={section}
        />
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {NotificationSections} from 'utils/constants';

type Props = {
    section: string;
}

export default function ExtraInfo({section}: Props) {
    switch (section) {
    case NotificationSections.DESKTOP:
        return (
            <span>
                <FormattedMessage
                    id='channel_notifications.override'
                    defaultMessage='Selecting an option other than "Default" will override the global notification settings. Desktop notifications are available on Firefox, Safari, and Chrome.'
                />
            </span>
        );
    case NotificationSections.PUSH:
        return (
            <span>
                <FormattedMessage
                    id='channel_notifications.overridePush'
                    defaultMessage='Selecting an option other than "Global default" will override the global notification settings for mobile push notifications in Settings. Push notifications must be enabled by the System Admin.'
                />
            </span>
        );
    case NotificationSections.MARK_UNREAD:
        return (
            <span>
                <FormattedMessage
                    id='channel_notifications.muteChannel.help'
                    defaultMessage='Muting turns off desktop, email and push notifications for this channel. The channel will not be marked as unread unless you are mentioned.'
                />
            </span>
        );
    case NotificationSections.IGNORE_CHANNEL_MENTIONS:
        return (
            <span>
                <FormattedMessage
                    id='channel_notifications.ignoreChannelMentions.help'
                    defaultMessage='When enabled, @channel, @here and @all will not trigger mentions or mention notifications in this channel.'
                />
            </span>
        );
    default:
        return null;
    }
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ChangeEvent} from 'react';
import {FormattedMessage} from 'react-intl';
import {useSelector} from 'react-redux';

import {isCollapsedThreadsEnabled} from 'mattermost-redux/selectors/entities/preferences';

import {IgnoreChannelMentions, NotificationLevels, NotificationSections} from 'utils/constants';

import SettingItemMax from 'components/setting_item_max';

import Describe from './describe';
import ExtraInfo from './extra_info';
import SectionTitle from './section_title';

type Props = {
    ignoreChannelMentions?: string;
    onChange: (e: ChangeEvent<HTMLInputElement>) => void;
    onChangeThreads?: (e: ChangeEvent<HTMLInputElement>) => void;
    onCollapseSection: (section: string) => void;
    onSubmit: (setting?: string) => void;
    globalNotifyLevel?: string;
    memberNotifyLevel: string;
    memberThreadsNotifyLevel?: string;
    section: string;
    serverError?: string;
}

export default function ExpandView({
    section,
    memberNotifyLevel,
    memberThreadsNotifyLevel,
    globalNotifyLevel,
    onChange,
    onChangeThreads,
    onSubmit,
    serverError,
    onCollapseSection,
    ignoreChannelMentions,
}: Props) {
    const isCRTEnabled = useSelector(isCollapsedThreadsEnabled);

    const inputs = [(
        <div key='channel-notification-level-radio'>
            {(section === NotificationSections.DESKTOP || section === NotificationSections.PUSH) &&
            <fieldset>
                <div className='radio'>
                    <label className=''>
                        <input
                            id='channelNotificationGlobalDefault'
                            name='channelDesktopNotifications'
                            type='radio'
                            value={NotificationLevels.DEFAULT}
                            checked={memberNotifyLevel === NotificationLevels.DEFAULT}
                            onChange={onChange}
                        />
                        <Describe
                            section={section}
                            memberNotifyLevel={NotificationLevels.DEFAULT}
                            globalNotifyLevel={globalNotifyLevel}
                        />
                    </label>
                </div>
                <div className='radio'>
                    <label className=''>
                        <input
                            id='channelNotificationAllActivity'
                            name='channelDesktopNotifications'
                            type='radio'
                            value={NotificationLevels.ALL}
                            checked={memberNotifyLevel === NotificationLevels.ALL}
                            onChange={onChange}
                        />
                        <Describe
                            section={section}
                            memberNotifyLevel={NotificationLevels.ALL}
                        />
                    </label>
                </div>
                <div className='radio'>
                    <label className=''>
                        <input
                            id='channelNotificationMentions'
                            name='channelDesktopNotifications'
                            type='radio'
                            value={NotificationLevels.MENTION}
                            checked={memberNotifyLevel === NotificationLevels.MENTION}
                            onChange={onChange}
                        />
                        <Describe
                            section={section}
                            memberNotifyLevel={NotificationLevels.MENTION}
                        />
                    </label>
                </div>
                <div className='radio'>
                    <label>
                        <input
                            id='channelNotificationNever'
                            name='channelDesktopNotifications'
                            type='radio'
                            value={NotificationLevels.NONE}
                            checked={memberNotifyLevel === NotificationLevels.NONE}
                            onChange={onChange}
                        />
                        <Describe
                            section={section}
                            memberNotifyLevel={NotificationLevels.NONE}
                        />
                    </label>
                </div>
            </fieldset>
            }
            {section === NotificationSections.IGNORE_CHANNEL_MENTIONS &&
                <fieldset>
                    <div className='radio'>
                        <label>
                            <input
                                id='ignoreChannelMentionsOn'
                                name='ignoreChannelMentions'
                                type='radio'
                                value={IgnoreChannelMentions.ON}
                                checked={ignoreChannelMentions === IgnoreChannelMentions.ON}
                                onChange={onChange}
                            />
                            <Describe
                                section={section}
                                ignoreChannelMentions={IgnoreChannelMentions.ON}
                                memberNotifyLevel={memberNotifyLevel}
                                globalNotifyLevel={globalNotifyLevel}
                            />
                        </label>
                    </div>
                    <div className='radio'>
                        <label>
                            <input
                                id='ignoreChannelMentionsOff'
                                name='ignoreChannelMentions'
                                type='radio'
                                value={IgnoreChannelMentions.OFF}
                                checked={ignoreChannelMentions === IgnoreChannelMentions.OFF}
                                onChange={onChange}
                            />
                            <Describe
                                section={section}
                                ignoreChannelMentions={IgnoreChannelMentions.OFF}
                                memberNotifyLevel={memberNotifyLevel}
                                globalNotifyLevel={globalNotifyLevel}
                            />
                        </label>
                    </div>
                </fieldset>
            }
            {section === NotificationSections.MARK_UNREAD &&
            <fieldset>
                <div className='radio'>
                    <label className=''>
                        <input
                            id='channelNotificationUnmute'
                            name='channelNotificationMute'
                            type='radio'
                            value={NotificationLevels.MENTION}
                            checked={memberNotifyLevel === NotificationLevels.MENTION}
                            onChange={onChange}
                        />
                        <Describe
                            section={section}
                            memberNotifyLevel={NotificationLevels.MENTION}
                        />
                    </label>
                </div>
                <div className='radio'>
                    <label className=''>
                        <input
                            id='channelNotificationMute'
                            name='channelNotificationMute'
                            type='radio'
                            value={NotificationLevels.ALL}
                            checked={memberNotifyLevel === NotificationLevels.ALL}
                            onChange={onChange}
                        />
                        <Describe
                            section={section}
                            memberNotifyLevel={NotificationLevels.ALL}
                        />
                    </label>
                </div>
            </fieldset>
            }
            <div className='mt-5'>
                <ExtraInfo section={section}/>
            </div>

            {isCRTEnabled &&
            section === NotificationSections.DESKTOP &&
            memberNotifyLevel === NotificationLevels.MENTION &&
            <>
                <hr/>
                <fieldset>
                    <legend className='form-legend'>
                        <FormattedMessage
                            id='user.settings.notifications.threads.desktop'
                            defaultMessage='Thread reply notifications'
                        />
                    </legend>
                    <div className='checkbox'>
                        <label>
                            <input
                                id='desktopThreadsNotificationAllActivity'
                                type='checkbox'
                                name='desktopThreadsNotificationLevel'
                                checked={memberThreadsNotifyLevel === NotificationLevels.ALL}
                                onChange={onChangeThreads}
                            />
                            <FormattedMessage
                                id='user.settings.notifications.threads.allActivity'
                                defaultMessage={'Notify me about threads I\'m following'}
                            />
                        </label>
                        <br/>
                    </div>
                    <div className='mt-5'>
                        <FormattedMessage
                            id='user.settings.notifications.threads'
                            defaultMessage={'When enabled, any reply to a thread you\'re following will send a desktop notification.'}
                        />
                    </div>
                </fieldset>
            </>
            }
            {isCRTEnabled &&
            section === NotificationSections.PUSH &&
            memberNotifyLevel === NotificationLevels.MENTION &&
            <>
                <hr/>
                <fieldset>
                    <legend className='form-legend'>
                        <FormattedMessage
                            id='user.settings.notifications.threads.push'
                            defaultMessage='Thread reply notifications'
                        />
                    </legend>
                    <div className='checkbox'>
                        <label>
                            <input
                                id='pushThreadsNotificationAllActivity'
                                type='checkbox'
                                name='pushThreadsNotificationLevel'
                                checked={memberThreadsNotifyLevel === NotificationLevels.ALL}
                                onChange={onChangeThreads}
                            />
                            <FormattedMessage
                                id='user.settings.notifications.push_threads.allActivity'
                                defaultMessage={'Notify me about threads I\'m following'}
                            />
                        </label>
                        <br/>
                    </div>
                    <div className='mt-5'>
                        <FormattedMessage
                            id='user.settings.notifications.push_threads'
                            defaultMessage={'When enabled, any reply to a thread you\'re following will send a mobile push notification.'}
                        />
                    </div>
                </fieldset>
            </>
            }
        </div>
    )];

    return (
        <SettingItemMax
            title={<SectionTitle section={section}/>}
            inputs={inputs}
            submit={onSubmit}
            serverError={serverError}
            updateSection={onCollapseSection}
        />
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import PropTypes from 'prop-types';
import React from 'react';

import {NotificationSections, NotificationLevels} from 'utils/constants';

import CollapseView from './collapse_view';
import ExpandView from './expand_view';

export default class NotificationSection extends React.PureComponent {
    static propTypes = {

        /**
         * Notification section
         */
        section: PropTypes.string.isRequired,

        /**
         * Expand if true, else collapse the section
         */
        expand: PropTypes.bool.isRequired,

        /**
         * Member's desktop notification level
         */
        memberNotificationLevel: PropTypes.string.isRequired,

        /**
         * Member's desktop_threads notification level
         */
        memberThreadsNotificationLevel: PropTypes.string,

        /**
         * Ignore channel-wide mentions @channel, @here and @all
         */
        ignoreChannelMentions: PropTypes.string,

        /**
         * User's global notification level
         */
        globalNotificationLevel: PropTypes.string,

        /**
         * onChange handles update of desktop notification level
         */
        onChange: PropTypes.func.isRequired,

        /**
         * onChangeThreads handles update of desktop_threads notification level
         */
        onChangeThreads: PropTypes.func,

        /**
         * Submit function to save notification level
         */
        onSubmit: PropTypes.func.isRequired,

        /**
         * Update function to to expand or collapse a section
         */
        onUpdateSection: PropTypes.func.isRequired,

        /**
         * Error string from the server
         */
        serverError: PropTypes.string,
    }

    handleOnChange = (e) => {
        this.props.onChange(e.target.value);
    }

    handleOnChangeThreads = (e) => {
        const value = e.target.checked ? NotificationLevels.ALL : NotificationLevels.MENTION;

        this.props.onChangeThreads(value);
    }

    handleExpandSection = () => {
        this.props.onUpdateSection(this.props.section);
    }

    handleCollapseSection = () => {
        this.props.onUpdateSection(NotificationSections.NONE);
    }

    render() {
        const {
            expand,
            globalNotificationLevel,
            memberNotificationLevel,
            memberThreadsNotificationLevel,
            ignoreChannelMentions,
            onSubmit,
            section,
            serverError,
        } = this.props;

        if (expand) {
            return (
                <ExpandView
                    section={section}
                    memberNotifyLevel={memberNotificationLevel}
                    memberThreadsNotifyLevel={memberThreadsNotificationLevel}
                    globalNotifyLevel={globalNotificationLevel}
                    ignoreChannelMentions={ignoreChannelMentions}
                    onChange={this.handleOnChange}
                    onChangeThreads={this.handleOnChangeThreads}
                    onSubmit={onSubmit}
                    serverError={serverError}
                    onCollapseSection={this.handleCollapseSection}
                />
            );
        }

        return (
            <CollapseView
                section={section}
                onExpandSection={this.handleExpandSection}
                memberNotifyLevel={memberNotificationLevel}
                globalNotifyLevel={globalNotificationLevel}
                ignoreChannelMentions={ignoreChannelMentions}
            />
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/* eslint-disable react/no-string-refs */

import deepEqual from 'fast-deep-equal';
import React from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

import {isChannelMuted} from 'mattermost-redux/utils/channel_utils';

import {IgnoreChannelMentions, NotificationLevels, NotificationSections} from 'utils/constants';

import NotificationSection from 'components/channel_notifications_modal/components/notification_section.jsx';

import {Channel, ChannelNotifyProps} from '@mattermost/types/channels';
import {UserNotifyProps, UserProfile} from '@mattermost/types/users';

import type {PropsFromRedux} from './index';

type Props = PropsFromRedux & {

    /**
     * Function that is called when the modal has been hidden and should be removed
     */
    onExited: () => void;

    /**
     * Object with info about current channel
     */
    channel: Channel;

    /**
     * Object with info about current user
     */
    currentUser: UserProfile;
};

export type ChannelMemberNotifyProps = Partial<ChannelNotifyProps> & Pick<UserNotifyProps, 'desktop_threads' | 'push_threads'>

type State = {
    show: boolean;
    activeSection: string;
    serverError: string | null;
    desktopNotifyLevel: ChannelNotifyProps['desktop'];
    desktopThreadsNotifyLevel: UserNotifyProps['desktop_threads'];
    markUnreadNotifyLevel: ChannelNotifyProps['mark_unread'];
    pushNotifyLevel: ChannelNotifyProps['push'];
    pushThreadsNotifyLevel: UserNotifyProps['push_threads'];
    ignoreChannelMentions: ChannelNotifyProps['ignore_channel_mentions'];
};

export default class ChannelNotificationsModal extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        const channelNotifyProps = props.channelMember && props.channelMember.notify_props;

        this.state = {
            show: true,
            activeSection: NotificationSections.NONE,
            serverError: null,
            ...this.getStateFromNotifyProps(props.currentUser.notify_props, channelNotifyProps),
        };
    }

    componentDidUpdate(prevProps: Props) {
        const prevChannelNotifyProps = prevProps.channelMember && prevProps.channelMember.notify_props;
        const channelNotifyProps = this.props.channelMember && this.props.channelMember.notify_props;

        if (!deepEqual(channelNotifyProps, prevChannelNotifyProps)) {
            this.resetStateFromNotifyProps(this.props.currentUser.notify_props, channelNotifyProps);
        }
    }

    resetStateFromNotifyProps(currentUserNotifyProps: UserNotifyProps, channelMemberNotifyProps?: Partial<ChannelNotifyProps>) {
        this.setState(this.getStateFromNotifyProps(currentUserNotifyProps, channelMemberNotifyProps));
    }

    getStateFromNotifyProps(currentUserNotifyProps: UserNotifyProps, channelMemberNotifyProps?: ChannelMemberNotifyProps) {
        let ignoreChannelMentionsDefault: ChannelNotifyProps['ignore_channel_mentions'] = IgnoreChannelMentions.OFF;

        if (channelMemberNotifyProps?.mark_unread === NotificationLevels.MENTION || (currentUserNotifyProps.channel && currentUserNotifyProps.channel === 'false')) {
            ignoreChannelMentionsDefault = IgnoreChannelMentions.ON;
        }

        let ignoreChannelMentions = channelMemberNotifyProps?.ignore_channel_mentions;
        if (!ignoreChannelMentions || ignoreChannelMentions === IgnoreChannelMentions.DEFAULT) {
            ignoreChannelMentions = ignoreChannelMentionsDefault;
        }

        return {
            desktopNotifyLevel: channelMemberNotifyProps?.desktop || NotificationLevels.DEFAULT,
            desktopThreadsNotifyLevel: channelMemberNotifyProps?.desktop_threads || NotificationLevels.ALL,
            markUnreadNotifyLevel: channelMemberNotifyProps?.mark_unread || NotificationLevels.ALL,
            pushNotifyLevel: channelMemberNotifyProps?.push || NotificationLevels.DEFAULT,
            pushThreadsNotifyLevel: channelMemberNotifyProps?.push_threads || NotificationLevels.ALL,
            ignoreChannelMentions,
        };
    }

    handleHide = () => this.setState({show: false});

    handleExit = () => {
        this.updateSection(NotificationSections.NONE);
        this.props.onExited();
    }

    updateSection = (section = NotificationSections.NONE) => {
        this.setState({activeSection: section});

        if (section === NotificationSections.NONE) {
            const channelNotifyProps = this.props.channelMember && this.props.channelMember.notify_props;
            this.resetStateFromNotifyProps(this.props.currentUser.notify_props, channelNotifyProps);
        }
    }

    handleUpdateChannelNotifyProps = async (props: Partial<ChannelNotifyProps>) => {
        const {
            actions,
            channel,
            currentUser,
        } = this.props;

        const {error} = await actions.updateChannelNotifyProps(currentUser.id, channel.id, props);
        if (error) {
            this.setState({serverError: error.message});
        } else {
            this.updateSection(NotificationSections.NONE);
        }
    }

    handleSubmitDesktopNotifyLevel = () => {
        const channelNotifyProps = this.props.channelMember && this.props.channelMember.notify_props as ChannelMemberNotifyProps;
        const {desktopNotifyLevel, desktopThreadsNotifyLevel} = this.state;

        if (
            channelNotifyProps?.desktop === desktopNotifyLevel &&
            channelNotifyProps?.desktop_threads === desktopThreadsNotifyLevel
        ) {
            this.updateSection(NotificationSections.NONE);
            return;
        }

        const props = {desktop: desktopNotifyLevel, desktop_threads: desktopThreadsNotifyLevel};

        this.handleUpdateChannelNotifyProps(props);
    }

    handleUpdateDesktopNotifyLevel = (desktopNotifyLevel: ChannelNotifyProps['desktop']) => this.setState({desktopNotifyLevel});

    handleUpdateDesktopThreadsNotifyLevel = (desktopThreadsNotifyLevel: UserNotifyProps['desktop_threads']) => this.setState({desktopThreadsNotifyLevel});

    handleSubmitMarkUnreadLevel = () => {
        const channelNotifyProps = this.props.channelMember && this.props.channelMember.notify_props;
        const {markUnreadNotifyLevel} = this.state;

        if (channelNotifyProps?.mark_unread === markUnreadNotifyLevel) {
            this.updateSection(NotificationSections.NONE);
            return;
        }

        const props = {mark_unread: markUnreadNotifyLevel};
        this.handleUpdateChannelNotifyProps(props);
    }

    handleUpdateMarkUnreadLevel = (markUnreadNotifyLevel: ChannelNotifyProps['mark_unread']) => this.setState({markUnreadNotifyLevel});

    handleSubmitPushNotificationLevel = () => {
        const channelNotifyProps = this.props.channelMember && this.props.channelMember.notify_props as ChannelMemberNotifyProps;
        const {pushNotifyLevel, pushThreadsNotifyLevel} = this.state;

        if (
            channelNotifyProps?.push === pushNotifyLevel &&
            channelNotifyProps?.push_threads === pushThreadsNotifyLevel
        ) {
            this.updateSection(NotificationSections.NONE);
            return;
        }

        const props = {push: pushNotifyLevel, push_threads: pushThreadsNotifyLevel};
        this.handleUpdateChannelNotifyProps(props);
    }

    handleUpdatePushNotificationLevel = (pushNotifyLevel: ChannelNotifyProps['push']) => this.setState({pushNotifyLevel});
    handleUpdatePushThreadsNotificationLevel = (pushThreadsNotifyLevel: UserNotifyProps['push_threads']) => this.setState({pushThreadsNotifyLevel});
    handleUpdateIgnoreChannelMentions = (ignoreChannelMentions: ChannelNotifyProps['ignore_channel_mentions']) => this.setState({ignoreChannelMentions});

    handleSubmitIgnoreChannelMentions = () => {
        const channelNotifyProps = this.props.channelMember && this.props.channelMember.notify_props;
        const {ignoreChannelMentions} = this.state;

        if (channelNotifyProps?.ignore_channel_mentions === ignoreChannelMentions) {
            this.updateSection('');
            return;
        }

        const props = {ignore_channel_mentions: ignoreChannelMentions};
        this.handleUpdateChannelNotifyProps(props);
    }

    render() {
        const {
            activeSection,
            desktopNotifyLevel,
            desktopThreadsNotifyLevel,
            markUnreadNotifyLevel,
            pushNotifyLevel,
            pushThreadsNotifyLevel,
            ignoreChannelMentions,
            serverError,
        } = this.state;

        const {
            channel,
            channelMember,
            currentUser,
            sendPushNotifications,
        } = this.props;

        let serverErrorTag = null;
        if (serverError) {
            serverErrorTag = <div className='form-group has-error'><label className='control-label'>{serverError}</label></div>;
        }

        return (
            <Modal
                dialogClassName='a11y__modal settings-modal settings-modal--tabless'
                show={this.state.show}
                onHide={this.handleHide}
                onExited={this.handleExit}
                role='dialog'
                aria-labelledby='channelNotificationModalLabel'
            >
                <Modal.Header closeButton={true}>
                    <Modal.Title
                        componentClass='h1'
                        id='channelNotificationModalLabel'
                    >
                        <FormattedMessage
                            id='channel_notifications.preferences'
                            defaultMessage='Notification Preferences for '
                        />
                        <span className='name'>{channel.display_name}</span>
                    </Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    <div className='settings-table'>
                        <div className='settings-content'>
                            <div className='user-settings'>
                                <br/>
                                <div className='divider-dark first'/>
                                <NotificationSection
                                    section={NotificationSections.MARK_UNREAD}
                                    expand={activeSection === NotificationSections.MARK_UNREAD}
                                    memberNotificationLevel={markUnreadNotifyLevel}
                                    onChange={this.handleUpdateMarkUnreadLevel}
                                    onSubmit={this.handleSubmitMarkUnreadLevel}
                                    onUpdateSection={this.updateSection}
                                    serverError={serverError}
                                />
                                <div className='divider-light'/>
                                <NotificationSection
                                    section={NotificationSections.IGNORE_CHANNEL_MENTIONS}
                                    expand={activeSection === NotificationSections.IGNORE_CHANNEL_MENTIONS}
                                    memberNotificationLevel={markUnreadNotifyLevel}
                                    ignoreChannelMentions={ignoreChannelMentions}
                                    onChange={this.handleUpdateIgnoreChannelMentions}
                                    onSubmit={this.handleSubmitIgnoreChannelMentions}
                                    onUpdateSection={this.updateSection}
                                    serverError={serverError}
                                />
                                {!isChannelMuted(channelMember) &&
                                <div>
                                    <div className='divider-light'/>
                                    <NotificationSection
                                        section={NotificationSections.DESKTOP}
                                        expand={activeSection === NotificationSections.DESKTOP}
                                        memberNotificationLevel={desktopNotifyLevel}
                                        memberThreadsNotificationLevel={desktopThreadsNotifyLevel}
                                        globalNotificationLevel={currentUser.notify_props ? currentUser.notify_props.desktop : NotificationLevels.ALL}
                                        onChange={this.handleUpdateDesktopNotifyLevel}
                                        onChangeThreads={this.handleUpdateDesktopThreadsNotifyLevel}
                                        onSubmit={this.handleSubmitDesktopNotifyLevel}
                                        onUpdateSection={this.updateSection}
                                        serverError={serverError}
                                    />
                                    <div className='divider-light'/>
                                    {sendPushNotifications &&
                                    <NotificationSection
                                        section={NotificationSections.PUSH}
                                        expand={activeSection === NotificationSections.PUSH}
                                        memberNotificationLevel={pushNotifyLevel}
                                        memberThreadsNotificationLevel={pushThreadsNotifyLevel}
                                        globalNotificationLevel={currentUser.notify_props ? currentUser.notify_props.push : NotificationLevels.ALL}
                                        onChange={this.handleUpdatePushNotificationLevel}
                                        onChangeThreads={this.handleUpdatePushThreadsNotificationLevel}
                                        onSubmit={this.handleSubmitPushNotificationLevel}
                                        onUpdateSection={this.updateSection}
                                        serverError={serverError}
                                    />
                                    }
                                </div>
                                }
                                <div className='divider-dark'/>
                            </div>
                        </div>
                    </div>
                    {serverErrorTag}
                </Modal.Body>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';
import {connect, ConnectedProps} from 'react-redux';

import {updateChannelNotifyProps} from 'mattermost-redux/actions/channels';
import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getMyCurrentChannelMembership} from 'mattermost-redux/selectors/entities/channels';
import {ActionResult} from 'mattermost-redux/types/actions';

import {GlobalState} from 'types/store/index';

import {ChannelNotifyProps} from '@mattermost/types/channels';

import ChannelNotificationsModal from './channel_notifications_modal';

const mapStateToProps = (state: GlobalState) => ({
    channelMember: getMyCurrentChannelMembership(state),
    sendPushNotifications: getConfig(state).SendPushNotifications === 'true',
});

type Actions = {
    updateChannelNotifyProps: (userId: string, channelId: string, props: Partial<ChannelNotifyProps>) => Promise<ActionResult>;
};

const mapDispatchToProps = (dispatch: Dispatch) => ({
    actions: bindActionCreators<ActionCreatorsMapObject, Actions>({
        updateChannelNotifyProps,
    }, dispatch),
});

const connector = connect(mapStateToProps, mapDispatchToProps);

export type PropsFromRedux = ConnectedProps<typeof connector>

export default connector(ChannelNotificationsModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

import Input, {CustomMessageInputType} from 'components/widgets/inputs/input/input';
interface InputBusinessEmailProps {
    email: string;
    handleEmailValues: (e: React.ChangeEvent<HTMLInputElement>) => void;
    customInputLabel: CustomMessageInputType;
}

const InputBusinessEmail = ({
    email,
    handleEmailValues,
    customInputLabel,
}: InputBusinessEmailProps): JSX.Element => {
    const {formatMessage} = useIntl();

    return (
        <Input
            type='email'
            autoComplete='off'
            autoFocus={true}
            required={true}
            value={email}
            name='request-business-email'
            containerClassName='request-business-email-container'
            inputClassName='request-business-email-input'
            label={formatMessage({id: 'start_cloud_trial.modal.enter_trial_email.input.label', defaultMessage: 'Enter business email'})}
            placeholder={formatMessage({id: 'start_cloud_trial.modal.enter_trial_email.input.placeholder', defaultMessage: 'name@companyname.com'})}
            onChange={handleEmailValues}
            customMessage={customInputLabel}
        />
    );
};

export default InputBusinessEmail;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useEffect, useState} from 'react';
import {useDispatch} from 'react-redux';

import {FormattedMessage, useIntl} from 'react-intl';

import {debounce} from 'lodash';

import {DispatchFunc} from 'mattermost-redux/types/actions';

import {trackEvent} from 'actions/telemetry_actions';
import {closeModal} from 'actions/views/modals';
import {validateBusinessEmail} from 'actions/cloud';

import {ItemStatus, TELEMETRY_CATEGORIES, ModalIdentifiers} from 'utils/constants';

import GenericModal from 'components/generic_modal';
import {CustomMessageInputType} from 'components/widgets/inputs/input/input';

import {isEmail} from 'mattermost-redux/utils/helpers';

import StartCloudTrialBtn from './cloud_start_trial_btn';
import InputBusinessEmail from './input_business_email';

import './request_business_email_modal.scss';

type Props = {
    onClose?: () => void;
    onExited: () => void;
}

const RequestBusinessEmailModal = (
    {
        onClose,
        onExited,
    }: Props): JSX.Element | null => {
    const {formatMessage} = useIntl();
    const dispatch = useDispatch<DispatchFunc>();
    const [email, setEmail] = useState<string>('');
    const [customInputLabel, setCustomInputLabel] = useState<CustomMessageInputType>(null);
    const [trialBtnDisabled, setTrialBtnDisabled] = useState<boolean>(true);

    useEffect(() => {
        trackEvent(
            TELEMETRY_CATEGORIES.REQUEST_BUSINESS_EMAIL,
            'request_business_email',
        );
    }, []);

    const handleOnClose = useCallback(() => {
        if (onClose) {
            onClose();
        }

        onExited();
    }, [onClose, onExited]);

    const handleEmailValues = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
        const email = e.target.value;
        setEmail(email.trim().toLowerCase());

        validateEmail(email);
    }, []);

    // eslint-disable-next-line react-hooks/exhaustive-deps
    const validateEmail = useCallback(debounce(async (email: string) => {
        // no value set, no validation and clean the custom input label
        if (!email) {
            setTrialBtnDisabled(true);
            setCustomInputLabel(null);
            return;
        }

        // function isEmail aready handle empty / null value
        if (!isEmail(email)) {
            const errMsg = formatMessage({id: 'request_business_email_modal.invalidEmail', defaultMessage: 'This doesn\'t look like a valid email'});
            setCustomInputLabel({type: ItemStatus.WARNING, value: errMsg});
            setTrialBtnDisabled(true);
            return;
        }

        // go and validate the email against the validateBusinessEmail endpoint
        const isValidBusinessEmail = await validateBusinessEmail(email)();
        if (!isValidBusinessEmail) {
            const errMsg = formatMessage({id: 'request_business_email_modal.not_business_email', defaultMessage: 'This doesn\'t look like a business email'});
            setCustomInputLabel({type: ItemStatus.ERROR, value: errMsg});
            setTrialBtnDisabled(true);
            return;
        }

        // if it is a valid business email, proceed, enable the start trial button and notify the user about the email is valid
        const okMsg = formatMessage({id: 'request_business_email_modal.valid_business_email', defaultMessage: 'This is a valid email'});
        setCustomInputLabel({type: ItemStatus.SUCCESS, value: okMsg});
        setTrialBtnDisabled(false);
    }, 250), []);

    // this function will be executed after successfull trial request, closing this request business email modal
    const closeMeAfterSuccessTrialReq = async () => {
        await dispatch(closeModal(ModalIdentifiers.REQUEST_BUSINESS_EMAIL_MODAL));
    };

    return (
        <GenericModal
            className='RequestBusinessEmailModal'
            id='RequestBusinessEmailModal'
            onExited={handleOnClose}
        >
            <div className='start-trial-email-title'>
                <FormattedMessage
                    id='start_cloud_trial.modal.enter_trial_email.title'
                    defaultMessage='Enter an email to start your trial'
                />
            </div>
            <div className='start-trial-email-description'>
                <FormattedMessage
                    id='start_cloud_trial.modal.enter_trial_email.description'
                    defaultMessage='Start a trial and enter a business email to get started. '
                />
            </div>
            <div className='start-trial-email-input'>
                <InputBusinessEmail
                    email={email}
                    handleEmailValues={handleEmailValues}
                    customInputLabel={customInputLabel}
                />
            </div>
            <div className='start-trial-email-disclaimer'>
                <FormattedMessage
                    id='request_business_email.start_trial.modal.disclaimer'
                    defaultMessage='By selecting <highlight>Start trial</highlight>, I agree to the <linkEvaluation>Mattermost Software Evaluation Agreement</linkEvaluation>, <linkPrivacy>privacy policy</linkPrivacy> and receiving product emails.'
                    values={{
                        highlight: (msg: React.ReactNode) => (
                            <strong>
                                {msg}
                            </strong>
                        ),
                        linkEvaluation: (msg: React.ReactNode) => (
                            <a
                                href='https://mattermost.com/software-evaluation-agreement'
                                target='_blank'
                                rel='noreferrer'
                            >
                                {msg}
                            </a>
                        ),
                        linkPrivacy: (msg: React.ReactNode) => (
                            <a
                                href='https://mattermost.com/privacy-policy/'
                                target='_blank'
                                rel='noreferrer'
                            >
                                {msg}
                            </a>
                        ),
                    }}
                />
            </div>
            <div className='start-trial-button'>
                <StartCloudTrialBtn
                    message={formatMessage({id: 'cloud.startTrial.modal.btn', defaultMessage: 'Start trial'})}
                    telemetryId='request_business_email_modal'
                    disabled={trialBtnDisabled}
                    email={email}
                    afterTrialRequest={closeMeAfterSuccessTrialReq}
                />
            </div>
        </GenericModal>
    );
};

export default RequestBusinessEmailModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useState} from 'react';
import {useIntl} from 'react-intl';
import {useDispatch} from 'react-redux';

import {DispatchFunc} from 'mattermost-redux/types/actions';

import useGetSubscription from 'components/common/hooks/useGetSubscription';

import {requestCloudTrial, validateWorkspaceBusinessEmail, getCloudLimits} from 'actions/cloud';
import {trackEvent} from 'actions/telemetry_actions';
import {openModal, closeModal} from 'actions/views/modals';

import TrialBenefitsModal from 'components/trial_benefits_modal/trial_benefits_modal';

import {ModalIdentifiers, TELEMETRY_CATEGORIES} from 'utils/constants';

import RequestBusinessEmailModal from './request_business_email_modal';
import './cloud_start_trial_btn.scss';

export type CloudStartTrialBtnProps = {
    message: string;
    telemetryId: string;
    onClick?: () => void;
    extraClass?: string;
    afterTrialRequest?: () => void;
    email?: string;
    disabled?: boolean;
};

enum TrialLoadStatus {
    NotStarted = 'NOT_STARTED',
    Started = 'STARTED',
    Success = 'SUCCESS',
    Failed = 'FAILED',
    Embargoed = 'EMBARGOED',
}

const TIME_UNTIL_CACHE_PURGE_GUESS = 5000;

const CloudStartTrialButton = ({
    message,
    telemetryId,
    extraClass,
    onClick,
    afterTrialRequest,
    email,
    disabled = false,
}: CloudStartTrialBtnProps) => {
    const {formatMessage} = useIntl();
    const dispatch = useDispatch<DispatchFunc>();
    const subscription = useGetSubscription();
    const [openBusinessEmailModal, setOpenBusinessEmailModal] = useState(false);
    const [status, setLoadStatus] = useState(TrialLoadStatus.NotStarted);

    const validateBusinessEmailOnLoad = async () => {
        const isValidBusinessEmail = await validateWorkspaceBusinessEmail()();
        if (!isValidBusinessEmail) {
            setOpenBusinessEmailModal(true);
        }
    };

    useEffect(() => {
        validateBusinessEmailOnLoad();
    }, []);

    const requestStartTrial = async (): Promise<TrialLoadStatus> => {
        setLoadStatus(TrialLoadStatus.Started);

        // email is set ONLY from the instance of this component created in the requestBusinessEmail modal.
        // So the flow is the following: If the email of the admin and the
        // email of the CWS customer are not valid, the requestBusinessModal is shown and that component will
        // create this StartCloudTrialBtn passing the email as Truthy, so the requetTrial flow continues normally
        if (openBusinessEmailModal && !email) {
            trackEvent(
                TELEMETRY_CATEGORIES.CLOUD_START_TRIAL_BUTTON,
                'trial_request_attempt_with_no_valid_business_email',
            );
            await dispatch(closeModal(ModalIdentifiers.LEARN_MORE_TRIAL_MODAL));
            openRequestBusinessEmailModal();
            setLoadStatus(TrialLoadStatus.Failed);
            return TrialLoadStatus.Failed;
        }

        const subscriptionUpdated = await dispatch(requestCloudTrial('start_cloud_trial_btn', subscription?.id as string, (email || '')));
        if (!subscriptionUpdated) {
            setLoadStatus(TrialLoadStatus.Failed);
            return TrialLoadStatus.Failed;
        }

        function ensureUpdatedData() {
            // Depending on timing of pods rolling, the webhook may still not get sent.
            // Re-request limits as a just-in-case, but only well after any
            // pods still alive should have either purged cache,
            // updated limits, or be brand new pods that won't be holding onto stale limits
            // We don't need to re-request subscription: the updated value is sent in the
            // request cloud trial response.
            // We don't need to request license: its update process is independent
            // from subscription/limit changes and always happens after pods roll.
            dispatch(getCloudLimits());
        }

        setTimeout(ensureUpdatedData, TIME_UNTIL_CACHE_PURGE_GUESS);
        if (afterTrialRequest) {
            afterTrialRequest();
        }
        setLoadStatus(TrialLoadStatus.Success);
        return TrialLoadStatus.Success;
    };

    const openTrialBenefitsModal = async (status: TrialLoadStatus) => {
        // Only open the benefits modal if the trial request succeeded
        if (status !== TrialLoadStatus.Success) {
            return;
        }
        await dispatch(openModal({
            modalId: ModalIdentifiers.TRIAL_BENEFITS_MODAL,
            dialogType: TrialBenefitsModal,
            dialogProps: {trialJustStarted: true},
        }));
    };

    const openRequestBusinessEmailModal = () => {
        dispatch(openModal({
            modalId: ModalIdentifiers.REQUEST_BUSINESS_EMAIL_MODAL,
            dialogType: RequestBusinessEmailModal,
        }));
    };

    const btnText = (status: TrialLoadStatus): string => {
        switch (status) {
        case TrialLoadStatus.Started:
            return formatMessage({id: 'start_cloud_trial.modal.gettingTrial', defaultMessage: 'Getting Trial...'});
        case TrialLoadStatus.Success:
            return formatMessage({id: 'start_cloud_trial.modal.loaded', defaultMessage: 'Loaded!'});
        case TrialLoadStatus.Failed:
            return formatMessage({id: 'start_cloud_trial.modal.failed', defaultMessage: 'Failed'});
        case TrialLoadStatus.Embargoed:
            return formatMessage({id: 'admin.license.trial-request.embargoed'});
        default:
            return message;
        }
    };
    const startCloudTrial = async () => {
        if (status !== TrialLoadStatus.NotStarted) {
            return;
        }
        const updatedStatus = await requestStartTrial();
        if (onClick && updatedStatus === TrialLoadStatus.Success) {
            onClick();
        } else {
            await openTrialBenefitsModal(updatedStatus);
        }
        trackEvent(
            TELEMETRY_CATEGORIES.CLOUD_START_TRIAL_BUTTON,
            telemetryId,
        );
    };

    return (
        <button
            id='start_cloud_trial_btn'
            className={`CloudStartTrialButton ${extraClass}`}
            onClick={startCloudTrial}
            disabled={disabled || status === TrialLoadStatus.Failed}
        >
            {btnText(status)}
        </button>
    );
};

export default CloudStartTrialButton;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {useSelector} from 'react-redux';

import {getTheme} from 'mattermost-redux/selectors/entities/preferences';

import {Message} from 'utils/i18n';

import CompassThemeProvider from 'components/compass_theme_provider/compass_theme_provider';
import GenericModal from 'components/generic_modal';
import useGetLimits from 'components/common/hooks/useGetLimits';
import useGetUsage from 'components/common/hooks/useGetUsage';

import {Limits} from '@mattermost/types/cloud';

import WorkspaceLimitsPanel, {messageToElement} from './workspace_limits_panel';

import './index.scss';

interface ModalAction {
    message: Message | React.ReactNode;
    onClick?: () => void;
}
export interface Props {
    title: Message | React.ReactNode;
    description?: Message | React.ReactNode;
    primaryAction?: ModalAction;
    secondaryAction?: ModalAction;
    onClose: () => void;
    ownLimits?: Limits;
    backdrop?: boolean;
    backdropClassName?: string;
    className?: string;

    // e.g. in contexts where the CompassThemeProvider isn't already applied, like the system console
    needsTheme?: boolean;
}

export default function CloudUsageModal(props: Props) {
    const [limits] = useGetLimits();
    const usage = useGetUsage();
    const theme = useSelector(getTheme);

    const modal = (
        <GenericModal
            handleCancel={props.onClose}
            compassDesign={true}
            onExited={props.onClose}
            modalHeaderText={messageToElement(props.title)}
            cancelButtonText={props.secondaryAction && messageToElement(props.secondaryAction.message)}
            handleConfirm={props.primaryAction?.onClick}
            confirmButtonText={props.primaryAction && messageToElement(props.primaryAction.message)}
            className='CloudUsageModal'
            backdrop={props.backdrop}
            backdropClassName={props.backdropClassName}
        >
            <>
                {React.isValidElement(props.description) ? props.description : <p className='CloudUsageModal__description'>
                    {props.description && messageToElement(props.description)}
                </p>}
                <WorkspaceLimitsPanel
                    showIcons={true}
                    limits={props.ownLimits || limits}
                    usage={usage}
                />
            </>
        </GenericModal>
    );

    if (!props.needsTheme) {
        return modal;
    }

    return (
        <CompassThemeProvider theme={theme}>
            {modal}
        </CompassThemeProvider>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import UsagePercentBar from 'components/common/usage_percent_bar';

import './limit_line.scss';

interface Props {
    icon: string;
    limitName: React.ReactNode;
    limitStatus: React.ReactNode;
    percent: number;
    showIcons?: boolean;
}

export default function LimitLine(props: Props) {
    return (
        <div className='WorkspaceLimitLine'>
            {props.showIcons && <i className={`WorkspaceLimitLine__icon ${props.icon}`}/>}
            <div className='WorkspaceLimitLine__bar'>
                <div className='WorkspaceLimitLine__bar-label'>{props.limitName}</div>
                <UsagePercentBar
                    barWidth='auto'
                    percent={Math.floor(props.percent * 100)}
                />
            </div>
            <div className='WorkspaceLimitLine__text-status'>
                {props.limitStatus}
            </div>
        </div>
    );
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage, useIntl} from 'react-intl';

import {CloudUsage, Limits} from '@mattermost/types/cloud';
import {asGBString, inK} from 'utils/limits';

import {Message} from 'utils/i18n';

import LimitLine from './limit_line';

export function messageToElement(x: Message | React.ReactNode): React.ReactNode {
    if (Object.prototype.hasOwnProperty.call(x, 'defaultMessage')) {
        return (
            <FormattedMessage
                id={(x as Message).id}
                defaultMessage={(x as Message).defaultMessage}
                values={(x as Message).values}
            />
        );
    }

    return x;
}

interface Props {
    limits: Limits;
    usage: CloudUsage;
    showIcons?: boolean;
}

export default function WorkspaceLimitsPanel(props: Props) {
    const intl = useIntl();
    return (
        <div>
            <LimitLine
                icon='icon-message-text-outline'
                showIcons={props.showIcons}
                percent={props.usage.messages.history / (props.limits?.messages?.history || Number.MAX_VALUE)}
                limitName={(
                    <FormattedMessage
                        id='workspace_limits.message_history.short'
                        defaultMessage='Messages'
                    />
                )}
                limitStatus={(
                    <FormattedMessage
                        id='workspace_limits.message_history.short.usage'
                        defaultMessage='{actual} / {limit}'
                        values={{
                            actual: inK(props.usage.messages.history),
                            limit: inK(props.limits?.messages?.history || 0),
                        }}
                    />
                )}
            />
            <LimitLine
                icon='icon-folder-outline'
                showIcons={props.showIcons}
                percent={props.usage.files.totalStorage / (props.limits?.files?.total_storage || Number.MAX_VALUE)}
                limitName={(
                    <FormattedMessage
                        id='workspace_limits.file_storage.short'
                        defaultMessage='Files'
                    />
                )}
                limitStatus={(
                    <FormattedMessage
                        id='workspace_limits.file_storage.short.usage'
                        defaultMessage='{actual} / {limit}'
                        values={{
                            actual: asGBString(props.usage.files.totalStorage, intl.formatNumber),
                            limit: asGBString(props.limits?.files?.total_storage || 0, intl.formatNumber),
                        }}
                    />
                )}
            />
            <LimitLine
                icon='icon-product-boards'
                showIcons={props.showIcons}
                percent={props.usage.boards.cards / (props.limits?.boards?.cards || Number.MAX_VALUE)}
                limitName={(
                    <FormattedMessage
                        id='workspace_limits.boards_cards.short'
                        defaultMessage='Board Cards'
                    />
                )}
                limitStatus={(
                    <FormattedMessage
                        id='workspace_limits.boards_cards.usage.short'
                        defaultMessage='{actual} / {limit} Cards'
                        values={{
                            actual: props.usage.boards.cards,
                            limit: props.limits?.boards?.cards || 0,
                        }}
                    />
                )}
            />
        </div>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useState, useRef, CSSProperties} from 'react';
import {Transition} from 'react-transition-group';
import scrollIntoView from 'smooth-scroll-into-view-if-needed';

import './auto_height_switcher.scss';

export enum AutoHeightSlots {
    SLOT1 = 1,
    SLOT2 = 2,
}

type AutoHeightProps = {
    showSlot: AutoHeightSlots;
    duration?: number;
    shouldScrollIntoView?: boolean;
    slot1: React.ReactNode | React.ReactNode[];
    slot2: React.ReactNode | React.ReactNode[];
    onTransitionEnd?: (node?: HTMLElement) => void;
};

const AutoHeightSwitcher = ({showSlot, slot1, slot2, onTransitionEnd, duration = 250, shouldScrollIntoView = false}: AutoHeightProps) => {
    const wrapperRef = useRef<HTMLDivElement>(null);
    const childRef = useRef<HTMLDivElement>(null);
    const prevSlot = useRef<AutoHeightProps['showSlot']>(showSlot);
    const prevHeight = useRef<number|null>(null);
    const [animate, setAnimate] = useState<boolean>(false);
    const [height, setHeight] = useState<string | number>('auto');
    const [overflow, setOverflow] = useState<string>('visible');
    const [child, setChild] = useState(showSlot === AutoHeightSlots.SLOT1 ? slot1 : slot2);

    useEffect(() => {
        if (prevSlot.current === showSlot) {
            // slot that is currently in view gets updated
            setChild(showSlot === AutoHeightSlots.SLOT1 ? slot1 : slot2);
        } else {
            // switch slots using height animation
            prevSlot.current = showSlot;
            setAnimate(true);
        }
    }, [showSlot, slot1, slot2]);

    useEffect(() => {
        if (shouldScrollIntoView) {
            const timeout = setTimeout(() => scrollIntoView(wrapperRef.current!, {
                behavior: 'smooth',
                scrollMode: 'if-needed',
                block: 'center',
            }), 200);
            return () => clearTimeout(timeout);
        }
        return () => {};
    }, [shouldScrollIntoView]);

    // necessary to override this on element-level since a rule from _post.scss has a higher specificity
    // and would override the display property
    const fixedStyles: CSSProperties = {
        transitionProperty: 'height',
        transitionDuration: `${duration}ms`,
        transitionTimingFunction: 'ease',
    };

    /**
     * the lifecycle of this transition-component is divided in 3 different stages:
     *     1. onEnter:
     *        we calculate the current height from the wrapperRef and set a fixed height
     *        for it to make the overflowing possible. Last action taken is to replace
     *        the current children with the new ones.
     *     2. onEntering:
     *        when the new children are rendered we can get the new offsetHeight from
     *        the childRef and set it as the height for the wrapper. A change in height
     *        will then trigger a transition via CSS.
     *     3. onEntered:
     *        when transitions are finished (this is checked within the addEndListener prop)
     *        we reset our component so that it behaves like before the switch-transition
     */
    return (
        <Transition
            in={animate}
            timeout={duration}
            onEnter={() => {
                setHeight(prevHeight.current ?? childRef.current!.offsetHeight);
                setOverflow('hidden');
                setChild(showSlot === AutoHeightSlots.SLOT1 ? slot1 : slot2);
            }}
            onEntering={() => {
                setHeight(childRef.current!.offsetHeight);
            }}
            onEntered={(node: HTMLElement) => {
                prevHeight.current = childRef.current!.offsetHeight;
                setHeight('auto');
                setOverflow('visible');
                setAnimate(false);
                onTransitionEnd?.(node);
            }}
        >
            <div
                className='AutoHeight'
                ref={wrapperRef}
                style={{...fixedStyles, height, overflow}}
            >
                <div ref={childRef}>
                    {child}
                </div>
            </div>
        </Transition>
    );
};

export default AutoHeightSwitcher;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useState} from 'react';

import CarouselButton, {BtnStyle} from './carousel_button';
import './carousel.scss';

type Props = {
    dataSlides: React.ReactNode[];
    id: string;
    infiniteSlide: boolean;
    onNextSlideClick?: (slideIndex: number) => void;
    onPrevSlideClick?: (slideIndex: number) => void;
    disableNextButton?: boolean;
    btnsStyle?: BtnStyle; // chevron or bottom buttons
    actionButton?: JSX.Element;
}
const Carousel = ({
    dataSlides,
    id,
    infiniteSlide,
    onNextSlideClick,
    onPrevSlideClick,
    disableNextButton,
    btnsStyle = BtnStyle.BUTTON,
    actionButton,
}: Props): JSX.Element | null => {
    const [slideIndex, setSlideIndex] = useState(1);
    const [prevButtonDisabled, setPrevButtonDisabled] = useState(!infiniteSlide);
    const [nextButtonDisabled, setNextButtonDisabled] = useState(false);

    const nextSlide = () => {
        setPrevButtonDisabled(false);

        const isLastIndex = slideIndex === dataSlides.length;
        const newSlideIndex = isLastIndex && infiniteSlide ? 1 : (!isLastIndex && slideIndex + 1) || undefined;

        if (newSlideIndex) {
            setSlideIndex(newSlideIndex);

            if (onNextSlideClick) {
                onNextSlideClick(newSlideIndex);
            }
        }
    };

    const prevSlide = () => {
        setNextButtonDisabled(false);

        const isFirstSlide = slideIndex === 1;
        const newSlideIndex = isFirstSlide && infiniteSlide ? dataSlides.length : (!isFirstSlide && slideIndex - 1) || undefined;

        if (newSlideIndex) {
            setSlideIndex(newSlideIndex);

            if (onPrevSlideClick) {
                onPrevSlideClick(newSlideIndex);
            }
        }
    };

    useEffect(() => {
        if (slideIndex === dataSlides.length) {
            if (!infiniteSlide) {
                setNextButtonDisabled(true);
            }
        } else if (slideIndex === 1) {
            if (!infiniteSlide) {
                setPrevButtonDisabled(true);
            }
        }
    }, [slideIndex]);

    const moveDot = (index: number) => {
        setSlideIndex(index);
    };

    return (
        <div
            className='container-slider'
            id={id}
        >
            {btnsStyle === BtnStyle.CHEVRON && <>
                <CarouselButton
                    moveSlide={prevSlide}
                    direction={'prev'}
                    disabled={prevButtonDisabled}
                    btnsStyle={BtnStyle.CHEVRON}
                />
                <CarouselButton
                    moveSlide={nextSlide}
                    direction={'next'}
                    disabled={nextButtonDisabled || disableNextButton}
                    btnsStyle={BtnStyle.CHEVRON}
                />
            </>}
            {dataSlides.map((obj: any, index: number) => {
                return (
                    <div
                        key={`${index.toString()}`}
                        className={slideIndex === index + 1 ? 'slide active-anim' : 'slide'}
                    >
                        {obj}
                    </div>
                );
            })}

            <div className='container-footer'>
                <div className='container-dots'>
                    {dataSlides.map((item, index) => (
                        <div
                            key={index.toString()}
                            onClick={() => moveDot(index + 1)}
                            className={slideIndex === index + 1 ? 'dot active' : 'dot'}
                        />
                    ))}
                </div>
                {btnsStyle === BtnStyle.BUTTON && <div className=' buttons container-buttons'>
                    <CarouselButton
                        moveSlide={prevSlide}
                        direction={'prev'}
                        disabled={prevButtonDisabled}
                    />
                    <CarouselButton
                        moveSlide={nextSlide}
                        direction={'next'}
                        disabled={nextButtonDisabled || disableNextButton}
                    />
                </div>}
                {actionButton && <div className=' buttons container-buttons'>
                    {actionButton}
                </div>}
            </div>
        </div>
    );
};

export default Carousel;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {useIntl} from 'react-intl';

import './carousel.scss';

export enum BtnStyle {
    BUTTON = 'button',
    CHEVRON = 'chevron',
}

type Props = {
    direction: string;
    moveSlide: () => void;
    btnsStyle?: BtnStyle;
    disabled?: boolean;
}

enum Destination {
    NEXT = 'next',
    PREV = 'prev',
}

const CarouselButton = ({direction, moveSlide, disabled, btnsStyle = BtnStyle.BUTTON}: Props): JSX.Element => {
    const {formatMessage} = useIntl();

    const handleMoveSlide = () => {
        if (disabled) {
            return;
        }
        moveSlide();
    };

    const text = direction === Destination.NEXT ?
        formatMessage({id: 'carousel.nextButton', defaultMessage: 'Next'}) :
        formatMessage({id: 'carousel.PreviousButton', defaultMessage: 'Previous'});

    const disabledClass = disabled ? ' disabled' : '';
    const orientation = direction === Destination.NEXT ? 'right' : 'left';

    if (btnsStyle === BtnStyle.CHEVRON) {
        return (
            <div
                className={`chevron-button chevron-${orientation} ${direction}-btn` + disabledClass}
                onClick={handleMoveSlide}
            >
                <i className={`icon-chevron-${orientation}`}/>
            </div>
        );
    }
    return (
        <a
            onClick={handleMoveSlide}
            className={`${direction === Destination.NEXT ? ' next next-btn' : ' prev previous-btn'}` + disabledClass}
        >
            {direction === Destination.PREV ? <i className='icon-arrow-back-ios'/> : null}
            {text}
            {direction === Destination.NEXT ? <i className='icon-arrow-forward-ios'/> : null}
        </a>
    );
};

export default CarouselButton;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';
import styled from 'styled-components';

import RenderEmoji from 'components/emoji/render_emoji';

// This component is a temporary placeholder for use until the authoritative `compass-components` Chip is implemented.

type Props = {
    onClick?: () => void;
    id?: string;
    defaultMessage?: string;
    values?: Record<string, any>;
    className?: string;

    // for the "other" option unlike the others, e.g. free-form response
    otherOption?: boolean;
    leadingIcon?: string;
    additionalMarkup?: React.ReactNode | React.ReactNodeArray;
}

const StyledChip = styled.button<{ otherOption?: boolean }>`
    display: flex;
    flex-shrink: 0;
    align-items: center;
    box-shadow: var(--elevation-1);
    font-weight: bold;

    padding: 6px 12px;
    margin-right: 12px;
    margin-bottom: 12px;

    &:last-child {
        margin-right: 0;
    }

    border: 1px solid rgba(var(--center-channel-color-rgb), 0.08);
    border-radius: 16px;

    background-color: var(--center-channel-bg);
    ${(p) => (p.otherOption ? 'color: rgba(var(--center-channel-color-rgb), 0.72);' : '')}

    &:hover {
        background-color: rgba(var(--center-channel-color-rgb), 0.08);
    }

    &:active {
        background-color: rgba(var(--mention-highlight-link-rgb), 0.08);
    }
`;

export default class Chip extends React.PureComponent<Props> {
    onClick = (e: React.MouseEvent) => {
        e.preventDefault();
        this.props.onClick?.();
    }

    render() {
        return (
            <StyledChip
                onClick={this.onClick}
                otherOption={this.props.otherOption}
                className={this.props.className || ''}
            >
                {this.props.leadingIcon && (
                    <RenderEmoji
                        emojiName={this.props.leadingIcon}
                        emojiStyle={{marginRight: '11px'}}
                    />
                )}
                {(this.props.id && this.props.defaultMessage && this.props.values) && (
                    <FormattedMessage
                        id={this.props.id}
                        defaultMessage={this.props.defaultMessage}
                        values={this.props.values}
                    />
                )}
                {this.props.additionalMarkup}
            </StyledChip>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function ReplyIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='16px'
                height='14px'
                viewBox='0 0 16 14'
                enableBackground='new -158 242 18 18'
                role='img'
                aria-label={formatMessage({id: 'generic_icons.reply', defaultMessage: 'Reply Icon'})}
            >
                <path d='M5.2 3.88001V5.48001L6.72 5.56001C8.85333 5.63467 10.64 6.51467 12.08 8.20001C11.312 7.94401 10.448 7.76801 9.488 7.67201C8.76267 7.59734 7.84 7.56001 6.72 7.56001H5.12V9.72001L2.16 6.76001L5.2 3.88001ZM6.64 0.600005C6.48 0.600005 6.34667 0.626672 6.24 0.680005L0.08 6.44001C0.048 6.47201 0.0266667 6.50934 0.016 6.55201C0.00533333 6.59467 0 6.66934 0 6.77601C0 6.87201 0.0266667 6.94667 0.08 7.00001L6.24 12.92C6.29333 12.9733 6.4 13 6.56 13C6.61333 12.9467 6.65067 12.8987 6.672 12.856C6.704 12.792 6.72 12.7067 6.72 12.6V9.08001C8.17067 9.08001 9.328 9.16001 10.192 9.32001C11.312 9.53334 12.272 9.91734 13.072 10.472C13.9573 11.0907 14.72 11.9867 15.36 13.16C15.4667 13.2667 15.5467 13.32 15.6 13.32H15.68C15.7653 13.2773 15.824 13.2187 15.856 13.144C15.888 13.0693 15.8827 12.9947 15.84 12.92C15.872 12.8133 15.8453 12.5413 15.76 12.104C15.6533 11.5707 15.4827 11.0107 15.248 10.424C14.96 9.66667 14.5973 8.95201 14.16 8.28001C13.2853 6.88267 12.2187 5.81067 10.96 5.06401C9.70133 4.30667 8.288 3.88534 6.72 3.80001V0.840006C6.752 0.765339 6.75733 0.706672 6.736 0.664005C6.71467 0.621339 6.68267 0.600005 6.64 0.600005Z'/>
            </svg>
        </span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {localizeMessage} from 'utils/utils';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import ReplyIcon from 'components/widgets/icons/reply_icon';

type Props = {
    location: 'CENTER' | 'SEARCH';
    handleCommentClick: React.EventHandler<React.MouseEvent>;
    searchStyle: string;
    commentCount: number;
    postId?: string;
    extraClass: string;
}

export default class CommentIcon extends React.PureComponent<Props> {
    public static defaultProps: Partial<Props> = {
        location: 'CENTER',
        searchStyle: '',
        commentCount: 0,
        extraClass: '',
    }

    public render(): JSX.Element {
        let commentCountSpan: JSX.Element | null = null;
        let iconStyle = 'post-menu__item post-menu__item--wide';
        if (this.props.commentCount > 0) {
            iconStyle += ' post-menu__item--show';
            commentCountSpan = (
                <span className='post-menu__comment-count'>
                    {this.props.commentCount}
                </span>
            );
        } else if (this.props.searchStyle !== '') {
            iconStyle = iconStyle + ' ' + this.props.searchStyle;
        }

        const tooltip = (
            <Tooltip
                id='comment-icon-tooltip'
                className='hidden-xs'
            >
                <FormattedMessage
                    id='post_info.comment_icon.tooltip.reply'
                    defaultMessage='Reply'
                />
            </Tooltip>
        );

        return (
            <OverlayTrigger
                delayShow={500}
                placement='top'
                overlay={tooltip}
            >
                <button
                    id={`${this.props.location}_commentIcon_${this.props.postId}`}
                    aria-label={localizeMessage('post_info.comment_icon.tooltip.reply', 'Reply').toLowerCase()}
                    className={iconStyle + ' ' + this.props.extraClass}
                    onClick={this.props.handleCommentClick}
                >
                    <span className='d-flex align-items-center'>
                        <ReplyIcon className='icon icon--small'/>
                        {commentCountSpan}
                    </span>
                </button>
            </OverlayTrigger>
        );
    }
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ComponentType} from 'react';

import {isEmpty} from 'lodash';

import {Subscription} from '@mattermost/types/cloud';

interface Actions {
    getCloudSubscription?: () => void;
}

interface UsedHocProps {
    subscription?: Subscription;
    isCloud: boolean;
    actions: Actions;
    userIsAdmin?: boolean;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function withGetCloudSubscription<P>(WrappedComponent: ComponentType<P>): ComponentType<any> {
    return class extends React.Component<P & UsedHocProps> {
        async componentDidMount() {
            // if not is cloud, not even try to destructure values from props, just return
            if (!this.props.isCloud) {
                return;
            }
            const {subscription, actions, userIsAdmin} = this.props;

            if (isEmpty(subscription) && userIsAdmin && actions?.getCloudSubscription) {
                await actions.getCloudSubscription();
            }
        }

        render(): JSX.Element {
            return <WrappedComponent {...this.props}/>;
        }
    };
}

export default withGetCloudSubscription;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useRef, useCallback, useState} from 'react';

type CopyOptions = {
    successCopyTimeout?: number;
    text: string;
    trackCallback?: () => void;
};

type CopyResponse = {
    copiedRecently: boolean;
    copyError: boolean;
    onClick: () => void;
};

const DEFAULT_COPY_TIMEOUT = 4000;

export default function useCopyText(options: CopyOptions): CopyResponse {
    const [copiedRecently, setCopiedRecently] = useState(false);
    const [copyError, setCopyError] = useState(false);
    const timerRef = useRef<NodeJS.Timeout | null>(null);

    let successCopyTimeout = DEFAULT_COPY_TIMEOUT;
    if (options.successCopyTimeout || options.successCopyTimeout === 0) {
        successCopyTimeout = options.successCopyTimeout;
    }

    const onClick = useCallback(() => {
        if (options.trackCallback) {
            options.trackCallback();
        }

        if (timerRef.current) {
            clearTimeout(timerRef.current);
            timerRef.current = null;
        }
        const clipboard = navigator.clipboard;
        if (clipboard) {
            clipboard.writeText(options.text).
                then(() => {
                    setCopiedRecently(true);
                    setCopyError(false);
                }).
                catch(() => {
                    setCopiedRecently(false);
                    setCopyError(true);
                });
        } else {
            const textField = document.createElement('textarea');
            textField.innerText = options.text;
            textField.style.position = 'fixed';
            textField.style.opacity = '0';

            document.body.appendChild(textField);
            textField.select();

            try {
                const success = document.execCommand('copy');
                setCopiedRecently(success);
                setCopyError(!success);
            } catch (err) {
                setCopiedRecently(false);
                setCopyError(true);
            }
            textField.remove();
        }

        timerRef.current = setTimeout(() => {
            setCopiedRecently(false);
            setCopyError(false);
        }, successCopyTimeout);
    }, [options.text, successCopyTimeout]);

    return {
        copiedRecently,
        copyError,
        onClick,
    };
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useMemo} from 'react';

import {CloudUsage, Limits} from '@mattermost/types/cloud';
import {limitThresholds, LimitTypes} from 'utils/limits';

interface MaybeLimitSummary {
    id: typeof LimitTypes[keyof typeof LimitTypes];
    limit: number | undefined;
    usage: number;
}
export interface LimitSummary {
    id: typeof LimitTypes[keyof typeof LimitTypes];
    limit: number;
    usage: number;
}

function refineToDefined(...args: MaybeLimitSummary[]): LimitSummary[] {
    return args.reduce((acc: LimitSummary[], maybeLimitType: MaybeLimitSummary) => {
        if (maybeLimitType.limit !== undefined) {
            acc.push(maybeLimitType as LimitSummary);
        }
        return acc;
    }, []);
}

// Hook used to tell if some limit status should be surfaced to the user
// for further attention, for example for prompting the user to upgrade
// from a free cloud instance to a paid cloud instance.
export default function useGetHighestThresholdCloudLimit(usage: CloudUsage, limits: Limits): LimitSummary | false {
    return useMemo(() => {
        if (Object.keys(limits).length === 0) {
            return false;
        }
        const maybeMessageHistoryLimit = limits.messages?.history;
        const messageHistoryUsage = usage.messages.history;

        const maybeBoardsCardsLimit = limits.boards?.cards;
        const boardsCardsUsage = usage.boards.cards;

        const maybeFileStorageLimit = limits.files?.total_storage;
        const fileStorageUsage = usage.files.totalStorage;

        // Order matters for this array. The designs specify:
        // > Show the plan limit that is the highest.
        // > Otherwise if there is a tie,
        // > default to showing Message History first,
        // > File storage second,
        // > and App limit third.
        const highestLimit = refineToDefined(
            {
                id: LimitTypes.messageHistory,
                limit: maybeMessageHistoryLimit,
                usage: messageHistoryUsage,
            },
            {
                id: LimitTypes.fileStorage,
                limit: maybeFileStorageLimit,
                usage: fileStorageUsage,
            },
            {
                id: LimitTypes.boardsCards,
                limit: maybeBoardsCardsLimit,
                usage: boardsCardsUsage,
            },
        ).
            reduce((acc: LimitSummary | false, curr: LimitSummary) => {
                if (!acc) {
                    if (curr.limit && curr.limit > 0) {
                        return curr;
                    }
                    return acc;
                }
                if ((curr.usage / curr.limit) > (acc.usage / acc.limit)) {
                    return curr;
                }
                return acc;
            }, false);

        // Either no limit category was defined (!highestLimit)
        // or no limit meets the minimum threshold for needing attention
        const noLimitNeedsAttention = !highestLimit || (highestLimit.usage / highestLimit.limit) < (limitThresholds.warn / 100);
        if (noLimitNeedsAttention) {
            return false;
        }
        return highestLimit;
    }, [usage, limits]);
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useState, useEffect, useMemo} from 'react';
import {useDispatch, useSelector} from 'react-redux';

import {Limits} from '@mattermost/types/cloud';
import {getCloudLimits, getCloudLimitsLoaded, isCurrentLicenseCloud} from 'mattermost-redux/selectors/entities/cloud';
import {getCloudLimits as getCloudLimitsAction} from 'actions/cloud';
import {useIsLoggedIn} from 'components/global_header/hooks';

export default function useGetLimits(): [Limits, boolean] {
    const isCloud = useSelector(isCurrentLicenseCloud);
    const isLoggedIn = useIsLoggedIn();
    const cloudLimits = useSelector(getCloudLimits);
    const cloudLimitsReceived = useSelector(getCloudLimitsLoaded);
    const dispatch = useDispatch();
    const [requestedLimits, setRequestedLimits] = useState(false);

    useEffect(() => {
        if (isLoggedIn && isCloud && !requestedLimits && !cloudLimitsReceived) {
            dispatch(getCloudLimitsAction());
            setRequestedLimits(true);
        }
    }, [isLoggedIn, isCloud, requestedLimits, cloudLimitsReceived]);

    const result: [Limits, boolean] = useMemo(() => {
        return [cloudLimits, cloudLimitsReceived];
    }, [cloudLimits, cloudLimitsReceived]);
    return result;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useState} from 'react';

import {NotifyAdminRequest} from '@mattermost/types/cloud';
import {Client4} from 'mattermost-redux/client';
import {trackEvent} from 'actions/telemetry_actions';

export const NotifyStatus = {
    NotStarted: 'NOT_STARTED',
    Started: 'STARTED',
    Success: 'SUCCESS',
    Failed: 'FAILED',
    AlreadyComplete: 'COMPLETE',
} as const;

export type NotifyStatusValues = ValueOf<typeof NotifyStatus>;

export const DefaultBtnText = {
    NotifyAdmin: 'Notify your admin',
    Notifying: 'Notifying...',
    Notified: 'Notified!',
    AlreadyNotified: 'Already notified!',
    Failed: 'Try again later!',
} as const;

type ValueOf<T> = T[keyof T];

type UseNotifyAdminArgs = {
    ctaText?: {
        id: string;
        defaultMessage: string;
    };
}

type NotifyAdminArgs = {
    requestData: NotifyAdminRequest;
    trackingArgs: {
        category: any;
        event: any;
        props?: any;
    };
}

export const useGetNotifyAdmin = (args: UseNotifyAdminArgs) => {
    const [notifyStatus, setStatus] = useState<ValueOf<typeof NotifyStatus>>(NotifyStatus.NotStarted);

    const btnText = (status: ValueOf<typeof NotifyStatus>): {id: string; defaultMessage: string} => {
        switch (status) {
        case NotifyStatus.Started:
            return {id: 'notify_admin_to_upgrade_cta.notify-admin.notifying', defaultMessage: DefaultBtnText.Notifying};
        case NotifyStatus.Success:
            return {id: 'notify_admin_to_upgrade_cta.notify-admin.notified', defaultMessage: DefaultBtnText.Notified};
        case NotifyStatus.AlreadyComplete:
            return {id: 'notify_admin_to_upgrade_cta.notify-admin.already_notified', defaultMessage: DefaultBtnText.AlreadyNotified};
        case NotifyStatus.Failed:
            return {id: 'notify_admin_to_upgrade_cta.notify-admin.failed', defaultMessage: DefaultBtnText.Failed};
        default:
            return args.ctaText || {id: 'notify_admin_to_upgrade_cta.notify-admin.notify', defaultMessage: DefaultBtnText.NotifyAdmin};
        }
    };

    const notifyAdmin = async ({requestData, trackingArgs}: NotifyAdminArgs) => {
        try {
            setStatus(NotifyStatus.Started);
            await Client4.notifyAdmin(requestData);
            trackEvent(trackingArgs.category, trackingArgs.event, trackingArgs.props);
            setStatus(NotifyStatus.Success);
        } catch (error) {
            if (error && error.status_code === 403) {
                setStatus(NotifyStatus.AlreadyComplete);
            } else {
                setStatus(NotifyStatus.Failed);
            }
        }
    };

    return {
        notifyStatus,
        btnText,
        notifyAdmin,
    };
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useEffect, useState} from 'react';
import {useDispatch, useSelector} from 'react-redux';

import {
    getCloudSubscription as getCloudSubscriptionAction,
} from 'mattermost-redux/actions/cloud';
import {getLicense} from 'mattermost-redux/selectors/entities/general';

import {Subscription} from '@mattermost/types/cloud';
import {getCloudSubscription} from 'mattermost-redux/selectors/entities/cloud';

export default function useGetSubscription(): Subscription | undefined {
    const cloudSubscription = useSelector(getCloudSubscription);
    const license = useSelector(getLicense);
    const retrievedCloudSub = Boolean(cloudSubscription);
    const dispatch = useDispatch();
    const [requestedSubscription, setRequestedSubscription] = useState(false);

    useEffect(() => {
        if (license.Cloud === 'true' && !retrievedCloudSub && !requestedSubscription) {
            dispatch(getCloudSubscriptionAction());
            setRequestedSubscription(true);
        }
    }, [requestedSubscription, retrievedCloudSub, license]);

    return cloudSubscription;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useEffect, useState} from 'react';
import {useDispatch, useSelector} from 'react-redux';

import {CloudUsage} from '@mattermost/types/cloud';
import {getUsage} from 'mattermost-redux/selectors/entities/usage';
import {isCurrentLicenseCloud} from 'mattermost-redux/selectors/entities/cloud';
import {
    getMessagesUsage,
    getFilesUsage,
    getBoardsUsage,
    getTeamsUsage,
} from 'actions/cloud';
import {useIsLoggedIn} from 'components/global_header/hooks';

export default function useGetUsage(): CloudUsage {
    const usage = useSelector(getUsage);
    const isCloud = useSelector(isCurrentLicenseCloud);
    const isLoggedIn = useIsLoggedIn();

    const dispatch = useDispatch();

    const [requestedMessages, setRequestedMessages] = useState(false);
    useEffect(() => {
        if (isLoggedIn && isCloud && !requestedMessages && !usage.messages.historyLoaded) {
            dispatch(getMessagesUsage());
            setRequestedMessages(true);
        }
    }, [isLoggedIn, isCloud, requestedMessages, usage.messages.historyLoaded]);

    const [requestedStorage, setRequestedStorage] = useState(false);
    useEffect(() => {
        if (isLoggedIn && isCloud && !requestedStorage && !usage.files.totalStorageLoaded) {
            dispatch(getFilesUsage());
            setRequestedStorage(true);
        }
    }, [isLoggedIn, isCloud, requestedStorage, usage.files.totalStorageLoaded]);

    const [requestedBoardsUsage, setRequestedBoardsUsage] = useState(false);
    useEffect(() => {
        if (isLoggedIn && isCloud && !requestedBoardsUsage && !usage.boards.cardsLoaded) {
            dispatch(getBoardsUsage());
            setRequestedBoardsUsage(true);
        }
    }, [isLoggedIn, isCloud, requestedBoardsUsage, usage.boards.cardsLoaded, isCloud]);

    const [requestedTeamsUsage, setRequestedTeamsUsage] = useState(false);
    useEffect(() => {
        if (isLoggedIn && isCloud && !requestedTeamsUsage && !usage.teams.teamsLoaded) {
            dispatch(getTeamsUsage());
            setRequestedTeamsUsage(true);
        }
    }, [isLoggedIn, isCloud, requestedTeamsUsage, usage.teams.teamsLoaded]);

    return usage;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useDispatch} from 'react-redux';

import {trackEvent} from 'actions/telemetry_actions';
import {openModal} from 'actions/views/modals';
import {ModalIdentifiers, TELEMETRY_CATEGORIES} from 'utils/constants';
import PurchaseModal from 'components/purchase_modal';

interface OpenPurchaseModalOptions{
    onClick?: () => void;
    trackingLocation?: string;
    isDelinquencyModal?: boolean;
}
type TelemetryProps = Pick<OpenPurchaseModalOptions, 'trackingLocation'>

export default function useOpenCloudPurchaseModal(options: OpenPurchaseModalOptions) {
    const dispatch = useDispatch();
    return (telemetryProps: TelemetryProps, isMonthlyPlan?: boolean) => {
        if (options.onClick) {
            options.onClick();
        }
        trackEvent(TELEMETRY_CATEGORIES.CLOUD_ADMIN, options.isDelinquencyModal ? 'click_open_delinquency_modal' : 'click_open_purchase_modal', {
            callerInfo: telemetryProps.trackingLocation,
        });
        dispatch(openModal({
            modalId: ModalIdentifiers.CLOUD_PURCHASE,
            dialogType: PurchaseModal,
            dialogProps: {
                callerCTA: telemetryProps.trackingLocation,
                isInitialPlanMonthly: isMonthlyPlan ?? true,
            },
        }));
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useDispatch, useSelector} from 'react-redux';

import {trackEvent} from 'actions/telemetry_actions';
import {openModal} from 'actions/views/modals';
import {ModalIdentifiers, TELEMETRY_CATEGORIES} from 'utils/constants';
import PricingModal from 'components/pricing_modal';

import {isCurrentLicenseCloud} from 'mattermost-redux/selectors/entities/cloud';

export type TelemetryProps = {
    trackingLocation: string;
}

export default function useOpenPricingModal() {
    const dispatch = useDispatch();
    const isCloud = useSelector(isCurrentLicenseCloud);
    let category;
    return (telemetryProps?: TelemetryProps) => {
        if (isCloud) {
            category = TELEMETRY_CATEGORIES.CLOUD_PRICING;
        } else {
            category = 'self_hosted_pricing';
        }
        trackEvent(category, 'click_open_pricing_modal', {
            callerInfo: telemetryProps?.trackingLocation,
        });
        dispatch(openModal({
            modalId: ModalIdentifiers.PRICING_MODAL,
            dialogType: PricingModal,
            dialogProps: {
                callerCTA: telemetryProps?.trackingLocation,
            },
        }));
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useSelector} from 'react-redux';

import {getCloudContactUsLink, InquiryType, SalesInquiryIssue} from 'selectors/cloud';

export default function useOpenSalesLink(issue?: SalesInquiryIssue, inquireType: InquiryType = InquiryType.Sales) {
    const contactSalesLink = useSelector(getCloudContactUsLink)(inquireType, issue);

    return () => window.open(contactSalesLink, '_blank');
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useSelector} from 'react-redux';
import styled from 'styled-components';
import {useIntl} from 'react-intl';

import {TrialPeriodDays} from 'utils/constants';
import {getRemainingDaysFromFutureTimestamp} from 'utils/utils';

import {getCloudSubscription as selectCloudSubscription, isCurrentLicenseCloud} from 'mattermost-redux/selectors/entities/cloud';
import {getLicense} from 'mattermost-redux/selectors/entities/general';

type PlanLabelProps = {
    text: string;
    bgColor: string;
    color: string;
    firstSvg: JSX.Element;
    secondSvg?: JSX.Element;
    renderLastDaysOnTrial?: boolean;
}

type StyledProps = {
    bgColor?: string;
    color?: string;
}

const StyledPlanLabel = styled.div<StyledProps>`
background-color: ${(props) => props.bgColor};
color: ${(props) => props.color};
`;

function PlanLabel(props: PlanLabelProps) {
    const {formatMessage} = useIntl();
    const isCloud = useSelector(isCurrentLicenseCloud);
    const subscription = useSelector(selectCloudSubscription);
    const license = useSelector(getLicense);
    const isSelfHostedEnterpriseTrial = license.IsTrial === 'true';

    let text = props.text;

    if (props.renderLastDaysOnTrial && ((isCloud && subscription?.is_free_trial === 'true') || isSelfHostedEnterpriseTrial)) {
        const daysLeftOnTrial = Math.min(
            getRemainingDaysFromFutureTimestamp(isSelfHostedEnterpriseTrial ? parseInt(license.ExpiresAt, 10) : subscription?.trial_end_at),
            TrialPeriodDays.TRIAL_30_DAYS,
        );
        text = formatMessage({id: 'pricing_modal.plan_label_trialDays', defaultMessage: '{days} DAYS LEFT ON TRIAL'}, {days: daysLeftOnTrial});
    }

    return (
        <StyledPlanLabel
            className='planLabel'
            bgColor={props.bgColor}
            color={props.color}
        >
            {props.firstSvg}
            {text}
            {props.secondSvg}
        </StyledPlanLabel>
    );
}

export default PlanLabel;


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode} from 'react';

import Badge from 'components/widgets/badges/badge';

type RadioGroupProps = {
    id: string;
    values: Array<{ key: React.ReactNode | React.ReactNodeArray; value: string; testId?: string}>;
    value: string;
    badge?: {matchVal: string; badgeContent: ReactNode; extraClass?: string} | undefined | null;
    sideLegend?: {matchVal: string; text: ReactNode};
    isDisabled?: null | ((id: string) => boolean);
    onChange(e: React.ChangeEvent<HTMLInputElement>): void;
    testId?: string;
}
const RadioButtonGroup = ({
    id,
    onChange,
    isDisabled,
    values,
    value,
    badge,
    sideLegend,
    testId,
}: RadioGroupProps) => {
    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        onChange(e);
    };

    const options = [];
    for (const {value: val, key, testId} of values) {
        const disabled = isDisabled ? isDisabled(val) : false;
        const moreProps: {'data-testid'?: string} = {};
        if (testId) {
            moreProps['data-testid'] = testId;
        }
        options.push(
            <div
                className='radio'
                key={val}
            >
                <label className={val === value ? 'selected' : ''}>
                    <input
                        type='radio'
                        value={val}
                        name={id}
                        checked={val === value}
                        onChange={handleChange}
                        disabled={disabled}
                        {...moreProps}
                    />
                    {key}
                    {(sideLegend && val === sideLegend?.matchVal) &&
                        <span className='side-legend'>
                            {sideLegend.text}
                        </span>
                    }
                </label>
                {(badge && val === badge?.matchVal) &&
                    <Badge className={`radio-badge ${badge.extraClass ?? ''}`}>
                        {badge.badgeContent}
                    </Badge>
                }
            </div>,
        );
    }

    return (
        <div
            className='radio-list'
            data-testid={testId || ''}
        >
            {options}
        </div>
    );
};

export default RadioButtonGroup;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

type SvgProps = {
    width: number;
    height: number;
}

const CreditCardSvg = (props: SvgProps) => (
    <svg
        width={props.width ? props.width.toString() : '489'}
        height={props.height ? props.height.toString() : '317'}
        viewBox='0 0 234 152'
        fill='none'
    >
        <g clipPath='url(#clip_credit_card)'>
            <path
                d='M138.978 49.6651C142.737 53.4214 143.517 59.1062 140.683 62.3984L74.9691 138.745C70.9805 143.382 63.9993 143.531 59.4457 138.956L3.34698 82.8884C-1.20661 78.3377 -1.08212 71.3609 3.55287 67.3749L79.9536 1.70829C83.2431 -1.12452 88.9315 -0.349295 92.6902 3.41183L138.978 49.6651Z'
                fill='#AFB3C0'
            />
            <path
                d='M113.112 23.8156L28.0925 107.623L8.29321 87.8361L96.7698 7.49341L113.112 23.8156Z'
                fill='#1B1D22'
            />
            <path
                d='M109.976 40.7646L50.1709 101.761L66.197 117.777L123.933 54.7086L109.976 40.7646Z'
                fill='white'
            />
            <path
                d='M75.8405 96.3108C72.4887 93.2101 74.4759 87.3913 75.6969 84.2188C77.6121 79.3092 79.5992 88.7359 79.6998 90.1954C80.0212 94.9865 79.598 99.7983 78.4453 104.46C77.7987 107.066 76.8573 109.589 75.6394 111.982C74.9021 113.47 73.8461 114.777 72.5462 115.81C69.3189 117.758 67.2792 115.863 66.4365 110.145C66.7632 108.397 67.5955 106.783 68.8306 105.503C73.0442 100.278 79.7094 97.6315 84.5886 93.5689C85.0674 93.1669 84.2965 92.4109 83.8225 92.8033C77.9904 97.6506 66.0007 101.651 65.2586 111.231C64.7797 117.566 71.1959 118.925 74.6434 115.399C79.1252 110.815 80.2696 102.479 80.6574 96.2151C80.8825 92.5736 81.8066 82.4961 76.4534 81.2711C76.3501 81.239 76.239 81.2428 76.1381 81.2819C76.0372 81.321 75.9526 81.3931 75.8979 81.4864C73.7768 85.2092 70.7458 93.0186 75.1318 97.0621C75.1812 97.1086 75.2393 97.1449 75.3027 97.169C75.3661 97.1931 75.4336 97.2044 75.5014 97.2024C75.5692 97.2004 75.636 97.1851 75.6978 97.1574C75.7597 97.1296 75.8155 97.0899 75.8621 97.0405C75.9086 96.9912 75.9449 96.9332 75.969 96.8698C75.9931 96.8065 76.0045 96.739 76.0025 96.6712C76.0005 96.6035 75.9852 96.5368 75.9574 96.4749C75.9296 96.4131 75.8899 96.3573 75.8405 96.3108V96.3108Z'
                fill='#63697E'
            />
            <path
                d='M83.1042 92.7026C87.8924 95.3536 89.0943 84.8167 88.467 81.936C88.4445 81.8509 88.4009 81.7727 88.3403 81.7088C88.2797 81.6448 88.204 81.5971 88.1201 81.5699C88.0362 81.5428 87.9469 81.5371 87.8603 81.5534C87.7737 81.5697 87.6925 81.6075 87.6243 81.6633C85.1057 83.6778 84.6604 88.9702 86.8007 92.0519C86.8414 92.1313 86.9025 92.1984 86.9778 92.2464C87.0531 92.2944 87.1398 92.3215 87.229 92.3249C87.3183 92.3284 87.4068 92.308 87.4855 92.2659C87.5642 92.2238 87.6303 92.1614 87.677 92.0853C89.0568 89.2287 90.225 86.2747 91.1724 83.2472C91.5985 81.9695 92.6998 82.2901 93.5665 81.3809C95.3429 79.5865 97.0666 77.7586 98.8 75.9738C100.993 73.7152 101.75 70.7101 103.77 68.461C106.351 65.5612 108.836 64.1544 110.124 60.178C110.421 59.2688 110.445 57.1537 108.874 57.0341C105.848 56.7996 103.196 63.1926 107.232 62.5801C112.169 61.8289 116.593 56.0915 119.792 53.0098C120.175 52.6462 119.471 51.9475 119.097 52.3112C117.498 53.828 115.865 55.3354 114.165 56.7948C112.818 57.9635 111.409 59.0578 109.942 60.0727C109.195 60.5847 103.55 63.0777 107.136 58.8907L109.052 60.3741C108.845 60.9032 108.607 61.4194 108.338 61.9198C107.854 62.8459 107.29 63.728 106.653 64.5563C105.47 66.1594 103.598 67.1021 102.257 68.5998C100.552 70.5139 99.8917 73.2271 98.0674 75.2177C97.263 76.0981 92.8722 81.7064 91.3112 81.046C91.2117 81.0077 91.1014 81.008 91.0021 81.0469C90.9028 81.0859 90.8217 81.1607 90.7749 81.2565C90.2961 82.6921 89.779 84.1707 89.281 85.635C89.0991 86.1709 87.0114 90.3483 87.0736 90.4919C86.1591 88.3099 86.4703 85.5297 87.2365 83.6156C87.5305 84.1529 87.7065 84.7466 87.7527 85.3572C87.799 85.9678 87.7144 86.5813 87.5046 87.1567C87.1551 89.755 85.8335 91.3101 83.5447 91.7934C82.9414 91.5016 82.5009 92.3725 83.1042 92.7026Z'
                fill='#63697E'
            />
            <path
                d='M173.233 23.3228C170.762 27.3566 162.929 24.1554 161.435 31.8594C164.308 31.8594 175.019 33.3333 175.019 33.3333L173.233 23.3228Z'
                fill='#66320A'
            />
            <path
                d='M161.085 63.8243C157.647 69.9301 129.717 82.0078 136.373 113.068C141.089 135.08 151.882 143.87 149.162 147.521C147.175 150.211 145.614 153.474 150.336 149.612C156.014 144.971 158.059 148.048 154.362 136.86C150.833 126.199 147.74 97.794 165.342 87.7452C182.943 77.6964 188.689 72.6385 179.999 60.2736C176.814 55.7613 161.085 63.8243 161.085 63.8243Z'
                fill='#FFBC1F'
            />
            <path
                d='M147.07 139.932C147.659 139.765 152.634 138.19 154.525 137.391C157.987 147.966 155.923 145.047 150.336 149.636C145.614 153.498 147.175 150.234 149.162 147.545C150.273 146.052 149.129 143.688 147.07 139.932Z'
                fill='#1C58D9'
            />
            <path
                d='M181.296 32.6442L181.741 23.605L182.958 20.2554C182.211 16.9393 180.276 15.3555 179.194 15.0875C176.723 14.4846 175.364 14.3888 174.032 15.4272C173.3 16.0541 172.17 18.9156 171.686 21.1694C171.428 22.38 170.843 23.3466 171.653 24.0979C172.206 24.5416 172.797 24.9355 173.42 25.275L173.544 30.9454L181.296 32.6442Z'
                fill='#FFBC1F'
            />
            <path
                d='M173.233 17.71C171.317 18.8058 171.035 19.1455 171.035 19.1455C170.752 19.9398 172.898 20.7485 172.898 20.7485L173.233 17.71Z'
                fill='#FFBC1F'
            />
            <path
                d='M176.058 26.0408C175.155 25.9995 174.273 25.7507 173.482 25.3135C173.194 25.1365 174.004 25.8399 174.301 26.0025C174.675 26.2698 175.112 26.4348 175.569 26.4811C175.909 26.4763 176.398 26.0647 176.058 26.0408Z'
                fill='#A37200'
            />
            <path
                d='M191.964 67.0018C193.554 89.492 194.148 119.72 214.469 124.725C234.79 129.73 234.019 127.271 234.01 134.817C234 142.363 232.444 141.248 231.515 136.41C230.323 130.19 208.129 141.301 193.075 128.898C178.021 116.495 171.653 92.5306 169.359 67.954C167.726 50.6078 191.964 67.0018 191.964 67.0018Z'
                fill='#FFBC1F'
            />
            <path
                d='M225.659 127.261C234.45 129.122 234 129.065 233.995 134.817C233.995 142.368 232.429 141.248 231.501 136.41C231.084 134.257 228.149 134.185 223.839 134.496C224.701 132.156 225.311 129.73 225.659 127.261V127.261Z'
                fill='#1C58D9'
            />
            <path
                d='M122.425 34.5297C122.904 33.6923 126.83 33.5727 131.465 37.3482C136.1 41.1236 143.627 45.7796 152.002 35.6064C159.515 26.4811 164.509 29.8642 172.112 30.2183C174.813 30.5581 185.725 31.9505 188.507 32.1993C192.601 32.1323 199.52 34.0703 204.308 22.8827C206.152 18.576 208.057 12.4271 210.696 8.25926C212.515 5.38817 214.301 3.64633 215.963 2.9477C217.213 2.4309 216.518 3.42621 215.561 4.86176C214.914 5.81879 215.628 5.71835 215.269 6.94335C215.058 7.66112 214.962 8.08218 214.727 8.69946C214.523 9.25444 214.353 9.82184 214.22 10.3982C214.115 10.8337 214.009 11.3026 213.918 11.7955C213.918 11.9103 213.87 12.0252 213.851 12.1448C212.894 17.4946 212.343 25.347 211.606 28.4956C209.053 39.3531 203.432 45.7653 193.271 48.0095C193.195 49.5455 193.089 51.2299 192.955 53.0865C191.122 78.711 193.731 71.7487 177.059 71.7869C160.386 71.8252 155.952 81.7735 158.461 67.4803C159.634 60.7811 159.242 52.9669 160.568 44.9901C158.025 46.5692 153.927 49.8087 149.809 50.8184C136.991 53.9622 125.159 37.2477 125.044 36.1567C124.929 34.5154 121.956 35.3671 122.425 34.5297Z'
                fill='#FFBC1F'
            />
            <path
                d='M157.01 48.7128C158.715 47.6505 159.404 45.7029 160.601 44.966C160.124 48.0004 159.805 51.0574 159.644 54.1248C159.51 56.302 159.4 58.4314 159.256 60.513C159.125 62.8331 158.87 65.1445 158.49 67.4371C155.986 81.7542 160.405 71.782 177.092 71.7437C191.687 71.7437 191.505 77.0553 192.462 61.1829C192.462 61.1446 192.462 61.1064 192.462 61.0776C192.505 60.3982 192.548 59.6804 192.596 58.9195C192.702 57.1825 192.831 55.235 192.984 53.0529C193.113 51.1915 193.224 49.5071 193.305 47.9711C197.772 46.9854 201.354 46.6552 204.193 44.0282C202.757 39.8268 200.842 34.3334 198.05 30.845C195.043 32.5725 191.979 32.2806 189.589 32.1992C189.206 32.1992 188.847 32.1992 188.507 32.1992L187.071 32.0509L183.149 31.5724C182.354 35.7403 175.881 35.1182 173.745 33.6635C172.466 32.7669 171.455 31.5396 170.82 30.1129C169.924 30.0315 169.057 29.9215 168.215 29.8114C167.372 29.7014 166.649 29.5914 165.888 29.4956C161.31 28.9501 157.269 29.175 152.002 35.5871C151.681 35.9795 151.355 36.3432 151.044 36.6925C152.485 40.5493 155.038 45.0856 157.01 48.7128Z'
                fill='white'
            />
            <path
                d='M145.25 78.73C148.397 83.1645 152.019 87.2417 156.053 90.8891C156.163 90.9943 156.283 91.0996 156.397 91.2001C157.192 91.9227 158.011 92.6357 158.835 93.3152C159.165 92.9318 159.527 92.5765 159.917 92.2528C160.027 92.1523 160.151 92.0471 160.276 91.9466C161.593 90.846 163.484 89.4727 165.366 88.1807C168.009 86.3624 170.633 84.6779 171.533 84.1181C172.203 87.7931 172.969 91.4011 173.927 94.8942C173.97 95.0522 174.009 95.2101 174.052 95.3728C174.2 95.9183 174.348 96.459 174.502 96.9997C180.655 96.7365 186.755 96.1623 192.697 94.4684C192.85 94.4301 192.999 94.3823 193.147 94.3392L194.105 94.052C194.215 94.0186 194.325 93.9947 194.43 93.9707C194.32 93.2673 194.21 92.4826 194.109 91.6356L194.052 91.1571C192.922 81.4863 192.338 64.0731 192.467 61.2116C192.467 61.1733 192.467 61.135 192.467 61.1063C192.118 60.8161 191.783 60.5079 191.466 60.1828C191.327 60.0345 191.184 59.8909 191.05 59.7377C188.014 56.3451 186.515 51.402 185.649 48.3874C185.95 41.736 186.563 38.2094 189.594 32.2279C189.211 32.2279 187.679 32.1227 187.071 32.0605C185.007 36.4867 184.016 41.2431 183.523 46.0905C177.853 45.0569 172.16 44.1382 166.472 43.2577C166.674 38.7505 167.257 34.2684 168.215 29.8593C167.42 29.7492 166.649 29.6392 165.888 29.5435C164.799 34.5346 164.282 39.6332 164.346 44.7411C164.02 45.5498 163.388 48.0285 162.909 48.8946C161.927 50.7115 160.838 52.4691 159.649 54.1582C159.515 56.3355 159.404 58.4649 159.261 60.5465C159.117 62.628 158.93 64.6282 158.638 66.5566C155.813 69.0927 151.245 72.4136 146.898 76.9595L146.567 77.3088C146.127 77.749 145.686 78.2324 145.25 78.73Z'
                fill='#1C58D9'
            />
            <path
                d='M176.489 64.7573C175.258 64.5516 173.86 64.3218 172.203 64.0778C170.077 63.7668 168.349 63.5515 166.936 63.384C163.546 62.9677 162.148 62.7906 161.53 62.0011C161.143 61.489 161.147 60.7904 161.291 59.7569C161.396 59.0247 161.425 58.4696 161.449 58.0246C161.54 56.3642 161.564 55.9144 164.547 52.3829C165.054 51.78 165.457 51.2489 165.806 50.7847C167.769 48.1959 168.287 47.8035 175 49.1051C179.151 49.909 179.467 50.3014 180.3 52.0288C180.698 52.8925 181.168 53.7215 181.703 54.5075C182.354 55.4645 182.867 56.1106 183.283 56.6321C184.571 58.2591 184.806 58.5462 184.322 62.0058C184.121 63.4414 183.843 64.3984 183.149 64.9296C182.615 65.2688 181.985 65.4266 181.354 65.3794C179.72 65.2844 178.094 65.0765 176.489 64.7573V64.7573ZM174.928 49.5645C168.31 48.282 167.99 48.7079 166.199 51.067C165.845 51.5455 165.442 52.0719 164.925 52.6844C162.052 56.101 162.019 56.5125 161.937 58.0485C161.909 58.527 161.88 59.0678 161.775 59.8239C161.645 60.733 161.631 61.336 161.923 61.7379C162.402 62.3743 163.948 62.5657 167.013 62.9437C168.406 63.1112 170.14 63.3266 172.28 63.6376C173.941 63.8816 175.34 64.1161 176.589 64.3171C180.219 64.9152 182.038 65.2167 182.914 64.5755C183.393 64.2022 183.685 63.4988 183.901 61.9676C184.38 58.7089 184.198 58.5079 182.943 56.948C182.527 56.4168 181.986 55.7613 181.349 54.7947C180.8 53.9893 180.319 53.1393 179.912 52.2537C179.161 50.6985 179.007 50.378 174.942 49.5884L174.985 49.3587L174.928 49.5645Z'
                fill='#1B1D22'
            />
            <path
                d='M178.845 51.5169C179.017 51.8675 179.212 52.2065 179.429 52.5314C179.596 52.785 179.194 53.0099 179.027 52.7706C178.81 52.4445 178.613 52.1057 178.438 51.7561C178.308 51.4834 178.71 51.2489 178.845 51.5169Z'
                fill='#1B1D22'
            />
            <path
                d='M180.133 53.857C180.406 54.2828 180.688 54.7039 180.985 55.1107C181.162 55.3595 180.755 55.5892 180.578 55.3499C180.281 54.9384 179.998 54.5221 179.73 54.0914C179.568 53.8378 179.994 53.6033 180.133 53.857Z'
                fill='#1B1D22'
            />
            <path
                d='M182.163 56.6179C182.377 56.8972 182.612 57.1595 182.867 57.4027C183.087 57.6084 182.757 57.9386 182.536 57.7329C182.283 57.4903 182.048 57.2296 181.832 56.9529C181.65 56.7136 181.981 56.3834 182.163 56.6179Z'
                fill='#1B1D22'
            />
            <path
                d='M183.092 59.7139C183.092 59.4124 183.537 59.4124 183.571 59.7139C183.596 60.0324 183.596 60.3524 183.571 60.6709C183.571 60.9724 183.092 60.9724 183.092 60.6709C183.117 60.3524 183.117 60.0324 183.092 59.7139V59.7139Z'
                fill='#1B1D22'
            />
            <path
                d='M182.68 62.2262C182.728 61.9295 183.159 62.0539 183.13 62.3506C183.063 62.7526 182.996 63.1545 182.924 63.5565C182.876 63.8532 182.445 63.7288 182.474 63.4321L182.68 62.2262Z'
                fill='#1B1D22'
            />
            <path
                d='M179.036 63.0013C179.629 63.1646 180.234 63.2782 180.846 63.341C181.143 63.341 181.148 63.8196 180.846 63.8196C180.198 63.7579 179.558 63.6394 178.931 63.4655C178.869 63.4515 178.816 63.4137 178.782 63.3603C178.748 63.3069 178.737 63.2422 178.751 63.1807C178.765 63.1191 178.803 63.0657 178.856 63.032C178.91 62.9984 178.974 62.9873 179.036 63.0013V63.0013Z'
                fill='#1B1D22'
            />
            <path
                d='M174.463 62.4796C175.06 62.5169 175.655 62.5856 176.245 62.6854C176.541 62.738 176.417 63.1639 176.12 63.1639C175.572 63.0692 175.019 63.0052 174.463 62.9725C174.167 62.9294 174.162 62.4604 174.463 62.4796Z'
                fill='#1B1D22'
            />
            <path
                d='M170.015 61.9678L171.614 62.1687C171.911 62.2022 171.916 62.6473 171.614 62.6473L170.015 62.4511C169.718 62.3985 169.718 61.9295 170.015 61.9678Z'
                fill='#1B1D22'
            />
            <path
                d='M165.6 61.5083L166.97 61.6662C167.267 61.6997 167.267 62.1448 166.97 62.1448L165.6 61.9868C165.308 61.9437 165.303 61.4748 165.6 61.5083Z'
                fill='#1B1D22'
            />
            <path
                d='M163.235 60.4412L163.743 60.9197C163.968 61.1254 163.632 61.4556 163.412 61.2547L162.905 60.7762C162.68 60.5704 163.01 60.2402 163.235 60.4412Z'
                fill='#1B1D22'
            />
            <path
                d='M162.675 57.7233C162.708 57.4267 163.154 57.4219 163.154 57.7233C163.095 58.2539 163.069 58.7877 163.077 59.3216C163.077 59.385 163.052 59.4459 163.007 59.4907C162.962 59.5356 162.901 59.5608 162.838 59.5608C162.774 59.5608 162.713 59.5356 162.668 59.4907C162.623 59.4459 162.598 59.385 162.598 59.3216C162.593 58.7878 162.618 58.2541 162.675 57.7233V57.7233Z'
                fill='#1B1D22'
            />
            <path
                d='M163.685 55.2637L164.164 54.5603C164.331 54.3115 164.738 54.5603 164.571 54.7996C164.403 55.0389 164.26 55.2781 164.092 55.4982C163.924 55.7183 163.517 55.5126 163.685 55.2637Z'
                fill='#1B1D22'
            />
            <path
                d='M175.244 50.268C175.789 50.2952 176.332 50.364 176.867 50.4738C177.164 50.536 177.039 50.9858 176.743 50.9523C176.249 50.8477 175.748 50.7836 175.244 50.7609C174.947 50.7226 174.942 50.2584 175.244 50.268Z'
                fill='#1B1D22'
            />
            <path
                d='M171.691 49.6459C172.21 49.6664 172.726 49.7208 173.238 49.8086C173.534 49.8612 173.41 50.311 173.113 50.2871C172.638 50.2058 172.158 50.1563 171.677 50.1388C171.375 50.1005 171.375 49.6363 171.691 49.6459Z'
                fill='#1B1D22'
            />
            <path
                d='M168.627 49.4593C168.982 49.397 169.343 49.3681 169.704 49.3731C169.767 49.3731 169.828 49.3983 169.873 49.4432C169.918 49.4881 169.943 49.5489 169.943 49.6124C169.943 49.6758 169.918 49.7367 169.873 49.7816C169.828 49.8265 169.767 49.8516 169.704 49.8516C169.383 49.8448 169.063 49.8672 168.746 49.9186C168.454 49.9617 168.33 49.5119 168.627 49.4593Z'
                fill='#1B1D22'
            />
            <path
                d='M166.496 51.7514L167.042 50.9714C167.214 50.7274 167.616 50.9714 167.444 51.2059L166.898 51.9859C166.726 52.2347 166.319 52.0003 166.496 51.7514Z'
                fill='#1B1D22'
            />
            <path
                d='M165.15 53.5458L165.629 52.9237C165.811 52.6844 166.218 52.9237 166.036 53.1582C165.854 53.3926 165.72 53.5745 165.557 53.785C165.394 53.9956 164.987 53.7898 165.15 53.5458Z'
                fill='#1B1D22'
            />
            <path
                d='M184.475 44.1288C186.257 44.6073 186.549 44.2532 186.314 46.6888C186.08 49.1245 186.314 48.8996 184.011 48.4594C182.383 48.1483 182.718 47.6794 182.991 46.1194C183.264 44.5595 183.48 43.8321 184.475 44.1288Z'
                fill='#FFBC1F'
            />
            <path
                d='M164.978 41.5256C166.812 41.7744 167.046 41.3724 167.137 43.8176C167.228 46.2628 166.74 46.0906 165.093 45.88C163.446 45.6695 163.704 45.2771 163.771 43.6932C163.838 42.1093 163.958 41.3868 164.978 41.5256Z'
                fill='#FFBC1F'
            />
            <path
                d='M180.023 25.859C180.023 25.859 178.055 27.0314 178.94 30.515C176.546 26.9596 179.692 22.0644 179.692 22.0644C179.77 22.1683 179.87 22.2527 179.986 22.3109C180.102 22.369 180.23 22.3993 180.36 22.3993C180.49 22.3993 180.618 22.369 180.734 22.3109C180.85 22.2527 180.95 22.1683 181.028 22.0644C183.422 19.6 181.698 18.8105 181.028 19.0976C180.358 19.3847 179.793 19.423 178.414 19.6527C177.035 19.8823 175.675 17.6429 175.675 17.6429L176.029 18.6622C175.392 18.3559 173.999 17.0591 174.032 15.4465C175.297 11.4175 183.073 10.7044 185.969 16.7768C188.866 22.8491 185.969 33.343 194.43 32.118C177.6 39.5398 180.023 25.859 180.023 25.859Z'
                fill='#66320A'
            />
            <path
                d='M146.898 76.926C151.715 83.7162 160.271 91.9466 160.271 91.9466'
                stroke='#1B1D22'
                strokeWidth='0.98'
                strokeMiterlimit='10'
            />
            <path
                d='M173.922 94.8896C182.311 95.2102 194.109 91.6213 194.109 91.6213'
                stroke='#1B1D22'
                strokeWidth='0.98'
                strokeMiterlimit='10'
            />
        </g>
        <defs>
            <clipPath id='clip_credit_card'>
                <rect
                    width='234'
                    height='151.412'
                    fill='white'
                />
            </clipPath>
        </defs>
    </svg>
);

export default CreditCardSvg;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

type SvgProps = {
    width?: number;
    height?: number;
}

const GuestAccessSVG = (props: SvgProps) => (
    <svg
        width={props.width?.toString() || '308'}
        height={props.height?.toString() || '220'}
        viewBox='0 0 308 220'
        fill='none'
        xmlns='http://www.w3.org/2000/svg'
        xmlnsXlink='http://www.w3.org/1999/xlink'
    >
        <g clipPath='url(#clip0_521_245590)'>
            <rect
                width='308'
                height='220'
                rx='100'
                fill='#1C58D9'
                fillOpacity='0.04'
            />
            <path
                d='M161.608 191.655C212.53 191.655 253.81 157.715 253.81 115.848C253.81 73.9817 212.53 40.042 161.608 40.042C110.687 40.042 69.4072 73.9817 69.4072 115.848C69.4072 157.715 110.687 191.655 161.608 191.655Z'
                stroke='#1E325C'
                strokeWidth='0.91'
                strokeMiterlimit='10'
            />
            <g clipPath='url(#clip1_521_245590)'>
                <path
                    d='M178.737 178.633L177.919 174.468C177.796 173.852 177.438 173.309 176.921 172.953C173.082 170.302 167.993 168.922 161.322 168.922C154.651 168.922 149.557 170.302 145.732 172.963C145.217 173.319 144.86 173.862 144.735 174.477L143.898 178.633C143.846 178.894 143.867 179.165 143.958 179.415C144.05 179.665 144.209 179.885 144.418 180.05C145.521 180.911 146.022 182.048 146.257 183.484C146.52 184.994 146.457 186.543 146.073 188.027C142.657 201.452 148.408 207.56 161.299 211.775C174.172 207.56 179.937 201.452 176.521 188.027C176.139 186.542 176.076 184.994 176.337 183.484C176.59 182.048 177.091 180.911 178.176 180.05C178.393 179.891 178.561 179.673 178.66 179.422C178.759 179.172 178.786 178.898 178.737 178.633Z'
                    fill='#CC8F00'
                />
                <path
                    d='M161.322 208.379C149.608 204.338 146.551 199.303 149.217 188.818C149.717 186.891 149.797 184.879 149.452 182.918C149.201 181.187 148.435 179.572 147.254 178.283L147.824 175.429C151.171 173.211 155.59 172.134 161.322 172.134C167.055 172.134 171.469 173.211 174.816 175.429L175.386 178.283C174.206 179.572 173.442 181.187 173.193 182.918C172.848 184.879 172.928 186.891 173.427 188.818C176.08 199.298 173.037 204.361 161.322 208.379Z'
                    fill='var(--away-indicator)'
                />
                <path
                    d='M161.322 208.379C149.608 204.338 146.551 199.303 149.217 188.818C149.717 186.891 149.797 184.879 149.452 182.918C149.201 181.187 148.435 179.572 147.254 178.283L147.824 175.429C151.171 173.211 155.59 172.134 161.322 172.134C167.055 172.134 171.469 173.211 174.816 175.429L175.386 178.283C174.206 179.572 173.442 181.187 173.193 182.918C172.848 184.879 172.928 186.891 173.427 188.818C176.08 199.298 173.037 204.361 161.322 208.379Z'
                    fill='var(--away-indicator)'
                />
                <path
                    d='M161.322 187.184V172.143C155.59 172.143 151.171 173.22 147.824 175.438L147.254 178.292C148.435 179.581 149.201 181.196 149.452 182.927C149.699 184.336 149.725 185.776 149.53 187.193L161.322 187.184Z'
                    fill='var(--away-indicator)'
                />
                <path
                    d='M161.323 208.379C173.037 204.361 176.08 199.298 173.427 188.818C173.291 188.28 173.185 187.734 173.11 187.184H161.323V208.379Z'
                    fill='var(--away-indicator)'
                />
                <path
                    d='M149.218 188.818C146.551 199.302 149.608 204.338 161.323 208.379V187.184H149.53C149.457 187.734 149.353 188.28 149.218 188.818V188.818Z'
                    fill='#FFD791'
                />
                <path
                    d='M161.323 172.143V187.193H173.11C172.915 185.776 172.942 184.336 173.193 182.927C173.442 181.196 174.206 179.581 175.386 178.292L174.816 175.438C171.483 173.211 167.051 172.143 161.323 172.143Z'
                    fill='#FFD791'
                />
                <path
                    d='M168.214 182.457L158.725 192.905L155.971 190.815H154.44L158.725 197.779L169.745 182.457H168.214Z'
                    fill='#66320A'
                />
            </g>
            <mask
                id='mask0_521_245590'
                style={{
                    maskType: 'alpha',
                }}
                maskUnits='userSpaceOnUse'
                x='199'
                y='75'
                width='114'
                height='112'
            >
                <path
                    d='M255.673 186.88C224.419 186.88 199.083 161.839 199.083 130.95C199.083 100.061 224.419 75.021 255.673 75.021C286.927 75.021 312.264 100.061 312.264 130.95C312.264 161.839 286.927 186.88 255.673 186.88Z'
                    fill='#E8E9ED'
                />
            </mask>
            <g mask='url(#mask0_521_245590)'>
                <path
                    d='M306.204 151.443C305.706 148.822 304.712 146.324 303.722 143.842C302.661 141.182 301.59 138.499 300.084 136.052C296.574 130.352 290.856 126.238 284.704 123.489C278.552 120.739 272.665 119.185 266.082 117.695C268.24 119.991 268.897 122.913 270.187 125.774C273.198 132.451 275.786 139.305 278.371 146.153C282.254 156.427 286.134 166.7 290.012 176.972C298.431 172.072 304.479 163.371 306.087 153.846L306.204 151.443Z'
                    fill='#FFE099'
                />
                <path
                    d='M241.639 117.937C237.888 119.164 232.027 121.326 232.027 121.326C232.027 121.326 218.569 159.666 215.587 178.139C215.499 178.682 215.42 179.279 215.674 179.761C216.045 180.472 216.942 180.689 217.675 181.029C219.353 181.804 220.414 183.461 221.868 184.595C223.121 185.57 224.644 186.138 226.142 186.685C239.473 191.515 253.951 195.555 267.717 192.11C268.587 191.891 269.487 191.625 270.15 191.025C270.727 190.495 271.079 189.758 271.396 189.038C275.589 179.537 283.824 159.909 283.743 146.024C283.649 129.979 274.851 120.2 274.707 119.993C274.363 119.5 261.488 116.175 253.559 116.002C253.551 116.006 244.792 116.903 241.639 117.937Z'
                    fill='#FFE099'
                />
                <mask
                    id='mask1_521_245590'
                    style={{
                        maskType: 'alpha',
                    }}
                    maskUnits='userSpaceOnUse'
                    x='215'
                    y='116'
                    width='69'
                    height='78'
                >
                    <path
                        d='M241.639 117.937C237.888 119.164 232.027 121.326 232.027 121.326C232.027 121.326 218.569 159.666 215.587 178.139C215.499 178.682 215.42 179.279 215.674 179.761C216.045 180.472 216.942 180.689 217.675 181.029C219.353 181.804 220.414 183.461 221.868 184.595C223.121 185.57 224.644 186.138 226.142 186.685C239.473 191.515 253.951 195.555 267.717 192.11C268.587 191.891 269.487 191.625 270.15 191.025C270.727 190.495 271.079 189.758 271.396 189.038C275.589 179.537 283.824 159.909 283.743 146.024C283.649 129.979 274.851 120.2 274.707 119.993C274.363 119.5 261.488 116.175 253.559 116.002C253.551 116.006 244.792 116.903 241.639 117.937Z'
                        fill='var(--center-channel-bg)'
                    />
                </mask>
                <g mask='url(#mask1_521_245590)'>
                    <rect
                        width='68.4423'
                        height='67.0726'
                        transform='matrix(-1 0 0 1 283.906 115.984)'
                        fill='url(#pattern0)'
                    />
                    <rect
                        width='59.9831'
                        height='77.5231'
                        transform='matrix(-1 0 0 1 283.906 115.984)'
                        fill='url(#pattern1)'
                    />
                </g>
                <path
                    d='M282.345 156.507C282.84 154.698 283.335 152.889 283.832 151.08C283.855 151.011 283.904 150.953 283.969 150.918C284.034 150.884 284.11 150.875 284.181 150.894C284.253 150.914 284.314 150.959 284.352 151.022C284.39 151.084 284.403 151.159 284.387 151.23C283.891 153.039 283.396 154.849 282.901 156.659C282.879 156.73 282.83 156.789 282.764 156.825C282.698 156.86 282.621 156.869 282.549 156.849C282.476 156.83 282.415 156.783 282.377 156.719C282.339 156.655 282.328 156.579 282.345 156.507V156.507Z'
                    fill='#1D1400'
                />
                <path
                    d='M284.618 149.563L284.756 148.932C284.779 148.863 284.828 148.805 284.894 148.77C284.959 148.736 285.035 148.727 285.106 148.747C285.177 148.766 285.238 148.811 285.277 148.874C285.315 148.936 285.327 149.011 285.312 149.082L285.173 149.715C285.152 149.787 285.103 149.849 285.037 149.886C284.971 149.923 284.893 149.933 284.82 149.915C284.748 149.891 284.689 149.842 284.653 149.776C284.618 149.711 284.608 149.635 284.627 149.563H284.618Z'
                    fill='#1D1400'
                />
            </g>
            <path
                d='M233.12 120.964C228.891 122.294 215.075 126.915 211.861 130.289C200.489 142.227 195.85 174.384 195.491 177.379C194.971 181.584 196.148 191.059 200.489 193.719C202.867 195.177 209.91 190.489 213.562 186.689C218.651 181.394 221.126 167.833 222.147 160.599C224.019 147.333 233.12 120.964 233.12 120.964Z'
                fill='#FFE099'
            />
            <path
                d='M252.007 116.212L228.533 114.812C228.533 114.812 227.764 111.599 230.004 107.871C231.298 105.716 233.612 104.544 235.131 101.572C236.589 98.7219 236.402 95.4253 236.987 92.5049C238.234 86.265 242.816 81.2754 245.115 80.2114C250.627 77.6596 252.007 116.212 252.007 116.212Z'
                fill='#1D1400'
            />
            <path
                d='M259.548 114.843C262.539 117.325 260.776 130.261 254.046 130.261C246.673 130.261 247.176 112.21 246.644 112.102C244.198 111.629 241.688 110.333 240.128 104.575C239.905 103.755 239.901 103.245 239.757 102.468C239.682 102.071 239.109 96.6673 239.269 90.7505C239.34 88.06 242.047 79.7966 251.827 81.898C264.054 84.5239 261.949 96.2436 260.759 98.7574C260.061 100.23 259.073 103.865 258.908 105.812C258.706 108.159 259.213 114.564 259.548 114.843Z'
                fill='#674600'
            />
            <path
                opacity='0.3'
                d='M246.665 112.084C247.201 112.183 247.745 112.234 248.29 112.236C249.665 112.234 251.023 111.925 252.262 111.333H252.277C252.306 111.32 252.335 111.309 252.365 111.299C252.9 111.136 253.177 111.924 252.671 112.16C251.672 112.636 250.75 113.257 249.937 114.003C249.103 114.778 248.447 115.722 248.015 116.769C247.741 117.291 247.517 117.837 247.346 118.4C246.913 114.995 246.861 112.169 246.654 112.11L246.665 112.084Z'
                fill='black'
            />
            <path
                d='M260.39 80.8152C255.745 76.7129 249.206 78.2976 246.355 79.544C241.459 81.6873 239.972 86.6655 239.972 86.6655C241.107 88.0544 240.617 89.3028 241.878 91.0072C243.35 93.0003 245.159 91.334 248.17 93.7452C249.402 94.7452 250.403 95.9943 251.106 97.4085C251.106 97.4085 252.119 95.4039 253.349 95.421C254.759 95.4419 255.608 96.7511 255.218 98.0811C254.936 99.0407 253.824 101.256 253.824 101.256L258.233 112.41C258.688 113.561 259.546 114.512 260.651 115.091C261.756 115.67 263.035 115.838 264.254 115.564L290.412 107.266C287.945 101.684 283.833 100.983 280.69 98.3149C277.614 95.6966 276.829 93.0193 274.259 91.0205C271.227 88.6606 266.494 87.2887 265.163 85.9777C261.382 82.2497 263.331 83.4126 260.39 80.8152Z'
                fill='#1D1400'
            />
            <mask
                id='mask2_521_245590'
                style={{
                    maskType: 'alpha',
                }}
                maskUnits='userSpaceOnUse'
                x='239'
                y='78'
                width='52'
                height='38'
            >
                <path
                    d='M260.39 80.8152C255.745 76.7129 249.206 78.2976 246.355 79.544C241.459 81.6873 239.972 86.6655 239.972 86.6655C241.107 88.0544 240.617 89.3028 241.878 91.0072C243.35 93.0003 245.159 91.334 248.17 93.7452C249.402 94.7452 250.403 95.9943 251.106 97.4085C251.106 97.4085 252.119 95.4039 253.349 95.421C254.759 95.4419 255.608 96.7511 255.218 98.0811C254.936 99.0407 253.824 101.256 253.824 101.256L258.233 112.41C258.688 113.561 259.546 114.512 260.651 115.091C261.756 115.67 263.035 115.838 264.254 115.564L290.412 107.266C287.945 101.684 283.833 100.983 280.69 98.3149C277.614 95.6966 276.829 93.0193 274.259 91.0205C271.227 88.6606 266.494 87.2887 265.163 85.9777C261.382 82.2497 263.331 83.4126 260.39 80.8152Z'
                    fill='#1D1400'
                />
            </mask>
            <g mask='url(#mask2_521_245590)'>
                <rect
                    width='42.8726'
                    height='37.6215'
                    transform='matrix(-1 0 0 1 290.443 78.1716)'
                    fill='url(#pattern2)'
                />
            </g>
            <path
                d='M243.958 129.536C245.006 126.675 245.688 123.758 244.785 120.845C243.593 116.967 242.156 116.789 238.502 114.955C234.847 113.122 234.232 112.082 232.002 108.168C231.477 107.245 230.929 107.44 230.819 108.14C230.723 108.755 230.819 110.04 230.819 110.04C230.819 110.04 229.281 105.29 228.704 105.1C227.595 104.733 227.316 107.053 227.166 107.57C226.505 109.859 226.974 110.99 228.512 115.17C229.514 117.889 231.704 121.159 234.193 122.717C235.155 123.317 236.308 124.03 236.375 125.567C236.4 126.156 235.97 126.667 235.626 127.148C233.62 129.939 217.498 148.735 215.147 150.964C207.487 158.226 200.882 163.664 197.752 173.688C196.377 178.095 197.559 189.459 198.713 191.929C201.404 197.686 211.209 190.029 215.247 184.899C224.219 173.495 240.39 139.293 243.958 129.536Z'
                fill='#674600'
            />
            <mask
                id='mask3_521_245590'
                style={{
                    maskType: 'alpha',
                }}
                x='197'
                y='105'
                width='49'
                height='89'
            >
                <path
                    d='M243.958 129.536C245.006 126.675 245.688 123.758 244.785 120.845C243.593 116.967 242.156 116.789 238.502 114.955C234.847 113.122 234.232 112.082 232.002 108.168C231.477 107.245 230.929 107.44 230.819 108.14C230.723 108.755 230.819 110.04 230.819 110.04C230.819 110.04 229.281 105.29 228.704 105.1C227.595 104.733 227.316 107.053 227.166 107.57C226.505 109.859 226.974 110.99 228.512 115.17C229.514 117.889 231.704 121.159 234.193 122.717C235.155 123.317 236.308 124.03 236.375 125.567C236.4 126.156 235.97 126.667 235.626 127.148C233.62 129.939 217.498 148.735 215.147 150.964C207.487 158.226 200.882 163.664 197.752 173.688C196.377 178.095 197.559 189.459 198.713 191.929C201.404 197.686 211.209 190.029 215.247 184.899C224.219 173.495 240.39 139.293 243.958 129.536Z'
                    fill='#674600'
                />
            </mask>
            <g mask='url(#mask3_521_245590)'>
                <rect
                    width='30.1838'
                    height='61.7524'
                    transform='matrix(-1 0 0 1 245.263 104.962)'
                    fill='url(#pattern3)'
                />
            </g>
            <path
                d='M197.367 173.687C200.497 163.663 207.487 158.225 215.147 150.962C215.612 150.522 216.612 149.442 217.934 147.957C218.015 148.046 218.094 148.147 218.175 148.224C220.897 151.211 224.257 153.355 228.037 154.774C229.346 155.266 231.765 155.749 233.12 155.931C227.407 167.389 220.676 179.739 216.079 185.572C212.042 190.703 201.018 197.678 198.328 191.92C197.175 189.458 195.992 178.094 197.367 173.687Z'
                fill='#FFE099'
            />
            <path
                d='M273.738 183.894C271.812 184.859 269.942 185.93 268.138 187.102C265.494 188.855 257.827 188.399 257.827 188.399C257.827 188.399 253.915 196.556 253.511 193.788C253.301 192.346 253.926 191.493 254.113 190.054C253.317 191.09 252.834 191.645 252.44 192.886C252.046 194.126 252.188 195.244 252.365 196.496C252.5 197.436 252.023 197.86 251.525 197.904C250.564 197.985 250.372 196.902 249.891 196.748C245.788 195.418 246.634 193.913 246.271 190.203C246.302 194.721 246.557 194.341 248.416 196.938C248.789 197.459 248.095 198.078 246.302 197.064C244.892 196.241 243.939 195.354 243.289 193.264C242.585 191.096 242.75 188.744 243.75 186.693C245.975 182.196 247.745 180.698 252.775 180.09C257.804 179.482 263.61 179.036 267.194 180.28C268.586 180.765 273.738 183.894 273.738 183.894Z'
                fill='#674600'
            />
            <path
                d='M203.618 161.988C207.957 157.006 212.413 152.129 216.983 147.357C217.037 147.309 217.107 147.282 217.18 147.283C217.253 147.283 217.323 147.311 217.376 147.361C217.429 147.411 217.46 147.478 217.465 147.55C217.47 147.622 217.446 147.693 217.4 147.748C212.831 152.525 208.376 157.402 204.035 162.379C203.793 162.658 203.375 162.265 203.618 161.988Z'
                fill='#1D1400'
            />
            <path
                d='M221.264 177.072L221.136 177.2C221.081 177.252 221.008 177.281 220.932 177.281C220.856 177.281 220.783 177.252 220.728 177.2C220.674 177.146 220.644 177.074 220.644 176.998C220.644 176.923 220.674 176.85 220.728 176.797L220.857 176.669C220.883 176.641 220.915 176.619 220.95 176.603C220.986 176.588 221.024 176.579 221.063 176.579C221.101 176.578 221.14 176.585 221.176 176.599C221.212 176.614 221.244 176.635 221.272 176.662C221.299 176.689 221.321 176.722 221.335 176.757C221.35 176.792 221.357 176.83 221.356 176.869C221.355 176.907 221.347 176.945 221.331 176.98C221.315 177.015 221.293 177.046 221.264 177.072V177.072Z'
                fill='var(--center-channel-bg)'
            />
            <path
                d='M221.209 177.491C225.359 170.616 229.246 163.596 232.871 156.43C233.036 156.103 233.534 156.39 233.369 156.719C229.747 163.878 225.859 170.899 221.707 177.779C221.668 177.845 221.604 177.892 221.53 177.911C221.456 177.93 221.378 177.919 221.311 177.881C221.245 177.843 221.198 177.78 221.178 177.707C221.159 177.634 221.17 177.556 221.209 177.491V177.491Z'
                fill='#1D1400'
            />
            <path
                d='M231.064 110.225C231.417 111.176 231.886 112.08 232.46 112.919C232.667 113.223 232.167 113.51 231.962 113.206C231.364 112.324 230.875 111.374 230.506 110.377C230.379 110.031 230.935 109.883 231.064 110.225V110.225Z'
                fill='black'
            />
            <path
                d='M232.789 114.201H232.692C232.616 114.201 232.543 114.171 232.488 114.118C232.434 114.064 232.404 113.992 232.404 113.916C232.404 113.84 232.434 113.768 232.488 113.714C232.543 113.661 232.616 113.631 232.692 113.631H232.789C232.865 113.631 232.938 113.661 232.992 113.714C233.047 113.768 233.077 113.84 233.077 113.916C233.077 113.992 233.047 114.064 232.992 114.118C232.938 114.171 232.865 114.201 232.789 114.201Z'
                fill='black'
            />
            <path
                d='M228.324 108.888C228.658 110.59 229.302 112.218 230.223 113.694C230.415 114.007 229.919 114.292 229.725 113.98C228.777 112.463 228.114 110.79 227.768 109.04C227.695 108.681 228.253 108.527 228.324 108.888V108.888Z'
                fill='black'
            />
            <path
                d='M230.385 114.772C230.308 114.772 230.235 114.742 230.181 114.688C230.127 114.635 230.097 114.562 230.097 114.487C230.097 114.411 230.127 114.339 230.181 114.285C230.235 114.232 230.308 114.202 230.385 114.202C230.461 114.202 230.535 114.232 230.589 114.285C230.643 114.339 230.673 114.411 230.673 114.487C230.673 114.562 230.643 114.635 230.589 114.688C230.535 114.742 230.461 114.772 230.385 114.772Z'
                fill='black'
            />
            <path
                d='M253.901 187.885L254.44 186.728C254.595 186.396 255.093 186.684 254.937 187.015C254.759 187.395 254.58 187.781 254.399 188.172C254.243 188.505 253.747 188.216 253.901 187.885Z'
                fill='#1D1400'
            />
            <path
                d='M247.682 185.135C247.007 186.646 246.747 188.264 246.705 189.906C246.676 190.557 246.687 191.209 246.738 191.859C246.832 192.821 247.418 193.429 248.083 194.073C248.351 194.329 247.941 194.732 247.676 194.476C247.145 193.968 246.586 193.425 246.33 192.724C246.046 191.964 246.113 191.044 246.121 190.254C246.14 188.392 246.417 186.57 247.182 184.856C247.332 184.521 247.828 184.81 247.68 185.143L247.682 185.135Z'
                fill='#1D1400'
            />
            <path
                d='M249.824 190.192C249.591 191.226 249.536 192.292 249.662 193.344C249.705 193.707 249.128 193.705 249.085 193.344C248.957 192.241 249.018 191.123 249.268 190.04C249.349 189.683 249.906 189.835 249.824 190.192V190.192Z'
                fill='#1D1400'
            />
            <path
                d='M249.978 187.558C250.132 186.867 250.204 186.161 250.191 185.454C250.191 185.088 250.768 185.088 250.768 185.454C250.78 186.213 250.701 186.97 250.533 187.71C250.452 188.067 249.897 187.915 249.978 187.558V187.558Z'
                fill='#1D1400'
            />
            <path
                d='M246.619 97.2094H246.673C246.879 97.2094 247.077 97.2904 247.223 97.4347C247.369 97.5791 247.451 97.7748 247.451 97.9789C247.451 98.183 247.369 98.3787 247.223 98.523C247.077 98.6673 246.879 98.7484 246.673 98.7484H246.619C246.412 98.7484 246.214 98.6673 246.068 98.523C245.922 98.3787 245.84 98.183 245.84 97.9789C245.84 97.7748 245.922 97.5791 246.068 97.4347C246.214 97.2904 246.412 97.2094 246.619 97.2094V97.2094Z'
                fill='black'
            />
            <path
                d='M241.14 98.5249H241.195C241.402 98.5249 241.6 98.6059 241.745 98.75C241.891 98.8941 241.973 99.0896 241.973 99.2935C241.973 99.4973 241.891 99.6928 241.745 99.8369C241.6 99.9811 241.402 100.062 241.195 100.062H241.14C240.933 100.062 240.736 99.9811 240.59 99.8369C240.444 99.6928 240.362 99.4973 240.362 99.2935C240.362 99.0896 240.444 98.8941 240.59 98.75C240.736 98.6059 240.933 98.5249 241.14 98.5249V98.5249Z'
                fill='black'
            />
            <path
                d='M248.514 104.964C247.734 105.812 246.831 106.543 245.836 107.134C246.338 107.802 247.436 107.84 248.086 107.312C248.735 106.784 248.943 105.841 248.732 105.032'
                fill='black'
            />
            <path
                d='M244.173 104.496C243.597 104.369 242.291 104.35 242.199 103.561C242.135 103.014 242.71 102.287 242.887 101.798C243.212 100.95 243.396 100.056 243.433 99.1495C243.433 98.7277 244.106 98.7258 244.098 99.1495C244.051 100.329 243.778 101.49 243.295 102.57C243.22 102.743 242.985 103.056 242.976 103.246C242.951 103.732 243.022 103.485 243.36 103.637C243.65 103.769 244.041 103.788 244.354 103.856C244.773 103.947 244.594 104.584 244.177 104.491L244.173 104.496Z'
                fill='black'
            />
            <path
                opacity='0.3'
                d='M235.626 127.147C238.241 125.353 238.702 122.587 235.626 120.964C232.55 119.341 229.014 116.362 229.014 116.362C229.014 116.362 230.704 120.922 234.194 122.712C237.683 124.502 235.626 127.147 235.626 127.147Z'
                fill='black'
            />
            <path
                d='M180.272 22.0923H142.145C140.736 22.0922 139.383 22.6505 138.383 23.6454C137.383 24.6403 136.815 25.9911 136.805 27.4033V51.6844C136.815 53.0967 137.383 54.4475 138.383 55.4423C139.383 56.4372 140.736 56.9955 142.145 56.9955H147.773V66.0992L156.225 56.9955H180.258C181.668 56.9955 183.02 56.4372 184.021 55.4423C185.021 54.4475 185.589 53.0967 185.599 51.6844V27.4033C185.589 25.9934 185.023 24.6446 184.025 23.6501C183.028 22.6556 181.679 22.0958 180.272 22.0923V22.0923Z'
                fill='#1C58D9'
            />
            <path
                d='M140.764 32.2531C141.153 30.8753 141.811 29.5888 142.7 28.4681C143.589 27.3473 144.692 26.4148 145.944 25.7246C146.018 25.6873 146.078 25.6264 146.114 25.5514C146.149 25.4764 146.159 25.3917 146.142 25.3105C146.124 25.2293 146.08 25.1562 146.016 25.1028C145.953 25.0494 145.873 25.0188 145.791 25.0156C143.387 24.8684 138.534 25.3835 140.056 32.2062C140.079 32.2795 140.124 32.344 140.184 32.3915C140.244 32.4389 140.317 32.467 140.394 32.4721C140.47 32.4771 140.546 32.4589 140.612 32.4199C140.678 32.3808 140.731 32.3226 140.764 32.2531V32.2531Z'
                fill='var(--center-channel-bg)'
                fillOpacity='0.16'
            />
            <path
                d='M174.236 36.0725C174.915 36.0725 175.578 36.2742 176.143 36.652C176.707 37.0297 177.147 37.5667 177.407 38.195C177.666 38.8232 177.734 39.5145 177.602 40.1814C177.469 40.8484 177.143 41.461 176.663 41.9418C176.183 42.4226 175.571 42.7501 174.906 42.8828C174.24 43.0154 173.55 42.9473 172.923 42.6871C172.296 42.4269 171.76 41.9862 171.383 41.4208C171.006 40.8554 170.805 40.1907 170.805 39.5107C170.805 38.5988 171.166 37.7243 171.81 37.0795C172.454 36.4348 173.326 36.0725 174.236 36.0725V36.0725Z'
                fill='var(--center-channel-bg)'
            />
            <path
                d='M161.212 36.0725C161.891 36.0725 162.554 36.2742 163.119 36.652C163.683 37.0297 164.123 37.5667 164.382 38.195C164.642 38.8232 164.71 39.5145 164.578 40.1814C164.445 40.8484 164.118 41.461 163.639 41.9418C163.159 42.4226 162.547 42.7501 161.882 42.8828C161.216 43.0154 160.526 42.9473 159.899 42.6871C159.272 42.4269 158.736 41.9862 158.359 41.4208C157.982 40.8554 157.781 40.1907 157.781 39.5107C157.781 38.5988 158.142 37.7243 158.786 37.0795C159.429 36.4348 160.302 36.0725 161.212 36.0725Z'
                fill='var(--center-channel-bg)'
            />
            <path
                d='M148.187 36.0725C148.865 36.0725 149.529 36.2742 150.093 36.652C150.658 37.0297 151.097 37.5667 151.357 38.195C151.617 38.8232 151.685 39.5145 151.552 40.1814C151.42 40.8484 151.093 41.461 150.613 41.9418C150.133 42.4226 149.522 42.7501 148.856 42.8828C148.191 43.0154 147.501 42.9473 146.874 42.6871C146.247 42.4269 145.711 41.9862 145.334 41.4208C144.957 40.8554 144.755 40.1907 144.755 39.5107C144.755 38.5988 145.117 37.7243 145.76 37.0795C146.404 36.4348 147.277 36.0725 148.187 36.0725V36.0725Z'
                fill='var(--center-channel-bg)'
            />
            <path
                d='M31.2452 105.929C31.2452 105.929 29.9937 93.2228 32.5488 82.359C34.5041 73.9124 39.8814 66.7199 42.7167 66.5958C49.1825 66.3083 53.6473 62.9702 56.4761 66.23C58.8161 69.2088 61.1821 85.8867 57.5125 88.8198C56.0997 89.7711 54.5845 90.56 52.9956 91.1715L52.5132 105.909L31.2452 105.929Z'
                fill='#CB8E00'
            />
            <path
                d='M57.5843 71.9193C60.3545 76.0675 62.1469 79.1052 62.1469 79.1052C62.199 80.7253 56.75 81.0062 56.75 81.0062L57.5843 71.9193Z'
                fill='#CB8E00'
            />
            <path
                d='M48.6544 90.7274C50.8977 91.0195 53.1782 90.7755 55.3093 90.0154C56.1176 89.7214 53.7515 91.1129 52.9368 91.4068C50.5577 92.2561 51.0531 92.3802 48.5372 92.0601C47.6964 91.9686 47.7941 90.6229 48.6544 90.7274Z'
                fill='#332660'
            />
            <path
                d='M31.6038 60.0555C29.8765 60.5651 28.7033 62.1786 27.9863 63.8248C27.2693 65.4711 26.8456 67.261 25.9331 68.8158C24.8968 70.5796 23.2542 71.9645 22.4395 73.8394C21.6248 75.7142 22.1396 78.471 24.1276 78.9413C25.4834 79.2549 26.9238 78.3599 28.2665 78.7388C30.2219 79.3072 30.5022 82.0051 30.0068 84.0302C29.5115 86.0553 28.7032 88.3026 29.9025 89.9945C31.2061 91.9151 34.426 91.5624 35.9642 89.7986C37.5025 88.0348 37.7046 85.487 37.4569 83.168C37.2092 80.8489 36.5704 78.5429 36.7138 76.2107C36.7855 74.9042 37.3656 73.3886 38.6301 73.1796C39.8945 72.9705 40.8983 74.2248 41.1004 75.4529C41.3024 76.681 40.9505 77.9222 40.8919 79.17C40.8332 80.4177 41.1721 81.8353 42.2737 82.4363C44.0009 83.3443 46.028 81.3192 46.1062 79.3594C46.1844 77.3996 45.135 75.6097 44.5744 73.7348C44.0139 71.86 44.1508 69.4233 45.878 68.4695C46.9535 67.862 48.2897 68.0711 49.4955 68.3258C50.7013 68.5806 52.0114 68.9072 53.1455 68.4108C63.3787 63.9228 67.1918 59.5198 61.091 54.5224C57.1281 51.2561 44.1442 48.2315 40.5007 53.0264C39.0016 54.9862 40.2204 58.2003 37.8023 59.5591C35.9642 60.5651 33.5461 59.4872 31.6038 60.0555Z'
                fill='#1A0C00'
            />
            <path
                d='M60.4653 103.969C83.1412 107.765 96.0598 107.484 109.35 99.279C122.64 91.074 128.363 66.9883 130.657 54.4391C132.951 41.8899 149.136 39.8714 143.693 44.8558C138.251 49.8402 140.258 48.3572 138.075 57.5356C135.891 66.7139 140.942 107.569 119.883 124.116C98.5041 140.911 69.9881 147.104 51.0599 144.642C32.1318 142.179 60.4653 103.969 60.4653 103.969Z'
                fill='#CB8E00'
            />
            <path
                d='M94.8801 140.656C92.84 141.453 90.8129 142.126 88.7663 142.707C87.554 143.06 86.3395 143.376 85.1228 143.654C76.3298 145.586 67.2966 146.178 58.3275 145.411C55.792 145.235 53.3673 144.974 51.0665 144.667C37.1832 142.857 48.7461 121.803 55.8833 110.697C58.4904 106.673 60.4458 103.975 60.4458 103.975C61.241 104.112 62.0427 104.243 62.8379 104.361C63.809 104.517 64.7933 104.668 65.7188 104.798C71.7256 105.774 77.7992 106.279 83.8844 106.307C85.1162 106.307 86.322 106.262 87.5018 106.183C88.3752 106.118 89.2486 106.046 90.109 105.948C92.0513 116.479 94.8345 140.499 94.8801 140.656Z'
                fill='#1E325C'
            />
            <mask
                id='mask4_521_245590'
                style={{
                    maskType: 'alpha',
                }}
                maskUnits='userSpaceOnUse'
                x='0'
                y='38'
                width='96'
                height='174'
            >
                <path
                    d='M96 38H0V212H96V38Z'
                    fill='#E8E9ED'
                />
            </mask>
            <g mask='url(#mask4_521_245590)'>
                <path
                    d='M63.822 211.188C49.4825 216.891 5.6297 207.334 -18.3042 201.389C-21.1265 200.677 -23.6685 200.037 -25.8585 199.469C-31.1576 198.103 -34.384 197.195 -34.384 197.195C-34.384 197.195 -30.4733 190.976 -18.7409 160.521C-16.6943 155.21 -14.4195 149.167 -11.884 142.289C-9.34857 135.41 -7.21063 129.4 -5.3139 124.291C-4.66211 122.534 -4.0103 120.868 -3.43021 119.307C4.33268 99.2908 8.95387 95.332 28.071 98.0561L28.5142 98.1215C32.0665 98.6572 36.1207 99.3888 40.7876 100.31C46.4582 101.401 51.503 102.133 55.8896 102.851C56.6196 102.956 57.3171 103.08 58.0015 103.197C58.7967 103.328 59.5527 103.465 60.3088 103.609C60.9606 103.739 61.6124 103.864 62.2642 104.007C76.5189 107.006 81.1206 112.5 75.1958 140.806C75.085 141.269 74.9937 141.759 74.9025 142.217C66.7681 181.053 63.822 211.188 63.822 211.188Z'
                    fill='#1E325C'
                />
                <path
                    d='M57.9428 103.205C57.2218 104.3 56.2832 105.234 55.1857 105.949C51.1576 108.562 46.8362 110.286 41.9803 109.555C37.2352 108.836 33.2333 106.138 30.046 102.623C28.8622 101.379 28.1418 99.7645 28.0059 98.0507C28.977 98.1878 29.9613 98.3447 31.0302 98.5145C33.1876 97.4824 38.7278 98.018 42.2997 98.717C46.6015 99.5532 50.7731 99.2984 52.5264 102.31C54.4362 102.663 56.2416 102.911 57.9428 103.205Z'
                    fill='#CB8E00'
                />
            </g>
        </g>
        <defs>
            <pattern
                id='pattern0'
                patternContentUnits='objectBoundingBox'
                width='1'
                height='1'
            >
                <use
                    xlinkHref='#image0_521_245590'
                    transform='scale(0.00280899)'
                />
            </pattern>
            <pattern
                id='pattern1'
                patternContentUnits='objectBoundingBox'
                width='1'
                height='1'
            >
                <use
                    xlinkHref='#image1_521_245590'
                    transform='scale(0.00320513 0.00245098)'
                />
            </pattern>
            <pattern
                id='pattern2'
                patternContentUnits='objectBoundingBox'
                width='1'
                height='1'
            >
                <use
                    xlinkHref='#image2_521_245590'
                    transform='scale(0.0044843 0.00505051)'
                />
            </pattern>
            <pattern
                id='pattern3'
                patternContentUnits='objectBoundingBox'
                width='1'
                height='1'
            >
                <use
                    xlinkHref='#image3_521_245590'
                    transform='scale(0.00636943 0.00307692)'
                />
            </pattern>
            <clipPath id='clip0_521_245590'>
                <rect
                    width='308'
                    height='220'
                    rx='100'
                    fill='var(--center-channel-bg)'
                />
            </clipPath>
            <clipPath id='clip1_521_245590'>
                <rect
                    width='34.8897'
                    height='42.8632'
                    fill='var(--center-channel-bg)'
                    transform='translate(143.875 168.912)'
                />
            </clipPath>
            <image
                id='image0_521_245590'
                width='356'
                height='353'
                xlinkHref='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWQAAAFhCAYAAABH1tCTAAAgAElEQVR4Xu2de68ty3XVO0CAACHBGOOExI5JBAriIcT3/wbwTyQCQQRiEgR2giHEEB42Rr/jHjfz1KnqmtVdvVattUdLW+fevarrMar36LlGzcfPbL6MgBEwAkZgCQR+ZolZeBJGwAgYASOwmZD9EBgBI2AEFkHAhLzIRngaRsAIGAETsp8BI2AEjMAiCJiQF9kIT8MIGAEjYEL2M2AEjIARWAQBE/IiG+FpGAEjYARMyH4GjIARMAKLIGBCXmQjPA0jYASMgAnZz4ARMAJGYBEETMiLbISnYQSMgBEwIfsZMAJGwAgsgoAJeZGN8DSMgBEwAiZkPwNGwAgYgUUQMCEvshGehhEwAkbAhOxnwAgYASOwCAIm5EU2wtMwAkbACJiQ/QwYASNgBBZBwIS8yEZ4GkbACBgBE7KfASNgBIzAIgiYkBfZCE/DCBgBI2BC9jNgBIyAEVgEARPyIhvhaRgBI2AETMh+BoyAETACiyBgQl5kIzwNI2AEjIAJ2c+AETACRmARBEzIi2yEp2EEjIARMCH7GTACRsAILIKACXmRjfA0jIARMAImZD8DRsAIGIFFEDAhL7IRnoYRMAJGwITsZ8AIGAEjsAgCJuRFNsLTMAJGwAiYkP0MGAEjYAQWQcCEvMhGeBpGwAgYAROynwEjYASMwCIImJAX2QhPwwgYASNgQvYzYASMgBFYBAET8iIb4WkYASNgBEzIfgaMgBEwAosgYEJeZCM8DSNgBIyACdnPgBEwAkZgEQRMyItshKdhBIyAETAh+xkwAkbACCyCgAl5kY3wNIyAETACJmQ/A0bACBiBRRAwIS+yEZ6GETACRsCE7GfACBgBI7AIAibkRTbC0zACRsAImJD9DBgBI2AEFkHAhLzIRngaRsAIGAETsp8BI2AEjMAiCJiQF9kIT8MIGAEjYEL2M2AEjIARWAQBE/IiG+FpGAEjYARMyH4GjIARMAKLIGBCXmQjPA0jYASMgAnZz4ARMAJGYBEETMiLbISnYQSMgBEwIfsZMAJGwAgsgoAJeZGN8DSMgBEwAiZkPwNGwAgYgUUQMCEvshGehhEwAkbAhOxnwAgYASOwCAIm5EU2wtMwAkbACJiQ/QwYASNgBBZBwIS8yEZ4GkbACBgBE7KfASNgBIzAIgiYkBfZCE/DCBgBI2BC9jNgBIyAEVgEARPyIhvhaRgBI2AETMh+BoyAETACiyBgQl5kIzwNI2AEjIAJ2c+AETACRmARBEzIi2yEp2EEjIARMCH7GTACRsAILIKACXmRjfA0jIARMAImZD8DRsAIGIFFEDAhL7IRnoYRMAJGwITsZ8AIGAEjsAgCJuRFNsLTMAJGwAiYkP0MGAEjYAQWQcCEvMhGeBpGwAgYAROynwEjYASMwCIImJAX2QhPwwgYASNgQvYzYASMgBFYBAET8iIb4WkYASNgBEzIfgaMgBEwAosgYEJeZCM8DSNgBIyACdnPgBFYC4G/sG3b39yn9Ifbtv2/tab32WyY689v2/a/tm3704Xn+TJTMyG/zFZ5oh8EgV/Ytu0X97X+YNu2P1l43b+0bdtf3F8av7/wPF9maibkl9kqT/SDIADB/e1t2/7ctm3/Zdu2Hy68bub5l7dt+9G2bf9x4Xm+zNRMyC+zVZ7oB0IAMuYHortyISlgbf/vmyxt+ucHycLXBARMyBNAdBdGYFEEZMEyPSzYqwS/6DLfZ1om5PfZS6/ECJQI/PVt2/6GJYXXeTBMyK+zV56pETiDANLHyp4aZ9b0tveYkN92a70wI2AEXg0BE/Kr7ZjnawSMwNsiYEJ+2631woyAEXg1BEzIr7Zjnq8RMAJvi4AJ+W231gszAkbg1RAwIb/ajnm+RsAIvC0CJuS33VovzAgYgVdDwIT8ajvm+RqBdRAgERJ+zn9sX+c5m2JCnoOjezECHw0BkgoRms31R9u2/Y+PBsAd6zUh34Gq+zQC748AlvHf2Zf5n5wnY86Gm5Dn4OhejMBHRABS5nJo9qTdNyFPAtLdGIEXROAv7XMmPaevBRAwIS+wCZ7CyyPwc9u2fX3btv+5J5W/uiAytJGpLVMx5GzyIBLhU/GDi3zG/HA45+uJCJiQnwi+h34bBESgLGhG3mG0WRK//59t29BnWxdtOFjj3wx5x37ioZx+/90FdoSXGy+jD/mCMCEv8AR6Ci+PANYmhUnRUr83YTWQ5V/btu2/76Tc6jKSKm3/6+DYf2UvwYR0AflTMurZl+r0MY8VXhAPxcOE/FC4PZgRmIpAJOTV6+9lF/6hk+qbkLOPidsZgTURwMr9ybZtf7rm9E7NCgmGbxsfznvDhHzqefFNRuCtEPj5nfwc3PHkbTUhP3kDPLwReDICf3X3EGEamYg7VbKGvN/JKn/yNvx0eBPyEtvgSRiBpyHA4SEHklwZHVoeIMgJeJS0ZAXc8TgsNGkPbK0JeQAsNzUCb4oApPzjJHn+6p5Q6Ec7IbcgEXH/tyf6N/NS+Nlt214m8MWE/KZ/YV6WEbgJASQLDhIJgoGUW5eI+4dPdKfTSwGf5hnuiDdB+mfdmpBvh9gDGIGHI0BwxTcSgSV3TgzfbNzyIORneEtgHfNS4OpZ83fiMNS3CXkILjc2Ai+BwOzIwZdYdGWSv7htGy+nP9lfDMuvw4S8/BZ5gkZgGAF5QhB9RwTfyhcHiopKHI00XHldp+ZmQj4Fm28yAsshAAkfabp3TZhx/9beOfIE1ujIlc3bMdLny7Y1Ib/s1nniRuArBEayw82GLfoxnzk8I1SaPl5GVpgNYOzPhHwnuu7bCLQR4NALfZMAi9Kyxeokeo5DMbwDeodiWW8C+sU3GDewWdY0h2fKOEf6ztUlkqWfSRPy0tvjyb0xAkckGq3O/5zwo8UNjZ9edjiNicvaH74xti+7NBPyy26dJ/7iCBwRMlYnuixJgwhn7lnIWSjkG3xGWsiO4XYXEDAhXwDPtxqBCwhIPiC0eBbh9qbzjDF7c/LnAQETsh8HI2AEXhEBdGu+SZB/A/e+t7hMyG+xjV6EEXgKAhAiejcW/iNTd2LpI/lwPTNXxnTQTcjTIXWHRuDtECBBD3p26ZkRIwKp/fdISxWNHWLmcHKWx8jTN86E/PQt8ATeAAHV1MN74RUqN+P7i8sdX/d7ZHbk8aEoO7YwU9xVFjVjOi1n5cE3Ib8BG3gJT0dAxMRX998fmA2kiJU3Gt2mIbgXwsQyzRJc/LpfZmJTyDV9SYJQjTvGxBrlpRPHx1+a9nhuxKuW+lIW9ShOA5C+dlMT8mvvn2c/hgCEoyCG7w+QWG8UcjFANvgBZy1kZWSj7x+cJGXWQvBIL1l8SZRUdgYLckfEQI5o8ariM8T69W3b/u9gVetaPmQR8lH2NeZFO14yWSx7+/Myn5uQX2arPNEJCCAtQEZcz8zTy/gQHaTFv6XlmV0qOioBIWfSS9ZyX8ys+NzyeeYFAtm2XP30kgEDvm08yiUwi/mt7UzIt8LrzhdEACsQYl7hMAgy5rpCOhAyBNfTgrNbwZwy80Eq4Wr5UUtOqYWGH81l5kshu+Zl2pmQl9kKT8QIHCLwCztRHunNkCQ5gJEhzurSmW3AysWS5TortxyNk30pZOZatuFFgVzEi2TWS+zMPKr3mJCnQemOjMBtCHBw9rW996PcFsgxWP9nJIyRyUdCzhRGHen77raSRO7G6NQ6TMinYPNNRuChCMTDtiNCxjrGkn6EPo5UgrRRelc8FJgTg5mQT4DmW4yAEfgzBPiaDSmTNpPItEd+3UfTxUKH5N/F66F3sPi0Z88W8tOg98BG4KEIoJvivoZVS1RdeXDH58giJfFGrwe5wl2duKqMMAcOVzOHiFfHfIn7TcgvsU2e5GIIYDX++d1ivINM7jjUQspA0uCqudm1iBcfayzkkShEdGwwwsOiFrAS50J60UfmwVjsUfp8OibkpbfHk1sQgXigdTaxTS2KTUuVDpzNWUxfVAFpRerJ3zhapbWQabmb4UKHBd27GJeXEgEj5aWgkNbBGYSNDzV9MNZy3g69xd/1uQn5LmTd77siEAM6zngYQIx4Q9BPzWVMwR7g15MI4lxqLweRO4SHVdxL/pO1zI/WEOd0tTIJ85d+/SEqUpuQ35U2vK47EYCQIJ4ewdXmEKMF8RcuiUb5JLCQ0XOPLuZARBxXrS8sVX6YJ8l/ZpVt6q0BmYMMcRwCXpF0vh0W33s53bnfD+vbhPwwqD2QEfgKAQgL6QOrtvy6roxo2cAF3M8gcci7JL9vbdv2zf3zf1l4SShnBOOfsT5FugSg3CU5YCGrIvWHKJ5qQjZLGIG1EIiZ47BqS5LNygqsSgdyWNsl6cYsbq1ES5A2OjHudq1rZD6zkZakMZLUafYcpvZnQp4KpzszApcRiN4OZRCIsqXNCFfW4aTc4KKVK79n2nBpPLwjIHmFZuvlMWM+Z4DrHR6e6fOp95iQnwq/BzcCXyAAGXKQhfdCqSFLU816YNA5HhiKqisDO1rJjWJSevrgcA4LW2WT5IlxVDn7EVv7dpKGCfkRj43HMAJzEMBC5kANcswcKMYSS8wgW2YJAsfbgwsLGm8SSJnfYTVD7FjJtIO8o2yh9r0Vq2oJ/bRc9o7cA3v9v+TnJuSX3DZP+s0RUCJ9lplxV1MUHrJD9CFWTmL64bPvVQ7gWvXyIFsurPEjTwkl2seq//FO3Jk8xhlrv5bk/q233oT81tvrxT0IAaxWiGk0929relEyyASfxORDkQzRe/msRcaxgkctnDoDn14eSCNcWO8Zrw3GZn6ytjWWNHQsZ6xovRR4mbz9ZUJ++y32Ak8i0LIca93JkhsppaR+aonc+aouySBTiJQXAgTHV//SPezIC0LzZi4icrndoWE/I5NbtJxZj9wDMxJNb6uXzoXM5E3IvS305x8RAVmO2cOzKA0cpccssYT8VN+uFbJcK7U0a09qRC5rO7v2WXNRPxzUMS9eLLNfCHoBZcPDZ6+t258JuQuRG3xABETI2T9c9FY01Ex6zAhnjHirEaASzisEuVYVevb2aO21yL/aC4WXyl2BIa21nTnsiyHdSyant4U8+1F2f++CwNl6cGfWr8xxtYg3fX0XgUSvCYJGRIT4B3PJrQ3y4QVB362cGUdz5UXRkgjABmkGzfgbeycj3wrOYFTeoxfVqBXPi5MfXjYzJJAZa/msD1vI0yF1h0ZgGgJ8fVcmNx1yQcrRwpOXA4NCjHg6oD9DqvEqPR+4j8PDSE69THPx8BAyVOBItmq25pXxHDkCURLRspbu2SfAhHwWOd9nBJ6DQBnMIS8HpbJUodNydhAoP7KiRWqSQ7Cm+R2h0lz/qpJaM2rleFJA6lia0auipXnzewWWZAm8hfDylu7ZR8OEfBY532cE2gjceRBXGzWSdMzXjLRAtJ8SEHGvsqZF9zIIFbKFlGkLcf9epXI1n+GqBgmXpaQUVs3aW6HUyoGcqRKiwJFsEMxbPI8m5LfYRi9iIQSkb96R3wHihfggxF6VjVg3rpV8Pr44lIdZQSCKzhO0Cj5h7NInuAy1bmm79MHVisyL2yj9/GpO5YUejf5UTMh9jNzCCGQRiF/LRw+cMmPEQ71sGLT6HcnKpuRC3IM1i1Ybx5YejU6NxAH5k+YTouVFgVXLPejf9MHveZH8/d36/p1OBjnmLAs+ExiTwU5t8C+H93yoN4Ka2xqBF0VACW96B1dyYWvVnastX5F3fBa9LLJQQUaSN45SasaDQtW8E0kr+EQ+1JAuZAsJ4ymCZc0VX07IJvRJfmYs8H/RKP2kdUD09JnNi5Fdf1zX6AstO8aldraQL8Hnm43AaQRkAUI6WJy9C1kAEoWssD5bFp48GfCeoL1CulVVWuMcFRdljF/fx0BzrvkZi3DlrUF/0Xc5+lgzJmStUOky61y59pZ7Xw+j3udRWnm0q15vbp8+NyGnYHIjIzAdAem6WI+yKluDQFAQONbpUSmjaJVC2Fix/E4JgpQwiHGO6gHGnMxHliQEi2Qh3+TSlxopQwd56M7ZyDsdTEa3NjDg5dUj895GYXnDe+WhZO++h3xuQn4IzB7ECFQRyOq639lDrCHZf97BUq5ptJUvMkQIWSo/hrLCtbK4RQsVIiXIhLbIEqM18iBrrtFovohN6Wt9JLcwVivP8/KPoQl5+S3yBI3ApwO1jIUMVPLRxQLE0oQQkRIgUizan+yW9hGxQmjcq4g8dHGulszBGJA9pIvlrb7pZ0Zo9VF1k/LxYC54uqgSyugL5KmPmwn5qfB7cCOQQkAEidU7amnWBhjJZIeVLdkB+aI2PjJASdoiRuaekWV6QGSt3uV14qOFmpB7j4E/NwLvhcAZwuqRIaSNBY81qiT4cZxskqYZSMtXmxDyl6tUbUKe8Qi4DyPwOQJYoFiIENWspPVZjHXAltGHcc1DX4Y8ad8LNsnOQTouUguHfljIBHj46iBgQvYjYgTmIsAB2Nf2TGgQHgdQsaxSZrQRSSH2J6v06NCOBEHIC2i96MxKKEQ/Z3ybM+tptVEaTazZGVLMlbmUOJKg/+HBIybkWVvofozATxGQh8LXd68EXNVGCDmWVYIgexekRnAGBKKUmy1yjTKC3NlEyEfVTpRXQt4aNesbHZnDt0yFE63pbBrNHiZXPo8YPfoFZT/kKzvne41ABQFF4GH1YR33ioSWXYiksqklY3vGwpOCqxb40Kqxh2dG68AwJiui31puiRgEMnKAN7rWRzxw8QXVOsS8bR62kG+D1h0bgVMIiNAhtkwgRcwNjESCJKHDtZr0oUi/rDtYrLTBgmqEG0tRjaTWZK1Y9WjXCmTBQuVbRUvCiC52jNW66BdyRZbBB3vkiomZRu673NaEfBlCd2AEnoqA/I4jgSMxQGyQbzbJEaRKAAZWfUmGkCA/HNBBljUyr3licA99ZgumKgH+kVdGNsGSrO8Ri/2pG8ngJuSnb4En8EER0FfjXtTcKDwQI1azLvqHZJWJrdWfyPBM5exWnzEEu6xYwj1lpGKvwCovGpWrgrSP9GraYumSBnWlA8PD/TQhjz7ubm8E5iCgCsj0NvPwKMoH6L2K0GOcmAdDHg4KQ77jBSFCrunhNY8QLGqVrCqt8DJ7XC//x5xdenAvJuQHA+7hjMCOgGQF9NPZAQySGLAiOcjja34pXeiFoEO6K9GArAV5BL0WIkW7huhLjThufozuy6bClAwxolO/1ANnQn6p7fJkH4zAo0sxHX31hzCJgssexsW+akmMdBiY1Zhrc0MfxpsEouTCElb+iqP0nrRVfmWIe8nMaw9+1j4NZ0J+Buoe8xUQuKtixejao0uZLENIT+koY4HRkb7RV5EHzkYSSnJQ8iD+jRnmmNdsy39kfS/Z1oT8ktvmST8AAX2lf2QehtaylL1MxUF1+EX7mfoz/ansEpavvCrivJRsSGk1+QzJQYSM1wf/nSFjJSDCsj5r/fceBXmPPCXyrje58nMT8ihibv9REMCCRH+FWB4eQruTWssNTaQoIjvak/Lw7qitrF6VekJOKKWH+DLQCyLjL10bV0n6+awlcTAnrl6ejVYCpDjfmqeH5lWrI/jwZ92E/HDIPaARSCGgA6wRCx3rFmIRecUUmJlioYrkox+4AaKNZZmYOC8DSE5uZ6nFNBpJemGeNRe2GMZ8VMVb62QYLO34AlU1bVnyrZdrTIL/NN9lE/KVx8n3GoH7EBgNK44hziLfsq7dkYWolSj0mv9XLuMzB4kzkIlrOio5FT02Sg8MyBpiZ138d4vY+YxzA9bMWE/JTmdCnvHYuA8jMB8Bpe/MJqWP1mS0au8qGDprxdKsCVypXZAy15EsonBqhYzX+lnpTKCJnQl51mPlfoxAHgEFYWRkhGyvMUKv/Mr9d/dO/uBmPZyv/cyjpvfKAsXylGdItOC/v0cTZtc72g7MeWkx9lOs38yETcgZlNzGCMxFQNZaNqNbdnSsYbwcIunEr/01bVSpNbnnyuFl1GBr5FrzDImHem8b7JHdPNqZkEfQclsjMAcBSJNsZHxNz7iHXRlVodSlNloGdbQOsrgvU1EkEn9JruoDApaswL/8Ht32jmjFK5g97V4T8tOg98BG4GkISG+GFNFmlVi+9lVeFVCYrEKcsXapioIl/MdhFS29twzT7i38yHdY0gf/lh4gvX6X/9yEvPwWeYIfHAEdWAHDrOCJKBXUEtkzltJmQrIQMJeCUP7ZHkCCN8LvJPZnNEz7KEtctMR5oeA58jaXCfltttILeREEankljqYu8iRqjkTraL1H6SQ5KMMNDGu3FUzBHGjzk0YeieixAeFBgrKmmetv7pIL0sS/T+CORIM3BfPPpMKMZaywypWxjjnL2wI8WCP/jxWP/t0LHklM9blNTMjPxd+jfywEsDqptQd5YO1mLgVPcB/k0zsIjNZlTLeZGUtteha0kuLjJZIhWPXLywIMMvkzGCOWv5JfNn3FdWUT1nPfKsmimnthQh55TN3WCFxDQJ4GPVKtjRJLNR0VP20RV9nnUYUQPoMQyWdR+gePkKryG6sKybd2+QPt93f3CWVJksAOlXuKB6F6eSiMvPWCEHFfyW53bfcTd5uQEyC5iRGYhABkhj8sX7Xxahi5FHEGQR65p6kmH2Mc+dvGCiHSYeUCR/81eQGi5oBOiYTKatpIHbKAmacO86T1/sNt2xiDtf9WqNDd0rGz+JB7Ay47wqWcS7bvh7YzIT8Ubg9mBJ6GgFzPmACSAYSMFRyt9W+H2ZVBK8oX8c1dx8a7IhYZjdKBykCJvDUGZExuCQgZyUZW/5UAmej/fJToHgtbBVRHXQ3BTgebHGTeFkpuQn7a34cHNgIPRQDCxDr/xu4uRtQekkQMzY6JeMrcETro4zCNr/1YtZGYIpmLkPUSaGnGzIdvDVfq3h35P88COJJ+L/H+pTFNyJfg881GYAkEMp4bkB8HgxAynhoQai25vTwqal//IXUIuXaYp8NEBX5cifobBRXrXTLK6L2Z9gquYZxsualMv1+0MSGfgs03fRAE+ENURYxVl1wrFtqaK1/bkSkgTZGqvo7zr/Ibn10r1u4ZIlawB+Myh7KPMq3o0fyUJ+QoXeeZ9bXyLZ/pq3mPCXkqnO7szRDQQdDsP+6ZMGUTsLfGjF/HFfKs4qSQEFb0bZrpPqmYZKiUBGK16Yx1+hJZ3VqbYUKe+afhvt4JgUgEz3aVkocFh2Nl8IPIkxJFo54b7Fe0Tjlog4TRklWiqfSAaFmzcofDOwOLFmuc+ZRuc9yveoDo1LoI+mBsDgvjCyCSdaZclQ7vwOkMHk99hk3IT4Xfgy+OgA6d+Hp/5qv4rOUdhRL3xoCgIDs8CyDL3hUP9mq+vTGKLyYkkv8z3ybAreUaF70xsu5uklnOlorqrXmZz03Iy2yFJ2IEmgjUQomzcIkoa3kfysAN+oTAGU/Z4Uors1VZQy8NZA8CODgchED1A0nzO1WmZj5IEJA+FjWf87uaW9lREEsGB+bGvJFDCFJZ9jIhL7s1ntgbIaCQ6dHqytxHVjWsW1zUYihxFh5FstV8fUXWBJBEn+KW1wLzgVRrQSPlPVHywcJVkAr/cj/EDAFHi5s11fIiX4lwjPOopRjVi2SJcwITcvaxdjsjcB6BePCWOZjSSFeIKM62FZ4sQi6JSpp16T8sX+MasTFX9F6IX7qxDth4mfAjTw7JP4zz90IlD4haxU5l1ULgvATo+0zIOTgocX/Ng0NrKl9K53f7wp0m5Avg+VYjsCOgcGWIqJZxDDKBFCCimu9vC0ilvoSoMtFlCsTgPmm4R+Mxb+ZWWt6titeKrIOQITARbwzOiMRG/3oZIGNAqFHHRtsm8g+ZBAtVmePK4qzKXJf5hkAYNVnsskmPZCEvkVvZhGxOMQLXEYiHbhlPgOsj1nvQ13+ITh4Z2YOz2OOv7S8QiJAkQCI3ESwHfxC+ZBAFTkh3LnNoxKrQ+oYAQROogiSDtltKFdyjStFZslQyfeartJ0ZrM/6T2f6HmpjQh6Cy42NQBUBBSMoZPhuv90ji5qXA5otbnD8jL4gtBZZtlilWK+yOiFdLGWuFlGWkocs6EiUGf9pvQDQrkvruoZB9OAgYdLVfRjJbDflT8OEPAVGd2IEvoqAe7ZrFiQGEUEm6LaQMpcS1zM/yQbRpxiLEm8HQqtrVyRTLFeIGemiRnotySP2KxmnV1ewZl23Hje9CFj3DB9krSNroV/+MzAhX4bQHRiBpyGANYv1iE5cvgjKKMNa4vro4YBkgP5Kn7ogIkgOi5sra3VqLDTzMkVnCywImjwZuKVFkpd1Hd3kHgW41lEmWrptfBPybdC6YyNwKwKtgzQGja5eIkW5v8WoQ5Vy4h4i5BSlx7+0g4j4b7TZrNXJ2Fi1ah/159ZBW8yzXPN26OWRGD3Iy24M47KehwUFmZCzW+N2RuAeBPijh1CQFkY0z0jINQsOPVU+w/r6nskKd7RKBWhAUq2UmjHrG/o1a4pRfLVoQenSWMhY41jV2RwaMWjmqJLKPbs3uVcT8mRA3Z0RGERA0sKoZwDDQF4ctpX5IgankGoerW5uaPnt1g7WMlWn0aWlX2Nd1wJEahPNlqyK97byZqSASDTKFJqtdmNCTqDrJkbgRgREVgyRJaGz04FUVfkik2pTcgUvC6xXubvxFb4WHMK8uEeVSKRr8/8QLm5yWMytKtHMjzEUQp3xJZYPOPPJHKjG7HZ3Reedzj1iQj77aPs+IzAHAbRdBU1kK1EfjUxfEFotQCV6LGQqX8RDPyzi74ScEL93Uls9cneDXFtkPQftn3qbQJi8OLJRk9yj0lNo7b3rdISlCbkHrT83AuMISBd+dCKbSKA162/UY0EHgSCAdQvR4BrXqjaSQUp+zrUw6Ch3ZMkyM2bZpndIWLaPL5HvJgdUIqWRc4FPlVp9GQEjMA8BRa1h7Z2JkrsyE2SBWIyzlqlNBJEhimyM6jAAAB7PSURBVFJ+kP8x7nCqUM3hW8xNcSQzQOZYm/zUDu1igI0ywV3BQ/eOEnA5ZtZn+vJcTciXIXQHRuAzBGIk28P8V8MMIE0OxcqDPlmfM5Ltx1wTOtxT/7LMlVeDeUDSZVa3ln6L3hwLrx49XuUYtbaa67OjKFN/JibkFExuZASGEIBUIAIsyYwlWnauwzNlPmsNzgEVlqpSWh5NUonnJRXIBxnyq+nNPSLEu4FvAXrplJ4UImgRofIsq98ZL6voYkfQSu2Kssujv7EMPTQ0NiEPQ+YbjMCtCEQvgF7Irly+MmkpFVaMxQoJxwO+M0QFofMjiaKsrlIe3gEaBMoVU3ReAbP2ksGnO2r3evHwrSGTMe/KfC7fa0K+DKE7MAJTEYgadM+KlIcGWnHm9D9OtKfXQthc2X4hYFnMkDTrwCqG/JFJYiBL1t2M9eFuV0uIz9wYD11aBMwLinGz/bc27lmHsraQp/4puTMjMAcBiIYr44d7ZcSWJ0CtEvXROBmrPoZH9140jBUJvPdNgfZRu8+2jxZ+XN/Tqo3bQr7yOPteI/B+CEBS8tVldTq0Owq7zlr1vGhoW8sNQW5kPv/+rrvz37J4swEzzBsib2Whq5FuWdpqlNinPgEm5KlwujMj8NIISJOGpJALICf+G1kAvRatGeu2dpWa8ggQeGD8k/2Gf7snrMdKRa6AoMuE9yN919rGMPCaNc2hLFo0UsmZQ9nT8zMhn4bONxqBl0Agm1AoSgQx0xuL/M3dbQ3L87caq0a24DqTVwOC/Me7dQshowFDyFy14qwzgEffjqSrStlo5pkQ7KtzqGaoMyFfhdX3G4F1ERipqAxxczAHMWMFyyqFGLGQsRoJt8ZKLq/oY3zGY4P+kBvgIx3QQZj0i4XKi+AM0Wd3pgwRjxW4s32MtFOpqS98o03IIzC6rRF4HQTi1/IrwSAi9SPXuhghOBryrAPBMttd1KUhrpqfcRmMcnZ34reDI72aOfFy4iJd6tlD1+gS+FmJLRPy2S30fUbgMQhAAPjQnvnjL32Dz8y4VZm67AsLGuKMX/eVXQ7CQwuuWbmRnKJ1Hf2kW14TMXXp1VzImfBqxvvlfZ1/sG3b2WRQ8gmH1D/Tx03IZx5R32MEHoOAvtoy2qjlWZvhlcoaIlf+xYqseUpAali8yA68QKLl2UrXqUxqzBeC04sHgucg8ShPNG3AqFWX78p6a/h9e6+UDW+yH1dfAl+MYUJ+zB+WRzECZxCI2c9Gq0eX40Vf4TM6b1l/r+b5ECPnIG3INAaMjJZCylitcZ2QO94hhIJjfepg8Mx6a/uFNMNLgG8seGCMrqf7DJiQuxC5gRF4GgIK+4VcelWURUZYi7XcFLI4WcwZgmIuEC4VSvCCQJ4oXcKi/HDWO0Lh1b08HnFTsNohf7ntMS+sbf6fKxOI8rRNjgObkJfYBk/CCFxGQHoqHbWqQysTHLo0Gu2ZEONewAb9wiu1xEpYr3wOWddq68UscjWJQ6WRoteFQsClXSOTSHOO6UIvA/yIDkzIj0DZYxiB+xEYOeBS21ZdvHK20Zc5Zk8bTWkZs7OhwSKjKD2nxkSn5ar1HS1geV1IJoGssfzL/u5HfuIIJuSJYLorI/BEBLLeEEwR8sKyxFLlgmSxKmuaaJnXAXImzFmBIC1rXIVESUSvS/XvGAdNmnmULm0x6ZGqVuv+mgsefeD5QH9YzjMOP5+2jSbkp0HvgY3AEgjUrM5IoFiskDCEHd28am5uui8eIBJMggZOGDTeF9KdI7lyAMjncotT3yJ1NGC9LCBg9OKoX0c/6Hj4GYu6jmjST9sYE/LToPfARmAJBI6kDvTYf7SHGGNN/5ukPzSk+Ss7EWOxQr6QY+lPDPGi/SrZfQxgiaTecpmLADJXSDpa+eoDnkOe4eWQzU0x6uExZTNNyFNgdCdG4DQCEBXubRBJNvcwg82q0CzvjJpkgQzwrX1+EPJvJ1cpkpenhf6f9UkmUVcxLSdWMhKHkvoo21sM5U5O4VMzeYbQj14GUUJp9RUPLnseKfg6M86UgrYm5JHtdVsjMB+BGJE2on/O9FE+WhXzw/rEIwPpoXfF9JWyeI/SbtIfljLj4DaHJQtxt7LK9cavfa4XQsbS5v7oc33kvhcDX1qRiEPzNSEPweXGRmA6AtE/eISQpZvyFTxToVl6LGSX/dp+drHMDbKCzNB7FSrMt4BWkiBq8kGckP7vhuCOzBx6FT5UWYSxs2vn5QA/ag21eURCnuLrbELObLfbGIF7EThbISSrc2YqesxeYZxbWV+vRorKKgeBI1ng+ZFJihTlBTTi0YKtrBu/bMkOWcIWXrxQ4dEz436BuQl59mPo/oxAGwHIQ5FoWLWjf/w9bCEVpayMBDFaDqk3Tu9zkSTt8HpQQIj+v5YoSfUBIWOl+4wZ5ljb1/awZXRg+UZHv+gzgS4jFUJm58YwIfeeJH9uBG5EIJJHtizRyHSi9lnKH2e+tmtsSQ6QfCvrHGMjNyBLxHVyKMbvsSS5N5P8XeOpQjbziH1KBqEv2qCnc52RDeKhYu3QURhI689U+B7Zs8/a2kI+DZ1vNALDCES/WAh5toU8qivHBRxZf0e+yvQRXwSKoFPYMhqsssCx3rOJ5mXlK4eG8lfw4oGQ8dAYcWuLa8fThPUfacySXUzIw4+9bzACHxcBiKqW+OcIkZJQyxeFCLlFRtF6rUXucT8EjfWc9UaAxEmtyZiSX7Q2yPko7eYdu69vGPoWcMcYn8RoX0bACHxsBKILXc3vVmSkPMdovPwuWpRHkXv/dA+1xheYbwZlYveadR5JPkviR7vY88RY4gkwIS+xDZ6EEXgqApArB2ZYsGXgRm1iZeBHjwj/wa4B4wcMISMzcGHlQuRY6OQYhngVXh0PIkfcAVtz+Y1t276x+1NjxY+4wD1sc0zID4PaAxmBl0dAVibExn9nAy2wdrkH6QEPCR3skScD6xhiVsJ7CJnDtZieUweJSjx0VEWkBTJVrZFNuBcLvVUW6tGb9Jnrogn50fB7PCPwmgjEoqMQsTwcot6MlIFlq9Dn3kohWHyksY5VQBTihiz5kSWtfpSQiP8fraAC6ZOqk/mSZP+MR8aZ5PlHGHzhQ21C7j0y/twIGAEQiO5hNesSclHJpKzlHJFV3gm8GSD7Wvh0LBEFIUPmyB2t1KGtncOrQkmIsN55kWC5HxWSjcnzz1ZDKecTZZlPfZqQ/cdmBIxAFgFICRKBcEtPjEjIkBskeeaiH35q/srl4eJIUv7aXOKcS5KVPBMrfmMhgwE6eMafOrN+XkDq80cm5AxkbmMEXgcB/rhjbmFmLu31bt2Usbl6xT+xSElyj0V6xR9bvsE1i7wVtRhJnZdKK6PcQ/yOy8fKhPw6f2ieqRHoIRBlhRhGHOvtfbfXyeTPcanjMC3W0Yu5LWL+CeQDZAheHNkAEgWIlNOOrnzRSyNrVUseod9eCs5pkJmQp0HpjozA0xGIOmc8tHqUhVwDQDXysJp1SMc8+fqv6tDSbtW2Fw2nHNLcjzxSi3hsRS2SVY4XV28M2vCCUP6Ms4mLhh4KE/IQXG5sBJZGIFqFrVp3Zxcg6xXXNSQCXfwe1zUO4WqHYsxJnhfxvto8NP+o59bIN5tQiHF5EUTC5mWg4qo9aSXmqj46yFNIPP1lEuA398CEfPbx9H1GYD0EdGrfs/5qM0fXjQdYsU3MiBb7jl4CZzwrMghGUpT/sSxs7p8RNNKah4gWN7mjPBnTigWYkDOPhNsYgfdGINaeQ7uV21lctXTfeDAYCRnLED7hd/x3z/o8QjTqwpGQIwEroILfqSZfVus9k+/jaL6sGXwUdHL6aTEhn4bONxqBt0FAxIrWjPSARZgNvJCbmjwWAOWKtSxrU8npy7SbRNlFaWTUP1gEz3xZ4+yMe5ceChPyJfh8sxF4GwQ4BEO2UHjxaAL9GMmnoqRoy7H4J4RPxBxWdq2ga+wjHgIyJ1z5WvmYVZ6KzYBgW8ViY+UU2mYt6uwmK2l+q71c8VhbtSiqCTkLtdsZgY+BQLYsVA0N7pUHgySOSKzRlaz0iZYnCP1iHUfZQ0QqDVnEF61btZFkQqKi8ppRA0/h4TEtKONk8mx0C9qakD/GH5lXaQQeiUA8BGRc+T7LFU1z0e9p/61dKuGzshRTJDIIHpmiTDAE2f7a7qaGhY71W7OUaQeRn9W45ZrHPOOBYsZvOcovVUnIhPzIx9RjGYE+Anylx9pCh73kQtUf6rYWUXrAEkZqgFQhUdJtojtHNzKsadJj0k6JiaK+GyutqEQUky9JDaL+ld1bhM/BsOWOd3bxsXpKrPbNutC/ewd7koSqodcm5LPb4vuMwD0IREvrzqg6AjMgTqzJs9biEQI1+YL2HMqVFipWJy8iiFcvoZa+S7+QO5U7IFysToWLQ/5ICnyulJ60Kw/vSEjEWGjcvASyUYHMn/sYD0KdfiBoQr7nj8q9GoGzCGBpQSiQJGRZXrIWr5Bp9Ey44hHB3DKVmPVVveUfzZohUoiSwzuubGBLlBDUP1aoAlbKvsqDPT6/88U39ByYkIfgcmMj8HQEIqFcIVO+XkOEkP7ZzGU6uMu4kPU8EGR9Qsp4IGTnFPN0xINCXlysj37iN4B4sMeY8dDx6ZtrQn76FngCRmAIgdK9rBeOPNT5YOOYMD5r0TIE1iuSgjReDYuVzFV1CTuYG+RLf1xo0Ed5jWkDKfMtgSolvbaDkFxrbkK+hp/vNgLPQiBjcY7MDTKE1Dhsy5IURNiyaJkf8gMabnnVMq7Fytej4dDRq+NOi/eKS2BqL0zIKZjcyAi8PQIiSaxGchS3LkgJ4u7JCuqvdGGjX6QE+uAwTYns+R0HmlzZKEHNMX5r6M3/7EbGckuzA0q+mpMJ+ez2+D4jsC4CMUgBQsx4EUh+OEpiDyl9ZydOLOl/3fA0iBbrSFJ8SBk9Oqsfxx1Q4vmymrSyu7Wi/Mo+VDevxC1a8LNKOH3xBJmQ1/2j8syMwFkERK54G5CX4j8UKTPP9ov2CiFzIIj++9sH8gZj014SiNJ3nk08JHc35JRYkbq3FvkN16QMZBqIHLLmOspeRzvlcOYbRE/WoT0WP/NOh6GbkHvb6c+NwOshABkiCZCMncAIyBMZYMYFsdI/xJqxvDWm3NNakkJNn4Uw+T3jxBSXI5KBXk4lIUfylWYdpY+a1NLCD88XvpWwNkUHRov6aL6frduEPOMRdR9GYE0EREa3fcUeWDYuctTRq4U0y/rkX5FXWYAUSx9S5hrRmFuBHJGQS8KU/p11KxTOyC14m3BBtFjIaO3gX7t44Xxjl2k+WdEm5IEnyk2NwAsi0Ko59+ilxAjE0kWulkIz/k7Z4QiYUb7mkfm3PFIYg8+iZn3GY4NvDcwNC7kWzNOa6xdWvwl5ZFvd1ggYgRIBhS5DlNJiayjFbG41CxdyIuoPqYCv+xAjFUy4sFSxQuU7jIarqiG9nB/ICVjmWK9ZLRdJhgNG+oZkexfyEP0frb/WBy9LiBz3wE/Z6UzIPaj9uREwAi0EyqxuPSkhk2ktaq9Rx9XhnBLXx8rVR+NmtdyzuxwjJ0e07ep4JuSz2+D7jIARiIdgZTrMEXSwdrEUsTLpB2uaK1bOLt3aevkx4viHGdZGJlppKwz4qKxmMty1CXkYMt9gBIxAgUCtunMPJA60OKjD+yGGYGNl0h/c1DoMU9+zoxUVgs2cRuWH3npTn5uQUzC5kRH4MAhASlzys70jXLj8mg85x1zCPR/fcjOYI33i0cC9PZ9hPscKL3XveMg2Gr599ICgjTPHbo4OE/KH+TvzQj8QAiWpZpcuotQBGPdhvdLfiF+uwqvLMkeaRxn1hjWq3MJncgyLSJV1Tgd5jFdz+YvEG/XnKINkDwAZ48iTJXqL/FHP8jYhZx9VtzMC9yMww0VNZJdJiVmzNPHBhVCRDpAUOEzjGgmBLgmX/sosbOi6X9uliexc6QdrmoRF0YqWBwfeCkQl0p9CoGtRdUfEyx5wf/bFEMPUa8E3MUdH1x/chHz/H5lHMAI9BOLhmLwIeve0Po9128587Ua/hZSU1lNubSNZ4BR0AaHTF+5rtQi96AqXSd95lAAJP2csX6ztTP6OEd1b1VV4qZTpTmOC/Faie14+yBZE8R0R/c+akM8+9r7PCMxDIH6tnZE+EgLgemauZNYkSxVSblnYIwmFCAVXIAceDfGKbnBXX2qx3xgxWHupyD+aUPIreH+SUUzI8/6o3JMRuIKAKnjwh50JRrgy1iPvhdD4aWVww1LF5Y3Pa1WiS3JEsigzutGGFwBWMmPVpIGzwRv0zd7wksMN7669+eRnbUJ+5KPpsYyAESgRiC5vpcTC13wluI//fYSidHiRMxoyJE60HhcRcSNJkR61Y588P0zIj4Lb4xiB90BALmOj1Zpbq4+ad4x0I+kO3hJYu4yJhZqVIso0msw1HvJFKxepA/JG50YukjcJY3M4idTC75U+lP+/jdBNyO/xR+JVGIFZCEB+fEWHhGoSQixsqsxmrbEzFaklN5RJfnRYJqlDh3BY0a2LuSsPBto0/48EBIlyP1eUTvj8N3ZvD0iatnyOVY1ezaVK1jpQzL4UTu2HCfkUbL7JCLwtAlFCqOWIkEXbc4Mb8b+tBZ/ggSE9GLAh2qOqH9G3WNKErN6jzfqVbdt+ebeMkUeUWQ5NV94maMfMBx1an8dczb2HgfXx0w14MSH3oPTnRuBjISDCxULGk6HmppXxl86WPBohbnZCQR/KnaHdkQUrq7aWV6I1bw4VlQhfFjRt+R04lFdc24i7Xu8l5mxvH+tvzas1AikEjghXlmiXXHbvCUjtyP82S9yaeHRvi2QYgz1qZNwL4EgBszcajehrueuBM7LOV5q0LeSRbXBbI/B+CGBxEjEHwWZq1cVAiNHAEw7mdFAWD8awUOEi5tCLkIPEIOVYsVq7cpR3I1rQkcizOne582jUWNO9+XKftO1ScvmiMokJ+f3+wLwiIzCCgCp5ZANSYrkiCLmri+6TgZTQZaWllmHGZYKgkTVk2qrOIKQI8XOhCfMyypZqyowz0uaLg0IT8gh8bmsE3g8BLD1kCKxjEVVvlSNhx9F6ledCLXCjDItWjuSWt0dvjpnPJX88i5B5SX0W6GJCzmyb2xgBIzADgVbUXgxPlltZ9PaQxIAVjbyBVR7lFX6ncHFc1moHcbX5f0GIjUVKJkGewOMiI1OcwsuEfAo232QEjMBkBCBULO8YiIHlHv1+Yx5lpcdEckF2wKLm8BDXtdI/GiuUvqOGKz27FbINyfPtgQuCF+F3U2ju94y4xX0FpQl58lPl7oyAEZiGAN4M6LxICpCt8lVgKUPIkCY/39xHxO+YaD+IV5GEse5fTA6kGn3cWsvSFg8vIW0IHcs8U6YpWvxDdfZMyNOeHXdkBD4cAnhMQD5HARtXQImeEZE0VbpJ7mdKj6lDRuaErIClTFvleI6uenKDa0XeKaEQ1nGUKegX6xfrmRcE0X2SSBgXix3yxnuDCiG9wq/C59OaTMhXHhffawQ+LgJlvghI6+xV83uG7L61kx5Waat/2kF+kCJyRQxsUZh1K8ijVZOPPumnlq8j+k2z3nggGPNyYK0jb7Sy3EWsZK3/wIR89hHyfUbgYyPQsjxHUdHhXWmp9kK4j8aRhZw5fGMdaNCQuXJ3RNe+Uo+OpMscOERUsiLGVRIjJSHquQVGeeOHJuTRx8ftjcD6CEAyWHIQ0szqyQpbVgIeeSn0xkAeUEBI9I6IVnap5V6NrFNhUYj2iJjRoBmLS4EuIl1ZvyJa/sXqlUWvvMySKkTQ8vrI+nYzPla5LeT1/7Y8QyMwjECriOdwR8UNseRSVhulC2nBJUHF0lXSd2NUG//NPRlLF0Kjph4kWSYaOjpYw3sCf+SjA7uePBNlDObKnDPZ6b7YD1vIVx9R328E1kNAxKnq0b2vzdkVqJo0+uhIuSLlEsaSrt0XNWTJBVnrkrnHKECCTiBZfqcrygq1tfYCXVj3UdFUWci8FLh4AfByyIZWfzUnE3L2UXQ7I/BaCPRIZtXVjIZys45owWJpU1wV2YCrVgevtXZJPXhHZINL1JeCVhibl8Kpy4R8CjbfZASMQAcByRRDfrh7n1iaWPUZqULTkFUc81RAjljk2X5ameTiUluJgqY8ECbkKTC6EyNgBAIC0XMgk6bzTvCOUomW40apB428RuSxYkqrzen1mJBPQ+cbjYAROECAgzU8HahRN0vDHgU8emoo1LrXBwEfzLclWUQreuRgszfup89NyCmY3MgIGIEKAsrIhk7bc327A8Ce9VsmKGIOuO6hEZ99SShNKAebmaCPoXWbkIfgcmMjYAQCAr18ED2wakl/evfoc7m2HRUdxdrlcE85kGXdjnhwZOczpZ0JeQqM7sQIfEgEvr4HfJypxNxK+nMEpHyNsXBVhFRVoXsbwHi/HgqntqpX41PMdWRFY2WjL9Mme8n1L+a++OJeE3IWTrczAkaghsBZ97oYep1JEB99jZFIIGf5GteytZVzhWiRMLCa/10Id47tyjwVNQ+R2CbrQRIPOQ/d8EzI/iMzAkbgWQgo9JrwZiWex4KsXWUSeyLyIEcFmxCIQT+tS77KR8EyMRKRfjiQLOsMxlwWWUKmL7kBsr5mZRYT8rMeRY9rBD4OAljD6MUQZu0wLRvqja8xnhuQpPpR3gjlmTg6XMwkHdIY7E6tWrYCQFjLSLQi/fUOIe1l8XH+JrxSI/AUBKI00dKakR8gZTTZkSi3WEGExZGic5QknwJKa1BbyEtthydjBN4OgXh4d+bw7wiQMmS6JXe8DKgm5JfZKk/UCLwsAsgAaLxIDdkw5uxikQH4afkEx8PAEc03O/7UdibkqXC6MyPwcghgweKfy79kRZtNmCOAKN8yfsJUCZlxRSsaOURJ6K/2DdEjs6BlT7PMTchXt8X3G4HXRiDqsNmKynetOOaJKCt1XBnzahi3Dh2j18UtIdQm5Cvb7HuNwOsjoCTxrCRTUfnOFWN1QnS4tDVdwyZOoOv1sI8ll7WogePPLAs5Y80r5PowbNuEPHF33ZURMAJPRQCXOFJuZvJUZEKvtRg0cAiYl8TZ/BXKq3EYWWhCfurz48GNgBE4gYASyeMLLIL8+b1YKRp4Ji2mrF6Gz0T6nZjmZ7eYkK8i6PuNgBFoIkDEGpFy+P2W0Wx3w1bLSRyDSzJVQvB9JjIPQn+EPAImvdSeDgy5+8lx/0bgTRH49r6uXnIfIvSQEUZLIh3BpjJPtOHwD6s4Fkyd7e/8sC20ZPEwqD2QEXgrBGSlHrmSRZezmT7AMZ8EWdtE9reWVxrYPYWKczg5dJmQh+ByYyNgBAYQiIQ8M6xZVZ6xjLO+06qYjUV/dzJ96dPDfs8m5IGny02NgBEYRgDdFAJ9lE7bmmBMmxmt6rJ91hXuCIhf3SWUTFrRz/oxIQ8/X77BCBiBF0QA1zVkFizkVn09Wba1tJsjSz4tnZiQR2B2WyNgBF4ZAWQLrlZ4uA4qn3YoaEJ+5cfLczcC74mAktXfrfWW6CkABO13pldIepdMyGmo3NAIGIEHIBC13mfn1njAcj8fwoT8cMg9oBEwAgcISOulCR4UBHlcvZAqCKseKUrKmCOh2OUcGZOfTBj3V/eakK9ute83AkZgNgJ4ZqDzns0bEecTa/F9f09clJlvtNQVfJK5jzanczCbkLMQu50RMAKviAAh0r+0T3zEFxodm9BqrtGgFl4oRBMOW/km5Fd8xDxnI2AERhBABkE+GPGFxsr92n64N1LnT/M6M6ZzWYzsqtsaASNgBO5EwBbynei6byNgBFZCAPmCPBhYvEOHbRMXgeVNwqVqonoT8kSk3ZURMALLIhCrX2fSc961EPRsXgzVOZiQ74Ld/RoBI7ASAjE958jhXm8No65xSlSPnv1FcVQTcg9uf24EjMC7IHDKN/hg8XKNy1YpoSskC+ZRjQQ0Ib/Lo+Z1GAEj8GgEYpWSUde46lxNyI/eQo9nBIxAiYACKbA0W5nYHo0aUgQ1+44uLF38lWlHqs3Llwn5MoTuwAh8KAR6GdPOgBGDN6ZYmmcmEe5RNZSHZ30zIV/cOd9uBD4QAiJOLNnvTcyIBsnz9f/Hu0vaCKRYqMyLA7JZrmyq2derFzgyz1RbE3IKJjcyAkZg9+GFOLmuJnGfAejPbdv2jb2jqtfCyUGQUAibps+HpuE0IZ/cMd9mBD4gAliyuG1xkYltlkV6Fsq7avadnc/l+0zIlyF0B0bACDwRgUM3sifO69TQJuRTsPkmI2AEjMB8BEzI8zF1j0bACBiBUwiYkE/B5puMgBEwAvMRMCHPx9Q9GgEjYAROIWBCPgWbbzICRsAIzEfAhDwfU/doBIyAETiFgAn5FGy+yQgYASMwHwET8nxM3aMRMAJG4BQCJuRTsPkmI2AEjMB8BEzI8zF1j0bACHwcBEhsRDj5lNShJuSP8+B4pUbACMxHQKk66fly6lAT8vwNco9GwAh8HASwkEnXSaIlUpJeuv4/w4vHoCVTgwAAAAAASUVORK5CYII='
            />
            <image
                id='image1_521_245590'
                width='312'
                height='408'
                xlinkHref='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATgAAAGYCAYAAADWY/6EAAAgAElEQVR4Xu2debNtsVHdtyEBkjAFMpjJAWwDJqmi+P5fgH9IVRIIYIxxwJiYMYHMiQP1s89ytfU0tLT3mXTXqbp137tnD+olaakntT5z+GMEjIAR2BSBz2wql8UyAkbACBwmOA8CI2AEtkXABLdt11owI2AETHAeA0bACGyLgAlu2661YEbACJjgPAaMgBHYFgET3LZda8GMgBEwwXkMGAEjsC0CJrhtu9aCGQEjYILzGDACRmBbBExw23atBTMCRsAE5zFgBIzAtgiY4LbtWgtmBIyACc5jwAgYgW0RMMFt27UWzAgYAROcx4ARMALbImCC27ZrLZgRMAImOI8BI2AEtkXABLdt11owI2AETHAeA0bACGyLgAlu2661YEbACJjgPAaMgBHYFgET3LZda8GMgBEwwXkMGAEjsC0CJrhtu9aCGQEjYILzGDACRmBbBExw23atBTMCRsAE5zFgBIzAtgiY4LbtWgtmBIyACc5jwAgYgW0RMMFt27UWzAgYAROcx4ARMALbImCC27ZrLZgRMAImOI8BI2AEtkXABLdt11owI2AETHAeA0bACGyLgAlu2661YEbACJjgPAaMgBHYFgET3LZda8GMgBEwwXkMGAEjsC0CJrhtu9aCGQEjYILzGDACRmBbBExw23atBTMCRsAE5zFgBIzAtgiY4LbtWgtmBIyACc5jwAgYgW0RMMFt27UWzAgYAROcx4ARMALbImCC27ZrLZgRMAImOI8BI2AEtkXABLdt11owI2AETHAeA0bACGyLgAlu2661YEbACJjgPAaMgBHYFgET3LZda8GMgBEwwXkMGAEjsC0CJrhtu9aCGQEjYILzGDACRmBbBExw23atBTMCRsAE5zFgBIzAtgiY4LbtWgtmBIyACc5jwAgYgW0RMMFt27UWzAgYAROcx4ARMALbImCC27ZrLZgRMAImOI8BI2AEtkXABLdt11owI2AETHAeA0bACGyLgAlu2661YEbACJjgPAaMgBHYFgET3LZda8GMgBEwwXkMGAEjsC0CJrhtu9aCGQEjYILzGDACRmBbBExw23atBTMCRsAE5zFgBIzAtgiY4LbtWgtmBIyACc5jwAgYgW0RMMFt27UWzAgYAROcx4ARMALbImCC27ZrLZgRMAImOI8BI2AEtkXABLdt11owI2AETHAeA0bACGyLgAlu2661YEbACJjgPAaMgBHYFgET3LZda8GMgBEwwXkMGAEjsC0CJrhtu9aCGQEjYILzGDACRmBbBExw23atBTMCRsAE5zFgBIzAtgiY4LbtWgtmBIyACc5jwAgYgW0RMMFt27UWzAgYAROcx4ARMALbImCC27ZrLZgRMAImOI8BI2AEtkXABLdt11owI2AETHAeA0bACGyLgAlu2661YEbACJjgPAaMgBHYFgET3LZda8GMgBEwwXkMGAEjsC0CJrhtu9aCGQEjYILzGDACRmBbBExw23atBTMCRsAE5zFgBIzAtgiY4LbtWgtmBIyACc5jwAgYgW0RMMFt27UWzAgYAROcx4ARMALbImCC27ZrLZgRMAImOI8BI2AEtkXABLdt11owI2AETHAeA0bACGyLgAlu2661YEbACJjgPAaMgBHYFgET3LZda8GMgBEwwXkMGAEjsC0CJrhtu9aCGQEjYILzGDACRmBbBExw23atBTMCRsAE5zFgBIzAtgiY4LbtWgtmBIyACc5jwAgYgW0RMMFt27UWzAgYAROcx4ARMALbImCC27ZrLZgRMAImOI8BI2AEtkXABLdt11owI2AETHAeA0bACGyLgAlu2661YEbACJjgPAaMgBHYFgET3LZda8GMgBEwwXkMGAEjsC0CJrhtu9aCGQEjYILzGDACRmBbBExw23atBTMCRsAE5zFgBIzAtgiY4LbtWgtmBIyACc5jwAgYgW0RMMFt27UWzAgYAROcx4ARMALbImCC27ZrLZgRMAImOI8BI2AEtkXABLdt11owI2AETHAeA0bACGyLgAlu2661YEbACJjgPAaMgBHYFgET3LZda8GMgBEwwXkMGAEjsC0CJrhtu9aCGQEjYILzGDACRmBbBExw23atBTMCRsAE5zFgBIzAtgiY4LbtWgtmBIyACc5jwAgYgW0RMMFt27UWzAgYAROcx4ARMALbImCC27ZrLZgRMAImOI8BI2AEtkXABLdt11owI2AETHAeA0bACGyLgAlu2661YEbACJjgPAaMgBHYFgET3LZda8GMgBEwwXkMGAEjsC0CJrhtu9aCGQEjYILzGDACRmBbBExw23atBTMCRsAE5zFgBIzAtgiY4LbtWgtmBIyACc5jwAgYgW0RMMFt27UWzAgYAROcx4ARMALbImCC27ZrLZgRMAImOI8BI2AEtkXABLdt11owI2AETHAeA0bACGyLgAlu2661YEbACJjgPAaMgBHYFgET3LZda8GMgBEwwXkMGAEjsC0CJrhtu9aCGQEjYILzGDACRmBbBExw23atBTMCRsAE5zFgBIzAtgiY4LbtWgtmBIyACc5jwAgYgW0RMMFt27UWzAgYAROcx4ARMALbImCC27ZrLZgRMAImOI8BI2AEtkXABLdt11owI2AETHAeA0bACGyLgAlu2661YEbACJjgPAaMgBHYFgET3LZda8GMgBEwwXkMGAEjsC0CJrhtu9aCGQEjYILzGDACRmBbBExw23atBTMCRsAE5zFgBIzAtgiY4LbtWgtmBIyACc5jwAgYgW0RMMFt27UWzAgYAROcx4ARMALbImCC27ZrLZgRMAImOI8BI2AEtkXABLdt11owI2AETHAeA0bACGyLgAlu2661YEbACJjgPAaMgBHYFgET3LZda8GMgBEwwXkMGAEjsC0CJrhtu9aCGQEjYILzGDACRmBbBExw23atBTMCRsAE5zFgBIzAtgiY4LbtWgtmBIyACc5jwAgYgW0RMMFt27UWzAgYAROcx4ARMALbImCC27ZrLZgRMAImOI8BI2AEtkXABLdt11owI2AETHAeA0bACGyLgAlu2661YEbACJjgPAaMgBHYFgET3LZda8GMgBEwwXkMGAEjsC0CJrhtu9aCGQEjYILzGDACRmBbBExw23atBTMCRsAE5zFgBIzAtgiY4LbtWgtmBIyACc5jwAgYgW0RMMFt27UWzAgYAROcx4ARMALbImCC27ZrLZgRMAImOI8BI2AEtkXABLdt11owI2AETHAeA0bACGyLgAlu2661YEbACJjgPAaMgBHYFgET3LZda8GMgBEwwXkMGAEjsC0CJrhtu9aCGQEjYILzGDACRmBbBExw23atBTMCRsAE5zFgBIzAtgicIbh/eBzH3x3H8f+2RceCGQEj8NYIrBLcPzmO458dx/H/j+P45nEc/+etUXDjjYAR2BKBVYL7p8dx/OgNkf9yHMd/3RIdC2UEjMBbI7BKcP/gOI5/ftPg/tJm6luPATfeCGyLwCrBbQuIBTMCRmAfBExw+/SlJTECRqBAwATnIWEEjMC2CLwCwSlg8VfHcfzttkhbMCNgBB6OwCsQ3L+6Sf2/biknDwfBLzQCRmBPBF6B4H78OI4fOI6DdBPn0+05ziyVEXgKAq9AcE8R3C81AkZgfwRMcPv3sSU0Ah8WARPch+16C24E9kdgR4L7wVu3/e/9u88SGgEj0EPgKoL7R8dx/NAtzeOZ1UVUBACZ//NxHCY5j38j8IERuIrgfuY4Dvan/o/jOP78iXhSAIC8Oj60g/b4YwSMwAdF4CqCY+P9Pz6O42+O4/jrJ2L5fcdx/NhxHN+6teWJTfGrjYAReDYCVxEccqDBPdM8fTaWfr8RMAIvhsCVBPdiork5RsAIfHQETHAffQRYfiOwMQI7Ehx+OM6LcAR144Fr0YxABoEawUEQnLXwjh/a/lM3f6Crk7xjD7rNRuBCBEqCI1DwL2/P/9M3JDoI7udu7Xd1kgsHih9lBN4RgZLgSLGgugefR+aRQaqQE+c7nK0oQmUSEo//+4OjurxTJ4294+LwjuPXbTYCXQRqGhwkhyb3qMNkeBeJwnz+2+2979htP3kcxw/fGv4nDybXd8TLbTYCd0fgiiADGt+P3BJrV48PZPcB5ACpvtruA9qFdka70ApbH4gakvufTjK++7j1C4xACoErCA6nPmYhn/+Ueut7XaRtaLvK91694dYagQkEriA47f989jatCbGnLpXpyS4NTE9/jIAReBMEriC4rKiYoexX/Ys3zFGjUgrBj3dNn8n2ka8zAlsh8CiCWw0kUNsNcnl0RHSrTrYwRuCjIvAoggNf+eqoNoI5O/pAipy4hWnonLYRWv7eCBiBTxCYITi2P/3dyfSH7C4JJRyTtEtkll0J3zzZfzyTgpjWBk8C6duNwLsgkCW4uEPgEZVyMUtJ/v3+W3oGfrtMKSbaCYmRqlFerwOm8aWRiAvhkd7Cde9y4DRtRg58gRB/BpN3GYtupxG4HIEswZEGgonJ51F7PHknhIV5mv1AipBjLeKpaK8IToTHsyG8szsosm08c10syc45sqt5h2fa4HuNwNsgkCU4BCLhFY0KbacWTYSMSIj9v08kix7BIQNt5EP7IVBSQPj3WfP3UR1OFJrqyWrzO5Dyo7Dxe4zAJwjMENwIvrhV6Y+TKRXcA9FcsQdVBAYJoPXtar4hH7KZ3EYj0t9/eAQyBBe1nh5gs3sxo9n7zntQP/wgMgBG4FURGBEcTm18b5Dcn92c9y1ZuBbSwnzK+M14pjQ4KpeUGknrKEL+/hO34MMzD7h51T51u4yAEbghMCI4+Xy4/NFbsciB41MeRagTvPju1at2QPokK1NdeFeT2ZPJCLwsAiOCo+EEF4hMErU7M0mJYqrqSCYtQwGDklghXSKgtOXVgwPaqO9E5ZedAm7YzghEgsP040MO2T0+2smgNI3MOzB5S9P1nc5cIFFZqS4iYxKmiTT7YwSMwJ0REMHF/Kp75bmpbhy5W5mtWjXRo0/wXu1svRfTGLKaKRZQ7p4QyTuH7c4D2483AiAggou+tpnJ97njODA9SZQl1ePen1hSfWT2zZrEvbZrZwXXzOBTPrOm0d0bszPPdxn2M+j53qcjEE1UfG2YT2hYmbJADP4vBf/cl0/66DJgYLKiSamkOuklrY/8X1fUcUNz02E8RHxXfZG0H20ZH+TqMzI4XXVNTP15xBa9q9rt5xiBbyOQCTK0oGKyosHh8CeF5FHVfCEbfkYEoTLomMMzW5qyBQE+whDS9jYFdEaYfwRMLOMbIXCG4BDzzAlW3MvWr3sFNVa6QZFb/Gy98xdWnv2Ie2RSotlelSOItoxGn9HqHyGj32EE0gicJbj0iyoXyoTs+bQw59AaHnVKvXxk77qzQgQN3K+eI3hm7PheI5BCAIIjofaREUk1TBHFMpFX35Mzx44FPmerfZBsi+nZ0xaJ8nKuKYT6jcReT575rYSpnOqIiy6SSTkKwFz0Oj/GCLw2AiK4KxzxkjS7d1Vbu8hzI0oJoeF8V+AAwiFqelYbieXSW6ZnrHeXIQel1dg39drj26374AhAcJhlM454tAR8Pfh4akm4aGaQykzUrVXmiMiuSparqyAX/HfZSGTc1N/abgbBYTLzO5MGQruIMPKZkfODDzeLbwQei8CsDy5qQzItY+oDjmgIk8+M2aucNbS3XsQzalot07aGIITEvTy/5SxHNn4yhQJ4R418Z3vvKge+THB8lbsGA6TRs+DhsthVztkx5Os7CPQIrmZq8jdVF9Ep9AoWiHCye1cxPzFNIR0R0KgunN4PMTx68/+VA4n2f+FmgpNX97UTEzaS/jtjMsLXAZQRQv7+EwRaBKdDX/g9KpO0sv0IE/df3Exd3qHN95noJdczqd+54CPy//qtNzD1ySFkgVj5RPN6Rqtdedcz72ERxE9L+s7qVr9ntt/vfgICEFxtQ3v0W/V8UpANJkPtGTVxVMsNMxDtDX8auXAQG+YVZu2zk0llCs2Y2LNdByn98k12zC1I7ozJRT+w3a5ngs+20dcbgbdHAIJrZe7jF4O4WmWSZJrOEEE0M9BatCvhbCJprDBCuyFO2t1KC6Ed3FMziVWHLhNNffsBYAGMwM4IzAYZhEUMNrSIQNqaDkjht8jjyrQU2iSy5dxWiIvfrXbFttd8VtriJR/jzv3fku2KM3BdFuojjpwXk3mV4BADIsAswryq+Y9qG7VFRBlf2wxU2oHAPRAbJNZqV2w7NdpKk5iJCUk+avfEjJzZa89soZN/lAWJ3RArprOOZLQWnO0xX3cXBEqC02HIDMyaeRcPHh75jVSCKSbDqoQ3z85OHO5RLbZWegDXEJWlkOQZB3Ssi7cakSRlg88zCbKMbM8MnlgaajXHT2Xlr9bUZ+TwtUbgk2oi0UdWO/ovft/zvUE4OnMUU09kpnJH0WylG5QywrWlRhVJh5SKbLRxpfKvtjpJE5wtiR7benZ7WTk8FfzIEK/6aVVTJmLJp1eOqjd96H/aS19l+8vT0QhcjkCpwWmCt8wT+dBoSI/gonkat0fVzNaoMdQmJESFyUObRrXqFNWlfZnN/DVAlZPHxJyN6MYdDnGze7bEU6+DlY4DDiw+I4JhMUETz2rKlw8uP9AIPBuBmg8OwiHHrDYxssmWMlF4BpqMiAKzFW0tniYf87gwe2ViRrLK4CS/D21H04Pg+MycAdF7j2QfRY2RkXdGclyJOJdtgbCkFa1qVhkcr75mth+vfr+f94ERmA0yyEeHr6s3yZSXxSSXqdrbXlMm7yoJOLMvVN2HhoP/i7w6TEvey7+/PpEUDNniZC+P+YuR11nCzCTiypx+teokZ6eGgw1nEfT9pxCYJbjyZZABk7K1qyD6pKLDepSrpqhojUxa+zfRnH4plDCS7yfuxKC9tAktsdZmmdA15zjaE/f2orNEYHkHxBrNabRiyJcs/JrZ23vvqQ5+8s0ONjy5Az7663uJvkxUNItWZdu426EVbZP/DBJEG9NHvryWPwmyYlsO0dYYFYUkPnszcWspDCJGCEbakFJB4p7N1nvjhm6eP/OJ/kXuG5my8dkyYflbLP1+z1wy/IW4C1gIrqr+W+LFYsQ4gdTfeWvdzDjwtS+EQKvgpXKhehM1ml6z6QSt8kgjaGKUs/ZOiJGJC5nWJhTvpYgme18xXeNHvqKaD23ULr6P/kkIFD9gtjKJNNq4z1KEea9cMgUtGANs9vfHCGyHgAiunEQxsokGpImKRsE9Ig+VGOJvTFKui5Oa1ZtJq4AF16CFYb5pw3wZzGhtHQN8vkPrYKdC1AjLjmll4tNetEc0iqhhabLXtC6wUGAE0mp9rt4PKsIEWx0Uzfuv0oToC9XA+6NQ8GC7QW6BPi4CTB4c+jWNp3T8R39aWWEkagPaLgXJ4KyPeVsyTVtVLyBEJrairLNpGvRkrLZbBjaimUrOnQIlalfN55eNHNdGUa3kVHa06QxYyqhjQsrMnzkhbPSudzundSSPvzcC34OAggwZX080D2M6Bw+U7wpyk1+PyQ1Bxdw2+ZrKZFWuRbOjHUTe+JTlxdVGiBcSaznsR2ZsrdwS96Cp1Yhez5stRQRB/fxNo0VDypweFrVX5dTRLhYKfs6cyVob+vQb7ohYKv6ZU+TMFrNnttvvflEEICNpKJn0B8gHEoOgStNSPixlwWOqQlrltqwyLyoe5sxzmeQECSA4vUMH0Eij4xkyq/FV4TeDnJioWTP23l3yxdsWM2T4vYEjH3nQgpU3KLl7OYmj9ouYZ1JtRs+89/dntpjdu21+/hsiIB+cml7bntUT64wJpufGCGKpGeqaGKGEiFV/bjah95EaAosBpi+a31cHuyJkjiLvzHa0Xt8oRSOzcL3K0D27xexV5HA7XgQBCE4lyNF+lJIBoUAGPZNIya9na+TLf9fbmK0EY8w0CAONTduQVNUE39Qow1/vuldksuzWXsAkXgvWce/uiu+xfLee2aqAe8XilDmOcWaoK2jV2kkz86yVa1XYQQvNFf0waof2bfP7yiDS6L0f4vtaom/mFCrAWd0EXwK7UmEk0zkQBiYepq4qe2Q0BO0qYPLin6oVAKgRmYIqmbbd4xr5MYm4jiZmNIlXJ1Xc3fFoM1gLnvYnX4Vn9N9epUmP2jbaiz263993EKgRXMyB62k6M5vgn9EJioyWAY1ReXVMZsgNXyJa4UjbAwcdlTiT3LuCidJs0LbLHLuZ3MI4kVvkxDgggos2VauqEgkuRqRrcmkHCdpkJtgywqa1Q2Z03+h7aVP4maMPeHTfme8ZP7gTrMGdQbFxb2uzPZOFz2hyn22SzljNaEmz78J0hcxaz2ZgEbxgAmvSaTVVoAKfIETHBG9t74oT/Z54xRSX2nu0fxec4m6IFm7gg9bZOgdDPjzub/lmVXmlV4MvaiiZSiiZfgYLjdGrI8uZ9/uaN0GgtReVQUkks1WYksHPYI1FL5noTJjWCl06+KMpvFq3bARzr0wRE+RzN3Put27JtFEbU0ItOx9oXy9NRGkm9z40p+dDpO0QDu3u7aCgn2L5qZY5q7NqeRaLxOon9rMLYK6i6PuWEMhutpfqrrQFBi0fmWR8D2Hwu2XyKFoatY+RlrUk1O0m+ZmY+DpQWpMZIv7pWya/Jl3cs8q9IrhW7t6Ztq3ee4W/Mpp3V/rO5LusVTJ+1AKwiqvv2xSBLMGp7I1gUJ6WDmaJaRxxlY5bpuQjuqcZF7spmkb8XaXTMUuZcLRNOXk45luTvZYYrPfwDp6HTDrb9YqhMnsuAtez6NCGUYHLiEvWkV7mLpYyRs03U3H4Coz8DCMwRCASnJzKSvuIN0d/jAgqpkDEXDYRXKz8gXbExJupMsuk4h7ezaf0pbVSFHCM4yQmQKCil5IFTY42KNDANZh1mOMrvhyR9lW+JbWT57ILgnb9ziBJOPrmsuQykyKSqel21g+pVKUY8R4O3sYFoxJeq8/1fW+IQCS4qIXFctuIVSO4KK5OHdc5qhDHmZC7JhX7L5nkfKKfrhVFixFgJgvykUTLBOSDlkYkr7fVa6YbJaOIReetiiwVRMFXObNJnjZzMDRETZLwyAemBWYUzZyRTde2SjmVz2IMaLvbKE0l3hvJ8awvVjteeP5s0noWGwWnWNSu1Nqz7/d1EwhEgpOfrazBVhJcqSWUxSu11QpygjR5x2zIXZOKZ0EMtI3Jy4SX/4/38lHZJK5Voia/VQVFZChneWby6dDrVuS0BnE0/fBNgqM0yNl9rLSZrV6Q+1du2uioW8v0FwV98ImNzNbes3kuC05tXOg+bbdbrS2XKSY6kp/vtSeaf5eLdOb+zDX3PFgo835fM4HAyAeHGQhR8Wkdy1eeBF8LJrSaxGCR7ygSj+q6QUpKQYiaBBOJCUfb+B2DHJpkPA/SU0mgrEM9mnwlMfGelvan1AXIROa0op5ZzUoFBaL2u6rVXBUcQStCplbhU/o2av9XnyY2MZy/fSljh/Zma/HNPl+LKPetuDVm3+frTyDQI7i4UvVWQ/mhpNmpBM/IL9UjklKkaMbwXblnNaYixL2X8R0zRCFyKN8jwuIdaGnIqFptrW7IbtdSHhvPhUzQmpB71rylHRGvWe0xytErkRWvU+WTd9r3emLa+NZ3QaBHcFL3ZSayIrYOe47mESsoP6MzMbORN2mRPLNV0gi8mWRMSDQ6TFl+o8XRNky9lqkmPxnyxVprtcihiA9tlvdBbv++cciz8siUojIaE1fXZoMgaWOmsrBSamrVTJRQ+2zNbISfvzcCnyAwMlEhFRz3KoGUTSvIQt1LwZBZDNHyKevD1d4RTVUma3lug/aXQjoyiaWV8byRY5rnaxM7hMTntxs+svjcuLNAgQjM1hh46Jm/WTxXr+vV0FM0+4wfL9suxhqfs9u5rvI/Ztvt614UgdrBz+WJUAwWsvmZjL0y4SsiSnvCvK0Nanw7pEug7aE9QkC1RFK9O5Yd4m/R74b29/mbLxGyxHnPpJX/aMa8kunbu0eR4Ggar5qOCgAhE4tMJBvaguYKYa8Sg/YVl4cDrfTp6j0xAl5WjK49s1WWPvpdz5jnq3L4vhdCIBJcGQVcCYEzuMpzRfk/z+Z5MZAQS4G3tvBw36/e7sd8pHAkk7ulTZTJvXGAo40SmdTRf78f2jNKZG11GYTKp5VgW/rfZJbzW0nSenZvW1mZ/hId/tHBP9JArxp6vV0Lq++gf2LOY6/0VS83b9Xvutpu3/fCCESCiyvfqimqyQYBMUDRuuS3ippMDAqUmlYJF4NZZY/4N5O9rNrB33gn2p3MajTRcm8oEUF+aEtvgzhtoI2YtDyzlsN2xYIgWaNmV9NeZHpzvbaU6V75SmsmecQSYufTi4byfSYJWH2KhozWCNGD0dnzInCFKDLemzbKy2ztiqHv6B/6+RGmdaut0q5HUegXpoj3bprOT1Ats9LfovwkyCCj0ZVng+IDU5Z6ac6NqlnUkK0dCJ2N9PV6qtwVUUZta2kecUGYSQMhAFLm4kUZZqK9kkkFQPl/aa4iGz8666J3xGP20J8YEOGdkAmfVhWTn735cXn3FW6OZ/orZ2Y8mEvL55jKTA7mzPN97QABCK6Xt6Yct2wVCCY9pKj9mWiCcsa3/FUMAAhWHyZAayAoPw6ylb9JKQrcnyWaGOFEo1FCrlJdIAlMaOUAtuTXDonMwJVZVauADG5oJSrvxHOlaaIVgREkMiorFfcMY66KhMGX90KuvWhoJNpeUEftox/oE94rbUn+UmlOXPvrtz7mb7/xgWYlqT+/eIu2/4fJ3SwtmKSxZ7flfSC4PxUVgtNqXJvEmjDZJNna1iSljdR2BWhC6fAb3sNPrcCiWq8OjuaJooAZ5zTPiRFOtMxYCUXbu+JJY1mC7w2mmKg8Oig79gmLBO3lU+sHCAUNjZQVSBAtWiTK/+XXgrAg7FYCLESk9BcVJsgQt2TumexfupEg5v5vNlxR36kAACAASURBVEDCzYAsIxP6ERP2Kh8jfQH+Khp6hWxxHN1rt8YjMH7IO5jMo9PgaUgrYlU2UhMzG73SpFCFDwgKv11v72WtEGOpuYz8LiLESJIKCGgAMSh1StcVvhy0M+SEiEb+P5G4TgoTAaN9laRTauDlSVw6KHv0TgV9sn1X9n3Ma6xp0sgU03Pi/TEwsFIVuZV6szqJtADWtCTaKo16dNziPc7a0Ni9YtFdxedt7hvlwSFINFtGUbpyV0MGCDnzUedFODXNQZFOfjNZICAGIP//hdtKieb3hycdy8p106E2StHQFqySPGMAYPZ8g5XoLfeg7UCUYDByAWT6gGu0cKz4AOM7VmTifhE1+EIiWaKLmmMkZ535qko2WRyihl8LYsT5MJNa1Hu/NEY07IzWnN0dMyPzltdmCC76uEamFSCNzjxoAdmL3vXSApRegJmG9gfJ1D4iKn7HPYQjbS/m1sVJJ61B26p4Z1zxR+XYM2WISjlqicxxh0dmcvQGcjytTNfVUn/OTIaW+cffkU/nE2TrBrY0x9qZHNmopsYKfVumq0RCvcoPprEwioSfwb12L2OU8a2Mh6uf//TnZQiORmonw+hYvqxAGshcj29otJ9zVLJHgYpegKKsZItMtGPkt6sViIxpLmgNqnUXibMsQlBiM5KphmWZyJxZcLJ9out4B0QnWWYOs8m8a3S4c8ZlUntPqdWgwbHoYUbSR3wifr1+j9fVML56Q7/MzqsJTjUeVUmnXMyltY/2jWf69SWvyRLc1Y2PZMOzR+YIJMMgiNVFZtukSCX3MejlfM+YZNIu4zvj2bG1PLmRuc4kwSdXliFSCgTaWOmUjluqMuZRS/tqmTgxPUYBjbNFPcuzOK7eczszDqI10sv1jGWX7rGI1Npc+k5n5GpdO6rywhiEzFkAzuYwXtHey5+xSnCZZNBeY6NZwXVZc+RKAOh8JjQOcf5Nm0YHXeN8Ljek99oU/VEyeyCuXhAlBkxqKR0MSPotk09WSwGqOalpG4EkmXBoPgpoiHAh4pmincJFDntpCSL2qFll+jUb6Bo9CyIBv962NnCgnfTVvcoujdp5xfcKciBrZrxc8c6XesYKwUn7YsDiwF0Z9AKBDlB9tTPP6YFaahBcy6RV6gUmMgEOPr10mLMHXcfVVI70WjpGNFdqUdPsAJKMTFZpe+VWNoJGfFQz7x6LzVkNkDZF0s8UXchi5Os2R2CF4OJgG5mWM/BdtUKX76xpMXHfI4EJZfmjqkNyLZ9g1J5GQYSyHZCLjutT5j/X1EylkbnSy9OSfxNixwmubUKQaew7meZKBuZ6EoHJVSO/KvsBE56BiVML2NAe3gvm2XzK8t0xNWj1GVl5fN1GCKwQnBzsMyXAI2Q1/0/UCssSR9Lyys362W5onSUayUp7FzVZR365mLelem+KqkIqI39G3NVQ7i0t5eJdaH8QhKJ2Iu2aNoMM8nNBnmiB+shkQaOLtf0gEA7rgaBIs8lq09n9uBzRqN0qcTuXoni8r6ySEnHQzgn2F/cCSdkx4es+CAIiOK2yow3T0expmQpEbpTUWe5flZlWan5xw3hplsXE2zhZyy6Sj6v0pZV5ba2u5T4y7pnkEEmpxYjAVGFX+WcQPSQHQfCRr0n+LLTBmh8HUqdtPTIU3uzl5ANuVFSJBKYIoeSC4JCDvoWscJLz4VngjD+mDF4I/2zyqBKP8SVCjshK30B49H8sf4X5zzXaJgZ++kTNzAU1PwjpPFJMEVx2J0BMj2jlAMWKIvLxSKZeBK0Ves/ujoglhUYaGO1hUmqLExNb22ogHkopxcz/Mi0EbYOIHFqJSiXpEGvIg3tjqkGZIF22VSZrqc3pOrRQ+orvv3YjEp1gVo4X2v9rtwjtH9zq3nFNLE9V2+IzMov1nqi1lflTkfS13a5WIKHUKFUtOjP2Z10DmWfGa8BPRw9GMp59jq9/AQREcHEPY28fKE3WiVMtU6F3ChOkIF9M1gxC84CI0Dx6SbnRbMxsNyp9c6MtMLPH4vXKGCmKzO+YglL64/hOiw8aEGSqCGzrSEIm6Bdu2hoT9HdvJuesltYanjKZtfk/apBa3KKfrLcXeXYKxD5m7LKYoAHXxtJqpF/5i7TtXgENae+0/2xytuZkLM4wi+u216/44F4RDOV7iYQyGeZRs2BCQhgQKKRwxaADJ6UatMg8anJcn908XdMoY7989jgO/F6QYXxm3KkAZmh1PGuU7PzIPteCRrCj7IeYXqRzP2pmdXSl0Lfgnzk+Md6HzKt1EVmQIZyaEhBzDTMLcQZ7mfpZF0PmmVtc8wiCUz04nRV6D+CiWZxNXYn5XSqqSdsy5u1VMsQJOzM4433a2K6adprIrWTeaB4qVeaqiXYFLpljJyM51xYzLRxcB9Gg5Y2irwp00Q9a5LJWRil3bxeLotb8vmqsKUIv98gV/XDmGdorfZWisNyWexNc6a+pJbjGaryrgpx1VscM95EmJd/d6vkHNRlH/q9aEKg0wWp7L0d4Kjpblk+P9ykJeEVetVukoeeWBUbj+7I+V+6JidSlrGinvIcP43xUK7DnM9Wzs2bvaDtadLvwzBYR8J2K0Y768lW+j/mij9oF0pT93gTHi3uVe68CQxFCVRjhvfI5xYit/Fm1VT/rh8wcqIxcaFI621SlvZWjNuNUR5bMHsrapDqbWxi1jZXdJjG5WaZy9KPVtKqez1Vl10f+2JKgeedIG5O2R0WP2p7rqDWP8j+RgR/e2fMb12obxrYrMLSC/bMIb7Y4x13buUJwNeJYbWStGq8m6mgQjd5ZM3Wk5WT2cdaenzEvREYEBbie3xqgMVpd87cpV6xMNFYpcZ7X8tOVxDCzeCjFBpljPlr0F61gRv+Ch3Zs8PyI4Uirin0Q/ZUjc7M3NqSBg/GMCRWxyLgTMtqeLI8Wtr0I9Gj8P/P7q4sRzBbe/a7sKwQ3qpIxC6yqejBo4yAa+ScYQEzi1oEefIejneeoJpgy6olGxjQQBSlqju1SHtpIB7aKYNa2ZGlCxgKIZbQ6kh+EiJYSj3DMTJjY1rgxf+Qsj9eWkUP6B3KRvK1jG2cWJjCMWhW4qPhBK/E5ujtmiLHsv1bid2bcZsuFZ/JFZWIzXsqCC2oL44xF76poa0bGV7xm9uiEUwQ3qpJxFiAGEQO+PBGrfG4022pJojMrvkgpszKP5GNw0zaIAFLo+Yl4FkQMifBbZ0DEd6xqKzK5yo35Si/RqVOQhchDhQRaVYNpV81cqkUGeb+SgGWit7CLOXo9Mla+4OwGePkCaRM/qlnYSxwf9XPv+xjlXu2/M+9fuVfJ27NFW1feNXtPrHA92iX0Pc9e0eC08syo97MCZa4fTcqZFT9Wk1VyMkTAD+aDUg3KdimfqXUu6kgO+aMgWExZSJ0P2iWrNxPzjLZSvr/cbM/30TfG/+UzioGAmBvWMqfKPMH4LsYKsjHxa9pILCHf27I1wrP1fVzsdDbIjB9v5b3IBAajhXrl2VffEwl5ZDld/e67Pm+V4O7aqImH0zFMnpYjtzSFWo+OvjkmmBzK2p+J2VbukR05y3tiyOcFWUBkECxaCauTtEieL0e1tDEmzWr1VVVVwWxncqNhtoIdIifGB3hgJkF4tBeCKh32tK/sg2j2ggXP5H2Sj/+j6Upu4aUTz0hduWonAe3TVrvR3t/s8AMTNO5WgYHZ0lp6rwJRtBkNc1RxOtve0XVy37yiBjdqe/P7SHCKRDKAV1IClhtx05RYZbXPc+VZtUmWfY60D7QoVS9mYDHZ+BtaVOkzi1E1Jjz4MSlrqTBl26KfjlA65IH8Ouim1I7jKWDINDobo5S7TGAdrdLIDbmzjxRn/L/rOORj/lgkD94ps4f2KDE3HgguXOLiEbXFWTmz/V27DrLVsY0t0lK/xGIJtcorI/dJr53x3pmdFGcj5mewe9l7I8HVTqtaaTiTlcGdPSItakIrkTraKBOEAXhm1YtaB8TD5B5tD5OviclRI59a23rBhoi5ND0220MMOgin3OM76qdYHoprM2YvRKPzYjnTs3Xwd69WW8QzkmqMpNKe6KdajRyCM4sT79EC3cu3i5hFE7ZGKhA918j/GOdK7bBr9Rta8myhSWlwtI8FXzL1/I6tajwj/+9o3Lz995HgYpnm7JahmqagSTGT5iEfWM0hq7LePZ9fSUytSF+mwxhQmB4zWqzMKkVnGXA69aqWC5ZpB4MTYuN+NENWaExY5fCVWqFyxFoLC20kKisTU6knrQrFChyMFh2Zfzp1rKblaKLHPowaXsxL1N8hJ8Yn99CG0elYZdWZGPgYOfohL7RNtPVacmp5ji7914t+Zvo3c002D642/qNmHbXMFU3vJ27jb3TweEYmpenMzK/Mc6vXlD64s/krURtTdnwvlaPUVkoSi4GE0gcW7+W9qPZa9ZYBueDGMv+MSYOW00oFaL2S56jUEFoJvhFtLGfy853ISWTFszJmTXQqc4/8LiwmSlHJQoFsmLP0nYiKdmXOXoCEaEtZ8kmLAr8hZNrUW3SVuqPq0LQjaonaqlWTSf3FXIDcapqSIs+zfZjFsHWdiCuzyNAP8czduLBKy+zVXWy1gXn1r0MZsJliqLVn9pSZs3h9cv89ggzRsb+qvaihcSKuapWXg1Y8sDTJy/wzZNDRbL2zGMp2Sna0LggDohR5lT48vtO+0sz2mBjhVOFSHb49e8LSz9/yDVW0Upq7ooiQzUpaBzJGR36ryo1M5BoJMBbpn567JPZXmW7UqtiyMqbAHOugVo+v97xVM5P7lHqknRnRnZAZJ7RLBMe//+g4jq+vCB/uEcGN/MAnX/Od2+9BcLFh8XyBngY26uCYFDojuHwh2gt5VUQqmldMIJlgytFhINNmJnfM8VJeHNdlJr0mqIppynemxNi4Q2BW+y4PXxmVi4q464Aa5GYCfP4mD0QyMgdn+i9z7crxi/G5ilDjluBHkXPIDi2UOYK8EHesgqxnyPQfVZyO7cySS0b+mWtWfIPgw2LDQkvVmSvm0Gjv9YxM3WvvTXC8fFYYRXOZPC3HdhaAUtM545uL74zVKlglVaettocRskM7YmAoUXU2oXjFL5jFKF43SrtRf0LafDRR5YTnb5HgZneItCoO92TROaqYuavn9iK3NE4msuSgPfQ184Tnl+Z/9PON9otqoaO9LHCMmbPje6WPP9Q9jyC4WUBHh+7OPK+m6czc37q2TCKWtjZ6tgb5I9RzZGeyZuqglRoN8rSCOjEiG8lMWmvcwtY6Uaum9YwqDo+wPfO9tCul+rAYQVgQHNob/8e/FcvpK68ODR4XQaZPGTfU6uP62UXujHwf9t5XJLhIHveq06/y4meiQtkk4nJwrfpUZgbpjGZRPjezpzSWa68RIZMec0/Jo3Eyx/6NdehixeEzqT4zOOlakWtspwJXsbqIzLOIL26IWvJzqx2QO4t45nCi2jNErL0zfFcw2PKeVyQ4gF4lj0wnZWrU1Z5DmzBXcBKvblObHZyjI/lq7cQchlggIU287J7LOHFbGkkvg5/2lCeGqYqwdj+gWX7xhiOmWgy81NwZEA2aaOsox1GfC3PMwZYJq2gubcz27RWL5KjttcVRaVhX+jq1F5rxMmPm0zd8rvDLzWKRuv5VCS7T+NUBph0I/O4VemxpNiNfS6vtsxuwy/2TmW1LaAe/HE4G4x7tvUSrwjwalXPv7aGMRQlaWtaofDbPUEoPB+j0Jkck3Fb6i/ybtUjpGU2WflQAgj7P+m+1JW5UAUTXsWCOatXFMaXFqzV2kVlVtLPBDGntLbO5ljun99C2bBXtzLy+9JpnEpwGDwJNVQgI1S+4d3UlU6KsHOFKzG0BrGTP1fLe2vHA74x5EQcqbSIKjYajLW3SNOLgg1xw+BP4+ErYvM87f+k4DhI2majsTJiZVMIks9tFOWmQAu/g3bEqbTa3i3dGfx8TmmeqvLwi69pBUpvMSkLmmpVx0johjj7gU0tWzZRc516Np9m0nBEBxDzMbLJ9r95azJ2LPsjYN6NyXKM23+37ZxJc7IhMcmoEQVqYVo/SrJjZLhad270VT2aMtkvNdAr3apJn1HltMeI32o5yzLQyi2SjVkjbW0nF4PW5mwYngsuaYlFO5VaxGJTJuTU8IAKlkChRmb9hcnJ/BosYvEBbw1enD/IyhltlnqSFQewipOwWQq6vnUQWNevaeBmVK1fba36/mTHVupY209f0EcdfrvRzfHZvl5AOT8cqyPTlFfJNPeOZBKcS4UyaXjBh1s6PPraMih4JLrNHszWRaWdt8oiMFaFjovc+0axC65CpE7UnaSOlhtPzn7R8iFkNdmpg3S7+hZumwuDnEOp4QHbsm55GFN+rPbwiLkxw5RPGCabtQExyJTDrObOLaZk6Mxpf2YWQ50KGOhC7ZgJHLZ52q45di6Tj2EHelqylVj3qWxWgmPHPxWfOvm/UnvT3zyQ4DVJ+98odKUM/a+ePBmAJDoMGFZ1oWeus1x6gTCC0FMwVJnHN9MuaLbwnamXRXxaz0OOCoIrIq6uofGI8n0TOLM4tTCAr+gCnPosH+DDAv3wLHqkIpmSImvyqf7NsS8QbMkBGfbKReTQX2sakLvPVMoU3IRswla8XDV71BSHmKHfLLxrHglwqyNGTYWSRxAV3luzTxFJcmDnHZPXZ3fueTXAjoVbtfCY9qnlmt0CvDZla8NqqBEn/2wbBaUdCpiQ67akdMs3AZGIpR2uEXfZ7Jj+kgxmHVsXkywQ0Ws9XuSPVc2OSRrO+1MjLunG1EklRI6uZXOALkbK4sNCwA0ELJ75L2gBuvdqBUZ6oCfXM3x7GZZCINogYISj5B0fPBx+1XwGV6AurtUF+ydpiW1oIs/7v7LiK12lfciZXcOX5zXteneBouOz82bIzZ4FiAH7pNmGYNK1UC2kpTB6igu/2UbCHyYNJF3MDI3FkfVezew15vwippZ2UVTXwTcqvhsap4w91P0TC4sSnp6VIy9JWPvVdWYxgZWIiF1hIg+M3bYpa6qz7Zfb61lisJWXfc9wq8NQ6x+Ru7y4LXmpf5VnH5N0a/MAHY0J84bZ6/s4gPyizHe1efgiREH3W2/qjIwwhsKxDOJrFreKT8uHFHRO0aSZKq+1WTP54GJC6WwSnYyG1N5fv8WkybtF0ojakZGQ0lJa8cddMGXHsFRlVAQXaU2pAyK75o+DSbGkgMOWnnIfyoyJPdsF54JS57FXISbDk9HbNSHCzK+9l0tzxQcqoXyHslcoLPVHuVSYmtrNVVkdbhEQI2ckRawSiQUNE5QEycRM5z2fyrRRWwEfVSuZV9JZ2KzjFu1RsgN+0TbXjskOKZ0FkpNZAcGjpcqRHH1kpU2vjfK+ySbZNZWAh9lXs67K6jhKaWcBmFpdsux553dkqRN9tqwguqtOjRNBS0KvU5qsBlJmxOuFoz9nokWSKZthVjnQ9O+PDYtL82i094/cm8w4hDj461q9MBpV/Rdo/1zLJ5BPj3/ijWlFmrq+lY/TGA20i+jirGdWeCZFRWBRtAYKFOBSxZuzwoxw87kcOrtfcUUS7jGCWGi/jUYUZegtuL/igc4S5PyZax3ev5mn2Fpir5+boeRH/lcXyE4LjDyvqtFYbBsFVh3mMhM9+P4qm0nZpAdlnnrmuFjgYPU9VLspzMkrNlOsgiZaJN7uLoraIyU9WErS0K8gGUiMaDfkoXw3NSP6yVtpOTIF5ZN0/iBdzl/czwX/3ZvppO1TN94Zc3IOsyBYrLKMNgkdNScgm9spXx3Nqe6X5u4g39pOev+IvjGX1wf/ZSovcLjN7fKtz6WyQoSzumEn+HE3q+H30Z8zcp2tbGliZIJvdhrPShuw9MQ1A99QmxUpVVp6nHQCZXRQ1gtPkzewIUL4aEzHmvrXu1fWYVtqbqmTtK4/3K6PZ0RRCZmldYAXh1Y6LFBnzPWk10XHO8/lhEVCxTO3vHB1Ukx0nrev0bjDM+ljjPFEqDQSnw4KQ7wot+axsy/efJTgmJauZzg7NNiRqfq1jymbNluy7uW4mQXbmuavXRjyi6aEFRKuyyE1H8PVKWZ9dHGokNxs84BlKh+DfPXKVbNq1MbupXO+hjRBTGXCJZpy0UJl8krV2gEy54DL5IQOubaVYRJdE7CPGXXZDP1oVJvOK/3hlHNI2BTZwZ8ANbPcjCt0jVdUGfMnjBs8S3AqQ3BOjVy2VerRpe/XdcdWiQ2tRu7PPnr2/tx0manbkmPF/8FOuWs2k65kro8NpZtteI8K495TvIZdSKyg11l+9mbXIxRYjEVzvPIX4bvxibFFCG0fziCePITPv/5WbWYmprJQeLaSl76rcYI4MmNradTFKklXkN6PxlhhGP9wjj06kHWjTFGxAfki8V2Y/tnNFzrNjbXj/swiOwSKndSvqE307rxQVaoXwa2BjZuGrGe2QEGnhu+rl+4n0mYz0XcvnJsd/GRAoD8QpTfOWz284kMIFtV0bMelVOwMgAKV1cDsJ0xA9BMfEiuZk5hBlngfBgeEfFMnKLAgceI21gcnF83tb5uKJVNKo46KscyzAV2MZWXhmNA97WnScAzoxTIsP38mHecYnqYVF0eZsP6KhMibpi54GyTVxHj9K28zKcfczGdINeaMLNYFHK/gVka0aLBnTE3NDBy1Hv2g0yXqaX6tsDu3pHTsXo/HRNJPjHNMaEoiJuKpE0SrTlD0SUoRI20viBgu0Xx29OKp+UXsnbWZLHs/4rTDxKUH1i7fgCkGK7M6A8oBngjMy97TtDjlGu3F0Ty0gERe07Ba12K6rfHCZMXsXCniWBncXYR7w0BicGEWrZq59QNO/+wpt95JWrK1ARAQZ3Py/lSoUHeXSbMrDlUWu4IPmVktAFuFRVUSE0Ar06Fo0o9UtZDLZe0cDxj6QRg3pyIXBJMUM5oMWqFO+0AzRPvlAfFmXh7Qr7uNZvFP7rrOpWrXirQomifDQxnhXJrgUNW3alW1Hb/xqzKymr5yaGzsSXC0aeQqk4mYdRJJJqGSyM7gevkUlKXB0ho9qhyEH1UHQCjCjOUIOEpcGUd4fJ0vr2aPSQyMxsn19RQRTBKT+lG+K/2P6QtCrBCw5pYVmI8dqE781HrEwdEjRVwdJv9wXzy0WYbIoyZUwG5Et+0zuktHZrqO+Xvp+N4JT2H80WZfA2vCmOGlHpaLQ7oQvpguO+l40OmoXreTmaNLW3q8JCHmUftjM2RGxy1rb6Wr+tl5Xl+WTHjUseC/mcSQ/8CnLubMAo2mCOdpxz9dY2xlxdQ6cNHpVln4UXt9+z24Ep0F/dZXUh3bKg1+G1sCgFoHwbzSrsvKJTCq+j9UsVK6pFhzJFHUs3x/Fb5X+KVM++L+SzWc1jpgLp4glZjfbtxQEmX2mEoi1i+Zsl8aFIJqNZUAHso4BilFkc1Ra6Wy7n37/bgRX5o2tABx9I9nTnVg1iZai1p81U1bafOU98dwFAhFnPjESuhJhi87+UsNTMi6TH0LikylwWsqj9I8YkY6OdjQgroG0sqewjXZmqM3Kc4tjrpZPFgku+n5VmorFScnFaExoeUSTyxSTUuu9bM/nmUFyz3t3IziwyvplWrhG02oUbdMzNNDuqTmelSs7jq5IsL4y125U2ke7IJjUqyW1VNwSRzhmXdyJAamVpeI1zuiTGnHXdmbUNFOZ7pmtdDX/HH3FvcgNKUNuCtxAnjHgEd+h90rbU5WW7Bh55HXlYjD17h0JbgqAxsWzJ8kr8MC2nGwUbaadrcKb2g6U1Syy71ypzKFnx8BBLc2AiYaGo4KYvTbpgOheyaOsTL3rYnWQ2m4G4QyJ0r/SuPi9EmmM5Z9UZ/CsrKP9yMiPxsYCjpWh9KFa7mM0sbNWTKYf5EqYMfnLWoCZ93z3GhPcFFynL2Y1KrP8Mw+Vhhjz06IfapSyknnHVddEsqjlXkXzrZebFTXpkS+p1XalsMRadTXtS4cxo8ko/aOHR1kQsyVHq7/pu7LS8Sr+OtNUtela5AFpsROjXFhq+53LHL1sea2eDLhweH9ZCWUkt8bLUhTWBDeC99rv44lLaF1MwMxmZvn40GSkIc5EQK+Vov+0WFeQ9iq3C20OokE7RCMdZdePIqxlK5iU0k50XKEqoJQ5WGdr88X0GtrRcmVccRaBimuyiPWOKaQdveTzGFCIhFwLBEnL5pmqEiQzvneAdm9kRH/fjK8UrBUBn/bjmuAeOfW/U5pbfht+8zPaETFq4dOyxBsNoz2QGH445OP/+IU0WVraAGSPYzymg/QirOXr41kQEE7N5yTtrVX6aYR1/D76Kmulwvieva8sSCxmpWYoYhlN9l6ZpSzR0u5IZIw5kphFGJmK1DUrQngoetvbxUFfqix+eTqXks1HWxpn+ufb15rgpiE7dYMcxXFbzij/7NQLOzffs8BhzK9SuSSc3shdM+dGe2QzGEAoKigJqUQTt8S4lpulNiuHMrNwcA331UqXo71hFkK0nCgWtQ/+BvlhXtLW/9gpcTSKakeXQG/fqsYeJiwpMHxG5Foj9NLnGHFezT8tF6dMf6euMcGlYLrLRWeP+zvTqKh9XOlEVpsURSRah0NbJo82pJemxqiu4KrTu5ejV+IXc8ogQHYnoOlwFGTtA4bsQ0UWVQKOcsmkqwWe0Lz+zU3TBR8qm/RqEvac8z3NqNbulSyB3liLroRs1kH5vDOVV7rzwAR3hiZe+16RgnLzVK6IQaiUAiR4dDmeEjUmKI5kTFRMlFqqR/TfaBLJuc7zMoGB+F7kV0FLkZIOvsFfx2lqfM/nNyvkowAPbYYweP9sG3gGcikye9VoglhpO8TZCjhcVYpfbV6JjtbGwbSPbQSaCW6E0Pt+H0kBB7/MEkXRMOcy1SrujUDU3lrRSGmATACVJIKw+WGyfv22NzbT1pjG0orOsucW3xfvYwN9rVL12UBFpq0r18RAVm+byY96VgAAAeZJREFUVnx2zf+58u6Xu8cE92mXMGmYUJgnmQjny3XqrUHIgH8IGdDiVHJ81YyIqzXkiOl1xYorDU5brbJ4Qowc68j99BVmXia/qow+4xeUPLG/GQeQIeTZkjP66ZRPdrmjPAAiPyPtQdaa708LBhocCxjySi7+jfbKfQr2nPF/Ir98uVeMhWzfp68zwX0vVK+aW5bu0MGFo90QrORMVAZ/iyxqBS2vat/sc2grExQfWBmZ6z0rbiiPTnqZ63Ec4EfEeV4eaajEXNImmNwU22Q+9WrpZeRT4ELloWI/qK0sXNoSSKCAa4hAR5KJMkhTjfltCjD06u1xPVi1th+uaIsZDC67xgT3KZSxntYrVRK+rNMbD4qaTS+x9pUIbkRiaBcxHYLryxPJanlgwkIHSjPBy3QeRf4gVp07i6aEhpw1DZUIHNvYS7KFjEi1gMzkI8R81s6TGDCKaTKKfNZOmqMN3E8bogYbI+GtVKaXP0vZBHdv2rj++do/eHX5mWxibW1P5PVSzj2x1Ka4Wz7IeC6usun5Pvr7mPh8VDCBiY6ckI0IpUyP0OQmBQUyAD9I4htJU5n36RlR6xMJqZJJy/TjOr7j3Tq7tkz7wD9JDiLPUsmpTG5h1P5oZyv95F5jYWRppEfH3wNh4maJRALdSQAAAABJRU5ErkJggg=='
            />
            <image
                id='image2_521_245590'
                width='223'
                height='198'
                xlinkHref='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN8AAADGCAYAAABSIFV/AAAgAElEQVR4Xu1dS3cdxbXe1ccW2CYLkTu/lrljUEOmLCwbS2bk1zAD/MCPhAF+/ICA/QOMzYBYMvg1uEOwPIolAoKV6cWtZJwg7vzGYiW8jnS67tp1qtrV1dXdVX26T58j77NWFllWd1fVV7Wrdu3HtxnQjxAgBFpBgLXSKjVKCBACQMJHi4AQaAkBEr6WgKdmCQESPloDhEBLCJDwtQQ8NUsIkPDRGiAEWkKAhK8l4KlZQoCEj9YAIdASAiR8LQFPzRICJHy0BgiBlhAg4WsJeGqWECDhozVACLSEAAlfS8BTs4QACR+tAUKgJQRI+FoCnpolBEj4aA0QAi0hQMLXEvDULCFAwkdrgBBoCQESvpaAp2YJARI+WgOEQEsIkPC1BDw1SwiQ8NEaIARaQoCEryXgqVlCgISP1gAh0BICJHwtAU/NEgIkfLQGCIGWECDhawl4apYQIOGjNUAItIQACV9LwFOzhAAJH60BQqAlBEj4WgKemiUESPhoDRACLSFAwtcS8NQsIUDCR2uAEGgJARK+loCnZgkBEj5aA4RASwiQ8LUEPDVLCJDw0RogBFpCgISvJeCpWUKAhI/WACHQEgIkfC0BT80SAiR8tAYIgZYQIOFrCXhqlhAg4aM1QAi0hAAJX0vAU7OEAAkfrQFCoCUESPhaAp6aJQRI+GgNEAItIUDC1xLw1CwhQMJHa4AQaAkBEr6WgKdmCQESPloDhEBLCJDwtQQ8NUsIkPDRGiAEWkKAhK8l4KlZQoCEj9YAIdASAiR8LQFPzRICJHy0BgiBlhAg4WsJeGqWECDhozVACLSEAAlfS8BTs4QACR+tAUKgJQRI+FoCnpolBEj4aA0QAi0hQMLXEvDULCEwdsJ3YSac/GE7HA8A9rAOXLvxp2iNppEQGEcExk74zs6F3wLAFILNOKzML0f7xhF46jMhMI7Cx/VpW1iKxm4MtOwIAXF4jBsMp+fCOwHAcdnvaGEpemXcxkD9JQTGUviw02+/ER4JAti9awPuXluJ1mkqCYFxRGDsTr5xBJn6TAjYECDho3VBCLSEAAlfS8BTs4QACR+tAUKgJQRqE74zB8PbjMMMAERBABfJ+d3SjFKzY4NALcJ3+s1wJojhSzVqzuH6zeXowtigQB0lBFpAoBbh+92b4VQcA0aeqN+JhaXobgvjoSYJgbFBoBbhw9GemQ1PoPObM/hqYSl6f2wQoI4SAi0hUJvwtdR/apYQGFsESPjGduqo4+OOAAnfuM8g9X9sESDhG9upo46POwKtC5+0lH7AOEzGABdvLkcRgvr7ufD4Jgc04qyxDlwmv+G4LzXqv4lA68J3Zja8xhiclx1bX1iKXjgxE05OTMBj1VlKmqWFuxURGAXhO8EY3FbgYnKsxW9IeXtbcfU95WNqXfgQf8zP2xbATI/D/Y8/j1ak31CciJzDOmNwcmEpuv+UzxUNf4shMBLCl4cpkiVRsuwWW3E0nASBkRY+midCYCsjQMK3lWeXxjbSCAjjBpnxR3qOqHNbFAGGPJjdLrxyh4iItugU07BGFQEUPs4YHJl/GC2OaiepX4TAVkRACF8QwJ4y1RPV02d/hnWyPm7FZUBjagMBdvpAOKN8a3kdODsXfgAAmJm+xjkcVSFgbXSY2iQEtgoCpdbOTKgXwOL8UnRkVAEQhVSehSMdgLUbf+o77OlHCIwiAqXCh50+Mxs+Zgwm8f+PepylXkgFAIjOYhRXHfVJIOAkfHjf4z0RfznyGQZ4h1Vzy0b8lKY1+HQj4CR8w4Lo3Gx4njO4wDis/bIBR6u4P1KnNIM78w+jk8Pqfxvt4J2dMfiMMcCaFRcpBraNWajWZu3Ch6dkrwe3AwDgDK67LgbzbgkAl6sQMZ09EF7gDN7DxRgEsK/Iiov3wx8n4DzjMDWuOYNnZ8NHwCAchytBtSW6dd+qXfjOzYZfcibIc/En8vNc4LMIX+P3tbNz4XsAkDCtBTHsuyGzKlz6PArP6HiP+n18FPAapT40LXxrC0vRHtcBy9QiVD2HQj94di68A09q/eEN+OLCw+iaa39H4TlxH9+EWzEAdLbBqTJ/7Sj0mfrQR6B24VPGGQ4wCUyojiObhydV5EfKkkvWURKLYSJQWfjeOTi9byOGyZvLqyhcqVLNdQ8A2+piHXbOVz5e+qvOjD1wUzJr/kQcw0pZsEFZY6cPTJ8MArY7hvhu3f0sa5v+Pn4IVBI+NGpAABj10rjfD5mwNZoJLzV2mNPRYj/VHDa6AQ4Ty6elrYzw/f61l17Y2MkmP17661reiWYYVQB5V5oC7OxciAYRNIzgb2SF79zB8DbncELh0O3CC1VcJb44yupQaO1crGId9m2Pnq8PgZTQSBUMqw1NFVnO5Ml3VXYD3QkXHbqEbXnvzuIOyeE9HsM0BHBvVA0iZ2bDkDH4FLEDgCvDEATjtMUpaNxC7DDP9IgjAinhM2j8oCjbQRorJsuCrKUvDYOyD3POr9xcXv3MsW9j+dgweWd09V+CVck36gL0794MZ+IYJkfZgOYyjlF6JiV82omG//7twlL04qCd1TIi8FPOfr9B230a3pe+0W/wtEWWt04HXm3C1aCfsORLrG9lZe5qKICMwcusA1fqmMhzb4Sf8g4clV3mC0sRBr/Qr0YEMMTsuU2Imsq1NPyhtIHWNHeNGUpU/9RdiHOYZAFcGdU7W014bsnPtGjJ3ZJ4qkE1Lnwjjh4mE5/HONCbyxFGu9AvBwGMPgoCmNy1AfebOmGfNvDbEr4qvilnaym6S9iuIPzo4Som0+ZaWM/OhneAwfGmjRVP26Ki8bohIIRALdYu52tNR2acnnt5T4cHojBKj8XXXdrDyJEOY6/HAF+VnVDSKofuEvwV1ngw/JV11YNodGNxm1Z6ahwQEAtFy/5ea5pG0DcFBo0JQQBKmArdH3IsqWDpIneJvMvckhM1sG8ON5YAgi/QqtuL+alPPl99VLYIpIHrcAxwt2xjKfsW/X28EGDSIJIsEs7hZJOLwKB5KD1tTF8W5/BKkW9RCisKAP4wIqbQXYJ+OXywjnuMvrGUnbrYJt6jOh1I/J5E4ThewjNob5nuK8KPBQG8WIeLIa9jRnRM6Wlj9M8pmkZmd0/v2oC7dQiVK8jnDoRf8AD2iecZPFp4GL1a9K4UPoyKEfdZzuHVsqAF177Qc6OPgFA7ZbTKYc5hddDIfpch42m7awPWfARjmJEjLmOwPaNy6yCAdRbAJZdNDFXfAOB1zuABRY9URX4833O2dr59YPqVgMEUZzwyjCRVDAzjiRb1mhCoEQEn4TPuhYlRRlou/4D9+WUDLg4jir/i2NnpuZenijI1tO/SZlIR5AZeE/OG33WxitfQPnv7wHTIAr4+jPachM+0OCqjjG6q5xyu31yOMIB6aD+R/vRs5zg6f/MSWPVMDTTAFFlzdfKlEquvmKSJn+O1P/7lb0nt+KEN/ClpyEgne39hKbrc4NDR+PgF6/MP8SCG/U3z+TgJHxo9npmAWxzgCDCIAgbH8D6jGxja4MjUneR5Ab+uFsUMgVMBn8vZuRCtw5hD17hrxrLY9DlzSdFi7xycFoRWHz1cTVw2DS7iuj7Nzs6G3yhmNiEQDRoDpZvoH6rzDOD+/FKkYpLrGlPqO07Cp9743Uw4dWMlwiRb8dNy2L7f7PFLt/5cHFFS0wiSSBfDbWFNtNVcD+K9ogk8Mxv+kzEQbGt5J7kpzE27ZnTMBBX+dsHROYObjQu3aSqrZMwIouTJJ641Msvmv2paQ5nP/Pa1l17YtaPzdzn/WLkLOV9PNdUeftdL+Gwd0RzLqJuX+u0GGQxOBuOwNwb+IeYFurotpDN9qoynRQhWAH8Q6Tk5TGAZYR6CeqIwMwXfhW1N36DGMR2oP2b2nzu7/J6PdbzKOhPseQze9bFWV2lHO10HeV1Ex6CTOCmcUuYEr9qa4Wxf73ZhDxp48E4HPwPoJ3LVNlzf09wDSHF41/U94zlvw44p+IzB0bK6iqkNisElyiqpOFsNvDbQyWfSGHAOj5tK6DTyAmFYHCkNYA66lbjH4is+ljUh+AwOcYB7rn5BGXSAmRtRE+Ohb1ZDYCDhM04jHsew39NJ72w8aIMjpRqk5W+ZrN7qFC9/k57YSghgZdr3OYe1m8tCfXKxniXjF1bQbfApD2AKGHzoo9JoxgO8K953JGGCASNdytKSyv5eae6FS2RXcIT3IMJga8NQVBosXqnR4b3krT4Pr2uj3ZIoC41d9PDT+Tisc0efYd7KWuJqnVSVyhQDRLbA8SdpS/xBnSRPhp8RsB5EjG6KAAT7Gwe4f3MpOqbiO0d7uaR7p6eHsQ5ccwmnG6fxNd3XRPjQZ1VW1cdYSANZNi3MWwntneZcLe2TC0DSh4e+OREtYVLsWTI7CjMnXNpUz2QslLL6kjz5pzDG9ccJURZt77ilFbn4WX2wetqe1YUPpG8jt56deVqVVPUpOrnYb197afJXuzpXOYe9kvBVcH9KAX9CCf/kRKysElqEKxWNYzrY6/Td4be3b4d/qHoQZuaCSdfYlLW4iYXt4mdtot2t8k3mkwZjhpnl+Y1QHWE8uNVfcPzewtKqoJbHXz9Am11FCrMei0+Zlj5tsarSYsgCvYdxmHTNfDcnRwjXdvhCRUvYUnfEacvhUJGPr+qky6wRjDJBlTdlcTSZrsepTJmrn7UqbhXeczbgVfh27a8wxQgNHJ6POVwpMkdbBCNDFY/Ghd7ODmaHJ74/3S3g4vRVzk4ewNcA8DwAqJjRgejiR9HkPu5W3Db8rDlSoMdmXnM14NUuUR4f9HY1GLtdJlPctORhX3QqBz2Ey6X2wtkD4WcQJII8CryftRqCPOaKHi1AADWqTsCQQBh/QwmMHnRC2O8OhDNF0dtnZqePMsam9awBvPvhicR/iR/ARHBYZRVsCwL09eklvNCSmspWVyFcwGAy4HDlRglln5btjcFwrUZoyI0Hy0hjXOUop1ANui7qfp/9/rWXJv/4l79h3Xgvd5ZrRzA287mdnf9RRrVhZCW49i3vOTyqT+RxtphkqWaajR5apu5/MpBXsJPVICzCyFInz0pVwAoMQVU/6fye3NUPb2P8q0EyE/Aujo36RNQ4dzL/QTTqYZUp/N+3nMOxpiJt1N0a/daewR41DNP/E+LOl+efMcsmmwQ/Z2bDx1pV1+T+V4Umwuy6YvXiASz6OO/9IXB7w7SY1lQRqFSFtfkJdU0F79guJ4pRf96nmtFARgx5Iv1ToTyMVB23GW3/qcI7n0atx2Qhjld0QX37YHi7wxPSWSdyI5chn34znAlijS4whn1NJza69Eu3iO7ahGODRNlrET6TRdWb8vyE2F8t+RcZ2AoFqopbQFSY2g5fSitxVSMGalf/l6TqxLAy/3m03wXvrf5MqcFF0oSjGrnKLSS3TVgQMy4NBkfKovfbnCg8fbrPBlOffL6KbgSnO01eloY5DpNdTneTqOgk+U4xQfBc+CmHfsGaMn+u6oNrInIZ9kJrALjVhBunrO1R/rvg7SzSwcvufXUOru8fZCGSNAUQII37Wwwgmu+HXw3yK1Xvqn5c3jMeSfXb+XQwKBJK4zttlYhkpvcrUqBuFyV/SjaC99Cl5FqBqi7hq4rtVn+PoZN3/mGUG9ViLhKM/og5X2XA9nLgX7mwMruAaCzi2ugZdF6WXsyP1dVfNSbzXlzEkK3jYDj+S/lLbRjK+6AoRb2zC9cGUYPz5ggNaJzD8TiAxU8K1onLHNMzaQTw5LtWRHxki8EEgKSiT4W8OkE+9EwHJnXLnSU3sHJ8pW7V01UzaZHF+0apaqgyESYA1oosjBrVAZ6utRQUHfYixbFim0QGNVzkC62d2BW5uyL9+lSPwV3G4G6JMcRmHdN5V/RaComRQFoT0UkqFnG3C69WoSJMWfUYXAQO72J4moR1nXGIOAPMQH8/D2rTwlhG1yATXKdZANeHGNlfOdZVH7eh2fhYQZtYqbWMqYmONfHNUoOL2ahhAED1MCUk0s+HoWUiRw+d9AEwjJn8brPDv9rGmaqjgFK2OL8UJWFoSo0KArhTdRGb4WsbPf7htm0MKdlTv6IYSqN0mLOBookJMr8pw/fQADZwjfuM77Jf20JtVMMYTtKGlvL17Q8/9e7991NAyegtfAotZDJ7FmBdv2dYzOJ4H9GLTiLzmUrrwU9dLjqBHGdfjAGLXGKkDWZJMCYyJVC478cc9um+SPXNoswFs5Q1AJwcgKvFcRhujxkbw0Almi2BA6X1JSy9FNSEGzFMDpAHmaIJZDF8+TS4I0rDy9yWRP8p494mQstkZIP4O3K8KGo++d2B1ZwzB8PbjIMwOgiB47CyGcP1Tke0t8YYmGW6sF+YJ7jfOF0Ti6gyjWMInG+Gvg9eqsvyv6X3UHzOyIIYONZVqp1vyfnxjj5JURMWbKYawfFjy0aGUTDImak25rG8O/vOPTs3FyI5aKL6eXwgw9pso5VQ4Wbo4wGA/YwBqoBTPIYVB0d14R3ActJi95PTwJKnd51zuP/cJkT6if3ObHhik4nwJ+e6eh445T6aRPEwQbko8hkNgRQyoX9AnFY9QJ/dlK3GvS0Wt46+5n0jZdDKP7HYmbnwMwZwWH4no/EYAfv4dx926sZcSU1ihzsO7jKmnl968dVZmzmHo0W+QpN3xYWHBeMZtzH2blE1WqMWn8IpZbY3sigyk24K6BC4LcVCOXVweka//6o7aFVuG/ymoUYm9IpFC+idg9P7Njnb24v5YhU3jCSD6qv5jJ2Yf/jonqU9tKojIbGohZhXPq1KDK/MD0Wad/x205TytcoiO3sw/EavIye5TKaLElfNu0LdVPEyb/BbbbIu5sV3qvJmcQzfBYEggkolq+pEqDu6cMr0hWXGwmFlfjnq19hr4Kepyan7r4qbHcTl4huWZ8arVk3kRYwZg/WiYGaDfdr3ZMubCXZuNvyC9+srCC2h24VfV7GSNzDVpZ9MRbjkhTzh7igv1PdxgJrFE09MVItqi+vEHtvUxSaLsKiFgaoxRt0XLSJ1d4EO/x44X/HJELCQRj2CWNxN12/KeEc9nraM3t6cXcNxb7vXpl6xCHqjVYkbCEXE9fsBY4DWX1yHqMVVpZRXaU9DK3yTWDstZmc0sR+JY3iBMbgttAXtVFBuATSi3FyOrpeKuecD2k75PQp3XhUix8+W3glcVR4zWXhbj+//6M9uBUjMxZ5XBlreBV/ucbhXJTXGZom24SS1hm+khlEqrPIbpVg6zkktj1UJmzMbNkoeDE11TYQvQzIUw5doEPlpO3ymHeulMYi1ICo/IvuEdPTCClZFLZLACpq+bYx/+NHD6sVcbBuUb6UiaYBCw8PiKFAdqBy4TgdWynyrCkvGYZ114HLZ83WuhQa/hW6O28CS7JyBLciufU35+SSB7rvAIVKWyDbDp8w7jAe3aDL+s7PhI63MFP77/W4XTuK9AFVItisIfQTynJYdoBqpk+3MdeLaeK7teowNjTlzb1xYipDfq/Gfk5PdIXyq1DpahRTWIGxCnd7b2W1YOxWglzGKptcDlY3gFchtbEhYTqq0YEnjMwkAKh7V9y7q2rdU9NAWcoQP6OZwhS/znBI+4bPDv/qam3HC4x2d9ziD9bx7WU5WutPdQd0ty8p75SGgsYMl7hQ8QdE6ZwQAeBkbxJgADvEOPKgz074q1UNZxnvlFaK9KO+sol6eJUihjiZa+wYag7DxKnfsqp0WAuAapWBrRFdFbD4yU3VEY2YM8dcdHuAkfv/LBrw/iGnYhUZB0CPGcF6Gnq2xAC7FsYiKQcc6/srYrpw2iqqToN4zg8J9hLoo433QftH7zSCghC8VRbGwFKXU0aK7kWn9M9+1cJ9g5AImyqpQosrxndpi9aKVtxhOcsPcpEqC/V2p0UBiFeYqVA9qWegB75Ly49UtYhBpZuWPwFfFIkixVhs5aWfnQgw9Q4sj/jJUBYbz1JoUqj0jzNk6vaB+WqLKNcHYlKsBRCdwKqFGSKU5ufq36ioBraJIUC1HECWbN24+d1VgeSbSRt6pfHPtbBnvI7DOqAsWBMSiTFirY+AmxYBLLYECH5l1hzeIl4TA6gLBOdy5uZyfXa/GYVDdW6NgTh8IL3QYTMUAxxmDtRjiY5vd4PHEBGDu4JR2SnynVFD1fVuWhm92g8FHg078CGuqqzb0zHfd2Y9FRuMYQs7htvTDVdYQbCsfNwT8dw8qQmEXYAFftwUW4Cax+VznMI/jr3wCD0qk0sWQN7aCXWrtNBjMbJVnrQImVbsPsMbCJueXTEOOGe1gMFNnaOhtCMuIDmTXmmIc7v/rp94lPQ8sE1GSDhRgpw+EezHI+scJcfdDSvqo24V9+h00CQyPYUVFofjMtoWGQ8/sKAyHMopo6pgMdAetcrdM2QUs5dy0MK+y+3MpfCpncZD6HKWNjMADpcKHfZQnAO7C9/XYSemgVTszOo3xPifuj2beWVn11Sr+xExcJoM7Oh+NeWr3VT5Y4RwWGYNpDNrmHVjTM/PLstYd5iwlGEYddQwluxAE4kTbW5SuZLkrY3Ly0YJMCIeu9R/xrYybpxJrDabz8QAwUwaZ0lLqvmMH005vBlVyDB2bavcxJ+HL66KF3yVh7zJrqLsQC8mTaso1k91c2Kbg6BQYqF6ie4FzeCBjAdWwjnIOWFEJeUwq+RLVh3SyJhlhL+54iVsigK9dk4ctRqHLcQAr+kZR1bmfYU5z4EXVU8NQJTaNOSlfmaT1P/1meCeI4bik1z/qaNXOOL2DAF7cisYjH+HLqDrmJOJCU/XljOo7VQKvnXZNkbUQwCHO4H/zFjbGOt5YiTCLwExGFRQRvR7c7TB4S3K7CIHBXbvojmPbkAwezYEpGRJtgEEUMDjW68GMirOVWOOGgtjm8tHkqevPPAPISoYFOaOPHakZy5jI8e7/M8AkYm24mDhncPHmQ7cYYF2QkTfIkTVtIFW8jTMQO1x6qdXVSxniJaghTNo8uSASZ7U+GT6DUzltABCikWSzxy/dcgxeLmtHOw2V093KtVlyx7E2I7OxxXdRSIp4NMv6mSc0ExMiM1+n4kg2vCrfbOodpInftaPz94SpOj/Xz9oFnCf4GUBtmkX9HNeYUzziv5xfFvTduTQGJqGQogu0GRNsKonvBFvuaoVcJf2ESpi6ubwqUp7K2lPWXSR1sp0amTuOQfSU9/3EmQ/wfWM8mrPhHS0IWOx3FdSy0g23DEOXv0tbwXFAtriH0TWXdyo8k6KgGKdaEKostHX3V7lrHQaH8xIWUQCxnjiqbPqC0zg7Jn3TgUyhRtUw+KF3aXNHMINs1rop2/BDCqNEhQlMvWKJKa1CatvIAjdUW9RbchONbTigi6EXs7eKGALwvSpB50Z7enUi/FNTqTrYTizb5jKxe+A1MOgacnk/qclupusYOU4i4ZMxeGyz0GH2exCw3bqQ2cqHuXRIPYNqH4thmgfwPePwnfTTCRoCva+m6luBxDdX7REhaf3AAnUPdBqCZpEs5Ad1+pjx0CDFaVwrLens4RVpNXBdoR9VxAsrwWgqW0DPxulsg1PjYpxJhM9M7DR9TLboFgTVsHgm2QGpbIJ8c3Hp6ZBDkpQ4nHUeF6lyDFrXoYpMJO9k+utwMgktYSeb/Hjpr8IoVKY6V80It0T2XLcxBGRyOzl4sYfLjRvZyBLBGzDLfKA5GdWX1ZGdsUbayjvHEL9oRi8YVHZ4QgqDi1yEVzkXxDb7TW4VKbR70eeWV5zTItxiYcpKPatqoUojSriwFN1X6i66FX74qbfoS746aFqOxf1SGJlybjY8zxmI+5DULjAE72gTu7fOjWMp+ZZYC4sqI+Us5JRl2qwSC8Au7Ozye03UkmhSsLS1xJsg8sUojxlbGoUpVDhImwqi0bwLHMou//3oheAEABPZ5fgromLQfXXAINr5C+z/90T8QgDBVRkBccq4A2JZamEN9FWZXNJy0Lhj1pnQF4Avj4ptk7MlDWtM1fDvH3vXfTcV7KNx8iXsZnhvlmFsmGZ1ETcxRUzFOayWpNmw02+Gt1kPDuPdXAWfqwz5cakSaxHilLO/CUNOrp/Pcj/A/llrwPkArd8F9QEXUURI18OUOj0NlTjVJ9MgYWZZ2EBWJ6iZ/sQ43ImBP1BGHqO6q25AyPgkXegRsV2ZGY/B68k3bEHiJg1+FYY104qsMNez/X2Z6E4dnN6nUSAqrSTFINfk6dTgt9NW1AaShwud7Oa9j3G4Pr8cYQyk10+5Ajhnu4MAPsh52Tlw2IieSTmz9ZrwchGfyuusVI9uAQAu/svdLlzbvh3+YbBq4+vrnPNTjInTWvnYhNBrycS7kdukzIpo64uiN+QBzChy4YyaPhcWpn25TAhuqADQ57hEot6H0atiAzgQfsEDEIHWvv7JEa7hN7DTXXP2c8bYyRxOUhforc8oJzv+MeMf040ZVXPEck5QvT1hdClTV/WTASNPOoEofrIbKekNXx17+43wMNZtwLtk0R3O9F9iCBx2TCbaTkuhzANXbBYWw5SX+V+Z9PkPccS3dZ4361+oxqWAqGyIKhFD4lNSS0FsktNJsQXg3x38k6lFbaFD9HJ9VF65BS8iazcAe1fLBkH/b6WfK6tdlY+jk/0aZ4Bugku2VBCcmI0NCH/Vg5UqF2ZbCBoyfsUxnGQMpgKA18so8owAbjXORXOhqFMIH0DSX8aD5wHgS61QiiJr7Qd/HwgvQADq7okn6Ivq45m4UR1dBtcWHvbp3XM4YpxCywx3TmlCsAs5LfbJMy9S8VXifa8wQEGbyzVVaFQaZ/6pbY55ickDn0SOC3xs6j4krgYUCJM2XpHlmo5tRxDEYylV58mLXk5rW3YCfsoM1tZPMpm9sA6BUCmTn5krKM32U7s24L65uYhdHeBdYCBKL8tfSkgs1s1cOnS9H6ZxR/ztiVui1AWTNwc+ebVY47UAAArWSURBVJHapoYnamFJ6yJafYUTA/h6fllsSikh1sK/rOllPuvJ4Vkk0v2/J1cH9s3C0qPfWN5DY6OobOUayO/QttcjuvBh9Zhfq7frrMWuDDJxDOudDt+zsLSKpvXSMDCtL9eMTAT8U0ZVNVRArFCE6UNJBSMlPD416Fy4UbR7Zl+FjmH/Zj8udX3bT71FW8VXi9CiseIUumYw+beIrr9ohgtyADOvmSpjkdHLKa1oLnzPkoNnZik87nbhRSPDofJmY8NCVZkSV6Ucp7uukbVVkkwc0TjhZsWbjGUsgD2D+p7OzIaoAuIuW6piWU4JUR0XAQ2wuqyFNcxQI6/gjhbHIN7TAsiL7ksZ1ciomJtrzRP0ilKF7jBANjd1P7OqoIZaixvRMeBwRIvbTL1nOOLz43DnQsxwEAxjLIaVojp35gZQRkqsLdhvkVZfvzeeOxhe41zQtuNPryxcVE+BnT0QnsfcSs4ER05eJJFThovHsYPtfqppRamDx+M7Az1a6GpILGM11GLImPGNxFeXUVjM9xlhsRkUlGDEAKt51PZ9FZv9AdlSeyxO+Q6lACJ1/orm82Kn516eklEpKWEw3R15uYwqf1F91/T5qfcMFTXDMWryvOB3AeD5XRtwt+ierjvTXVJ3ZBGd1y0W3cIcPI0NAac52fxO7Z8+qlUNzsuARzUSLbQznnmBhUvK6FNdhVtclnHyTKGrwbaQvb6uPWxezC0BsM5qKH62jKbCp5++WQxlwpCyTGom/bI+6Se3HipXlPyqOcjRfeBjafQ6TczkXvOUNLSOTMESW3qZjAlGV4/6ZYKvTQFF1bwoIqoMY/3vVVPefNooetYnmXbgNtXFXIRRdeABj+E9tETiQvtFUri7NtJkeeSyyBhTXbMVPKkaf6nIW/UCnkUuH4MO3xoEYWIqDCA8EAU2A8R+Ay6WZZlb+HAyflkpoHt3dmHRxTJubCpWd5OpnuN9+sbn0YrrOhnl54YqfDoQJmGSLyWC4WgfWGfXaRIYg1MYYpU3cRlDRQ334bJFIq3GezsdWNTv3npQAUj6hrJvZXyTDiemseHwzR5/I2BsOggAsceCmF6aC15JtVQg7HJugRJxbeDwVtyBRdds+DIMRuHvVuHDiJROwLCSDu6kqUVYh/sBB24YdLzrHaiYT5uxqCqwrqW18PvaAsYcQsyk8F18VbuZeU/5/7b/3Fvd2BUcKavVYN4tSzhPRXuiFNcz8AH0YDcauyCGUBmHqhSwkcL3dwAR2FB7jcfawG3wQxnh03O5sF1dtzeiVbwsluYYhPAU1BavYcxF5mv2zsFpYY304K1MupSps8dhpcdhEYJ4sUbOSm8IDKE6mnd662TDohGHk8/sTB2xpjLzH4McvtvRhcsuqqo3KCP8Qkb4LLlcCSeLhTYit7hIDZnQlWFT2fUxwF3b5bwKP0tKZe6b81Wdh+RPZXdFfFBPeXIwHDj7v3ysyUZtDpEGJjQIBusOfRLjNQwsx4rU9MoT2X9xWJExA3bT//WM8Bm5XKlqpbYg2uCH3tdmjTuD2sGr/JY2hFxTftEwXRzHuivARWAsuz4SSGH9hszPwVeWpDxhMLeNQ6YKaayZg1d2/xMbKYdDwOABcJjS/IupELwirH2Zyn2XJxqGkFrf5v7x/Zbn80MR+FyDi43z3zwVMcuBM8C7ITqxEyHLsJp5qjWmKT8IYJ+rgz/jK7NwUhpByl6hbjiJhXGfOQKF75nm+ry7lmHJdbJgqu/3+nl1SAzlHExsYLaO7N/zyxFmg3jfYxV3aQAQsQ6czJk3l8WdiYzRI7A8hcn5cT0+mHXgmuu6c25AP11yXsoF5+xs+I2s9LoGMXwIWoqQ2vUtZuncKkB6+6I2XRwcDtiTy7xUPJz8V5Z2rYRKKlEUv21zuuuJqzHj37EY1bFVVSxGdEkxoMWxWOyCWyYvHUgfo8HBYi326RMiVmXSMyf5kwDzZDMuM6LYCrhY6CMy8aLa4n6+pLQ0WkNvaxoG+g6TwPc6xm35RjqBtoEcPr3NzMkndfnzjGNREbho5pXhy3gC4r9rLF99YiONWdhWYroIMJ3iwHjO2RJaR2ETbNtMNZL9yc03TLK+f4kfbI/5+h//8rfCDIEyH6ARfeF9MldZmOI0Z3BVBZGrUxkt32ZxFONa8YRPB/2HECjuFpsFk52ZC+8wgLewj2UxlWKD24RbPICpOIZTQyhcmaK9l7wzjQk8Wv32dTlfQytdRq104Kv0oBsoXBNmlAkOnMWwZonhLIzMkMaEwzyGNVVX3ncx6uS32ruF6p8eaYIZ8GbRFt8+lOSROacB4UnTfTaY+uTzVczfK1QjE3eCrFYVx+Je22fD1q4Opo9WZ4yTRrm3bPhnIlpGsA6DYUiqnDfpMt8qq0Hc17ZvhynGBCNyH28OK1XoClwatj2TlMiKYSUvGv3MwfA262cqFKbAVOyDMPLwXjDd6YiM+4QZumyXzmT958euZjYPH9ImIw2o0JhluI3yns21qBouiSTQ2yhqE3e78B9lETLSr6erkV4U8hXns9JrdYZVFnUgSSlSESZ6jbiySI9KIxvgJUuxSi9KO7WnyP+ap0ASwCuTfa9jNSHg8DIEAFgroejybSzI3I1LM/MnflLd4FFqLe3fzxIqDhna9sB2qpUVRFH8onkumRS9hHH/0bM4XNVBQ51OWdIHWBZj+6oSvkxEuSsBkMfInX1Wed/MxPl5Vq9Bg4CqBf+vn3qXFQOYvJ/u1YtWyj6scQ6Xc3xfGaNUme/L5otjDC6nKvWWZHvocZ6CcoUDxjmumvl/ZVT+Zl8wiMVM6Umc4P1Y3Ct1WP6kACKXz906vuex/lp/FDUc/lxn+safoq9ws2SCPYvB1w1y6WNBFbw3oEsCa/h5VdQxERM7LoNDHOCejzkdv5Ni6ZIqta2AptFmpk5EnxCKXUX/k2mUKrqrWfhshOqsXB8u1lLsm3BZbMIRzvqB6f0rGSzOL0Uia990afQJoGCfbjxzCZRufbXW14GBN/5BuyJ9lt/I+RL5jk0EVqdOBItv68j8w2hx0MFUed/IsxMGFDNDgXPAyrG4oJNxdLvw61S12tnwkXS3pBa9S5+UcxurL+3owikVUuVbSz2Dq3Y/1xzuqhJTxkyvO+WrkmO5jLflZ0S9CMZhd4/FV1oM/cMrzQcaG4PQNGsVPmnNOoS1FZRaZxQdwblw8vlpk1bbrpXKAJCsZ7b6BZwDk6crBg9/aGoFOmlSQVCyqO+HAeq+hWJcF6zhM0yFeOmM4Xl39zxyLM8QONfuDv05w7pqo68YWp/0Kwlu8J0O/MYUvsoL3UI4m1hKcYEHHK7yAL52oKZLAJGZ01i+OXKNOSxD0+Zj0+uuuxTaUOOBANZZAJfMu4vICmHsljodsU+qaGhZ/3z/bpyYLpEjpU0YxMbOfKqlH27gAanOHeIsfmCcbNbTps1cQHXflSUSokT4XGsn5OFnuUM4h0XZvul6J0lFo0B8t0XVIhmGjcvTN1/Rd50mYV0MVnwTk822jHAzJxpES39r2QiKcDDuUZmTTUbc/Fm6jDLZ9b4Y1/28AChj+fKMxRS65Ew4OTEBWBZK+cYGisywZIvfmX8YnbQsFAz7EoaGYfsl8ybDqHOBpEvrdRQNzWvPoLHHx1KnlW+GiaGeezuahVVvR/A+B/ayyYdT5wI2NmhrJJQqNbBrA9ZGLWXp/wF5dHdJ7CrNfAAAAABJRU5ErkJggg=='
            />
            <image
                id='image3_521_245590'
                width='157'
                height='325'
                xlinkHref='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJ0AAAFFCAYAAAD2PO8gAAAYw0lEQVR4Xu2d33Icx3XGT8+S4h/ZJSgvINAvQDDXqRKUsh0sU2WBT0CwJIB2LkwyKYuAq1IEk9gAlUpI+iYm4BTBFzDJXBB0khLhqlxb1BMQfoFoc2ECILFzUt07vegdzu70zPacHex+uBK1M3N6vv5NT8/pc04rwh8UEFZACduDOShAgA4QiCsA6MQlh0FABwbEFQB04pLDIKADA+IKADpxyWEQ0IEBcQUAnbjkMAjowIC4AoBOXHIYBHRgQFwBQCcuOQwCOjAgrgCgE5ccBgEdGBBXANCJSw6DgA4MiCsA6MQlh0FABwbEFQB04pLDIKADA+IKADpxyWEQ0IEBcQUAnbjkMAjowIC4AoBOXHIYBHRgQFwBQCcuOQwCOjAgrgCgE5ccBgEdGBBXANCJSw6DgA4MiCsA6MQlh0FABwbEFQB04pLDIKADA+IKADpxyWEQ0IEBcQUAnbjkMAjowIC4AoBOXHIYBHRgQFwBQCcuOQwCOjAgrgCgE5ccBgEdGBBXANCJSw6DgA4MiCsA6MQlh0FABwbEFQB04pLDIKADA+IKADpxyWEQ0IEBcQUAnbjkMAjowIC4AoBOXHIYBHRgQFwBQCcuOQwCOjAgrgCgE5ccBgEdGBBXANCJSw6DgA4MiCsA6MQlh0FABwbEFQB04pLDIKADA+IKADpxyWEQ0IEBcQUAnbjkMAjowIC4AoBOXHIYBHRgQFwBQCcuOQwCOjAgrgCgE5ccBgEdGBBXANCJSw6DgA4MiCsA6MQlh0FABwbEFQB04pLDIKADA+IKADpxyWEQ0IEBcQUAnbjkMAjowIC4AoBOXHIYBHRgQFwBQCcuOQwCOjAgrgCgE5ccBgEdGBBXANCJSw6DgA4MiCsA6MQlh0FABwbEFQB04pLDIKADA+IKADpxyWEQ0IEBcQUAnbjkMAjowIC4AoBOXHIYBHRgQFwBQCcuOQwCOjAgrgCgE5ccBgEdGBBXANCJSw6DgA4MiCsA6MQlh0FABwbEFQB04pLDIKADA+IKADpxyWEQ0IEBcQUAnbjkMAjowIC4AoBOXHIYBHRgQFwBQCcuOQwCOjAgrgCgE5ccBgEdGBBXANCJSw6DgA4MiCsA6MQlh0FABwbEFQB04pLDIKADA+IKADpxyWEQ0IEBcQUAnbjkMAjowIC4AoBOXHIYBHRgQFwBQCcuOQwCOjAgrgCgE5ccBgEdGBBXANCJSw6DgA4MiCsA6MQlh0FABwbEFQB04pLDIKADA+IKADpxyWEQ0IEBcQUAnbjkMAjowIC4AoBOXHIYBHRgQFwBQCcuOQwCOjAgrgCgE5ccBgEdGBBXANCJSw6DgA4MiCsA6MQlh0FABwbEFQB04pLDIKADA+IKADpxyWEQ0IEBcQUAnbjkMAjowIC4AoBOXHIYBHRgQFwBQCcuOQwCOjAgrgCgE5ccBgEdGBBXANCJSw6DgA4MiCsA6MQlh0FABwbEFQB04pLDIKADA+IKADpxyWEQ0IEBcQUAnbjkMAjowIC4AoBOXHIYBHRgQFwBQCcuOQwCOjAgrgCgE5ccBgEdGBBXANCJSw6DgA4MiCswsdCt/XhuWsXqMRHNKKIbNze274mrP6EGJxe6z+dmVaRemH5X/HT5wfP5ujKwen126uyfzl5mFbdubjx/VNd2+rZrYqFbXZifOv3ewddENF33ke7O0twtJrWqOzXiwwtfbP7XS98OruNxEwud7Qw9iqze22kN2zlfLv5gpt1oTK38+vnOsNdKn7+2NLeqSN0iphY3+MLKr5/vhrYheb2Jhy6E2GuLcwtKqYdVjkR3PmvO7313byfEAxLinoe5BqAbRr3k3DtLzetMdFf/kyM+d9xHogCSDLwEoAugsJ4fnjq5P09Muyu/Cf96DdDEWl0C0NWqOyajMYBuMvq5VncJ6GrVHZPRGEA3Gf1cq7sEdLXqjsloDKCbjH6u1V0Culp1x2Q0BtBNRj/X6i4BXa26493G6LXhM6/PXiOKd8chwkTfIaCrOXQS67rSEgA6acUL2nOg2+WIPxmHdd1jBd2XVy9ei5kXOOYbIdY49avr1P7pmSrCkQqyNfBw3U59wDhEmBy71+v6UvOVDroMFelrr6eIF6qaL+mw+ChWd5VSO20VPx2HkWrYB+pYjXTri817pOgaM91f2dy+PszNm8jhkwevSNFUXuTwL5ea8xHTQ4ro5f7B3qXVLf+gz7WluS1F6rJta56tYe7puJx7rKALLeovFi/ORBTPHLy//2TQq8sFJ5lXeUcH/3KpeT0ivkakpk37a5SPESpqumi/TDR0vmK50O2/2fuwyEhnbRjAVTxPEW3V4RV7NLWQz4QDdB7k6XkZxbRAMe2E+IDxMFnpIfoBaCjWSUl65N1afvD8SqUGUxcHdJJq18jW+lLzMRHPxKRu/Hxj+4lk0wCdkNrG3UM8HzPdl+5koVv0NgPovKUa7sD1pSYnV2gtb2x/mHe1O0sXb7Gi6f2D1zfKzCHzrj/K3wGdkPqd1xnNE/PW8ubgOZS79DWOLhZAJwSdNqM/SHy+XN2UxkGOa+s/VIq2bm5s3xC8laFMAboh5FtfbL7QzmWO+JIPTEVM6eTqWHFr0Ndyyn94bPJtAV0REpxj15wCPMx8ZWXz+VbJS5U+7cvFizNxFN9VrJ6OquqUGW2J7ipFL/cO9q74zD8BXckuTwrwmKpPVYx0JZslflp3rtrRQUfB5K7WADrxbpI3aEuNtRvhAw46y3ympMbu/pu9CxjpPPrXd/1x1JP2jguFZxWrnZsbz2573Fr3EBsoQUSt/Td753zAKHJ9/YF0cHq/5Rt6NdYjXRJ/d12R2kp3VBJl8pgUzTZUPP+zB797OkjoEOuvRTrSPTapGqrDuszf8sZ2oX5zoPMejcq21ee8Qo33uWCdjllfaur1xZmsjnLXH5n49srGc1N0sN+f76TdjEjEq4roXkg3RvdemHeWN59/UkRnW+CnQdHLLzafjbyg4lhDZ+YbTLeY6FFW/J12wlKkZg7O7K36vhryOnsQ6Hnn5v3u6+fLu86ofx9r6EYhbjKxvqyIHo3KjTGK+y5iE9AVUQvHBlEA0AWRERcposCxgU5P5FnxLSL6/SS9tkzG2p9Ozzeo/VK6qvr64sWHpHgm4sMrIW1XAp12VbSJzx0c7K2G8gmtX22+IKZZ7YRc3tg+V+TJGsWxRdMb9UcNK9VKx9o57g7Rcv49bprA0cXBoetZk/RwRfgCYcva+7g37DWdXXFo/83eJ2UegG6oeoHcBmO3rb7uZJrlpze6oUzppaQySUGh8mRtdDFHFDTJOzx0ne2PjCPTR3Bf6PRxRV0Gbmf6OICz2uK4QLyCL/U1enyAqXTJrJWN7j4RRJRupwGY6ZZi9Y3PtML6CUnRzvKD7UL+vCJ9McyxwaGzcDTa0dSoHZHGKfre/j1SqrXyoFyebNnXuomJU3yeFd12w57ckcuuLJh2njpYjZh2fcCyHZ6EVk1HfHjJzrmcBfjaTkMqgW6Yp6Bu55rXa5tmQ3nzzcqG4och/HjdEHhnzpWsnFyL4uh+v4fejIbM10cV/AnoEso7r7HoluJ4Z1CJCZtgE8WHN0J+0ZV52DqvZbpcNKOrW56jxDpumXamzwF0iSKpuLC+UbjO6FLrnRMHwZHMda+FGG3LQAjojqDrGxzgCusU8RFPUi7TwXU8B9D1vF7pVszqaV5eqp43hf5I8o3rqyNE6TbdWWreZaJ5RbyaNVWpJXRm8s7qesT8dVUlvKrovM4knnQNvUxw+/nPkq/Q2XFIN0w5lTOnILWErmov/NqP52Y5VlN5I1pRMPN8ev2K1jjzxJ3lB8Vi5fq10S6fUYN2Qmeq5emi+08p+kixup31RqgldGXi7l0hbCFCvWSWDqRMEmq+1cf71rlLNhBu5XXeIJ+eazddtEZ/hUakzvfrpKxOzntw7iw1H+tXXB2XDWsJnRZZv6pev/96t0xwpeuATW8/7m6j7lOxyFnVyMwvsC4UxbylpwJ6GfDgO/svs9pdFK5+sLuvsH6vZOcB0EuApcqb5Y1oZX+vLXRlb0if546UWcWhzZzxkKb7wdEzatqtzDNS7NK5C2nAA93DO7D7VACw82Jq85NBCduh1mmL3OtYQqcFCCVmspSm0+xeZX3UuI7WrF2ti64X285z57XpIACbc8vET/NyOwb66woGJhQBa9CxYwtdWYGKwmqXybJ2tU5cB9eJ1dby5rNChQePvuCLrccWue+e6JaAEUF5bQB0jkJJiQRdXSlIfuj6YvPbpJD2y5sb2xfSnaE/Bhrt6HwVSdB5HW/eBklARETqg72ze1fKzJ997KSPAXSOImVi1zofPT+YOVQnptMuGF0Ehxp0OY75fnpe1R0FO/YN5O+9d2bWVHFX5t8Xzp48Ox0T6yI95t9l4gHLQGHPSeICdVV5KlpVHq/XDAWyInttbisz/d5nrtTtFGUimqlIgKlTJNG0Ts8HVax0eQbt5jBxdTFH57hTssG7TsgwkL0zEi/OLSilHhr7AYsEHZuRzuSoNmjXp0CLj/BHa6h+wY6J32vaLZbjBl8amwXCursuDaaWUnRbx9HZsCdibumEahtnp/+tHwL9OiZW875pAL7+xX56JV/ntkhQsOjhkUGnIYoUsc8y152luVtMymTg+1YGygMvb77lnt8vBD+BxFQp55gfHXxn/7o7LzKj6d6ZVUXqg6wyrkW+bF3nss9ymbun2ChezbV7veq5DjdIT9jNayXP098z1yq4W043T0LPi5zdbkzRwRM0S4rv5dkfVBZMX59jNZO1pBayjKu7w0/E6kJewIHrckk7h4cdAfMe6LzfRzLSOSOHV0EXN8GmaC04t8xD1iiZvLYrWZ/sl3CzfvXiQyKeLprDUKQ6kob07Mk3l9scf+N+xDgfMF7a5wFU5veRQKcbOmi5qMyN9DvHzp0U0ZObG9uX3OOcDjBfj6dOn57S0cP6mFBVzfV9NlTUsiOTO8qHXMHw1WyU1adsG0cGna9IIY7rN0Kk1ydPnTw9n/W1pifwUUwfufNP67xVROeLhK530xOJX+ZVXyrqqPbRqt8I6HNuqGMmArp+YtkkFsVk8iLMv7VfTM81G3xBz/WyJvDdND/nwlmL6lkfCuYLlMxX+G66XdaNk/z/XRUr3ZZpnw+HUEDY61Q575to6LI6Kj26uFEpOo+X2ur/7EeQe74Ok2rQ4ZZN1snKP3UCETKz9deWmls60cZcl2lHF2w0/+3pitGQN9rRp6/fvn40jCO56nnfsYMuqa+xIPn0J51p8nhd90kCnS4yqHeeNltr2hHPfXXb/NZBi/j63J7koJgf6ZUAxfQRN+hK3hd2cr7ZhNk3TrDvPNhutOLcT8iR9PhBl2x3pIgy1zOHEcf61RqkXn3x4Nn9ftfS4FFD6Y2HTXK0G2pkXUAGzobJzO+W289bxO+GIzG3Ds7u33N9fnd+8teXuR3rjZVnFKnVrLrDR77H/FIWg3Sy7WCmndDR1WbgHqaTRnGuWQVgdc168fPE8xkh7DXcFYaiTmjjemHa9d2aM/0aN5AqpWsgv7POmh5d+z1w7oic1zdOmdobRaoK5F3X5/djB53PTeljytT0SPnVcp3Wvm1JH+csL+llNbP3Qgp4Y9s6nlXMLRWZjwr9t8sR61IVWy64Ttn+b3yWCp18jeBvjDxdxhY6d36UV43cTWKJ3ipd9mHg9kiuqPYLNVkSM2FRerQa5EbpXanovArdV6teZ02F1T/lNt1z/X0uuHp+y0zTpOiaO68c1PmjLFM7ttCZTvGsduTus+CzLabtTLvaYTpd0adJ/Tzz86CIEwPUqf3HilWrXxxbTyi84neyxHp2p+4YtF+7Iyuc4xsKNbbQ5Q3xPaPVUR6Ed4elodDhUIqUWc0wDHisKee10YyIEX2crvxkz3NdMDoUiuPGH8smM+W1xed339JsgC5Rs8yyXLKkdD5idaXdiFsqVnqL8imOTHkwrw3qymzo1vPALM4tNCj64IvN/l/becDoByjqxPK9k7KZd677uzPF0K6jvkGngK6IqhUc6xOtfASFell0iyafJrsfMSHWg/NKZAA6n14pcEzRUaM7OjDv9nMCD8rjLdC0voe6UT8S9ZyPHXTOuufL5YxklxCdMMw13JWIEKOGbkt3JGJq2TXhYdo46nOPHXSuK6RM5rpZcI9plgoUrradlKwK6EKEOkwqc/ty51VlPkpC7Z5YZs45arj62T920HW+2Pia2e8rZxO59E2n6ol4FTV0E3iy1lOzhHVLYlS5V1hdocpr17GDLu+GBv3uOlx9F8XdIojESu+omLmrYj+7eQ+Jk1E2xaSermw8e2c3RrsmTKxaWb/3s12nUrVuGycKOjM/6oT/eFV+T/vidMFEs4tzie0v+4HhRp7oY7JS/VIBBV5blqfa7jWqD/NAFzl3bKEbZu7mCphVaenOUnOe2Sw5zXCDL/msdfbrFDd83UCXrMX2tMHmnxb4kOgZ1QVLRvjAN5bQ9URlKA76lLtedy1wiLi+ZN44NWhL8rIfEkXSHH2AscfoVzczz+692btSNGB0LKEbtGNNEWGzjk2lFT6RrAEybNtDnd9bWJKvrGz6rb5Y+yODTr+i2kRURZCgvjkNnlL8Tn2REMJr8AYtPVkHsd5gLlRWWYh2D7pGUad28oFlpwPv5HsMsjUS6NzRIpQDtWyn2N1jWPH9oi6YfjZ74vIC1gApe48+51Vd53nkX6+Ddv3zESjkMdbZHDL8/Whpi6bKriDoed57r8/Mum+CMoGpvlp158EBv8z72R7JSKcbY8o6FAiW9BWv6HFa7ChS14oUmS5qo8zx1j/oxuUVCUwtY1PqnJFBJ3WDdbJjnbXc5tsD6wDrIM+TB690QUXXiX2Up+u3Dac+/lDx9Js3eztFvzCr1A3QearrJEJ3E6Wd5JZ7/dZi3cs7Nelyg0X1h9BJoo9fv//6UdkKmUXLoXlKMfRhgM5Twm4itLN5b6rIde5KgV279V2C82xa38OcJbxgm6IM0ybrMxw76GxW1KHiP4Z0xziAdXe4LlMouipnbRYM2p92pnEwu/fdvZ2yo+UwkLnndjdTUbQzdtClsuiDpRFm7UitRbVbEsUR3yiSYxuqM4/LdZypRWvsoHOTVUIkx9hOdStbFomulRrZqna2Dwu3iTNU9LGueDB20Glx0jXhhhXMnl+0dFeVfjX3nty1Zp0V9rMHv3sa6p6ruM5YQleFUGWuuXa1+VvFdIlIvVreePa9rGusLV1cJcVTvsWrM6+hS1JE6iv9W0PFlwBdmd4ak3M6fjX+aRSrX2XVCHbDmoaNVtEulojimaKL72mp2alvo3QKdwV/GOmI6B8//+G5E1F0mZi+Wdl8bgpwS/wlRRi/6uyqw1d8Ks1X3S5bik3nwFZVlR3Q6S/Qq80XtiREmWSfYUAwNUyIqA5fvj3RxkSZhRuHuVd7LqAz0M19RaxmidRuv7lXUbHta6roK0qfV/Scom0bdLz+yiRSPyLi/wgVdZO2B+iSvAlq02yorcftzjeKdC3j7FTFrI7/l8+aF96eUD89efjmV3/37/9tNkXx/dOw/utn3595raLW3//mP3VFztr+AboKumbt6txDxWpBX7qIr9BJV+yuevg2z92eoEjlKd/rhzwO0IVUM7mWmafF6reqs8fXX/qa6L7mO6XBvM/T10/cM/PE1Fre3P4zX5ujOA7QjUL1PjZNyPhbNVNmrdRWVk/vkFOj2+s2BdBV3CtrP/mLDw/fnp2q+zyrYhl6Lg/oKlTb1jExwZgBiiSWbeo/L85dOtRuGUEf5KC2ArqyPelxnhPxwhzx90bhi+vZNjQjkdvjNoIfAuiCS3p0wc4HBS1ERK9CrTbo1ZMGqdk28Y7PKzvJAf6DblXEh39ud/Sp8LZzLz2x0Gm/1j99/sNpn47LVVHwACca2LtygfYb6ibm7RErdRvHAroqvPTWrzXsQnvIjvK5z/XF5v/qOWJMdP/nBRzPIds57LVqD90v/uavPona0aeH7fb9kKNSN51P8YuiPrFhRc8634Y4rTzY1lsx9f0zr+w2zQ4bTVLFPfhes/bQ2TDnkMnQWhwTVnSCfsSK/6HIBN9GpBzG8aNQD0HPZP+YVATwBSzruPpDl7xOqISXfhhh+p3rLlXp3bBD5JMm0JkgzLpM9qvQzl6z9tB1Pe2N+GmREakq0daWmn9QRBcGRQOXsa3vc1CpsDLXrOs5tYeubsJZN0iDoyd1+Rqsm0Z57QF0eQrh9+AKALrgkuKCeQoAujyF8HtwBQBdcElxwTwFAF2eQvg9uAKALrikuGCeAoAuTyH8HlwBQBdcUlwwTwFAl6cQfg+uAKALLmn1F9R5F9rKyr/9z7fVWwtvAdCF17TSKya7Jn6d5F3klpyttDElLw7oSgo3qtPcSk9uuf9RtaeMXUBXRrURn7O+1LxLij5ixX9bh8ibonL8PxD8Ic7FcMcHAAAAAElFTkSuQmCC'
            />
        </defs>
    </svg>

);

export default GuestAccessSVG;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

type SvgProps = {
    width: number;
    height: number;
}

const HandsSvg = (props: SvgProps) => (
    <svg
        width={props.width ? props.width.toString() : '110'}
        height={props.height ? props.height.toString() : '100'}
        viewBox='0 0 110 100'
        fill='none'
        xmlns='http://www.w3.org/2000/svg'
    >
        <g clipPath='url(#prefix__clip0_88_26129)'>
            <path
                d='M52.01 64.4c-2.21-2.96-3.96-3.55-7.24-2.47-1.27 1.09-2.96 1.62-4.02 2.98-.13.13-.26.25-.39.38-.68 1.21-1.89 2.04-2.46 3.31-1.03 2.32-2.84 3.05-5.3 3.4-3.82.54-7.39 1.94-9.73 5.37-.22.24-.29.59-.6.76.24-.28.42-.6.65-.89 3.05-4.4 7.27-6.86 12.55-7.58 1.38-.19 2.73-.48 2.67-2.34-.55-.47-.36-1.12-.43-1.7-1-8.95-.25-17.92-.37-26.88-.03-2.68-.63-5.01-3.45-6.1-2.57-.08-3.75 1.49-4.34 3.71-.13.5-.22 1-.28 1.51.09-1.52.08-3.05-.2-4.58-.71-.81-.34-1.83-.49-2.74-.42-2.56-1.68-4.11-4.44-4.1-3.12.8-3.99 3.26-4.09 6.01-.14 3.58-.43 7.16-.49 10.74-.09 5.46-.41 10.98 2.19 16.2-.89-.41-2.72 1.69-2.56-.87.47-7.6-.07-15.21.49-22.81.14-1.95.14-4.03-.97-5.85-.87-.33-1.72-.86-2.68-.27-3.89 2.17-4.38 5.82-4.05 9.71.2 2.3.07 4.51-.29 6.78a34.11 34.11 0 00-.4 4.14c.05-1.58.07-3.17.01-4.75-.09-2.53.46-5.3-1.34-7.58-.91-.01-1.72-.98-2.7-.25-1.22 1.4-2.39 2.92-2.65 4.76-.73 5.29-2.27 10.45-2.55 15.8-.47 9.24.4 18.29 3.09 27.24 1.57 5.23 4.51 8.71 9.4 10.46 6.13 2.2 12.38 3.36 18.37-.62 2.73-6.59 6.69-12.37 11.5-17.59 1.25-1.36 2.27-2.86 3.02-4.55.89-2.51 1.79-5.01 3.71-6.99.47-.46 1.06-.94.86-1.75zM28.89 41.86c.11-1.02.23-2.04.32-3.07-.02.75.02 1.5.12 2.25.19 1.49.39 3 .07 4.45-1.07 4.91-.42 9.7.92 14.55-1.67.03-2.62-.26-2.16-2.23.42-1.79.44-3.68.32-5.5-.24-3.5.02-6.96.41-10.45zM10.02 62.3c-.18.08-.31.15-.44.08.98-.77 1.18-1.87 1.23-3 .14-2.9.37-5.81.47-8.72-.04 2.4.22 4.79.86 7.15.89 3.23.96 3.21-2.12 4.49z'
                fill='#FFBC1F'
            />
            <path
                d='M33.9 32.64c-3.33 1.43-4.59 4.08-3.87 8.37.4 2.37.01 4.64-.25 6.99-.43 4.05-.35 8.15 1.65 11.93.19.37.29.79.55 1.5-2.09-.53-3.9-.98-5.58-1.41 2.04-3.26 1.26-6.78 1.28-10.16.05-5.57.56-11.09 1.39-16.59 1.47-1.27 3.08-1.48 4.83-.63z'
                fill='#CC8F00'
            />
            <path
                d='M47.46 73.15c-.21-3.82 2.09-6.33 4.55-8.75 1.13.96.46 1.91-.11 2.73-1.43 2.04-2.96 4.02-4.44 6.02z'
                fill='#FFC847'
            />
            <path
                d='M44.77 61.93c.32.14 1.07.18.23.66-1.4.81-2.83 1.55-4.25 2.32.74-1.8 2.26-2.55 4.02-2.98z'
                fill='#F7B527'
            />
            <path
                d='M38.63 66.54c-.2.22-.37.47-.48.77-.42 1.27-1.4 1.5-2.62 1.68-5.55.84-10.36 2.93-13.01 8.33-.64.57-1.16 1.19-.96 2.39.57-.72 1.02-1.28 1.46-1.84 2.76-3.39 6.44-4.88 10.68-5.37 1.16-.13 2.8.09 3.29-1.1 0 0 5.44-7.9 10.24-9.96-.01-.01-4.81-.68-8.6 5.1z'
                fill='#CC8F00'
            />
            <path
                d='M32.31 95.01c-6.03 3.48-12.11 2.31-18.08 0-3.13-1.22-6.05-3.09-7.26-6.45-4.68-13.03-5.64-26.34-2.71-39.9.71-3.28.84-6.73 2.5-9.74.46-.64 1.4-1.39 3.2-1.02 0 0-2.47-1.71-4.74.93-.05.04-.1.11-.15.17l-.02.02c-.75.91-1.15 2.09-1.54 3.24C1.76 47.44 1.27 52.87.96 58.27.55 65.34.4 72.48 2.63 79.32c1.08 3.36 2.01 6.69 2.02 10.22.01 2.39 1.01 4.18 2.97 5.51 5 3.38 10.53 5.16 16.54 4.93 3.55-.14 6.95-1.07 8.77-4.69-.2-.1-.5-.35-.62-.28z'
                fill='#CC8F00'
            />
            <path
                d='M18.72 29.85s-2.8-2.19-6.33 1.13c-.89.78-1.4 1.91-1.73 3.6-.22 1.11-.46 2.21-.69 3.31 1.02 5.64.68 11.32.29 16.97-.21 3.08 1.02 6.69-2.85 8.76 2.23-.52 4.19-1.21 6.17-1.82.8-.25 1.39-.49.68-1.38-2.32-2.89-2-6.37-2.2-9.74-.18-3 1.19-5.91.83-8.83-.46-3.65-.44-7.06 1.37-10.04.4-.6 2.02-2.72 4.46-1.96zM27.1 27.38s-2.07-2.1-5.15-.85c-.21.07-.41.17-.59.28-.01.01-.03.01-.04.02-1.09.66-1.84 1.85-2.6 3.02.45 4.62.13 9.23-.02 13.84-.07 2.35-.33 4.69-.12 7.06.29 3.36.71 6.78-1.4 10.26 2.23-1.05 4.44-.09 6.42-1.41-1.64-1.62-2.46-3.36-2.82-5.56-1.12-6.85-.07-13.67-.1-20.5-.01-2.37.54-4.42 2.08-5.99.62-.57 2.08-1.46 4.34-.17z'
                fill='#CC8F00'
            />
            <path
                d='M58.84 66.16c1.92 1.98 2.82 4.48 3.71 6.99.74 1.69 1.76 3.19 3.02 4.55 4.82 5.22 8.77 11.01 11.5 17.59 5.99 3.98 12.24 2.82 18.37.62 4.89-1.75 7.83-5.23 9.4-10.46 2.69-8.96 3.56-18 3.09-27.24-.27-5.35-1.82-10.51-2.55-15.8-.25-1.85-1.43-3.36-2.65-4.76-.97-.73-1.79.24-2.7.25-1.8 2.28-1.25 5.05-1.34 7.58-.06 1.58-.04 3.16.01 4.75-.04-1.38-.18-2.76-.4-4.14-.36-2.27-.49-4.49-.29-6.78.33-3.89-.16-7.54-4.05-9.71-.96-.59-1.81-.06-2.68.27-1.11 1.82-1.11 3.9-.97 5.85.56 7.6.02 15.21.49 22.81.16 2.56-1.68.46-2.56.87 2.6-5.22 2.28-10.74 2.19-16.2-.06-3.58-.35-7.16-.49-10.74-.1-2.75-.97-5.21-4.09-6.01-2.75-.01-4.01 1.54-4.44 4.1-.15.91.23 1.93-.49 2.74-.28 1.53-.29 3.06-.2 4.58-.06-.51-.14-1.01-.28-1.51-.59-2.22-1.77-3.79-4.34-3.71-2.82 1.09-3.41 3.42-3.45 6.1-.11 8.96.63 17.93-.38 26.87-.07.59.12 1.24-.43 1.7-.06 1.86 1.29 2.15 2.67 2.34 5.28.72 9.5 3.18 12.55 7.58.22.29.4.62.65.89-.3-.17-.38-.51-.6-.76-2.34-3.42-5.91-4.83-9.73-5.37-2.46-.35-4.26-1.08-5.3-3.4-.57-1.28-1.78-2.1-2.46-3.31-.13-.13-.26-.25-.39-.38-1.06-1.37-2.75-1.89-4.02-2.98-3.27-1.09-5.03-.49-7.24 2.47-.18.81.41 1.29.87 1.76zm22.68-13.84c-.12 1.82-.1 3.71.32 5.5.46 1.96-.49 2.26-2.16 2.23 1.34-4.85 1.99-9.64.92-14.55-.32-1.45-.12-2.97.07-4.45.09-.75.14-1.5.12-2.25.09 1.03.21 2.05.32 3.07.39 3.48.65 6.94.41 10.45zm16.33 5.49c.64-2.36.9-4.75.86-7.15.11 2.91.33 5.81.47 8.72.06 1.13.26 2.24 1.23 3-.12.07-.25 0-.44-.08-3.07-1.28-3-1.26-2.12-4.49z'
                fill='#FFBC1F'
            />
            <path
                d='M76.11 32.64c3.33 1.43 4.59 4.08 3.87 8.37-.4 2.37-.01 4.64.25 6.99.43 4.05.35 8.15-1.65 11.93-.19.37-.29.79-.55 1.5 2.09-.53 3.9-.98 5.58-1.41-2.04-3.26-1.26-6.78-1.28-10.16-.05-5.57-.56-11.09-1.39-16.59-1.48-1.27-3.09-1.48-4.83-.63z'
                fill='#CC8F00'
            />
            <path
                d='M62.54 73.15c.21-3.82-2.09-6.33-4.55-8.75-1.13.96-.46 1.91.11 2.73 1.44 2.04 2.96 4.02 4.44 6.02z'
                fill='#FFC847'
            />
            <path
                d='M65.23 61.93c-.32.14-1.07.18-.23.66 1.4.81 2.83 1.55 4.25 2.32-.74-1.8-2.26-2.55-4.02-2.98z'
                fill='#F7B527'
            />
            <path
                d='M71.37 66.54c.2.22.37.47.48.77.42 1.27 1.4 1.5 2.62 1.68 5.55.84 10.36 2.93 13.01 8.33.64.57 1.16 1.19.96 2.39-.57-.72-1.02-1.28-1.46-1.84-2.76-3.39-6.44-4.88-10.68-5.37-1.16-.13-2.8.09-3.29-1.1 0 0-5.44-7.9-10.24-9.96.01-.01 4.81-.68 8.6 5.1z'
                fill='#CC8F00'
            />
            <path
                d='M77.69 95.01c6.03 3.48 12.11 2.31 18.08 0 3.13-1.22 6.05-3.09 7.26-6.45 4.68-13.03 5.64-26.34 2.71-39.9-.71-3.28-.84-6.73-2.5-9.74-.46-.64-1.4-1.39-3.2-1.02 0 0 2.47-1.71 4.74.93.06.06.11.12.17.19l.02.02c.75.91 1.15 2.09 1.54 3.24 1.75 5.18 2.24 10.61 2.55 16.01.41 7.07.56 14.21-1.67 21.05-1.09 3.36-2.02 6.69-2.03 10.22-.01 2.39-1.01 4.18-2.97 5.51-5 3.38-10.53 5.16-16.54 4.93-3.55-.14-6.95-1.07-8.77-4.69.19-.12.49-.37.61-.3z'
                fill='#CC8F00'
            />
            <path
                d='M91.28 29.85s2.8-2.19 6.33 1.13c.89.78 1.4 1.91 1.73 3.6.22 1.11.46 2.21.69 3.31-1.02 5.64-.68 11.32-.29 16.97.21 3.08-1.02 6.69 2.85 8.76-2.23-.52-4.19-1.21-6.17-1.82-.8-.25-1.39-.49-.68-1.38 2.32-2.89 2-6.37 2.2-9.74.18-3-1.19-5.91-.83-8.83.46-3.65.44-7.06-1.37-10.04-.4-.6-2.02-2.72-4.46-1.96z'
                fill='#CC8F00'
            />
            <path
                d='M82.9 27.38s2.07-2.1 5.15-.85c.21.07.41.17.59.28.01.01.03.01.04.02 1.09.66 1.84 1.85 2.6 3.02-.45 4.62-.13 9.23.02 13.84.07 2.35.33 4.69.12 7.06-.29 3.36-.71 6.78 1.4 10.26-2.23-1.05-4.44-.09-6.42-1.41 1.64-1.62 2.46-3.36 2.82-5.56 1.12-6.85.07-13.67.1-20.5.01-2.37-.54-4.42-2.08-5.99-.62-.57-2.08-1.46-4.34-.17z'
                fill='#CC8F00'
            />
            <path
                d='M32.35 12.07l-1.12 2.39c-.67 1.42-.49 3.09.45 4.35L42.7 33.49c.24.32.74.09.65-.3-.82-3.69-3.4-13.17-9.55-21.29a.858.858 0 00-1.45.17zM45.99 16.98s-1.56-1.1-2.33.51c-.54 1.13 1.6 5.23 2.9 7.55.25.44.91.25.89-.25-.1-2.66-.44-7.27-1.46-7.81zM53.89.1l-.84.12a2.179 2.179 0 00-1.84 2.47l3.75 26.19c.05.33.52.33.57 0l3.75-26.19C59.45 1.5 58.63.4 57.44.22L56.59.1c-.89-.13-1.8-.13-2.7 0zM78.14 12.07l1.12 2.39c.67 1.42.49 3.09-.45 4.35L67.79 33.49c-.24.32-.74.09-.65-.3.82-3.69 3.4-13.17 9.55-21.29.38-.5 1.18-.41 1.45.17zM64.49 16.98s1.56-1.1 2.33.51c.54 1.13-1.6 5.23-2.9 7.55-.25.44-.91.25-.89-.25.11-2.66.45-7.27 1.46-7.81z'
                fill='#1B1D22'
            />
        </g>
        <defs>
            <clipPath id='prefix__clip0_88_26129'>
                <path
                    fill='#fff'
                    transform='translate(.71)'
                    d='M0 0h108.58v100H0z'
                />
            </clipPath>
        </defs>
    </svg>
);

export default HandsSvg;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

type Props = {
    width?: number;
    height?: number;
}

export default (props: Props) => (
    <svg
        width={props.width ? props.width.toString() : '182'}
        height={props.height ? props.height.toString() : '30'}
        viewBox='0 0 182 30'
        fill='none'
        xmlns='http://www.w3.org/2000/svg'
    >
        <path
            fillRule='evenodd'
            clipRule='evenodd'
            d='M69.6495 14.9024C69.6495 14.448 69.5734 14.0782 69.4213 13.7937C69.2695 13.5099 69.0604 13.2868 68.7944 13.1262C68.5284 12.9649 68.2005 12.8557 67.8111 12.7992C67.4215 12.7423 66.9891 12.7139 66.514 12.7139C65.488 12.7139 64.3956 12.9127 63.2364 13.3106C62.9702 12.8179 62.7709 12.3535 62.6381 11.9178C62.5051 11.4821 62.4383 10.961 62.4383 10.3544C63.2745 10.0702 64.1103 9.86184 64.9465 9.72921C65.7824 9.59657 66.5619 9.53008 67.2836 9.53008C69.2598 9.53008 70.8036 10.0037 71.9153 10.9516C73.0268 11.8991 73.5826 13.4147 73.5826 15.4992V24.0265C72.9175 24.2348 72.1099 24.434 71.1598 24.6235C70.2101 24.813 69.1363 24.9078 67.9392 24.9078C66.9702 24.9078 66.0817 24.8224 65.2741 24.6518C64.4667 24.4814 63.7729 24.1969 63.194 23.799C62.6141 23.4015 62.1677 22.8896 61.8538 22.2643C61.5407 21.6387 61.3838 20.8715 61.3838 19.9618C61.3838 19.0524 61.5786 18.2897 61.9681 17.6738C62.3576 17.0581 62.8613 16.5651 63.4785 16.1958C64.0963 15.8262 64.7849 15.561 65.5452 15.3998C66.3052 15.2387 67.0651 15.1582 67.8252 15.1582C68.3763 15.1582 68.9842 15.1869 69.6495 15.2434V14.9024ZM69.6495 17.8302C69.4213 17.7923 69.1744 17.7588 68.9081 17.7307C68.6421 17.7023 68.4051 17.6882 68.1957 17.6882C67.2646 17.6882 66.5282 17.8537 65.9866 18.1854C65.4452 18.517 65.1744 19.0524 65.1744 19.7914C65.1744 20.2843 65.279 20.6629 65.488 20.9285C65.6969 21.1936 65.9489 21.3878 66.2433 21.5108C66.5379 21.6342 66.8511 21.71 67.1837 21.7385C67.5166 21.7666 67.8062 21.7814 68.0529 21.7814C68.3382 21.7814 68.6233 21.7574 68.9081 21.71C69.1934 21.6625 69.4402 21.6202 69.6495 21.582V17.8302ZM76.2809 12.9411H74.4281L74.2853 12.3726L79.6155 5.57913H80.271V9.8711H83.7197C83.7764 10.1556 83.8146 10.4113 83.8339 10.6385C83.8525 10.8662 83.862 11.1029 83.862 11.3495C83.862 11.6146 83.8525 11.8704 83.8339 12.1167C83.8146 12.3633 83.7764 12.638 83.7197 12.9411H80.271V18.7114C80.271 19.2986 80.3188 19.7723 80.4139 20.1326C80.5084 20.4921 80.6463 20.7766 80.8267 20.9852C81.0076 21.1936 81.2306 21.3357 81.4966 21.4114C81.7625 21.4876 82.0764 21.5254 82.437 21.5254C82.7223 21.5254 83.0023 21.5016 83.2781 21.4541C83.5534 21.4069 83.7957 21.3642 84.0046 21.3264C84.138 21.686 84.2325 22.0604 84.2898 22.4491C84.347 22.8375 84.3752 23.1836 84.3752 23.4867C84.3752 23.6951 84.3706 23.8702 84.361 24.0125C84.3515 24.1544 84.3375 24.2923 84.3182 24.4245C83.4443 24.6333 82.5419 24.737 81.6108 24.737C79.8815 24.737 78.5607 24.3346 77.6489 23.5295C76.7369 22.7239 76.2809 21.4114 76.2809 19.5924V12.9411ZM86.9742 12.9411H85.1218L84.9789 12.3726L90.309 5.57913H90.9645V9.8711H94.4132C94.47 10.1556 94.5083 10.4113 94.5274 10.6385C94.546 10.8662 94.5556 11.1029 94.5556 11.3495C94.5556 11.6146 94.546 11.8704 94.5274 12.1167C94.5083 12.3633 94.47 12.638 94.4132 12.9411H90.9645V18.7114C90.9645 19.2986 91.0124 19.7723 91.1071 20.1326C91.2022 20.4921 91.34 20.7766 91.5203 20.9852C91.701 21.1936 91.9239 21.3357 92.1902 21.4114C92.456 21.4876 92.7699 21.5254 93.1304 21.5254C93.4156 21.5254 93.6957 21.5016 93.9716 21.4541C94.247 21.4069 94.4893 21.3642 94.6983 21.3264C94.8313 21.686 94.9262 22.0604 94.983 22.4491C95.0404 22.8375 95.0688 23.1836 95.0688 23.4867C95.0688 23.6951 95.0641 23.8702 95.0545 24.0125C95.0452 24.1544 95.0309 24.2923 95.0118 24.4245C94.1377 24.6333 93.2356 24.737 92.3041 24.737C90.5752 24.737 89.2544 24.3346 88.3424 23.5295C87.4304 22.7239 86.9742 21.4114 86.9742 19.5924V12.9411ZM105.696 15.6418C105.658 14.7318 105.407 13.9977 104.941 13.4387C104.476 12.8796 103.825 12.5998 102.989 12.5998C102.039 12.5998 101.317 12.8653 100.822 13.3958C100.329 13.9265 100.034 14.6751 99.9393 15.6418H105.696ZM99.9105 18.4554C99.9866 19.5924 100.386 20.4167 101.108 20.9285C101.83 21.4402 102.78 21.696 103.958 21.696C104.604 21.696 105.264 21.6342 105.939 21.5108C106.613 21.3878 107.254 21.2125 107.863 20.9852C108.072 21.3642 108.252 21.819 108.404 22.3497C108.556 22.8798 108.641 23.4487 108.661 24.055C107.178 24.6235 105.506 24.9078 103.644 24.9078C102.276 24.9078 101.103 24.7183 100.124 24.3391C99.1457 23.9603 98.3475 23.4342 97.7301 22.7619C97.1125 22.0891 96.6564 21.2884 96.362 20.3597C96.0676 19.4312 95.9205 18.4176 95.9205 17.3188C95.9205 16.2385 96.0723 15.2247 96.3764 14.2772C96.68 13.3293 97.1315 12.5054 97.7301 11.8044C98.3286 11.1029 99.0695 10.5488 99.9533 10.1413C100.837 9.73393 101.868 9.53008 103.046 9.53008C104.072 9.53008 104.984 9.71013 105.782 10.0702C106.58 10.4302 107.259 10.9231 107.82 11.5486C108.38 12.1734 108.803 12.9176 109.088 13.7797C109.373 14.6418 109.516 15.5659 109.516 16.551C109.516 16.9111 109.502 17.2666 109.473 17.6169C109.445 17.9672 109.411 18.247 109.373 18.4554H99.9105ZM111.061 9.8711C111.346 9.8146 111.617 9.77172 111.874 9.74356C112.13 9.71467 112.41 9.70068 112.715 9.70068C113 9.70068 113.28 9.71994 113.555 9.75737C113.831 9.79534 114.102 9.84294 114.367 9.89981C114.425 9.99465 114.477 10.1318 114.524 10.3119C114.572 10.4919 114.614 10.6814 114.653 10.8806C114.691 11.0795 114.724 11.2781 114.752 11.4774C114.781 11.6765 114.804 11.8417 114.824 11.975C115.242 11.3873 115.755 10.8613 116.363 10.3973C116.971 9.93288 117.731 9.70068 118.643 9.70068C118.833 9.70068 119.051 9.71013 119.298 9.72921C119.545 9.7481 119.726 9.77644 119.84 9.8146C119.878 10.0037 119.906 10.2218 119.925 10.4681C119.945 10.7145 119.954 10.9703 119.954 11.2357C119.954 11.5579 119.939 11.9084 119.911 12.2873C119.883 12.6663 119.83 13.0263 119.754 13.3675C119.545 13.3293 119.313 13.3106 119.056 13.3106C118.8 13.3106 118.643 13.3106 118.586 13.3106C118.263 13.3106 117.902 13.3439 117.503 13.41C117.104 13.4765 116.724 13.6516 116.363 13.9361C116.001 14.2203 115.702 14.6467 115.465 15.2154C115.227 15.7835 115.108 16.5795 115.108 17.6029V24.5953C114.767 24.6518 114.425 24.6898 114.082 24.7087C113.741 24.7278 113.408 24.737 113.085 24.737C112.762 24.737 112.434 24.7278 112.101 24.7087C111.769 24.6898 111.422 24.6518 111.061 24.5953V9.8711ZM121.851 9.8711C122.117 9.8146 122.383 9.77172 122.649 9.74356C122.915 9.71467 123.21 9.70068 123.533 9.70068C123.856 9.70068 124.141 9.71467 124.388 9.74356C124.635 9.77172 124.891 9.8146 125.157 9.8711C125.214 9.96594 125.267 10.1035 125.314 10.2835C125.361 10.4634 125.404 10.6533 125.442 10.8518C125.48 11.051 125.513 11.245 125.542 11.4345C125.571 11.624 125.594 11.7852 125.613 11.9178C125.765 11.6338 125.965 11.3495 126.212 11.065C126.459 10.7812 126.753 10.5255 127.095 10.2977C127.437 10.0702 127.822 9.88546 128.25 9.74356C128.677 9.60112 129.157 9.53008 129.689 9.53008C131.988 9.53008 133.461 10.402 134.107 12.1455C134.487 11.4441 135.024 10.8333 135.717 10.3119C136.411 9.79062 137.29 9.53008 138.354 9.53008C140.026 9.53008 141.256 9.99011 142.044 10.9091C142.833 11.8279 143.228 13.2634 143.228 15.2154V24.5668C142.544 24.6805 141.869 24.737 141.204 24.737C140.539 24.737 139.864 24.6805 139.18 24.5668V16.2666C139.18 15.2434 139.052 14.4572 138.795 13.9078C138.539 13.3582 138.021 13.0833 137.242 13.0833C136.919 13.0833 136.601 13.1309 136.288 13.2254C135.974 13.3199 135.689 13.4952 135.432 13.7512C135.176 14.007 134.967 14.3673 134.805 14.8315C134.644 15.2953 134.563 15.8975 134.563 16.6364V24.5668C133.879 24.6805 133.204 24.737 132.539 24.737C131.874 24.737 131.199 24.6805 130.515 24.5668V16.2666C130.515 15.2434 130.387 14.4572 130.131 13.9078C129.874 13.3582 129.357 13.0833 128.578 13.0833C128.255 13.0833 127.932 13.1309 127.608 13.2254C127.286 13.3199 126.996 13.5048 126.739 13.7797C126.482 14.0542 126.278 14.438 126.126 14.9309C125.974 15.4234 125.898 16.0679 125.898 16.8637V24.5668C125.214 24.6805 124.54 24.737 123.875 24.737C123.21 24.737 122.535 24.6805 121.851 24.5668V9.8711ZM151.47 21.8379C152.534 21.8379 153.299 21.4449 153.764 20.6582C154.23 19.872 154.463 18.7396 154.463 17.2617C154.463 15.7835 154.23 14.6514 153.764 13.8649C153.299 13.0782 152.534 12.6852 151.47 12.6852C150.425 12.6852 149.67 13.0782 149.204 13.8649C148.739 14.6514 148.506 15.7835 148.506 17.2617C148.506 18.7396 148.739 19.872 149.204 20.6582C149.67 21.4449 150.425 21.8379 151.47 21.8379ZM151.47 24.9078C150.273 24.9078 149.233 24.7134 148.349 24.325C147.466 23.9367 146.734 23.3965 146.154 22.7047C145.575 22.013 145.138 21.2031 144.844 20.2745C144.549 19.3459 144.402 18.3419 144.402 17.2617C144.402 16.1816 144.549 15.1676 144.844 14.2203C145.138 13.2728 145.575 12.4532 146.154 11.7615C146.734 11.0697 147.466 10.5255 148.349 10.1271C149.233 9.72921 150.273 9.53008 151.47 9.53008C152.667 9.53008 153.712 9.72921 154.605 10.1271C155.498 10.5255 156.239 11.0697 156.829 11.7615C157.418 12.4532 157.854 13.2728 158.14 14.2203C158.425 15.1676 158.567 16.1816 158.567 17.2617C158.567 18.3419 158.425 19.3459 158.14 20.2745C157.854 21.2031 157.418 22.013 156.829 22.7047C156.239 23.3965 155.498 23.9367 154.605 24.325C153.712 24.7134 152.667 24.9078 151.47 24.9078ZM162.963 18.1713C161.899 17.8678 161.068 17.418 160.469 16.821C159.871 16.2243 159.571 15.3288 159.571 14.1347C159.571 12.6945 160.089 11.5675 161.125 10.7526C162.16 9.9376 163.571 9.53008 165.357 9.53008C166.098 9.53008 166.83 9.59657 167.552 9.72921C168.274 9.86184 169.006 10.0606 169.746 10.3262C169.708 10.8186 169.613 11.3302 169.461 11.8611C169.31 12.3915 169.129 12.8557 168.92 13.2541C168.464 13.0644 167.961 12.8985 167.409 12.7563C166.859 12.6144 166.279 12.5433 165.671 12.5433C165.025 12.5433 164.522 12.6427 164.16 12.8417C163.799 13.0408 163.619 13.3582 163.619 13.7937C163.619 14.2107 163.747 14.5045 164.003 14.6751C164.26 14.8455 164.626 15.007 165.101 15.1582L166.725 15.6418C167.258 15.7932 167.737 15.9778 168.165 16.1958C168.592 16.4138 168.958 16.6838 169.262 17.0057C169.566 17.3279 169.804 17.7259 169.974 18.1996C170.146 18.6734 170.231 19.2512 170.231 19.9332C170.231 20.6347 170.084 21.2884 169.789 21.8947C169.495 22.5012 169.067 23.027 168.507 23.4721C167.946 23.9178 167.267 24.2683 166.469 24.5239C165.671 24.7799 164.768 24.9078 163.761 24.9078C163.305 24.9078 162.887 24.8935 162.507 24.8651C162.127 24.8364 161.762 24.7892 161.41 24.723C161.058 24.6565 160.712 24.5762 160.37 24.4814C160.028 24.3867 159.657 24.2636 159.258 24.1118C159.296 23.6 159.386 23.0837 159.529 22.5628C159.671 22.0419 159.857 21.5346 160.085 21.0419C160.712 21.2884 161.306 21.473 161.866 21.5962C162.427 21.7196 163.011 21.7814 163.619 21.7814C163.885 21.7814 164.175 21.7574 164.488 21.71C164.802 21.6625 165.091 21.5773 165.357 21.4541C165.624 21.331 165.847 21.1698 166.027 20.971C166.208 20.7721 166.298 20.5116 166.298 20.1891C166.298 19.7347 166.16 19.4076 165.885 19.2087C165.609 19.0099 165.224 18.834 164.731 18.6827L162.963 18.1713ZM172.821 12.9411H170.969L170.826 12.3726L176.156 5.57913H176.811V9.8711H180.26C180.317 10.1556 180.355 10.4113 180.375 10.6385C180.393 10.8662 180.403 11.1029 180.403 11.3495C180.403 11.6146 180.393 11.8704 180.375 12.1167C180.355 12.3633 180.317 12.638 180.26 12.9411H176.811V18.7114C176.811 19.2986 176.859 19.7723 176.954 20.1326C177.049 20.4921 177.187 20.7766 177.367 20.9852C177.548 21.1936 177.771 21.3357 178.037 21.4114C178.303 21.4876 178.617 21.5254 178.978 21.5254C179.263 21.5254 179.543 21.5016 179.819 21.4541C180.094 21.4069 180.336 21.3642 180.545 21.3264C180.678 21.686 180.774 22.0604 180.83 22.4491C180.888 22.8375 180.916 23.1836 180.916 23.4867C180.916 23.6951 180.911 23.8702 180.902 24.0125C180.892 24.1544 180.878 24.2923 180.859 24.4245C179.985 24.6333 179.083 24.737 178.151 24.737C176.422 24.737 175.102 24.3346 174.189 23.5295C173.278 22.7239 172.821 21.4114 172.821 19.5924V12.9411ZM39.2629 5.37164C40.0865 5.25736 40.8788 5.19995 41.6403 5.19995C42.4432 5.19995 43.2359 5.25736 44.018 5.37164L49.1127 15.9173L54.3617 5.37164C54.9998 5.25736 55.7096 5.19995 56.4921 5.19995C57.2744 5.19995 58.0253 5.25736 58.746 5.37164L59.7957 24.7363C59.0138 24.8508 58.2727 24.9078 57.573 24.9078C56.8727 24.9078 56.1835 24.8508 55.5043 24.7363L54.9483 10.7354L50.4402 20.4122C50.1518 20.4503 49.8536 20.4841 49.5446 20.5123C49.2358 20.541 48.9274 20.5552 48.6184 20.5552C48.3506 20.5552 48.0833 20.5457 47.8159 20.5266C47.5483 20.5076 47.2705 20.4692 46.9821 20.4122L42.783 10.5348L42.3507 24.7363C41.6921 24.8508 41.0539 24.9078 40.4361 24.9078C39.7774 24.9078 39.0978 24.8508 38.3984 24.7363L39.2629 5.37164Z'
            fill='#1E325C'
        />
        <path
            fillRule='evenodd'
            clipRule='evenodd'
            d='M20.1373 12.2575C20.1373 12.2575 20.1838 14.3044 18.7644 15.695C17.3448 17.0856 15.6012 16.9585 14.467 16.5745C13.3326 16.1905 11.8704 15.2323 11.5873 13.2655C11.3045 11.2986 12.5848 9.70069 12.5848 9.70069L15.3747 6.23118L16.9996 4.24963L18.3944 2.52282C18.3944 2.52282 19.0345 1.66544 19.2169 1.48849C19.2531 1.45342 19.2901 1.43042 19.3265 1.4127L19.3529 1.39919L19.3577 1.39736C19.4344 1.36431 19.5228 1.35719 19.6081 1.38604C19.6915 1.41435 19.7562 1.47169 19.7971 1.54236L19.8056 1.55605L19.8131 1.57176C19.833 1.60938 19.8496 1.65229 19.8575 1.70525C19.8948 1.95671 19.8825 3.02665 19.8825 3.02665L19.9415 5.24543L20.0286 7.8066L20.1373 12.2575ZM23.7488 2.86301C28.9088 6.61849 31.2753 13.4339 29.1235 19.8082C26.4751 27.653 17.9863 31.8597 10.1633 29.2041C2.34031 26.5484 -1.85455 18.0361 0.79367 10.1914C2.9491 3.80658 8.97324 -0.167855 15.3585 0.00544665L13.3118 2.43039C9.52375 3.11721 6.25309 5.71126 4.96759 9.51933C3.05491 15.185 6.26074 21.3926 12.1281 23.3842C17.9952 25.376 24.3022 22.3977 26.2149 16.7321C27.4962 12.9366 26.4802 8.89825 23.9063 6.04672L23.7488 2.86301Z'
            fill='#1E325C'
        />
    </svg>
);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

type SvgProps = {
    width?: number;
    height?: number;
};

const MonitorImacLikeSVG = (props: SvgProps) => (
    <svg
        width={props.width?.toString() || '150'}
        height={props.height?.toString() || '160'}
        viewBox='0 0 150 160'
        fill='none'
        xmlns='http://www.w3.org/2000/svg'
        xmlnsXlink='http://www.w3.org/1999/xlink'
    >
        <path
            d='M144.783 17.2976C144.783 12.6825 140.156 8.06738 135.529 8.06738H15.2276C10.6006 8.06738 5.97363 12.6825 5.97363 17.2976V105.037H144.783V17.2976Z'
            fill='#2D3039'
        />
        <path
            d='M5.97363 105.036V114.266C5.97363 118.881 10.6006 123.496 15.2276 123.496H135.529C140.156 123.496 144.783 118.881 144.783 114.266V105.036H5.97363Z'
            fill='#DDDFE4'
        />
        <path
            d='M56.8702 128.095C56.8702 137.325 47.6162 137.325 38.3975 137.325H112.429C103.175 137.325 93.9563 137.325 93.9563 128.095V123.462H56.9406L56.8702 128.095Z'
            fill='#C6C9D2'
        />
        <path
            d='M135.529 17.333H15.2278V95.7893H135.529V17.333Z'
            fill='white'
        />
        <path
            d='M75.3781 111.801C75.8357 111.801 76.283 111.936 76.6635 112.19C77.0439 112.443 77.3404 112.804 77.5155 113.225C77.6906 113.647 77.7364 114.111 77.6471 114.558C77.5579 115.006 77.3376 115.417 77.014 115.74C76.6905 116.063 76.2782 116.283 75.8295 116.372C75.3807 116.461 74.9155 116.415 74.4928 116.24C74.0701 116.066 73.7088 115.77 73.4546 115.39C73.2004 115.011 73.0647 114.565 73.0647 114.108C73.0647 113.496 73.3084 112.909 73.7423 112.477C74.1761 112.044 74.7646 111.801 75.3781 111.801Z'
            fill='#BABEC9'
        />
        <path
            d='M112.394 137.325H38.3623V146.555H112.394V137.325Z'
            fill='#A4A9B7'
        />
        <path
            d='M52.9387 24.4707H28.9387C26.7296 24.4707 24.9387 26.2616 24.9387 28.4707V44.4707C24.9387 46.6798 26.7296 48.4707 28.9387 48.4707H52.9387C55.1479 48.4707 56.9387 46.6798 56.9387 44.4707V28.4707C56.9387 26.2616 55.1479 24.4707 52.9387 24.4707Z'
            fill='#3D3C40'
            fillOpacity='0.24'
        />
        <path
            d='M40.9387 28.4707C39.3565 28.4707 37.8098 28.9399 36.4942 29.8189C35.1786 30.698 34.1532 31.9474 33.5477 33.4092C32.9422 34.871 32.7838 36.4796 33.0924 38.0314C33.4011 39.5833 34.163 41.0087 35.2819 42.1275C36.4007 43.2464 37.8261 44.0083 39.378 44.317C40.9298 44.6257 42.5384 44.4672 44.0002 43.8617C45.462 43.2562 46.7114 42.2309 47.5905 40.9153C48.4695 39.5997 48.9387 38.0529 48.9387 36.4707C48.9325 34.3509 48.0877 32.3196 46.5887 30.8207C45.0898 29.3218 43.0585 28.4769 40.9387 28.4707ZM40.9387 30.8707C41.4134 30.8707 41.8774 31.0115 42.2721 31.2752C42.6668 31.5389 42.9744 31.9137 43.156 32.3523C43.3377 32.7908 43.3852 33.2734 43.2926 33.7389C43.2 34.2045 42.9714 34.6321 42.6358 34.9678C42.3001 35.3034 41.8725 35.532 41.4069 35.6246C40.9414 35.7172 40.4588 35.6697 40.0203 35.488C39.5817 35.3064 39.2069 34.9987 38.9432 34.6041C38.6795 34.2094 38.5387 33.7454 38.5387 33.2707C38.5408 32.6348 38.7944 32.0256 39.244 31.576C39.6936 31.1264 40.3029 30.8728 40.9387 30.8707V30.8707ZM40.9387 42.4245C39.9906 42.4202 39.0579 42.1847 38.2215 41.7383C37.385 41.2919 36.6701 40.6482 36.1387 39.863C36.1772 38.263 39.3387 37.3822 40.9387 37.3822C42.5387 37.3822 45.7003 38.263 45.7387 39.863C45.2067 40.6476 44.4917 41.2909 43.6554 41.7372C42.8191 42.1835 41.8867 42.4194 40.9387 42.4245Z'
            fill='white'
        />
        <path
            d='M87.9387 24.4707H63.9387C61.7296 24.4707 59.9387 26.2616 59.9387 28.4707V44.4707C59.9387 46.6798 61.7296 48.4707 63.9387 48.4707H87.9387C90.1479 48.4707 91.9387 46.6798 91.9387 44.4707V28.4707C91.9387 26.2616 90.1479 24.4707 87.9387 24.4707Z'
            fill='#3D3C40'
            fillOpacity='0.24'
        />
        <path
            d='M75.9387 28.4707C74.3565 28.4707 72.8098 28.9399 71.4942 29.8189C70.1786 30.698 69.1532 31.9474 68.5477 33.4092C67.9422 34.871 67.7838 36.4796 68.0924 38.0314C68.4011 39.5833 69.163 41.0087 70.2819 42.1275C71.4007 43.2464 72.8261 44.0083 74.378 44.317C75.9298 44.6257 77.5384 44.4672 79.0002 43.8617C80.462 43.2562 81.7114 42.2309 82.5905 40.9153C83.4695 39.5997 83.9387 38.0529 83.9387 36.4707C83.9325 34.3509 83.0877 32.3196 81.5887 30.8207C80.0898 29.3218 78.0585 28.4769 75.9387 28.4707ZM75.9387 30.8707C76.4134 30.8707 76.8774 31.0115 77.2721 31.2752C77.6668 31.5389 77.9744 31.9137 78.156 32.3523C78.3377 32.7908 78.3852 33.2734 78.2926 33.7389C78.2 34.2045 77.9714 34.6321 77.6358 34.9678C77.3001 35.3034 76.8725 35.532 76.4069 35.6246C75.9414 35.7172 75.4588 35.6697 75.0203 35.488C74.5817 35.3064 74.2069 34.9987 73.9432 34.6041C73.6795 34.2094 73.5387 33.7454 73.5387 33.2707C73.5408 32.6348 73.7944 32.0256 74.244 31.576C74.6936 31.1264 75.3029 30.8728 75.9387 30.8707V30.8707ZM75.9387 42.4245C74.9906 42.4202 74.0579 42.1847 73.2215 41.7383C72.385 41.2919 71.6701 40.6482 71.1387 39.863C71.1772 38.263 74.3387 37.3822 75.9387 37.3822C77.5387 37.3822 80.7003 38.263 80.7387 39.863C80.2067 40.6476 79.4917 41.2909 78.6554 41.7372C77.8191 42.1835 76.8867 42.4194 75.9387 42.4245Z'
            fill='white'
        />
        <path
            d='M122.939 24.4707H98.9387C96.7296 24.4707 94.9387 26.2616 94.9387 28.4707V44.4707C94.9387 46.6798 96.7296 48.4707 98.9387 48.4707H122.939C125.148 48.4707 126.939 46.6798 126.939 44.4707V28.4707C126.939 26.2616 125.148 24.4707 122.939 24.4707Z'
            fill='#166DE0'
        />
        <path
            d='M110.939 28.4707C109.356 28.4707 107.81 28.9399 106.494 29.8189C105.179 30.698 104.153 31.9474 103.548 33.4092C102.942 34.871 102.784 36.4796 103.092 38.0314C103.401 39.5833 104.163 41.0087 105.282 42.1275C106.401 43.2464 107.826 44.0083 109.378 44.317C110.93 44.6257 112.538 44.4672 114 43.8617C115.462 43.2562 116.711 42.2309 117.59 40.9153C118.47 39.5997 118.939 38.0529 118.939 36.4707C118.933 34.3509 118.088 32.3196 116.589 30.8207C115.09 29.3218 113.059 28.4769 110.939 28.4707ZM110.939 30.8707C111.413 30.8707 111.877 31.0115 112.272 31.2752C112.667 31.5389 112.974 31.9137 113.156 32.3523C113.338 32.7908 113.385 33.2734 113.293 33.7389C113.2 34.2045 112.971 34.6321 112.636 34.9678C112.3 35.3034 111.873 35.532 111.407 35.6246C110.941 35.7172 110.459 35.6697 110.02 35.488C109.582 35.3064 109.207 34.9987 108.943 34.6041C108.679 34.2094 108.539 33.7454 108.539 33.2707C108.541 32.6348 108.794 32.0256 109.244 31.576C109.694 31.1264 110.303 30.8728 110.939 30.8707V30.8707ZM110.939 42.4245C109.991 42.4202 109.058 42.1847 108.221 41.7383C107.385 41.2919 106.67 40.6482 106.139 39.863C106.177 38.263 109.339 37.3822 110.939 37.3822C112.539 37.3822 115.7 38.263 115.739 39.863C115.207 40.6476 114.492 41.2909 113.655 41.7372C112.819 42.1835 111.887 42.4194 110.939 42.4245Z'
            fill='white'
        />
        <path
            d='M52.9387 64.4707H28.9387C26.7296 64.4707 24.9387 66.2616 24.9387 68.4707V84.4707C24.9387 86.6798 26.7296 88.4707 28.9387 88.4707H52.9387C55.1479 88.4707 56.9387 86.6798 56.9387 84.4707V68.4707C56.9387 66.2616 55.1479 64.4707 52.9387 64.4707Z'
            fill='#166DE0'
        />
        <path
            d='M40.9387 68.4707C39.3565 68.4707 37.8098 68.9399 36.4942 69.8189C35.1786 70.698 34.1532 71.9474 33.5477 73.4092C32.9422 74.871 32.7838 76.4796 33.0924 78.0314C33.4011 79.5833 34.163 81.0087 35.2819 82.1275C36.4007 83.2464 37.8261 84.0083 39.378 84.317C40.9298 84.6257 42.5384 84.4672 44.0002 83.8617C45.462 83.2562 46.7114 82.2309 47.5905 80.9153C48.4695 79.5997 48.9387 78.0529 48.9387 76.4707C48.9325 74.3509 48.0877 72.3196 46.5887 70.8207C45.0898 69.3218 43.0585 68.4769 40.9387 68.4707ZM40.9387 70.8707C41.4134 70.8707 41.8774 71.0115 42.2721 71.2752C42.6668 71.5389 42.9744 71.9137 43.156 72.3523C43.3377 72.7908 43.3852 73.2734 43.2926 73.7389C43.2 74.2045 42.9714 74.6321 42.6358 74.9678C42.3001 75.3034 41.8725 75.532 41.4069 75.6246C40.9414 75.7172 40.4588 75.6697 40.0203 75.488C39.5817 75.3064 39.2069 74.9987 38.9432 74.6041C38.6795 74.2094 38.5387 73.7454 38.5387 73.2707C38.5408 72.6348 38.7944 72.0256 39.244 71.576C39.6936 71.1264 40.3029 70.8728 40.9387 70.8707V70.8707ZM40.9387 82.4245C39.9906 82.4202 39.0579 82.1847 38.2215 81.7383C37.385 81.2919 36.6701 80.6482 36.1387 79.863C36.1772 78.263 39.3387 77.3822 40.9387 77.3822C42.5387 77.3822 45.7003 78.263 45.7387 79.863C45.2067 80.6476 44.4917 81.2909 43.6554 81.7372C42.8191 82.1835 41.8867 82.4194 40.9387 82.4245Z'
            fill='white'
        />
        <path
            d='M86.9387 64.4707H62.9387C60.7296 64.4707 58.9387 66.2616 58.9387 68.4707V84.4707C58.9387 86.6798 60.7296 88.4707 62.9387 88.4707H86.9387C89.1479 88.4707 90.9387 86.6798 90.9387 84.4707V68.4707C90.9387 66.2616 89.1479 64.4707 86.9387 64.4707Z'
            fill='#166DE0'
        />
        <path
            d='M74.9387 68.4707C73.3565 68.4707 71.8098 68.9399 70.4942 69.8189C69.1786 70.698 68.1532 71.9474 67.5477 73.4092C66.9422 74.871 66.7838 76.4796 67.0924 78.0314C67.4011 79.5833 68.163 81.0087 69.2819 82.1275C70.4007 83.2464 71.8261 84.0083 73.378 84.317C74.9298 84.6257 76.5384 84.4672 78.0002 83.8617C79.462 83.2562 80.7114 82.2309 81.5905 80.9153C82.4695 79.5997 82.9387 78.0529 82.9387 76.4707C82.9325 74.3509 82.0877 72.3196 80.5887 70.8207C79.0898 69.3218 77.0585 68.4769 74.9387 68.4707ZM74.9387 70.8707C75.4134 70.8707 75.8774 71.0115 76.2721 71.2752C76.6668 71.5389 76.9744 71.9137 77.156 72.3523C77.3377 72.7908 77.3852 73.2734 77.2926 73.7389C77.2 74.2045 76.9714 74.6321 76.6358 74.9678C76.3001 75.3034 75.8725 75.532 75.4069 75.6246C74.9414 75.7172 74.4588 75.6697 74.0203 75.488C73.5817 75.3064 73.2069 74.9987 72.9432 74.6041C72.6795 74.2094 72.5387 73.7454 72.5387 73.2707C72.5408 72.6348 72.7944 72.0256 73.244 71.576C73.6936 71.1264 74.3029 70.8728 74.9387 70.8707V70.8707ZM74.9387 82.4245C73.9906 82.4202 73.0579 82.1847 72.2215 81.7383C71.385 81.2919 70.6701 80.6482 70.1387 79.863C70.1772 78.263 73.3387 77.3822 74.9387 77.3822C76.5387 77.3822 79.7003 78.263 79.7387 79.863C79.2067 80.6476 78.4917 81.2909 77.6554 81.7372C76.8191 82.1835 75.8867 82.4194 74.9387 82.4245Z'
            fill='white'
        />
        <path
            d='M120.939 64.4707H96.9387C94.7296 64.4707 92.9387 66.2616 92.9387 68.4707V84.4707C92.9387 86.6798 94.7296 88.4707 96.9387 88.4707H120.939C123.148 88.4707 124.939 86.6798 124.939 84.4707V68.4707C124.939 66.2616 123.148 64.4707 120.939 64.4707Z'
            fill='#3D3C40'
            fillOpacity='0.24'
        />
        <path
            d='M108.939 68.4707C107.356 68.4707 105.81 68.9399 104.494 69.8189C103.179 70.698 102.153 71.9474 101.548 73.4092C100.942 74.871 100.784 76.4796 101.092 78.0314C101.401 79.5833 102.163 81.0087 103.282 82.1275C104.401 83.2464 105.826 84.0083 107.378 84.317C108.93 84.6257 110.538 84.4672 112 83.8617C113.462 83.2562 114.711 82.2309 115.59 80.9153C116.47 79.5997 116.939 78.0529 116.939 76.4707C116.933 74.3509 116.088 72.3196 114.589 70.8207C113.09 69.3218 111.059 68.4769 108.939 68.4707ZM108.939 70.8707C109.413 70.8707 109.877 71.0115 110.272 71.2752C110.667 71.5389 110.974 71.9137 111.156 72.3523C111.338 72.7908 111.385 73.2734 111.293 73.7389C111.2 74.2045 110.971 74.6321 110.636 74.9678C110.3 75.3034 109.873 75.532 109.407 75.6246C108.941 75.7172 108.459 75.6697 108.02 75.488C107.582 75.3064 107.207 74.9987 106.943 74.6041C106.679 74.2094 106.539 73.7454 106.539 73.2707C106.541 72.6348 106.794 72.0256 107.244 71.576C107.694 71.1264 108.303 70.8728 108.939 70.8707V70.8707ZM108.939 82.4245C107.991 82.4202 107.058 82.1847 106.221 81.7383C105.385 81.2919 104.67 80.6482 104.139 79.863C104.177 78.263 107.339 77.3822 108.939 77.3822C110.539 77.3822 113.7 78.263 113.739 79.863C113.207 80.6476 112.492 81.2909 111.655 81.7372C110.819 82.1835 109.887 82.4194 108.939 82.4245Z'
            fill='white'
        />
    </svg>
);

export default MonitorImacLikeSVG;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

type SvgProps = {
    width: number;
    height: number;
}

const PaymentFailedSvg = ({width, height}: SvgProps) => (
    <svg
        width={width ? width.toString() : '319'}
        height={height ? height.toString() : '260'}
        viewBox='0 0 319 260'
        fill='none'
        xmlns='http://www.w3.org/2000/svg'
    >
        <g clipPath='url(#clip_payment_failed)'>
            <path
                d='M23.3084 212.009H234.816C236.372 211.987 237.857 211.35 238.944 210.236C240.031 209.123 240.633 207.624 240.618 206.068V64.7859C240.633 63.2299 240.031 61.7311 238.944 60.6177C237.857 59.5042 236.372 58.8668 234.816 58.845H23.3084C21.7528 58.869 20.2697 59.5071 19.1829 60.62C18.096 61.733 17.4936 63.2305 17.5069 64.7859V206.076C17.4958 207.63 18.0992 209.125 19.1858 210.237C20.2724 211.348 21.7542 211.985 23.3084 212.009Z'
                fill='#24262E'
            />
            <path
                d='M0.5 232.757C0.5 239.883 6.30153 247.008 13.338 247.008H244.67C251.301 247.008 257.5 239.899 257.5 232.757H0.5Z'
                fill='#24262E'
            />
            <path
                d='M236.084 212.009H21.916L0.5 232.756H257.5L236.084 212.009Z'
                fill='#D1D4DB'
            />
            <path
                d='M229.006 213.658H29.118L21.9821 222.383H236.15L229.006 213.658Z'
                fill='#AFB3C0'
            />
            <path
                d='M151.042 226.219H107.091L103.792 230.578H154.332L151.042 226.219Z'
                fill='#24262E'
            />
            <path
                d='M227.581 71.7463H30.5519V199.108H227.581V71.7463Z'
                fill='#DDDFE4'
            />
            <path
                d='M157.63 117.352L149.506 109.225L129.185 129.55L108.864 109.225L100.73 117.352L121.051 137.685L100.73 158.009L108.864 166.135L129.185 145.811L149.506 166.135L157.63 158.009L137.309 137.685L157.63 117.352Z'
                fill='#C43133'
            />
            <path
                d='M129.062 62.1509C129.718 62.1509 130.359 62.3453 130.904 62.7095C131.449 63.0736 131.874 63.5913 132.125 64.1969C132.376 64.8025 132.441 65.4689 132.313 66.1118C132.186 66.7547 131.87 67.3453 131.406 67.8088C130.943 68.2723 130.352 68.588 129.709 68.7159C129.066 68.8438 128.399 68.7781 127.793 68.5272C127.188 68.2764 126.67 67.8516 126.306 67.3066C125.941 66.7615 125.747 66.1207 125.747 65.4652C125.747 64.5862 126.096 63.7432 126.718 63.1216C127.34 62.5001 128.183 62.1509 129.062 62.1509Z'
                fill='#DDDFE4'
            />
            <path
                d='M147.495 242.037H110.514C109.238 242.037 105.864 242.037 105.864 237.728H152.169C152.169 242.037 148.696 242.037 147.495 242.037Z'
                fill='#3F4350'
            />
        </g>
        <path
            d='M315.265 116.114C318.832 119.674 319.567 125.07 316.879 128.194L254.577 200.63C250.796 205.03 244.164 205.147 239.856 200.832L186.671 147.636C182.35 143.314 182.474 136.694 186.867 132.913L259.302 70.6175C262.426 67.9359 267.815 68.6649 271.381 72.2382L315.265 116.114Z'
            fill='#BABEC9'
        />
        <path
            d='M290.375 91.3414L210.079 171.375L191.375 152.475L274.944 75.75L290.375 91.3414Z'
            fill='#363A45'
        />
        <path
            d='M287.297 107.25L230.75 165.166L245.906 180.375L300.5 120.492L287.297 107.25Z'
            fill='white'
        />
        <path
            d='M255.101 160.078C251.985 157.081 253.832 151.457 254.967 148.394C256.725 143.645 258.577 152.757 258.666 154.169C258.965 158.8 258.575 163.45 257.512 167.956C256.915 170.484 256.042 172.932 254.91 175.251C254.231 176.683 253.256 177.94 252.055 178.931C249.073 180.814 247.176 178.984 246.409 173.454C246.719 171.764 247.495 170.205 248.642 168.971C252.537 163.911 258.698 161.358 263.234 157.432C263.678 157.041 262.968 156.311 262.53 156.689C257.131 161.378 246.034 165.244 245.4 174.508C244.943 180.629 250.888 181.942 254.073 178.533C258.216 174.104 259.275 166.033 259.631 159.965C259.84 156.444 260.697 146.703 255.748 145.522C255.653 145.49 255.55 145.493 255.456 145.53C255.363 145.567 255.284 145.637 255.234 145.728C253.273 149.329 250.469 156.875 254.523 160.788C254.563 160.85 254.616 160.902 254.678 160.939C254.741 160.976 254.81 160.997 254.882 161.002C254.953 161.006 255.025 160.993 255.09 160.963C255.156 160.934 255.215 160.889 255.261 160.832C255.307 160.775 255.341 160.708 255.358 160.635C255.375 160.562 255.376 160.486 255.36 160.413C255.345 160.34 255.313 160.272 255.268 160.214C255.223 160.156 255.166 160.109 255.101 160.078Z'
            fill='#505667'
        />
        <path
            d='M262.517 157.469C267.035 160.015 268.152 149.876 267.565 147.113C267.543 147.031 267.502 146.955 267.445 146.894C267.388 146.832 267.317 146.786 267.238 146.76C267.159 146.734 267.075 146.728 266.993 146.744C266.912 146.759 266.835 146.795 266.771 146.849C264.402 148.781 263.982 153.874 265.996 156.835C266.036 156.911 266.095 156.975 266.167 157.019C266.239 157.063 266.322 157.086 266.406 157.086C266.49 157.086 266.573 157.063 266.645 157.019C266.717 156.975 266.776 156.911 266.816 156.835C268.115 154.09 269.213 151.25 270.102 148.34C270.502 147.113 271.541 147.396 272.361 146.545C274.027 144.817 275.647 143.063 277.28 141.348C279.339 139.171 280.049 136.302 281.954 134.092C284.381 131.308 286.718 129.963 287.931 126.13C288.209 125.253 288.228 123.222 286.75 123.109C283.91 122.885 281.411 129.046 285.207 128.439C289.849 127.72 294.012 122.199 297.02 119.264C297.382 118.914 296.717 118.241 296.375 118.604C294.877 120.062 293.341 121.513 291.746 122.912C290.476 124.033 289.149 125.086 287.77 126.064C287.066 126.559 281.76 128.954 285.13 124.93L286.924 126.355C286.737 126.861 286.521 127.357 286.279 127.839C285.826 128.731 285.294 129.578 284.691 130.372C283.58 131.922 281.818 132.825 280.559 134.263C278.958 136.097 278.332 138.716 276.622 140.629C275.866 141.473 271.735 146.869 270.263 146.229C270.169 146.195 270.067 146.197 269.975 146.236C269.883 146.275 269.808 146.348 269.766 146.44C269.288 147.832 268.824 149.237 268.352 150.648C268.184 151.163 266.222 155.173 266.28 155.312C265.539 153.168 265.594 150.821 266.435 148.715C266.71 149.232 266.875 149.803 266.918 150.39C266.961 150.976 266.883 151.566 266.687 152.119C266.358 154.619 265.112 156.116 262.962 156.578C262.905 156.548 262.842 156.53 262.778 156.525C262.714 156.52 262.65 156.527 262.589 156.548C262.528 156.568 262.471 156.6 262.422 156.643C262.373 156.685 262.333 156.737 262.304 156.796C262.274 156.854 262.257 156.918 262.252 156.983C262.246 157.049 262.254 157.115 262.274 157.177C262.294 157.24 262.325 157.298 262.367 157.348C262.409 157.398 262.459 157.439 262.517 157.469Z'
            fill='#505667'
        />
        <defs>
            <clipPath id='clip_payment_failed'>
                <rect
                    width='257'
                    height='219'
                    fill='white'
                    transform='translate(0.5 28)'
                />
            </clipPath>
        </defs>
    </svg>

);

export default PaymentFailedSvg;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

type SvgProps = {
    width: number;
    height: number;
}

const PaymentSuccessStandardSvg = (props: SvgProps) => (
    <svg
        width={props.width ? props.width.toString() : '312'}
        height={props.height ? props.height.toString() : '257'}
        viewBox='0 0 312 257'
        fill='none'
        xmlns='http://www.w3.org/2000/svg'
    >
        <g clipPath='url(#clip_payment_success)'>
            <path
                d='M22.6373 196.797H232.466C234.01 196.775 235.483 196.143 236.562 195.038C237.64 193.934 238.237 192.447 238.222 190.904V50.7664C238.237 49.2229 237.64 47.7363 236.562 46.6319C235.483 45.5274 234.01 44.8952 232.466 44.8735H22.6373C21.094 44.8973 19.6227 45.5303 18.5445 46.6342C17.4663 47.7382 16.8686 49.2236 16.8818 50.7664V190.912C16.8708 192.454 17.4694 193.937 18.5474 195.039C19.6254 196.141 21.0954 196.773 22.6373 196.797Z'
                fill='#24262E'
            />
            <path
                d='M0.0098877 217.376C0.0098877 224.445 5.76538 231.513 12.746 231.513H242.242C248.82 231.513 254.97 224.461 254.97 217.376H0.0098877Z'
                fill='#24262E'
            />
            <path
                d='M233.724 196.796H21.2559L0.0098877 217.376H254.97L233.724 196.796Z'
                fill='#D1D4DB'
            />
            <path
                d='M226.703 198.432H28.401L21.3218 207.087H233.79L226.703 198.432Z'
                fill='#AFB3C0'
            />
            <path
                d='M149.357 210.892H105.755L102.483 215.215H152.621L149.357 210.892Z'
                fill='#24262E'
            />
            <path
                d='M225.288 57.6704H29.8234V184.001H225.288V57.6704Z'
                fill='#DDDFE4'
            />
            <path
                d='M153.186 90.751L113.343 134.562L101.779 125.806H95.3497L113.343 155.016L159.615 90.751H153.186Z'
                fill='#339970'
            />
            <path
                d='M127.552 48.1526C128.202 48.1526 128.838 48.3454 129.379 48.7066C129.92 49.0679 130.341 49.5813 130.59 50.182C130.839 50.7827 130.904 51.4437 130.777 52.0814C130.651 52.7192 130.337 53.3049 129.877 53.7647C129.417 54.2245 128.831 54.5376 128.193 54.6644C127.555 54.7913 126.894 54.7261 126.293 54.4773C125.692 54.2285 125.179 53.8071 124.817 53.2665C124.456 52.7259 124.263 52.0903 124.263 51.4401C124.263 50.5682 124.609 49.732 125.226 49.1155C125.843 48.4989 126.68 48.1526 127.552 48.1526Z'
                fill='#DDDFE4'
            />
            <path
                d='M145.838 226.581H109.15C107.884 226.581 104.538 226.581 104.538 222.307H150.475C150.475 226.581 147.03 226.581 145.838 226.581Z'
                fill='#3F4350'
            />
        </g>
        <path
            d='M307.836 95.9331C311.392 99.4834 312.126 104.864 309.445 107.979L247.319 180.211C243.548 184.598 236.935 184.715 232.639 180.412L179.605 127.366C175.296 123.056 175.419 116.456 179.799 112.685L252.031 50.5654C255.146 47.8913 260.519 48.6182 264.075 52.1815L307.836 95.9331Z'
            fill='#BABEC9'
        />
        <path
            d='M283.016 71.231L202.947 151.039L184.295 132.192L267.629 55.6836L283.016 71.231Z'
            fill='#363A45'
        />
        <path
            d='M279.947 87.0945L223.559 144.847L238.672 160.013L293.112 100.299L279.947 87.0945Z'
            fill='white'
        />
        <path
            d='M247.841 139.774C244.735 136.785 246.576 131.177 247.708 128.122C249.461 123.387 251.308 132.473 251.397 133.882C251.694 138.499 251.306 143.137 250.245 147.63C249.65 150.15 248.78 152.591 247.651 154.904C246.973 156.332 246.001 157.585 244.804 158.574C241.831 160.452 239.939 158.627 239.174 153.112C239.483 151.426 240.257 149.872 241.401 148.641C245.285 143.596 251.428 141.05 255.952 137.135C256.395 136.745 255.686 136.018 255.249 136.395C249.866 141.07 238.8 144.925 238.168 154.163C237.712 160.266 243.64 161.576 246.816 158.177C250.947 153.76 252.004 145.712 252.358 139.661C252.567 136.15 253.421 126.436 248.486 125.259C248.391 125.227 248.289 125.229 248.195 125.267C248.102 125.304 248.024 125.374 247.974 125.464C246.019 129.055 243.223 136.58 247.265 140.481C247.305 140.543 247.358 140.595 247.42 140.632C247.482 140.669 247.551 140.69 247.623 140.695C247.694 140.699 247.765 140.686 247.831 140.657C247.896 140.627 247.955 140.582 248.001 140.526C248.047 140.469 248.08 140.401 248.097 140.329C248.115 140.257 248.115 140.181 248.1 140.108C248.084 140.035 248.053 139.967 248.008 139.909C247.963 139.851 247.906 139.805 247.841 139.774Z'
            fill='#505667'
        />
        <path
            d='M255.236 137.171C259.742 139.71 260.856 129.601 260.27 126.845C260.249 126.763 260.208 126.688 260.151 126.626C260.094 126.565 260.023 126.519 259.944 126.493C259.865 126.467 259.782 126.461 259.7 126.477C259.619 126.492 259.542 126.528 259.478 126.582C257.116 128.509 256.697 133.587 258.706 136.54C258.745 136.616 258.804 136.679 258.876 136.723C258.948 136.767 259.031 136.79 259.114 136.79C259.198 136.79 259.281 136.767 259.353 136.723C259.425 136.679 259.484 136.616 259.523 136.54C260.818 133.802 261.914 130.971 262.8 128.068C263.199 126.845 264.235 127.127 265.053 126.279C266.714 124.556 268.329 122.806 269.958 121.096C272.011 118.925 272.719 116.064 274.618 113.861C277.039 111.085 279.369 109.743 280.579 105.922C280.856 105.047 280.875 103.021 279.401 102.909C276.569 102.686 274.078 108.829 277.863 108.224C282.491 107.507 286.643 102.001 289.643 99.0745C290.003 98.7259 289.34 98.055 288.999 98.4167C287.505 99.8704 285.973 101.317 284.383 102.712C283.117 103.83 281.793 104.88 280.418 105.856C279.716 106.349 274.425 108.737 277.785 104.725L279.575 106.145C279.388 106.651 279.173 107.145 278.931 107.625C278.479 108.515 277.949 109.36 277.348 110.151C276.24 111.697 274.483 112.598 273.228 114.032C271.631 115.86 271.007 118.472 269.301 120.379C268.548 121.221 264.428 126.601 262.961 125.963C262.867 125.929 262.765 125.932 262.673 125.971C262.581 126.01 262.507 126.082 262.465 126.174C261.989 127.562 261.525 128.963 261.055 130.37C260.888 130.883 258.931 134.882 258.989 135.02C258.25 132.883 258.305 130.542 259.143 128.443C259.418 128.958 259.582 129.527 259.625 130.112C259.668 130.697 259.59 131.285 259.394 131.837C259.066 134.33 257.824 135.823 255.68 136.283C255.623 136.254 255.561 136.236 255.497 136.23C255.433 136.225 255.369 136.233 255.308 136.253C255.247 136.273 255.191 136.305 255.142 136.348C255.093 136.39 255.053 136.442 255.024 136.5C254.995 136.559 254.977 136.622 254.972 136.688C254.967 136.753 254.974 136.819 254.994 136.881C255.014 136.943 255.045 137.001 255.087 137.051C255.128 137.101 255.179 137.142 255.236 137.171Z'
            fill='#505667'
        />
        <defs>
            <clipPath id='clip_payment_success'>
                <rect
                    width='254.96'
                    height='217.226'
                    fill='white'
                    transform='translate(0.0098877 14.2778)'
                />
            </clipPath>
        </defs>
    </svg>

);

export default PaymentSuccessStandardSvg;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import styled from 'styled-components';

import {limitThresholds} from 'utils/limits';

type Thresholds = {
    ok: number;
    warn: number;
    danger: number;
    exceeded: number;
}

type Props = {

    // 0-100, i.e. not a 0-1 decimal
    percent: number;
    thresholds?: Thresholds;
    barWidth?: number | string;
}

const defaultThresholds = limitThresholds;

type BarBackgroundProps = {
    width: number | string;
    thresholds: Thresholds;
    percent: number;
}

const BarBackground = styled.div<BarBackgroundProps>`
    height: ${(props) => (typeof props.width === 'number' ? Math.ceil(props.width / 20).toString() + 'px' : '8px')};
    width: ${(props) => (typeof props.width === 'number' ? props.width.toString() + 'px' : props.width)};
    background: ${(props) => (
        isExceeded(props.percent, props.thresholds) ?
            'var(--dnd-indicator)' :
            'rgba(var(--center-channel-color-rgb), 0.11)'
    )};
    border-radius: 8px;
    position: relative;
`;

type BarForegroundProps = {
    width: number | string;
    percent: number;
    thresholds: Thresholds;
}

function getColor(percent: number, thresholds: Thresholds): string {
    switch (true) {
    case percent < thresholds.ok:
        return '';
    case percent < thresholds.warn:
        return 'var(--online-indicator)';
    case percent < thresholds.danger || percent > thresholds.exceeded:
        // exceeded case also has a red background, applied elsewhere
        return 'var(--away-indicator)';
    case percent < thresholds.exceeded:
        return 'var(--dnd-indicator)';
    default:
        return '';
    }
}

function isExceeded(percent: number, thresholds: Thresholds): boolean {
    return percent >= thresholds.exceeded;
}

const BarForeground = styled.div<BarForegroundProps>`
    height: 100%;
    width: ${(props) => (isExceeded(props.percent, props.thresholds) ? 91 : props.percent)}%;
    border-radius: 8px;
    background-color: ${(props) => getColor(props.percent, props.thresholds)};
    transition: background-color 0.4s ease, width 0.4s ease;
    position: absolute;
`;

const UsagePercentBar = (props: Props) => {
    const thresholds = props.thresholds || defaultThresholds;
    const percent = Math.max(0, props.percent);
    const barWidth = props.barWidth || 155;
    return (
        <BarBackground
            width={barWidth}
            thresholds={thresholds}
            percent={percent}
        >
            <BarForeground
                width={barWidth}
                thresholds={thresholds}
                percent={percent}
            />
        </BarBackground>
    );
};

export default UsagePercentBar;


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState, useEffect} from 'react';

import ThemeProvider, {lightTheme} from '@mattermost/compass-components/utilities/theme';

import {Theme} from 'mattermost-redux/selectors/entities/preferences';

type Props = {
    theme: Theme;
    children?: React.ReactNode;
}

const CompassThemeProvider = ({theme, children}: Props): JSX.Element | null => {
    const [compassTheme, setCompassTheme] = useState({
        ...lightTheme,
        noStyleReset: true,
        noDefaultStyle: true,
        noFontFaces: true,
    });

    useEffect(() => {
        setCompassTheme({
            ...compassTheme,
            palette: {
                ...compassTheme.palette,
                primary: {
                    ...compassTheme.palette.primary,
                    main: theme.sidebarHeaderBg,
                    contrast: theme.sidebarHeaderTextColor,
                },
                alert: {
                    ...compassTheme.palette.alert,
                    main: theme.dndIndicator,
                },
            },
            action: {
                ...compassTheme.action,
                hover: theme.sidebarHeaderTextColor,
                disabled: theme.sidebarHeaderTextColor,
            },
            badges: {
                ...compassTheme.badges,
                online: theme.onlineIndicator,
                away: theme.awayIndicator,
                dnd: theme.dndIndicator,
            },
            text: {
                ...compassTheme.text,
                primary: theme.sidebarHeaderTextColor,
            },
        });
    }, [theme]);

    return (
        <ThemeProvider theme={compassTheme}>
            {children}
        </ThemeProvider>
    );
};

export default CompassThemeProvider;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useState} from 'react';

import ConfirmModal from 'components/confirm_modal';

type Props = Omit<React.ComponentProps<typeof ConfirmModal>, 'show'> & {
    onExited: () => void;
};

export default function ConfirmModalRedux(props: Props) {
    const {
        onCancel,
        onConfirm,
        onExited,
        ...otherProps
    } = props;

    const [show, setShow] = useState(true);

    const wrappedOnCancel = useCallback((checked) => {
        onCancel?.(checked);

        setShow(false);
    }, [onCancel]);
    const wrappedOnConfirm = useCallback((checked) => {
        onConfirm?.(checked);

        setShow(false);
    }, [onConfirm]);

    return (
        <ConfirmModal
            {...otherProps}
            onCancel={wrappedOnCancel}
            onConfirm={wrappedOnConfirm}
            onExited={onExited}
            show={show}
        />
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import ConfirmModalRedux from './confirm_modal_redux';

export default ConfirmModalRedux;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState} from 'react';
import {FormattedMessage} from 'react-intl';
import {Tooltip} from 'react-bootstrap';
import classNames from 'classnames';

import OverlayTrigger from 'components/overlay_trigger';

import Constants from 'utils/constants';
import {copyToClipboard} from 'utils/utils';
import {t} from 'utils/i18n';

type Props = {
    content: string;
    beforeCopyText?: string;
    afterCopyText?: string;
    placement?: string;
    className?: string;
};

const CopyButton: React.FC<Props> = (props: Props) => {
    const [isCopied, setIsCopied] = useState(false);

    const copyText = (e: React.MouseEvent<HTMLAnchorElement, MouseEvent>): void => {
        e.preventDefault();
        setIsCopied(true);

        setTimeout(() => {
            setIsCopied(false);
        }, 2000);

        copyToClipboard(props.content);
    };

    const getId = () => {
        if (isCopied) {
            return t('copied.message');
        }
        return props.beforeCopyText ? t('copy.text.message') : t('copy.code.message');
    };

    const getDefaultMessage = () => {
        if (isCopied) {
            return props.afterCopyText;
        }
        return props.beforeCopyText ?? 'Copy code';
    };

    const tooltip = (
        <Tooltip id='copyButton'>
            <FormattedMessage
                id={getId()}
                defaultMessage={getDefaultMessage()}
            />
        </Tooltip>
    );

    const spanClassName = classNames('post-code__clipboard', props.className);

    return (
        <OverlayTrigger
            shouldUpdatePosition={true}
            delayShow={Constants.OVERLAY_TIME_DELAY}
            placement={props.placement}
            overlay={tooltip}
        >
            <span
                className={spanClassName}
                onClick={copyText}
            >
                {!isCopied &&
                    <i
                        role='button'
                        className='icon icon-content-copy'
                    />
                }
                {isCopied &&
                    <i
                        role='button'
                        className='icon icon-check'
                    />
                }
            </span>
        </OverlayTrigger>
    );
};

CopyButton.defaultProps = {
    afterCopyText: 'Copied',
    placement: 'top',
};

export default CopyButton;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {ContextMenu, ContextMenuTrigger, MenuItem} from 'react-contextmenu';
import {FormattedMessage} from 'react-intl';

type Props = {

    /**
     * The child component that will be right-clicked on to show the context menu
     */
    children: React.ReactNode;

    /**
     * The link to copy to the user's clipboard when the 'Copy' option is selected from the context menu
     */
    link: string;

    /**
     * A unique id differentiating this instance of context menu from others on the page
     */
    menuId: string;

    siteURL?: string;

    actions: {
        copyToClipboard: (link: string) => void;
    };
}

export default class CopyUrlContextMenu extends React.PureComponent<Props> {
    copy = () => {
        let link = this.props.link;

        // Transform relative links to absolute ones for copy and paste.
        if (link.indexOf('http://') === -1 && link.indexOf('https://') === -1) {
            link = this.props.siteURL + link;
        }

        this.props.actions.copyToClipboard(link);
    }

    render(): JSX.Element {
        const contextMenu = (
            <ContextMenu id={'copy-url-context-menu' + this.props.menuId}>
                <MenuItem
                    onClick={this.copy}
                >
                    <FormattedMessage
                        id='copy_url_context_menu.getChannelLink'
                        defaultMessage='Copy Link'
                    />
                </MenuItem>
            </ContextMenu>
        );

        const contextMenuTrigger = (
            <ContextMenuTrigger
                id={'copy-url-context-menu' + this.props.menuId}
                holdToDisplay={-1}
            >
                {this.props.children}
            </ContextMenuTrigger>
        );

        return (
            <span>
                {contextMenu}
                {contextMenuTrigger}
            </span>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {GlobalState} from 'types/store/index.js';

import {getConfig} from 'mattermost-redux/selectors/entities/general';

import {copyToClipboard} from 'utils/utils';

import CopyUrlContextMenu from './copy_url_context_menu';

function mapStateToProps(state: GlobalState) {
    const config = getConfig(state);

    return {
        siteURL: config.SiteURL,
    };
}

function mapDispatchToProps() {
    return {
        actions: {
            copyToClipboard,
        },
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(CopyUrlContextMenu);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {Modal} from 'react-bootstrap';

import {FormattedMessage} from 'react-intl';

import {UserProfile} from '@mattermost/types/users';

import * as Utils from 'utils/utils';
import {GroupCreateWithUserIds} from '@mattermost/types/groups';

import 'components/user_groups_modal/user_groups_modal.scss';
import './create_user_groups_modal.scss';
import {ModalData} from 'types/actions';
import Input from 'components/widgets/inputs/input/input';
import AddUserToGroupMultiSelect from 'components/add_user_to_group_multiselect';
import {ActionResult} from 'mattermost-redux/types/actions';
import LocalizedIcon from 'components/localized_icon';
import {t} from 'utils/i18n';
import {localizeMessage} from 'utils/utils';
import Constants, {ItemStatus} from 'utils/constants';

export type Props = {
    onExited: () => void;
    backButtonCallback?: () => void;
    actions: {
        createGroupWithUserIds: (group: GroupCreateWithUserIds) => Promise<ActionResult>;
        openModal: <P>(modalData: ModalData<P>) => void;
    };
}

type State = {
    show: boolean;
    name: string;
    mention: string;
    savingEnabled: boolean;
    usersToAdd: UserProfile[];
    mentionUpdatedManually: boolean;
    mentionInputErrorText: string;
    nameInputErrorText: string;
    showUnknownError: boolean;
    saving: boolean;
}

export default class CreateUserGroupsModal extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            show: true,
            name: '',
            mention: '',
            savingEnabled: false,
            usersToAdd: [],
            mentionUpdatedManually: false,
            mentionInputErrorText: '',
            nameInputErrorText: '',
            showUnknownError: false,
            saving: false,
        };
    }

    doHide = () => {
        this.setState({show: false});
    }
    isSaveEnabled = () => {
        return this.state.name.length > 0 && this.state.mention.length > 0 && this.state.usersToAdd.length > 0;
    }
    updateNameState = (e: React.ChangeEvent<HTMLInputElement>) => {
        const value = e.target.value;
        let mention = this.state.mention;
        if (!this.state.mentionUpdatedManually) {
            mention = value.replace(/[^A-Za-z0-9.\-_@]/g, '').toLowerCase();
            if (mention.substring(0, 1) !== '@') {
                mention = `@${mention}`;
            }
        }
        this.setState({name: value, mention});
    }

    updateMentionState = (e: React.ChangeEvent<HTMLInputElement>) => {
        const value = e.target.value;
        this.setState({mention: value, mentionUpdatedManually: true});
    }

    private addUserCallback = (usersToAdd: UserProfile[]): void => {
        this.setState({usersToAdd});
    };

    private deleteUserCallback = (usersToAdd: UserProfile[]): void => {
        this.setState({usersToAdd});
    };

    goBack = () => {
        if (typeof this.props.backButtonCallback === 'function') {
            this.props.backButtonCallback();
            this.props.onExited();
        }
    }

    createGroup = async (users?: UserProfile[]) => {
        this.setState({showUnknownError: false, mentionInputErrorText: '', nameInputErrorText: '', saving: true});
        let mention = this.state.mention;
        const displayName = this.state.name;

        if (!displayName || !displayName.trim()) {
            this.setState({nameInputErrorText: Utils.localizeMessage('user_groups_modal.nameIsEmpty', 'Name is a required field.'), saving: false});
            return;
        }

        if (!users || users.length === 0) {
            this.setState({saving: false});
            return;
        }
        if (mention.substring(0, 1) === '@') {
            mention = mention.substring(1, mention.length);
        }

        if (mention.length < 1) {
            this.setState({mentionInputErrorText: Utils.localizeMessage('user_groups_modal.mentionIsEmpty', 'Mention is a required field.'), saving: false});
            return;
        }

        if (Constants.SPECIAL_MENTIONS.includes(mention.toLowerCase())) {
            this.setState({mentionInputErrorText: Utils.localizeMessage('user_groups_modal.mentionReservedWord', 'Mention contains a reserved word.'), saving: false});
            return;
        }

        const mentionRegEx = new RegExp(/^[a-z0-9.\-_]+$/);
        if (!mentionRegEx.test(mention)) {
            this.setState({mentionInputErrorText: Utils.localizeMessage('user_groups_modal.mentionInvalidError', 'Invalid character in mention.'), saving: false});
            return;
        }

        const group = {
            name: mention,
            display_name: this.state.name,
            allow_reference: true,
            source: 'custom',
            user_ids: users.map((user) => {
                return user.id;
            }),
        };

        const data = await this.props.actions.createGroupWithUserIds(group);

        if (data?.error) {
            if (data.error?.server_error_id === 'app.custom_group.unique_name') {
                this.setState({mentionInputErrorText: Utils.localizeMessage('user_groups_modal.mentionNotUnique', 'Mention needs to be unique.')});
            } else if (data.error?.server_error_id === 'app.group.username_conflict') {
                this.setState({mentionInputErrorText: Utils.localizeMessage('user_groups_modal.mentionUsernameConflict', 'A username already exists with this name. Mention must be unique.')});
            } else {
                this.setState({showUnknownError: true});
            }
            this.setState({saving: false});
        } else if (typeof this.props.backButtonCallback === 'function') {
            this.goBack();
        } else {
            this.doHide();
        }
    }

    render() {
        return (
            <Modal
                dialogClassName='a11y__modal user-groups-modal-create'
                show={this.state.show}
                onHide={this.doHide}
                onExited={this.props.onExited}
                role='dialog'
                aria-labelledby='createUserGroupsModalLabel'
                id='createUserGroupsModal'
            >
                <Modal.Header closeButton={true}>
                    {
                        typeof this.props.backButtonCallback === 'function' ?
                            <>
                                <button
                                    type='button'
                                    className='modal-header-back-button btn-icon'
                                    aria-label='Back'
                                    onClick={() => {
                                        this.goBack();
                                    }}
                                >
                                    <LocalizedIcon
                                        className='icon icon-arrow-left'
                                        ariaLabel={{id: t('user_groups_modal.goBackLabel'), defaultMessage: 'Back'}}
                                    />
                                </button>
                                <Modal.Title
                                    componentClass='h1'
                                    id='createGroupsModalTitleWithBack'
                                >
                                    <FormattedMessage
                                        id='user_groups_modal.createTitle'
                                        defaultMessage='Create Group'
                                    />
                                </Modal.Title>
                            </> :
                            <Modal.Title
                                componentClass='h1'
                                id='createGroupsModalTitle'
                            >
                                <FormattedMessage
                                    id='user_groups_modal.createTitle'
                                    defaultMessage='Create Group'
                                />
                            </Modal.Title>
                    }

                </Modal.Header>
                <Modal.Body
                    className='overflow--visible'
                >
                    <div className='user-groups-modal__content'>
                        <div className='group-name-input-wrapper'>
                            <Input
                                type='text'
                                placeholder={Utils.localizeMessage('user_groups_modal.name', 'Name')}
                                onChange={this.updateNameState}
                                value={this.state.name}
                                data-testid='nameInput'
                                maxLength={64}
                                autoFocus={true}
                                customMessage={{type: ItemStatus.ERROR, value: this.state.nameInputErrorText}}
                            />
                        </div>
                        <div className='group-mention-input-wrapper'>
                            <Input
                                type='text'
                                placeholder={Utils.localizeMessage('user_groups_modal.mention', 'Mention')}
                                onChange={this.updateMentionState}
                                value={this.state.mention}
                                maxLength={64}
                                data-testid='mentionInput'
                                customMessage={{type: ItemStatus.ERROR, value: this.state.mentionInputErrorText}}
                            />
                        </div>
                        <h2>
                            <FormattedMessage
                                id='user_groups_modal.addPeople'
                                defaultMessage='Add People'
                            />
                        </h2>
                        <div className='group-add-user'>
                            <AddUserToGroupMultiSelect
                                multilSelectKey={'addUsersToGroupKey'}
                                onSubmitCallback={this.createGroup}
                                focusOnLoad={false}
                                savingEnabled={this.isSaveEnabled()}
                                addUserCallback={this.addUserCallback}
                                deleteUserCallback={this.deleteUserCallback}
                                backButtonText={localizeMessage('multiselect.cancelButton', 'Cancel')}
                                backButtonClick={
                                    typeof this.props.backButtonCallback === 'function' ?
                                        this.goBack :
                                        this.doHide
                                }
                                backButtonClass={'multiselect-back'}
                                saving={this.state.saving}
                            />
                        </div>
                        {
                            this.state.showUnknownError &&
                            <div className='Input___error group-error'>
                                <i className='icon icon-alert-outline'/>
                                <FormattedMessage
                                    id='user_groups_modal.unknownError'
                                    defaultMessage='An unknown error has occurred.'
                                />
                            </div>
                        }
                    </div>
                </Modal.Body>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {Action, ActionResult} from 'mattermost-redux/types/actions';

import {GroupCreateWithUserIds} from '@mattermost/types/groups';
import {createGroupWithUserIds} from 'mattermost-redux/actions/groups';
import {ModalData} from 'types/actions';
import {openModal} from 'actions/views/modals';

import CreateUserGroupsModal from './create_user_groups_modal';

type Actions = {
    createGroupWithUserIds: (group: GroupCreateWithUserIds) => Promise<ActionResult>;
    openModal: <P>(modalData: ModalData<P>) => void;
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, Actions>({
            createGroupWithUserIds,
            openModal,
        }, dispatch),
    };
}

export default connect(null, mapDispatchToProps)(CreateUserGroupsModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useMemo, memo} from 'react';
import {useSelector} from 'react-redux';

import {CustomStatusDuration} from '@mattermost/types/users';

import {GlobalState} from 'types/store';
import {getCurrentUserTimezone} from 'selectors/general';
import {makeGetCustomStatus, isCustomStatusEnabled, isCustomStatusExpired} from 'selectors/views/custom_status';

import Constants from 'utils/constants';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import RenderEmoji from 'components/emoji/render_emoji';

import ExpiryTime from './expiry_time';

interface Props {
    emojiSize?: number;
    showTooltip?: boolean;
    tooltipDirection?: 'top' | 'right' | 'bottom' | 'left';
    spanStyle?: React.CSSProperties;
    emojiStyle?: React.CSSProperties;
    userID?: string;
    onClick?: () => void;
}

function CustomStatusEmoji({
    emojiSize = 16,
    showTooltip = false,
    tooltipDirection = 'top',
    spanStyle = {},
    emojiStyle = {
        marginLeft: 4,
    },
    userID = '',
    onClick,
}: Props) {
    const getCustomStatus = useMemo(makeGetCustomStatus, []);
    const customStatus = useSelector((state: GlobalState) => getCustomStatus(state, userID));

    const timezone = useSelector(getCurrentUserTimezone);

    const customStatusExpired = useSelector((state: GlobalState) => isCustomStatusExpired(state, customStatus));
    const customStatusEnabled = useSelector(isCustomStatusEnabled);
    const isCustomStatusSet = Boolean(customStatusEnabled && customStatus?.emoji && !customStatusExpired);
    if (!isCustomStatusSet) {
        return null;
    }

    const statusEmoji = (
        <RenderEmoji
            emojiName={customStatus.emoji}
            size={emojiSize}
            emojiStyle={emojiStyle}
            onClick={onClick}
        />
    );

    if (!showTooltip) {
        return statusEmoji;
    }

    return (
        <OverlayTrigger
            delayShow={Constants.OVERLAY_TIME_DELAY}
            placement={tooltipDirection}
            overlay={
                <Tooltip id='custom-status-tooltip'>
                    <div className='custom-status'>
                        <RenderEmoji
                            emojiName={customStatus.emoji}
                            size={14}
                            emojiStyle={{
                                marginTop: 2,
                            }}
                        />
                        {customStatus.text &&
                            <span
                                className='custom-status-text'
                                style={{marginLeft: 5}}
                            >
                                {customStatus.text}
                            </span>
                        }
                    </div>
                    {customStatus.expires_at && customStatus.duration !== CustomStatusDuration.DONT_CLEAR &&
                        <div>
                            <ExpiryTime
                                time={customStatus.expires_at}
                                timezone={timezone}
                                className='custom-status-expiry'
                            />
                        </div>
                    }
                </Tooltip>
            }
        >
            <span style={spanStyle}>
                {statusEmoji}
            </span>
        </OverlayTrigger>
    );
}

function arePropsEqual(prevProps: Props, nextProps: Props) {
    return prevProps.userID === nextProps.userID;
}

export default memo(CustomStatusEmoji, arePropsEqual);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState} from 'react';
import {FormattedMessage} from 'react-intl';
import classNames from 'classnames';

import {CustomStatusDuration, UserCustomStatus} from '@mattermost/types/users';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import RenderEmoji from 'components/emoji/render_emoji';
import Constants, {durationValues} from 'utils/constants';

import CustomStatusText from './custom_status_text';

import './custom_status.scss';

type Props = {
    handleSuggestionClick: (status: UserCustomStatus) => void;
    handleClear?: (status: UserCustomStatus) => void;
    status: UserCustomStatus;
};

const CustomStatusSuggestion: React.FC<Props> = (props: Props) => {
    const {handleSuggestionClick, handleClear, status} = props;
    const {emoji, text, duration} = status;
    const [show, setShow] = useState(false);

    const showClearButton = () => setShow(true);

    const hideClearButton = () => setShow(false);

    const handleRecentCustomStatusClear = (event: React.MouseEvent<HTMLButtonElement>) => {
        event.stopPropagation();
        event.preventDefault();
        if (handleClear) {
            handleClear(status);
        }
    };

    const clearButton = handleClear ?
        (
            <div
                className='suggestion-clear'
            >
                <OverlayTrigger
                    delayShow={Constants.OVERLAY_TIME_DELAY}
                    placement='top'
                    overlay={
                        <Tooltip id='clear-recent-custom-status'>
                            {'Clear'}
                        </Tooltip>
                    }
                >
                    <button
                        className='style--none input-clear-x'
                        onClick={handleRecentCustomStatusClear}
                    >
                        <i className='icon icon-close-circle'/>
                    </button>
                </OverlayTrigger>
            </div>
        ) : null;

    return (
        <div
            className='statusSuggestion__row cursor--pointer'
            onMouseEnter={showClearButton}
            onMouseLeave={hideClearButton}
            onClick={() => handleSuggestionClick(status)}
        >
            <div className='statusSuggestion__icon'>
                <RenderEmoji
                    emojiName={emoji}
                    size={20}
                />
            </div>
            <CustomStatusText
                text={text}
                tooltipDirection='top'
                className={classNames('statusSuggestion__text', {
                    with_duration: duration,
                })}
            />
            {duration &&
            duration !== CustomStatusDuration.CUSTOM_DATE_TIME &&
            duration !== CustomStatusDuration.DATE_AND_TIME && (
                <span className='statusSuggestion__duration'>
                    <FormattedMessage
                        id={durationValues[duration].id}
                        defaultMessage={durationValues[duration].defaultMessage}
                    />
                </span>
            )}
            {show && clearButton}
        </div>
    );
};

export default CustomStatusSuggestion;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState, useEffect} from 'react';
import {FormattedMessage, useIntl} from 'react-intl';

import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import Menu from 'components/widgets/menu/menu';
import {CustomStatusDuration} from '@mattermost/types/users';
import {durationValues} from 'utils/constants';

import ExpiryTime from './expiry_time';

type ExpiryMenuItem = {
    text: string;
    value: string;
}

type Props = {
    duration: CustomStatusDuration;
    expiryTime?: string;
    handleDurationChange: (expiryValue: CustomStatusDuration) => void;
}

const {
    DONT_CLEAR,
    THIRTY_MINUTES,
    ONE_HOUR,
    FOUR_HOURS,
    TODAY,
    THIS_WEEK,
    DATE_AND_TIME,
    CUSTOM_DATE_TIME,
} = CustomStatusDuration;

const ExpiryMenu: React.FC<Props> = (props: Props) => {
    const {duration, handleDurationChange, expiryTime} = props;
    const {formatMessage} = useIntl();
    const [menuItems, setMenuItems] = useState<JSX.Element[]>([]);

    const expiryMenuItems: { [key in CustomStatusDuration]?: ExpiryMenuItem } = {
        [DONT_CLEAR]: {
            text: formatMessage(durationValues[DONT_CLEAR]),
            value: formatMessage(durationValues[DONT_CLEAR]),
        },
        [THIRTY_MINUTES]: {
            text: formatMessage(durationValues[THIRTY_MINUTES]),
            value: formatMessage(durationValues[THIRTY_MINUTES]),
        },
        [ONE_HOUR]: {
            text: formatMessage(durationValues[ONE_HOUR]),
            value: formatMessage(durationValues[ONE_HOUR]),
        },
        [FOUR_HOURS]: {
            text: formatMessage(durationValues[FOUR_HOURS]),
            value: formatMessage(durationValues[FOUR_HOURS]),
        },
        [TODAY]: {
            text: formatMessage(durationValues[TODAY]),
            value: formatMessage(durationValues[TODAY]),
        },
        [THIS_WEEK]: {
            text: formatMessage(durationValues[THIS_WEEK]),
            value: formatMessage(durationValues[THIS_WEEK]),
        },
        [CUSTOM_DATE_TIME]: {
            text: formatMessage({id: 'custom_status.expiry_dropdown.choose_date_and_time', defaultMessage: 'Choose date and time'}),
            value: formatMessage(durationValues[CUSTOM_DATE_TIME]),
        },
    };

    useEffect(() => {
        const menuItemArray = Object.keys(expiryMenuItems).map((item, index) => (
            <Menu.ItemAction
                key={item.toString()}
                onClick={(event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {
                    event.preventDefault();
                    handleDurationChange(item as CustomStatusDuration);
                }}
                ariaLabel={expiryMenuItems[item as CustomStatusDuration]?.text.toLowerCase()}
                text={expiryMenuItems[item as CustomStatusDuration]?.text}
                id={`expiry_menu_item_${index}`}
            />
        ));

        setMenuItems(menuItemArray);
    }, []);

    return (
        <div className='statusExpiry'>
            <div className='statusExpiry__content'>
                <MenuWrapper
                    className={'statusExpiry__menu'}
                >
                    <span className='expiry-wrapper expiry-selector'>
                        <FormattedMessage
                            id='custom_status.expiry_dropdown.clear_after'
                            defaultMessage='Clear after'
                        />{': '}
                        {expiryTime && duration !== DONT_CLEAR ? (
                            <ExpiryTime
                                time={expiryTime}
                                className='expiry-value'
                                showPrefix={false}
                            />
                        ) : (
                            <span className='expiry-value'>
                                {expiryMenuItems[duration === DATE_AND_TIME ? CUSTOM_DATE_TIME : duration]?.value}
                            </span>
                        )}
                        <span>
                            <i
                                className='fa fa-angle-down'
                                aria-hidden='true'
                            />
                        </span>
                    </span>
                    <Menu
                        ariaLabel={formatMessage({id: 'custom_status.expiry_dropdown.clear_after', defaultMessage: 'Clear after'})}
                        id='statusExpiryMenu'
                    >
                        <Menu.Group>
                            {menuItems}
                        </Menu.Group>
                    </Menu>
                </MenuWrapper>
            </div>
        </div>
    );
};

export default ExpiryMenu;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useState, useCallback} from 'react';
import {useSelector} from 'react-redux';
import DayPickerInput from 'react-day-picker/DayPickerInput';
import {DayModifiers, NavbarElementProps} from 'react-day-picker';
import {useIntl} from 'react-intl';

import moment, {Moment} from 'moment-timezone';
import MomentUtils from 'react-day-picker/moment';

import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import Menu from 'components/widgets/menu/menu';
import Timestamp from 'components/timestamp';
import {getCurrentLocale} from 'selectors/i18n';
import {getCurrentMomentForTimezone} from 'utils/timezone';

const CUSTOM_STATUS_TIME_PICKER_INTERVALS_IN_MINUTES = 30;

const Navbar: React.FC<Partial<NavbarElementProps>> = (navbarProps: Partial<NavbarElementProps>) => {
    const {
        onPreviousClick,
        onNextClick,
        className,
    } = navbarProps;
    const styleLeft: React.CSSProperties = {
        float: 'left',
        fontSize: 18,
    };
    const styleRight: React.CSSProperties = {
        float: 'right',
        fontSize: 18,
    };

    return (
        <div className={className}>
            <button
                className='style--none'
                style={styleLeft}
                onClick={(e) => {
                    e.preventDefault();
                    if (onPreviousClick) {
                        onPreviousClick();
                    }
                }}
            >
                <i
                    className='fa fa-angle-left'
                    aria-hidden='true'
                />
            </button>
            <button
                className='style--none'
                style={styleRight}
                onClick={(e) => {
                    e.preventDefault();
                    if (onNextClick) {
                        onNextClick();
                    }
                }}
            >
                <i
                    className='fa fa-angle-right'
                    aria-hidden='true'
                />
            </button>
        </div>
    );
};

export function getRoundedTime(value: Moment) {
    const roundedTo = CUSTOM_STATUS_TIME_PICKER_INTERVALS_IN_MINUTES;
    const start = moment(value);
    const diff = start.minute() % roundedTo;
    if (diff === 0) {
        return value;
    }
    const remainder = roundedTo - diff;
    return start.add(remainder, 'm').seconds(0).milliseconds(0);
}

const getTimeInIntervals = (startTime: Moment): Date[] => {
    const interval = CUSTOM_STATUS_TIME_PICKER_INTERVALS_IN_MINUTES;
    let time = moment(startTime);
    const nextDay = moment(startTime).add(1, 'days').startOf('day');
    const intervals: Date[] = [];
    while (time.isBefore(nextDay)) {
        intervals.push(time.toDate());
        time = time.add(interval, 'minutes').seconds(0).milliseconds(0);
    }

    return intervals;
};

type Props = {
    time: Moment;
    handleChange: (date: Moment) => void;
    timezone?: string;
}

const DateTimeInputContainer: React.FC<Props> = (props: Props) => {
    const locale = useSelector(getCurrentLocale);
    const {time, handleChange, timezone} = props;
    const [timeOptions, setTimeOptions] = useState<Date[]>([]);
    const {formatMessage} = useIntl();

    const setTimeAndOptions = () => {
        const currentTime = getCurrentMomentForTimezone(timezone);
        let startTime = moment(time).startOf('day');
        if (time.date() === currentTime.date()) {
            startTime = getRoundedTime(currentTime);
        }
        setTimeOptions(getTimeInIntervals(startTime));
    };

    useEffect(setTimeAndOptions, [time]);

    const handleDayChange = (day: Date, modifiers: DayModifiers) => {
        if (modifiers.today) {
            const currentTime = getCurrentMomentForTimezone(timezone);
            const roundedTime = getRoundedTime(currentTime);
            handleChange(roundedTime);
        } else {
            const dayWithTimezone = timezone ? moment.tz(day, timezone) : moment(day);
            handleChange(dayWithTimezone.startOf('day'));
        }
    };

    const handleTimeChange = useCallback((time: Date, e: React.MouseEvent) => {
        e.preventDefault();
        handleChange(moment(time));
    }, [handleChange]);

    const currentTime = getCurrentMomentForTimezone(timezone).toDate();
    const modifiers = {
        today: currentTime,
    };

    return (
        <div className='dateTime'>
            <div className='dateTime__date'>
                <span className='dateTime__input-title'>{formatMessage({id: 'custom_status.expiry.date_picker.title', defaultMessage: 'Date'})}</span>
                <span className='dateTime__date-icon'>
                    <i className='icon-calendar-outline'/>
                </span>
                <DayPickerInput
                    value={time.toDate()}
                    format='yyyy-MM-DD'
                    formatDate={MomentUtils.formatDate}
                    onDayChange={handleDayChange}
                    inputProps={{
                        readOnly: true,
                        className: 'dateTime__input',
                    }}
                    dayPickerProps={{
                        navbarElement: <Navbar/>,
                        fromMonth: currentTime,
                        modifiers,
                        locale: locale.toLowerCase(),
                        disabledDays: {
                            before: currentTime,
                        },
                    }}
                />
            </div>
            <div className='dateTime__time'>
                <MenuWrapper
                    className='dateTime__time-menu'
                >
                    <div>
                        <span className='dateTime__input-title'>{formatMessage({id: 'custom_status.expiry.time_picker.title', defaultMessage: 'Time'})}</span>
                        <span className='dateTime__time-icon'>
                            <i className='icon-clock-outline'/>
                        </span>
                        <div
                            className='dateTime__input'
                        >
                            <Timestamp
                                useRelative={false}
                                useDate={false}
                                value={time.toString()}
                            />
                        </div>
                    </div>
                    <Menu
                        ariaLabel={formatMessage({id: 'time_dropdown.choose_time', defaultMessage: 'Choose a time'})}
                        id='expiryTimeMenu'
                    >
                        <Menu.Group>
                            {Array.isArray(timeOptions) && timeOptions.map((option, index) => (
                                <Menu.ItemAction
                                    onClick={handleTimeChange.bind(this, option)}
                                    key={index}
                                    text={
                                        <Timestamp
                                            useRelative={false}
                                            useDate={false}
                                            value={option}
                                        />
                                    }
                                />
                            ))}
                        </Menu.Group>
                    </Menu>
                </MenuWrapper>
            </div>
        </div>
    );
};

export default DateTimeInputContainer;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useMemo, useRef, useState} from 'react';
import {useDispatch, useSelector} from 'react-redux';
import classNames from 'classnames';
import {FormattedMessage, useIntl} from 'react-intl';
import moment, {Moment} from 'moment-timezone';

import {setCustomStatus, unsetCustomStatus, removeRecentCustomStatus} from 'mattermost-redux/actions/users';
import {setCustomStatusInitialisationState} from 'mattermost-redux/actions/preferences';
import {Preferences} from 'mattermost-redux/constants';
import {UserCustomStatus, CustomStatusDuration} from '@mattermost/types/users';
import {Emoji} from '@mattermost/types/emojis';

import {loadCustomEmojisIfNeeded} from 'actions/emoji_actions';
import GenericModal from 'components/generic_modal';
import EmojiIcon from 'components/widgets/icons/emoji_icon';
import EmojiPickerOverlay from 'components/emoji_picker/emoji_picker_overlay';
import RenderEmoji from 'components/emoji/render_emoji';
import QuickInput, {MaxLengthInput} from 'components/quick_input';
import {makeGetCustomStatus, getRecentCustomStatuses, showStatusDropdownPulsatingDot, isCustomStatusExpired} from 'selectors/views/custom_status';
import {getCurrentUserTimezone} from 'selectors/general';
import {GlobalState} from 'types/store';
import {getCurrentMomentForTimezone} from 'utils/timezone';
import {Constants} from 'utils/constants';
import {t} from 'utils/i18n';
import {localizeMessage} from 'utils/utils';

import CustomStatusSuggestion from 'components/custom_status/custom_status_suggestion';
import ExpiryMenu from 'components/custom_status/expiry_menu';
import DateTimeInput, {getRoundedTime} from 'components/custom_status/date_time_input';

import 'components/category_modal.scss';
import './custom_status.scss';

type Props = {
    onExited: () => void;
};

// This is the same limit set
// https://github.com/mattermost/mattermost-server/pull/16835/files#diff-73c61af5954b16f5e3cb5ee786af9eb698f660eff0d65db5556949be5fb6e60bR15
const CUSTOM_STATUS_TEXT_CHARACTER_LIMIT = 100;
const EMOJI_PICKER_WIDTH_OFFSET = 308;

type DefaultUserCustomStatus = {
    emoji: string;
    message: string;
    messageDefault: string;
    duration: CustomStatusDuration;
};

const {
    DONT_CLEAR,
    THIRTY_MINUTES,
    ONE_HOUR,
    FOUR_HOURS,
    TODAY,
    THIS_WEEK,
    DATE_AND_TIME,
    CUSTOM_DATE_TIME,
} = CustomStatusDuration;

const defaultCustomStatusSuggestions: DefaultUserCustomStatus[] = [
    {
        emoji: 'calendar',
        message: t('custom_status.suggestions.in_a_meeting'),
        messageDefault: 'In a meeting',
        duration: ONE_HOUR,
    },
    {
        emoji: 'hamburger',
        message: t('custom_status.suggestions.out_for_lunch'),
        messageDefault: 'Out for lunch',
        duration: THIRTY_MINUTES,
    },
    {
        emoji: 'sneezing_face',
        message: t('custom_status.suggestions.out_sick'),
        messageDefault: 'Out sick',
        duration: TODAY,
    },
    {
        emoji: 'house',
        message: t('custom_status.suggestions.working_from_home'),
        messageDefault: 'Working from home',
        duration: TODAY,
    },
    {
        emoji: 'palm_tree',
        message: t('custom_status.suggestions.on_a_vacation'),
        messageDefault: 'On a vacation',
        duration: THIS_WEEK,
    },
];

const defaultDuration = TODAY;
const CustomStatusModal: React.FC<Props> = (props: Props) => {
    const getCustomStatus = useMemo(makeGetCustomStatus, []);
    const dispatch = useDispatch();
    const currentCustomStatus = useSelector(getCustomStatus);
    const customStatusExpired = useSelector((state: GlobalState) => isCustomStatusExpired(state, currentCustomStatus));
    const recentCustomStatuses = useSelector(getRecentCustomStatuses);
    const customStatusControlRef = useRef<HTMLDivElement>(null);
    const {formatMessage} = useIntl();
    const isCurrentCustomStatusSet = !customStatusExpired && (currentCustomStatus?.text || currentCustomStatus?.emoji);
    const [showEmojiPicker, setShowEmojiPicker] = useState<boolean>(false);
    const [text, setText] = useState<string>(isCurrentCustomStatusSet ? currentCustomStatus?.text : '');
    const [emoji, setEmoji] = useState<string>(isCurrentCustomStatusSet ? currentCustomStatus?.emoji : '');
    const initialDuration = isCurrentCustomStatusSet ? currentCustomStatus?.duration : defaultDuration;
    const [duration, setDuration] = useState<CustomStatusDuration>(initialDuration === undefined ? defaultDuration : initialDuration);
    const isStatusSet = Boolean(emoji || text);
    const firstTimeModalOpened = useSelector(showStatusDropdownPulsatingDot);
    const timezone = useSelector(getCurrentUserTimezone);

    const currentTime = getCurrentMomentForTimezone(timezone);
    let initialCustomExpiryTime: Moment = getRoundedTime(currentTime);
    if (isCurrentCustomStatusSet && currentCustomStatus?.duration === DATE_AND_TIME && currentCustomStatus?.expires_at) {
        initialCustomExpiryTime = moment(currentCustomStatus.expires_at);
    }
    const [customExpiryTime, setCustomExpiryTime] = useState<Moment>(initialCustomExpiryTime);

    const handleCustomStatusInitializationState = () => {
        if (firstTimeModalOpened) {
            dispatch(setCustomStatusInitialisationState({[Preferences.CUSTOM_STATUS_MODAL_VIEWED]: true}));
        }
    };

    const loadCustomEmojisForRecentStatuses = () => {
        const emojisToLoad = new Set<string>();
        recentCustomStatuses.forEach((customStatus: UserCustomStatus) => emojisToLoad.add(customStatus.emoji));
        dispatch(loadCustomEmojisIfNeeded(Array.from(emojisToLoad)));
    };

    const handleStatusExpired = () => {
        if (customStatusExpired && currentCustomStatus) {
            dispatch(unsetCustomStatus());
        }
    };

    useEffect(() => {
        handleCustomStatusInitializationState();
        loadCustomEmojisForRecentStatuses();
        handleStatusExpired();
    }, []);

    const handleSetStatus = () => {
        const expiresAt = calculateExpiryTime();
        const customStatus: UserCustomStatus = {
            emoji: emoji || 'speech_balloon',
            text: text.trim(),
            duration: duration === CUSTOM_DATE_TIME ? DATE_AND_TIME : duration,
        };
        if (expiresAt) {
            customStatus.expires_at = expiresAt;
        }
        dispatch(setCustomStatus(customStatus));
    };

    const calculateExpiryTime = (): string => {
        switch (duration) {
        case DONT_CLEAR:
            return '';
        case THIRTY_MINUTES:
            return moment().add(30, 'minutes').seconds(0).milliseconds(0).toISOString();
        case ONE_HOUR:
            return moment().add(1, 'hour').seconds(0).milliseconds(0).toISOString();
        case FOUR_HOURS:
            return moment().add(4, 'hours').seconds(0).milliseconds(0).toISOString();
        case TODAY:
            return moment().endOf('day').toISOString();
        case THIS_WEEK:
            return moment().endOf('week').toISOString();
        case DATE_AND_TIME:
        case CUSTOM_DATE_TIME:
            return customExpiryTime.toISOString();
        default:
            return '';
        }
    };

    const handleClearStatus = isCurrentCustomStatusSet ? () => dispatch(unsetCustomStatus()) : undefined;

    const getCustomStatusControlRef = () => customStatusControlRef.current;

    const handleEmojiClose = () => setShowEmojiPicker(false);

    const handleEmojiClick = (selectedEmoji: Emoji) => {
        setShowEmojiPicker(false);
        const emojiName = ('short_name' in selectedEmoji) ? selectedEmoji.short_name : selectedEmoji.name;
        setEmoji(emojiName);
    };

    const toggleEmojiPicker = (e?: React.MouseEvent<HTMLButtonElement, MouseEvent>): void => {
        e?.stopPropagation();
        setShowEmojiPicker((prevShow) => !prevShow);
    };

    const handleTextChange = (event: React.ChangeEvent<HTMLInputElement>) => setText(event.target.value);

    const handleRecentCustomStatusClear = (status: UserCustomStatus) => dispatch(removeRecentCustomStatus(status));

    const customStatusEmoji = emoji || text ? (
        <RenderEmoji
            emojiName={emoji || 'speech_balloon'}
            size={20}
        />
    ) : <EmojiIcon className={'icon icon--emoji'}/>;

    const clearHandle = () => {
        setEmoji('');
        setText('');
        setDuration(defaultDuration);
    };

    const handleSuggestionClick = (status: UserCustomStatus) => {
        setEmoji(status.emoji);
        setText(status.text);
        setDuration(status.duration || DONT_CLEAR);
    };

    const calculateRightOffSet = () => {
        let rightOffset = Constants.DEFAULT_EMOJI_PICKER_RIGHT_OFFSET;
        const target = getCustomStatusControlRef();
        if (target) {
            rightOffset = window.innerWidth - target.getBoundingClientRect().left - EMOJI_PICKER_WIDTH_OFFSET;
            if (rightOffset < 0) {
                rightOffset = Constants.DEFAULT_EMOJI_PICKER_RIGHT_OFFSET;
            }
        }

        return rightOffset;
    };

    const recentStatuses = (
        <div id='statusSuggestion__recents'>
            <div className='statusSuggestion__title'>
                {formatMessage({id: 'custom_status.suggestions.recent_title', defaultMessage: 'RECENT'})}
            </div>
            {
                recentCustomStatuses.map((status: UserCustomStatus) => (
                    <CustomStatusSuggestion
                        key={status.text}
                        handleSuggestionClick={handleSuggestionClick}
                        handleClear={handleRecentCustomStatusClear}
                        status={status}
                    />
                ))
            }
        </div>
    );

    const renderCustomStatusSuggestions = () => {
        const recentCustomStatusTexts = recentCustomStatuses.map((status: UserCustomStatus) => status.text);
        const customStatusSuggestions = defaultCustomStatusSuggestions.
            map((status) => ({
                emoji: status.emoji,
                text: formatMessage({id: status.message, defaultMessage: status.messageDefault}),
                duration: status.duration,
            })).
            filter((status: UserCustomStatus) => !recentCustomStatusTexts.includes(status.text)).
            map((status: UserCustomStatus, index: number) => (
                <CustomStatusSuggestion
                    key={index}
                    handleSuggestionClick={handleSuggestionClick}
                    status={status}
                />
            ));

        if (customStatusSuggestions.length <= 0) {
            return null;
        }

        return (
            <>
                <div className='statusSuggestion__title'>
                    {formatMessage({id: 'custom_status.suggestions.title', defaultMessage: 'SUGGESTIONS'})}
                </div>
                {customStatusSuggestions}
            </>
        );
    };

    const areEmojiAndTextSame = currentCustomStatus?.emoji === emoji && currentCustomStatus?.text === text;
    const areSelectedAndSetStatusSame = areEmojiAndTextSame && duration === currentCustomStatus?.duration;

    const showSuggestions = !isStatusSet || areSelectedAndSetStatusSame;

    const disableSetStatus = !isStatusSet || text.length > CUSTOM_STATUS_TEXT_CHARACTER_LIMIT;

    const showDateAndTimeField = !showSuggestions && (duration === CUSTOM_DATE_TIME || duration === DATE_AND_TIME);

    const suggestion = (
        <div
            className='statusSuggestion'
            style={{marginTop: isStatusSet ? 44 : 8}}
        >
            <div className='statusSuggestion__content'>
                {recentCustomStatuses.length > 0 && recentStatuses}
                <div id='statusSuggestion__suggestions'>
                    {renderCustomStatusSuggestions()}
                </div>
            </div>
        </div>
    );

    return (
        <GenericModal
            enforceFocus={false}
            onExited={props.onExited}
            modalHeaderText={
                <FormattedMessage
                    id='custom_status.set_status'
                    defaultMessage='Set a status'
                />
            }
            confirmButtonText={
                <FormattedMessage
                    id='custom_status.modal_confirm'
                    defaultMessage='Set Status'
                />
            }
            cancelButtonText={
                <FormattedMessage
                    id='custom_status.modal_cancel'
                    defaultMessage='Clear Status'
                />
            }
            isConfirmDisabled={disableSetStatus}
            id='custom_status_modal'
            className={'StatusModal'}
            handleConfirm={handleSetStatus}
            handleEnterKeyPress={handleSetStatus}
            handleCancel={handleClearStatus}
            confirmButtonClassName='btn btn-primary'
            ariaLabel={localizeMessage('custom_status.set_status', 'Set a status')}
        >
            <div className='StatusModal__body'>
                <div className='StatusModal__input'>
                    <div
                        ref={customStatusControlRef}
                        className='StatusModal__emoji-container'
                    >
                        {showEmojiPicker && (
                            <EmojiPickerOverlay
                                target={getCustomStatusControlRef}
                                show={showEmojiPicker}
                                onHide={handleEmojiClose}
                                onEmojiClick={handleEmojiClick}
                                rightOffset={calculateRightOffSet()}
                                leftOffset={3}
                                topOffset={3}
                                defaultHorizontalPosition='right'
                            />
                        )}
                        <button
                            type='button'
                            onClick={toggleEmojiPicker}
                            className={classNames('emoji-picker__container', 'StatusModal__emoji-button', {
                                'StatusModal__emoji-button--active': showEmojiPicker,
                            })}
                        >
                            {customStatusEmoji}
                        </button>
                    </div>
                    <QuickInput
                        inputComponent={MaxLengthInput}
                        value={text}
                        maxLength={CUSTOM_STATUS_TEXT_CHARACTER_LIMIT}
                        clearableWithoutValue={Boolean(isStatusSet)}
                        onClear={clearHandle}
                        className='form-control'
                        clearClassName='StatusModal__clear-container'
                        tooltipPosition='top'
                        onChange={handleTextChange}
                        placeholder={formatMessage({id: 'custom_status.set_status', defaultMessage: 'Set a status'})}
                    />
                </div>
                {showSuggestions && suggestion}
                {showDateAndTimeField && (
                    <DateTimeInput
                        time={customExpiryTime}
                        handleChange={setCustomExpiryTime}
                        timezone={timezone}
                    />
                )}
                {isStatusSet && (
                    <ExpiryMenu
                        duration={duration}
                        expiryTime={showSuggestions ? currentCustomStatus?.expires_at : undefined}
                        handleDurationChange={setDuration}
                    />
                )}
            </div>
        </GenericModal >
    );
};

export default CustomStatusModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState} from 'react';
import {useSelector} from 'react-redux';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import {isCustomStatusEnabled} from 'selectors/views/custom_status';
import {GlobalState} from 'types/store';
import Constants from 'utils/constants';

interface ComponentProps {
    tooltipDirection?: 'top' | 'right' | 'bottom' | 'left';
    text: string;
    className?: string;
}

const CustomStatusText = (props: ComponentProps) => {
    const {tooltipDirection, text, className} = props;
    const customStatusEnabled = useSelector((state: GlobalState) => {
        return isCustomStatusEnabled(state);
    });
    const [show, setShow] = useState<boolean>(false);
    let spanElement: HTMLSpanElement | null = null;
    if (!customStatusEnabled) {
        return null;
    }

    const showTooltip = () => {
        setShow(Boolean(spanElement && spanElement.offsetWidth < spanElement.scrollWidth));
    };

    const customStatusTextComponent = (
        <span
            className={`overflow--ellipsis text-nowrap ${className}`}
            ref={(element) => {
                spanElement = element;
                showTooltip();
            }}
        >
            {text}
        </span>
    );

    if (!show) {
        return customStatusTextComponent;
    }

    return (
        <OverlayTrigger
            delayShow={Constants.OVERLAY_TIME_DELAY}
            placement={tooltipDirection}
            overlay={
                <Tooltip id='custom-status-tooltip'>
                    {text}
                </Tooltip>
            }
        >
            {customStatusTextComponent}
        </OverlayTrigger>
    );
};

CustomStatusText.defaultProps = {
    tooltipDirection: 'bottom',
    text: '',
    className: '',
};

export default CustomStatusText;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import moment from 'moment-timezone';

import {FormattedMessage} from 'react-intl';

import Timestamp, {RelativeRanges} from 'components/timestamp';
import {Props as TimestampProps} from 'components/timestamp/timestamp';

import {getCurrentMomentForTimezone} from 'utils/timezone';

const CUSTOM_STATUS_EXPIRY_RANGES = [
    RelativeRanges.TODAY_TITLE_CASE,
    RelativeRanges.TOMORROW_TITLE_CASE,
];

interface Props {
    time: string;
    timezone?: string;
    className?: string;
    showPrefix?: boolean;
    withinBrackets?: boolean;
}

const ExpiryTime = ({time, timezone, className, showPrefix, withinBrackets}: Props) => {
    const currentMomentTime = getCurrentMomentForTimezone(timezone);
    const timestampProps: Partial<TimestampProps> = {
        value: time,
        ranges: CUSTOM_STATUS_EXPIRY_RANGES,
    };

    if (moment(time).isSame(currentMomentTime.clone().endOf('day')) || moment(time).isAfter(currentMomentTime.clone().add(1, 'day').endOf('day'))) {
        timestampProps.useTime = false;
    }

    if (moment(time).isBefore(currentMomentTime.clone().endOf('day'))) {
        timestampProps.useDate = false;
        delete timestampProps.ranges;
    }

    if (moment(time).isAfter(currentMomentTime.clone().add(1, 'day').endOf('day')) && moment(time).isBefore(currentMomentTime.clone().add(6, 'days'))) {
        timestampProps.useDate = {weekday: 'long'};
    }

    if (moment(time).isAfter(currentMomentTime.clone().add(6, 'days'))) {
        timestampProps.month = 'short';
    }

    if (moment(time).isAfter(currentMomentTime.clone().endOf('year'))) {
        timestampProps.year = 'numeric';
    }

    const prefix = showPrefix && (
        <>
            <FormattedMessage
                id='custom_status.expiry.until'
                defaultMessage='Until'
            />{' '}
        </>
    );

    return (
        <span className={className}>
            {withinBrackets && '('}
            {prefix}
            <Timestamp
                {...timestampProps}
            />
            {withinBrackets && ')'}
        </span>
    );
};

ExpiryTime.defaultProps = {
    showPrefix: true,
    withinBrackets: false,
};

export default React.memo(ExpiryTime);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import hoistStatics from 'hoist-non-react-statics';
import React from 'react';

type DeferredRenderWrapperState = {
    shouldRender: boolean;
}

/**
 * Allows two animation frames to complete to allow other components to update
 * and re-render before mounting and rendering an expensive `WrappedComponent`.
 * If provided, `PreRenderComponent` will be rendered instead of null when not
 * rendering the `Wrapped Component`.
 *
 * Based on this Twitter built component
 * https://gist.github.com/paularmstrong/cc2ead7e2a0dec37d8b2096fc8d85759#file-defercomponentrender-js
 */
export default function deferComponentRender<ComponentProps>(WrappedComponent: React.ComponentType<ComponentProps>, PreRenderComponent: React.ReactNode = null) {
    class DeferredRenderWrapper extends React.PureComponent<ComponentProps, DeferredRenderWrapperState> {
        mounted = false;
        constructor(props: ComponentProps) {
            super(props);

            this.state = {
                shouldRender: false,
            };
        }

        componentDidMount() {
            this.mounted = true;
            window.requestAnimationFrame(() => {
                window.requestAnimationFrame(() => {
                    if (this.mounted) {
                        this.setState({shouldRender: true});
                    }
                });
            });
        }

        componentWillUnmount() {
            this.mounted = false;
        }

        render() {
            return this.state.shouldRender ? <WrappedComponent {...this.props}/> : PreRenderComponent;
        }
    }

    return hoistStatics(DeferredRenderWrapper, WrappedComponent);
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';
import {matchPath} from 'react-router-dom';

import {Post} from '@mattermost/types/posts';

import * as UserAgent from 'utils/user_agent';
import {getHistory} from 'utils/browser_history';

const urlFormatForDMGMPermalink = '/:teamName/messages/:username/:postid';
const urlFormatForChannelPermalink = '/:teamName/channels/:channelname/:postid';

type Props = {
    channelName?: string;
    teamName?: string;
    post: Post;
    commentCount: number;
    isRHS: boolean;
    onExited: () => void;
    actions: {
        deleteAndRemovePost: (post: Post) => Promise<{data: boolean}>;
    };
    location: {
        pathname: string;
    };
}

type State = {
    show: boolean;
}

export default class DeletePostModal extends React.PureComponent<Props, State> {
    deletePostBtn: React.RefObject<HTMLButtonElement>;

    constructor(props: Props) {
        super(props);
        this.deletePostBtn = React.createRef();

        this.state = {
            show: true,
        };
    }

    handleDelete = async () => {
        const {
            actions,
            post,
        } = this.props;

        let permalinkPostId = '';

        const result = await actions.deleteAndRemovePost(post);

        const matchUrlForDMGM = matchPath<{postid: string}>(this.props.location.pathname, {
            path: urlFormatForDMGMPermalink,
        });

        const matchUrlForChannel = matchPath<{postid: string}>(this.props.location.pathname, {
            path: urlFormatForChannelPermalink,
        });

        if (matchUrlForDMGM) {
            permalinkPostId = matchUrlForDMGM.params.postid;
        } else if (matchUrlForChannel) {
            permalinkPostId = matchUrlForChannel.params.postid;
        }

        if (permalinkPostId === post.id) {
            const channelUrl = this.props.location.pathname.split('/').slice(0, -1).join('/');
            getHistory().replace(channelUrl);
        }

        if (result.data) {
            this.onHide();
        }
    }

    handleEntered = () => {
        this.deletePostBtn?.current?.focus();
    }

    onHide = () => {
        this.setState({show: false});

        if (!UserAgent.isMobile()) {
            let element;
            if (this.props.isRHS) {
                element = document.getElementById('reply_textbox');
            } else {
                element = document.getElementById('post_textbox');
            }
            if (element) {
                element.focus();
            }
        }
    }

    render() {
        let commentWarning: React.ReactNode = '';

        if (this.props.commentCount > 0 && this.props.post.root_id === '') {
            commentWarning = (
                <FormattedMessage
                    id='delete_post.warning'
                    defaultMessage='This post has {count, number} {count, plural, one {comment} other {comments}} on it.'
                    values={{
                        count: this.props.commentCount,
                    }}
                />
            );
        }

        const postTerm = this.props.post.root_id ? (
            <FormattedMessage
                id='delete_post.comment'
                defaultMessage='Comment'
            />
        ) : (
            <FormattedMessage
                id='delete_post.post'
                defaultMessage='Post'
            />
        );

        return (
            <Modal
                dialogClassName='a11y__modal'
                show={this.state.show}
                onEntered={this.handleEntered}
                onHide={this.onHide}
                onExited={this.props.onExited}
                enforceFocus={false}
                id='deletePostModal'
                role='dialog'
                aria-labelledby='deletePostModalLabel'
            >
                <Modal.Header closeButton={true}>
                    <Modal.Title
                        componentClass='h1'
                        id='deletePostModalLabel'
                    >
                        <FormattedMessage
                            id='delete_post.confirm'
                            defaultMessage='Confirm {term} Delete'
                            values={{
                                term: (postTerm),
                            }}
                        />
                    </Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    <FormattedMessage
                        id='delete_post.question'
                        defaultMessage='Are you sure you want to delete this {term}?'
                        values={{
                            term: (postTerm),
                        }}
                    />
                    <br/>
                    <br/>
                    {commentWarning}
                </Modal.Body>
                <Modal.Footer>
                    <button
                        type='button'
                        className='btn btn-link'
                        onClick={this.onHide}
                    >
                        <FormattedMessage
                            id='delete_post.cancel'
                            defaultMessage='Cancel'
                        />
                    </button>
                    <button
                        ref={this.deletePostBtn}
                        type='button'
                        autoFocus={true}
                        className='btn btn-danger'
                        onClick={this.handleDelete}
                        id='deletePostModalButton'
                    >
                        <FormattedMessage
                            id='delete_post.del'
                            defaultMessage='Delete'
                        />
                    </button>
                </Modal.Footer>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';
import {connect} from 'react-redux';
import {withRouter} from 'react-router-dom';

import {ActionFunc} from 'mattermost-redux/types/actions';
import {Post} from '@mattermost/types/posts';
import {makeGetCommentCountForPost} from 'mattermost-redux/selectors/entities/posts';

import {GlobalState} from 'types/store';
import {deleteAndRemovePost} from 'actions/post_actions';

import DeletePostModal from './delete_post_modal';

type Actions = {
    deleteAndRemovePost: (post: Post) => Promise<{data: boolean}>;
};

type Props = {
    channelName?: string;
    teamName?: string;
    post: Post;
    commentCount: number;
    isRHS: boolean;
    onHide: () => void;
    actions: {
        deleteAndRemovePost: (post: Post) => Promise<{data: boolean}>;
    };
    location: {
        pathname: string;
    };
}

function makeMapStateToProps() {
    const getReplyCount = makeGetCommentCountForPost();

    return (state: GlobalState, ownProps: Props) => {
        const post = ownProps.post;

        return {
            commentCount: getReplyCount(state, post),
        };
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc>, Actions>({
            deleteAndRemovePost,
        }, dispatch),
    };
}

export default withRouter(connect<any, any, any>(makeMapStateToProps, mapDispatchToProps)(DeletePostModal));

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

export default class DotsHorizontalIcon extends React.PureComponent<React.HTMLAttributes<HTMLSpanElement>> {
    render() {
        return (
            <span {...this.props}>
                <svg
                    width='14px'
                    height='4px'
                    viewBox='0 0 14 4'
                    role='img'
                    aria-label='dots horizontal icon'
                >
                    <path d='M10.2 2.00001C10.2 1.56267 10.3547 1.18934 10.664 0.880006C10.984 0.560006 11.3627 0.400006 11.8 0.400006C12.2373 0.400006 12.6107 0.560006 12.92 0.880006C13.24 1.18934 13.4 1.56267 13.4 2.00001C13.4 2.43734 13.24 2.81601 12.92 3.13601C12.6107 3.44534 12.2373 3.60001 11.8 3.60001C11.3627 3.60001 10.984 3.44534 10.664 3.13601C10.3547 2.81601 10.2 2.43734 10.2 2.00001ZM5.4 2.00001C5.4 1.56267 5.55467 1.18934 5.864 0.880006C6.184 0.560006 6.56267 0.400006 7 0.400006C7.43733 0.400006 7.81067 0.560006 8.12 0.880006C8.44 1.18934 8.6 1.56267 8.6 2.00001C8.6 2.43734 8.44 2.81601 8.12 3.13601C7.81067 3.44534 7.43733 3.60001 7 3.60001C6.56267 3.60001 6.184 3.44534 5.864 3.13601C5.55467 2.81601 5.4 2.43734 5.4 2.00001ZM0.6 2.00001C0.6 1.56267 0.754667 1.18934 1.064 0.880006C1.384 0.560006 1.76267 0.400006 2.2 0.400006C2.63733 0.400006 3.01067 0.560006 3.32 0.880006C3.64 1.18934 3.8 1.56267 3.8 2.00001C3.8 2.43734 3.64 2.81601 3.32 3.13601C3.01067 3.44534 2.63733 3.60001 2.2 3.60001C1.76267 3.60001 1.384 3.44534 1.064 3.13601C0.754667 2.81601 0.6 2.43734 0.6 2.00001Z'/>
                </svg>
            </span>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {AlertOutlineIcon, CheckIcon, InformationOutlineIcon} from '@mattermost/compass-icons/components';
import React, {memo} from 'react';
import styled, {css} from 'styled-components';

type NotificationVariant = 'general' | 'info' | 'success'| 'warning' | 'danger';

type NotificationProps = {
    id?: string;
    dismissable?: boolean;
    title?: JSX.Element | string;
    text: JSX.Element | string;
    variant: NotificationVariant;
}

const variantColorMap: Record<NotificationVariant, string> = {
    general: 'var(--semantic-color-general)',
    info: 'var(--semantic-color-info)',
    success: 'var(--semantic-color-success)',
    warning: 'var(--semantic-color-warning)',
    danger: 'var(--semantic-color-danger)',
};

type NotificationWrapperProps = {
    color: string;
}

const NotificationWrapper = styled.div(({color}: NotificationWrapperProps) => {
    return css`
        display: grid;
        grid-template-columns: minmax(0px, max-content) 1fr  minmax(0px, max-content);
        grid-template-rows: auto;
        grid-template-areas:
          "icon title close"
          ". text ."
          ". actions .";
        column-gap: 4px;

        padding: 16px;
        background-color: rgba(${color}, 0.08);
        border-width: 1px;
        border-style: solid;
        border-color: rgba(${color}, 0.16);
        border-radius: 4px;
    `;
});

const NotificationIcon = styled.div`
    grid-area: icon;
    width: 24px;
    place-items: center;
    place-content: center;
`;

const NotificationTitle = styled.h2`
    grid-area: title;
    color: rgb(var(--center-channel-color-rgb));
    font-weight: 600;
    font-size: 14px;
    line-height: 20px;
`;

const NotificationText = styled.p(({noTitle}: {noTitle: boolean}) => {
    const area = noTitle ? 'title' : 'text';
    return css`
        grid-area: ${area};
        color: rgb(var(--center-channel-color-rgb));
        font-weight: 400;
        font-size: 14px;
        line-height: 20px;
        margin: 0;
    `;
});

const NotificationBox = ({variant, title, text, id = ''}: NotificationProps) => {
    const color = variantColorMap[variant];

    const iconProps = {
        size: 20,
        color: `rgb(${color})`,
    };

    let icon = null;
    switch (variant) {
    case 'info':
        icon = <InformationOutlineIcon {...iconProps}/>;
        break;
    case 'success':
        icon = <CheckIcon {...iconProps}/>;
        break;
    case 'warning':
    case 'danger':
        icon = <AlertOutlineIcon {...iconProps}/>;
        break;
    case 'general':
    default:
        break;
    }

    return (
        <NotificationWrapper
            color={color}
            data-testid={`notification${id ? `_${id}` : ''}`}
        >
            <NotificationIcon>
                {icon}
            </NotificationIcon>
            {title && <NotificationTitle>{title}</NotificationTitle>}
            {text && (
                <NotificationText
                    noTitle={!title}
                    data-testid={'notification-text'}
                >
                    {text}
                </NotificationText>
            )}
        </NotificationWrapper>
    );
};

export default memo(NotificationBox);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {CSSProperties} from 'react';
import {ControlProps} from 'react-select';
import * as CSS from 'csstype';

import {ChannelOption} from './forward_post_channel_select';

type Pseudos = CSS.Pseudos | '::-webkit-scrollbar' | '::-webkit-scrollbar-track' | '::-webkit-scrollbar-thumb';

type CSSPropertiesWithPseudos = CSSProperties & { [P in Pseudos]?: CSS.Properties };

const menuMargin = 4;
const selectHeight = 40;

const getBaseStyles = (bodyHeight: number) => {
    const minMenuHeight = bodyHeight - selectHeight - menuMargin;

    return ({
        input: (provided: CSSProperties): CSSPropertiesWithPseudos => ({
            ...provided,
            padding: 0,
            margin: 0,
            color: 'var(--center-channel-color)',
        }),
        placeholder: (provided: CSSProperties): CSSPropertiesWithPseudos => ({
            ...provided,
            margin: 0,
            color: 'rgba(var(--center-channel-color-rgb), 0.64)',
            fontSize: '14px',
            lineHeight: '20px',
        }),

        // disabling this rule here since otherwise tsc will complain about it in the props
        // eslint-disable-next-line @typescript-eslint/ban-types
        control: (provided: CSSProperties, state: ControlProps<{}>): CSSPropertiesWithPseudos => {
            const focusShadow = 'inset 0 0 0 2px var(--button-bg)';

            return ({
                ...provided,
                color: 'var(--center-channel-color)',
                backgroundColor: 'var(--center-channel-bg)',
                cursor: 'pointer',
                borderWidth: 0,
                boxShadow: state.isFocused ? focusShadow : 'inset 0 0 0 1px rgba(var(--center-channel-color-rgb), 0.16)',
                borderRadius: '4px',
                minHeight: `${selectHeight}px`,
                padding: '0 0 0 16px',

                ':hover': {
                    color: state.isFocused ? focusShadow : 'inset 0 0 0 1px rgba(var(--center-channel-color-rgb), 0.24)',
                },
            });
        },
        indicatorSeparator: (): CSSPropertiesWithPseudos => ({
            display: 'none',
        }),
        indicatorsContainer: (provided: CSSProperties): CSSPropertiesWithPseudos => ({
            ...provided,
            padding: '2px',
        }),
        dropdownIndicator: (provided: CSSProperties, state: ControlProps<ChannelOption>): CSSPropertiesWithPseudos => ({
            ...provided,
            transform: state.isFocused ? 'rotate(180deg)' : 'rotate(0)',
            transition: 'transform 250ms ease-in-out',
        }),
        valueContainer: (provided: CSSProperties): CSSPropertiesWithPseudos => ({
            ...provided,
            overflow: 'visible',
            padding: '0 16px 0 0',
            margin: 0,
        }),
        menu: (provided: CSSProperties): CSSPropertiesWithPseudos => ({
            ...provided,
            padding: 0,
            margin: `${menuMargin}px 0 0 0`,
            zIndex: 10,
        }),
        menuList: (provided: CSSProperties): CSSPropertiesWithPseudos => ({
            ...provided,
            padding: 0,
            backgroundColor: 'var(--center-channel-bg)',
            borderRadius: '4px',
            border: '1px solid rgba(var(--center-channel-color-rgb), 0.16)',
            maxHeight: `min(${minMenuHeight}px, 300px)`,

            /* Elevation 4 */
            boxShadow: '0 8px 24px rgba(0, 0, 0, 0.12)',

            /* scrollbar styles */
            overflowY: 'auto', // for Firefox and browsers that doesn't support overflow-y:overlay property

            scrollbarColor: 'var(--center-channel-bg)',
            scrollbarWidth: 'thin',

            '::-webkit-scrollbar': {
                width: '8px',
            },

            '::-webkit-scrollbar-track': {
                width: '0px',
                background: 'transparent',
            },

            '::-webkit-scrollbar-thumb': {
                border: '1px var(--center-channel-bg) solid',
                background: 'rgba(var(--center-channel-color-rgb), 0.24) !important',
                backgroundClip: 'padding-box',
                borderRadius: '9999px',
            },
        }),
        groupHeading: (provided: CSSProperties): CSSPropertiesWithPseudos => ({
            ...provided,
            cursor: 'default',
            position: 'relative',
            display: 'flex',
            height: '2.8rem',
            alignItems: 'center',
            justifyContent: 'flex-start',
            padding: '0 0 0 2rem',
            margin: 0,
            color: 'rgba(var(--center-channel-color-rgb), 0.56)',
            backgroundColor: 'none',
            fontSize: '1.2rem',
            fontWeight: 600,
            textTransform: 'uppercase',
        }),
        singleValue: (provided: CSSProperties): CSSPropertiesWithPseudos => ({
            ...provided,
            maxWidth: 'calc(100% - 10px)',
            width: '100%',
            overflow: 'visible',
        }),
        option: (provided: CSSProperties, state: ControlProps<ChannelOption>): CSSPropertiesWithPseudos => ({
            ...provided,
            cursor: 'pointer',
            padding: '8px 20px',
            backgroundColor: state.isFocused ? 'rgba(var(--center-channel-color-rgb), 0.08)' : 'transparent',
        }),
        menuPortalTarget: (provided: CSSProperties): CSSPropertiesWithPseudos => ({
            ...provided,
            zIndex: 10,
        }),
    });
};

export {getBaseStyles};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {
    ArchiveOutlineIcon, ChevronDownIcon,
    GlobeIcon,
    LockOutlineIcon,
    MessageTextOutlineIcon,
} from '@mattermost/compass-icons/components';

import React, {useEffect, useRef} from 'react';

import {useIntl} from 'react-intl';

import {useSelector} from 'react-redux';

import {components, IndicatorProps, OptionProps, SingleValueProps, ValueType} from 'react-select';

import {Props as AsyncSelectProps} from 'react-select/src/Async';

import {getDirectTeammate} from 'mattermost-redux/selectors/entities/channels';
import {getMyTeams, getTeam} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentUserId, getStatusForUserId, getUser} from 'mattermost-redux/selectors/entities/users';
import {isGuest} from 'mattermost-redux/utils/user_utils';

import {GlobalState} from 'types/store';
import Constants from 'utils/constants';
import * as Utils from 'utils/utils';
import CustomStatusEmoji from 'components/custom_status/custom_status_emoji';
import ProfilePicture from 'components/profile_picture';
import SharedChannelIndicator from 'components/shared_channel_indicator';
import SwitchChannelProvider from 'components/suggestion/switch_channel_provider';
import BotBadge from 'components/widgets/badges/bot_badge';
import GuestBadge from 'components/widgets/badges/guest_badge';

import {ProviderResult} from 'components/suggestion/provider';

import {Channel} from '@mattermost/types/channels';

import {getBaseStyles} from './forward_post_channel_select_styles';

const AsyncSelect = require('react-select/lib/Async').default as React.ElementType<AsyncSelectProps<ChannelOption>>; // eslint-disable-line global-require

type ChannelTypeFromProvider = Channel & {
    userId?: string;
}

export type ChannelOption = {
    label: string;
    value: string;
    details: ChannelTypeFromProvider;
}

type GroupedOption = {
    label: React.ReactNode;
    options: ChannelOption[];
}

export const makeSelectedChannelOption = (channel: Channel): ChannelOption => ({
    label: channel.display_name || channel.name,
    value: channel.id,
    details: channel,
});

const FormattedOption = (props: ChannelOption & {className: string; isSingleValue?: boolean}) => {
    const {details} = props;

    const {formatMessage} = useIntl();

    const currentUserId = useSelector((state: GlobalState) => getCurrentUserId(state));
    const user = useSelector((state: GlobalState) => getUser(state, details.userId || ''));
    const status = useSelector((state: GlobalState) => getStatusForUserId(state, details.userId || ''));
    const teammate = useSelector((state: GlobalState) => getDirectTeammate(state, details.id));
    const team = useSelector((state: GlobalState) => getTeam(state, details.team_id));
    const userImageUrl = user?.id && Utils.imageURLForUser(user.id, user.last_picture_update);
    const isPartOfOnlyOneTeam = useSelector((state: GlobalState) => getMyTeams(state).length === 1);

    const channelIsArchived = details.delete_at > 0;

    let icon;
    const iconProps = {
        size: 16,
        color: 'rgba(var(--center-channel-color-rgb), 0.56)',
    };

    if (channelIsArchived) {
        icon = <ArchiveOutlineIcon {...iconProps}/>;
    } else if (details.type === Constants.OPEN_CHANNEL) {
        icon = <GlobeIcon {...iconProps}/>;
    } else if (details.type === Constants.PRIVATE_CHANNEL) {
        icon = <LockOutlineIcon {...iconProps}/>;
    } else if (details.type === Constants.THREADS) {
        icon = <MessageTextOutlineIcon {...iconProps}/>;
    } else if (details.type === Constants.GM_CHANNEL) {
        icon = <div className='status status--group'>{'G'}</div>;
    } else {
        icon = (
            <ProfilePicture
                src={userImageUrl}
                status={teammate && teammate.is_bot ? undefined : status}
                size='sm'
            />
        );
    }

    let customStatus = null;

    let name = details.display_name;
    let description = `~${details.name}`;

    let tag = null;
    if (details.type === Constants.DM_CHANNEL) {
        tag = (
            <>
                <BotBadge
                    show={Boolean(teammate?.is_bot)}
                    className='badge-autocomplete'
                />
                <GuestBadge
                    show={Boolean(teammate && isGuest(teammate.roles))}
                    className='badge-autocomplete'
                />
            </>
        );

        const emojiStyle = {
            marginBottom: 2,
            marginLeft: 8,
        };

        customStatus = (
            <CustomStatusEmoji
                showTooltip={true}
                userID={user.id}
                emojiStyle={emojiStyle}
            />
        );

        const deactivated = user.delete_at ? ` - ${formatMessage({id: 'channel_switch_modal.deactivated', defaultMessage: 'Deactivated'})}` : '';

        if (details.display_name && !teammate?.is_bot) {
            description = `@${user.username}${deactivated}`;
        } else {
            name = user.username;
            if (user.id === currentUserId) {
                name += ` ${formatMessage({id: 'suggestion.user.isCurrent', defaultMessage: '(you)'})}`;
            }
            description = deactivated;
        }
    } else if (details.type === Constants.GM_CHANNEL) {
        // remove the slug from the option
        name = details.display_name;
        description = '';
    }

    const sharedIcon = details.shared ? (
        <SharedChannelIndicator
            className='shared-channel-icon'
            channelType={details.type}
        />
    ) : null;

    const teamName = details.team_id && team ? (
        <span className='option__team-name'>{team.display_name}</span>
    ) : null;

    const componentType = props.isSingleValue ? 'singleValue' : 'option';

    const componentId = `post-forward_channel-select_${componentType}_${details.id}`;

    return (
        <div
            id={componentId}
            className={props.className}
            data-testid={details.name}
            aria-label={name}
        >
            {icon}
            <span className='option__content'>
                <span className='option__content--text'>{name}</span>
                {(isPartOfOnlyOneTeam || details.type === Constants.DM_CHANNEL) && description && (
                    <span className='option__content--description'>{description}</span>
                )}
                {customStatus}
                {sharedIcon}
                {tag}
            </span>
            {!isPartOfOnlyOneTeam && teamName}
        </div>
    );
};

const Option = (props: OptionProps<ChannelOption>) => {
    const {data} = props;

    const teammate = useSelector((state: GlobalState) => getDirectTeammate(state, data.details.id));

    if (teammate?.is_bot) {
        return null;
    }

    return (
        <components.Option {...props}>
            <FormattedOption
                {...data}
                className='option'
            />
        </components.Option>
    );
};

const SingleValue = (props: SingleValueProps<ChannelOption>) => {
    const {data} = props;

    return (
        <components.SingleValue {...props}>
            <FormattedOption
                {...data}
                isSingleValue={true}
                className='singleValue'
            />
        </components.SingleValue>
    );
};

const DropdownIndicator = (props: IndicatorProps<ChannelOption>) => {
    return (
        <components.DropdownIndicator {...props}>
            <ChevronDownIcon
                size={16}
                color={'rgba(var(--center-channel-color-rgb), 0.64)'}
            />
        </components.DropdownIndicator>
    );
};

const validChannelTypes = ['O', 'P', 'D', 'G'];

type Props<O> = {
    onSelect: (channel: ValueType<O>) => void;
    currentBodyHeight: number;
    value?: O;
}

function ForwardPostChannelSelect({onSelect, value, currentBodyHeight}: Props<ChannelOption>) {
    const {formatMessage} = useIntl();
    const {current: provider} = useRef<SwitchChannelProvider>(new SwitchChannelProvider());

    useEffect(() => {
        provider.forceDispatch = true;
    }, [provider]);

    const baseStyles = getBaseStyles(currentBodyHeight);

    const isValidChannelType = (channel: Channel) => validChannelTypes.includes(channel.type) && !channel.delete_at;

    const getDefaultResults = () => {
        let options: GroupedOption[] = [];

        const handleDefaultResults = (res: ProviderResult) => {
            options = [
                {
                    label: formatMessage({id: 'suggestion.mention.recent.channels', defaultMessage: 'Recent'}),
                    options: res.items.filter((item) => item?.channel && isValidChannelType(item.channel) && !item.deactivated).map((item) => {
                        const {channel} = item;
                        return makeSelectedChannelOption(channel);
                    }),
                },
            ];
        };

        provider.fetchAndFormatRecentlyViewedChannels(handleDefaultResults);
        return options;
    };

    const defaultOptions = useRef<GroupedOption[]>(getDefaultResults());

    const handleInputChange = (inputValue: string) => {
        return new Promise<ChannelOption[]>((resolve) => {
            let callCount = inputValue ? 0 : 1;
            const options: ChannelOption[] = [];

            /** we optimistically assume this callback gets invoked twice when we have a value to be passed into the provider.
             * If, for some reason, we decide to change the behavior of the provider we should change the handling here as well.
             * A comment will be added to the repective section of the provider as well.
             *
             * @see {@link components/suggestion/switch_channel_provider.jsx}
             */
            const handleResults = async (res: ProviderResult) => {
                callCount++;
                await res.items.filter((item) => item?.channel && isValidChannelType(item.channel) && !item.deactivated).forEach((item) => {
                    const {channel} = item;

                    if (options.findIndex((option) => option.value === channel.id) === -1) {
                        options.push(makeSelectedChannelOption(channel));
                    }
                });

                if (callCount === 2) {
                    resolve(options);
                }
            };

            provider.handlePretextChanged(inputValue, handleResults);
        });
    };

    return (
        <AsyncSelect
            value={value}
            onChange={onSelect}
            loadOptions={handleInputChange}
            defaultOptions={defaultOptions.current}
            components={{DropdownIndicator, Option, SingleValue}}
            styles={baseStyles}
            legend='Forward to'
            placeholder='Select channel or people'
            className='forward-post__select'
            data-testid='forward-post-select'
        />
    );
}

export default ForwardPostChannelSelect;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useRef} from 'react';
import {useIntl} from 'react-intl';

import {useSelector} from 'react-redux';

import {getConfig} from 'mattermost-redux/selectors/entities/general';

import Textbox, {TextboxClass, TextboxElement} from 'components/textbox';

import Constants from 'utils/constants';
import {applyMarkdown, ApplyMarkdownOptions} from 'utils/markdown/apply_markdown';
import * as Utils from 'utils/utils';
import {GlobalState} from 'types/store';

const {KeyCodes} = Constants;

type Props = {
    channelId: string;
    canForwardPost: boolean;
    comment: string;
    permaLinkLength: number;
    onSubmit: () => void;
    onChange: (comment: string) => void;
    onError: (error: React.ReactNode) => void;
    onHeightChange: (width: number, height: number) => void;
}

const ForwardPostCommentInput = ({channelId, canForwardPost, comment, permaLinkLength, onChange, onError, onSubmit, onHeightChange}: Props) => {
    const {formatMessage} = useIntl();

    const config = useSelector((state: GlobalState) => getConfig(state));

    const textboxRef = useRef<TextboxClass>(null);

    const maxPostSize =
        (parseInt(config.MaxPostSize || '', 10) ||
        Constants.DEFAULT_CHARACTER_LIMIT) - permaLinkLength - 1;
    const enableEmojiPicker = config.EnableEmojiPicker === 'true';

    // we do not allow sending the forwarding when hitting enter
    const postMsgKeyPress = () => {};

    const handleSelect = (e: React.SyntheticEvent<Element, Event>) => {
        Utils.adjustSelection(
            textboxRef?.current?.getInputBox(),
            e as React.KeyboardEvent<HTMLInputElement>,
        );
    };

    const handleChange = useCallback(
        (e: React.ChangeEvent<TextboxElement>) => {
            const message = e.target.value;

            onChange(message);
        },
        [onChange],
    );

    const setCommentAsync = async (message: string) => {
        await onChange(message);
    };

    const applyMarkdownMode = (params: ApplyMarkdownOptions) => {
        const res = applyMarkdown(params);

        setCommentAsync(res.message).then(() => {
            const textbox = textboxRef.current?.getInputBox();
            Utils.setSelectionRange(
                textbox,
                res.selectionStart,
                res.selectionEnd,
            );
        });
    };

    const handleKeyDown = (e: React.KeyboardEvent<TextboxElement>) => {
        const ctrlKeyCombo = Utils.cmdOrCtrlPressed(e) && !e.altKey && !e.shiftKey;
        const ctrlAltCombo = Utils.cmdOrCtrlPressed(e, true) && e.altKey;
        const ctrlShiftCombo = Utils.cmdOrCtrlPressed(e, true) && e.shiftKey;
        const markdownLinkKey = Utils.isKeyPressed(e, KeyCodes.K);
        const ctrlOrMetaKeyPressed = e.ctrlKey || e.metaKey;
        const ctrlEnterKeyCombo =
            Utils.isKeyPressed(e, KeyCodes.ENTER) && ctrlOrMetaKeyPressed;

        const {selectionStart, selectionEnd, value} =
            e.target as TextboxElement;

        // listen for line break key combo and insert new line character
        if (Utils.isUnhandledLineBreakKeyCombo(e)) {
            onChange(Utils.insertLineBreakFromKeyEvent(e));
        } else if (ctrlAltCombo && markdownLinkKey) {
            applyMarkdownMode({
                markdownMode: 'link',
                selectionStart,
                selectionEnd,
                message: value,
            });
        } else if (ctrlKeyCombo && Utils.isKeyPressed(e, KeyCodes.B)) {
            applyMarkdownMode({
                markdownMode: 'bold',
                selectionStart,
                selectionEnd,
                message: value,
            });
        } else if (ctrlKeyCombo && Utils.isKeyPressed(e, KeyCodes.I)) {
            applyMarkdownMode({
                markdownMode: 'italic',
                selectionStart,
                selectionEnd,
                message: value,
            });
        } else if (ctrlShiftCombo && Utils.isKeyPressed(e, KeyCodes.X)) {
            applyMarkdownMode({
                markdownMode: 'strike',
                selectionStart,
                selectionEnd,
                message: value,
            });
        } else if (ctrlShiftCombo && Utils.isKeyPressed(e, KeyCodes.E)) {
            e.stopPropagation();
            e.preventDefault();
        } else if (ctrlEnterKeyCombo && canForwardPost) {
            onSubmit();
        }
    };

    const createMessage = formatMessage({
        id: 'forward_post_modal.comment.placeholder',
        defaultMessage: 'Add a comment (optional)',
    });

    return (
        <Textbox
            onChange={handleChange}
            onKeyPress={postMsgKeyPress}
            onKeyDown={handleKeyDown}
            onSelect={handleSelect}
            onHeightChange={onHeightChange}
            handlePostError={onError}
            value={comment}
            emojiEnabled={enableEmojiPicker}
            createMessage={createMessage}
            channelId={channelId}
            id={'forward_post_textbox'}
            ref={textboxRef}
            characterLimit={maxPostSize}
            useChannelMentions={false}
            supportsCommands={false}
            suggestionListPosition='bottom'
            alignWithTextbox={true}
        />
    );
};

export default ForwardPostCommentInput;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useRef, useState} from 'react';

import {FormattedList, FormattedMessage, useIntl} from 'react-intl';

import {useSelector} from 'react-redux';

import {ValueType} from 'react-select';

import classNames from 'classnames';

import {makeGetChannel} from 'mattermost-redux/selectors/entities/channels';
import {getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';

import NotificationBox from 'components/notification_box';

import {GlobalState} from 'types/store';

import {haveIChannelPermission} from 'mattermost-redux/selectors/entities/roles';
import {General, Permissions} from 'mattermost-redux/constants';

import Constants from 'utils/constants';

import PostMessagePreview from 'components/post_view/post_message_preview';
import GenericModal from 'components/generic_modal';

import {PostPreviewMetadata} from '@mattermost/types/posts';
import {getSiteURL} from '../../utils/url';
import * as Utils from '../../utils/utils';

import ForwardPostChannelSelect, {ChannelOption, makeSelectedChannelOption} from './forward_post_channel_select';
import ForwardPostCommentInput from './forward_post_comment_input';

import {ActionProps, OwnProps, PropsFromRedux} from './index';

import './forward_post_modal.scss';

export type Props = PropsFromRedux & OwnProps & { actions: ActionProps };

const noop = () => {};

const ForwardPostModal = ({onExited, post, actions}: Props) => {
    const {formatMessage} = useIntl();

    const getChannel = makeGetChannel();

    const channel = useSelector((state: GlobalState) => getChannel(state, {id: post.channel_id}));
    const currentTeam = useSelector(getCurrentTeam);

    const relativePermaLink = useSelector((state: GlobalState) => Utils.getPermalinkURL(state, currentTeam.id, post.id));
    const permaLink = `${getSiteURL()}${relativePermaLink}`;

    const isPrivateConversation = channel.type !== Constants.OPEN_CHANNEL;

    const [comment, setComment] = useState('');
    const [bodyHeight, setBodyHeight] = useState<number>(0);
    const [hasError, setHasError] = useState<boolean>(false);
    const [postError, setPostError] = useState<React.ReactNode>(null);
    const [selectedChannel, setSelectedChannel] = useState<ChannelOption>();

    const bodyRef = useRef<HTMLDivElement>();

    const measuredRef = useCallback((node) => {
        if (node !== null) {
            bodyRef.current = node;
            setBodyHeight(node.getBoundingClientRect().height);
        }
    }, []);

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const onHeightChange = (width: number, height: number) => {
        if (bodyRef.current) {
            setBodyHeight(bodyRef.current.getBoundingClientRect().height);
        }
    };

    const selectedChannelId = selectedChannel?.details?.id || '';

    const canPostInSelectedChannel = useSelector(
        (state: GlobalState) => {
            const channelId = isPrivateConversation ? channel.id : selectedChannelId;
            const isDMChannel = selectedChannel?.details?.type === Constants.DM_CHANNEL;
            const teamId = isPrivateConversation ? currentTeam.id : selectedChannel?.details?.team_id;

            const hasChannelPermission = haveIChannelPermission(
                state,
                teamId || currentTeam.id,
                channelId,
                Permissions.CREATE_POST,
            );

            return Boolean(channelId) && (hasChannelPermission || isDMChannel);
        },
    );

    const canForwardPost = (isPrivateConversation || canPostInSelectedChannel) && !postError;

    const onHide = useCallback(() => {
        onExited?.();
    }, [onExited]);

    const handleChannelSelect = useCallback(
        (channel: ValueType<ChannelOption>) => {
            if (Array.isArray(channel)) {
                setSelectedChannel(channel[0]);
            }
            setSelectedChannel(channel as ChannelOption);
        },
        [],
    );

    // since the original post has a click handler specified we should prevent any action here
    const preventActionOnPreview = (e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();
    };

    const messagePreviewTitle = formatMessage({
        id: 'forward_post_modal.preview.title',
        defaultMessage: 'Message preview',
    });

    const previewMetaData: PostPreviewMetadata = {
        post,
        post_id: post.id,
        team_name: currentTeam.name,
        channel_display_name: channel.display_name,
        channel_type: channel.type,
        channel_id: channel.id,
    };

    let notification;
    if (isPrivateConversation) {
        let notificationText;
        if (channel.type === General.PRIVATE_CHANNEL) {
            const channelName = `~${channel.display_name}`;
            notificationText = (
                <FormattedMessage
                    id='forward_post_modal.notification.private_channel'
                    defaultMessage='This message is from a private channel and can only be shared with <strong>{channelName}</strong>'
                    values={{
                        channelName,
                        strong: (x: React.ReactNode) => <strong>{x}</strong>,
                    }}
                />
            );
        } else {
            const allParticipants = channel.display_name.split(', ');
            const participants = allParticipants.map((participant) => <strong key={participant}>{participant}</strong>);

            notificationText = (
                <FormattedMessage
                    id='forward_post_modal.notification.dm_or_gm'
                    defaultMessage='This message is from a private conversation and can only be shared with {participants}'
                    values={{
                        participants: <FormattedList value={participants}/>,
                        strong: (x: React.ReactNode) => <strong>{x}</strong>,
                    }}
                />
            );
        }

        notification = (
            <NotificationBox
                variant={'info'}
                text={notificationText}
                id={'forward_post'}
            />
        );
    }

    const handlePostError = (error: React.ReactNode) => {
        setPostError(error);
        setHasError(true);
        setTimeout(() => setHasError(false), Constants.ANIMATION_TIMEOUT);
    };

    const handleSubmit = () => {
        if (postError) {
            return Promise.resolve();
        }

        const channelToForward = isPrivateConversation ? makeSelectedChannelOption(channel) : selectedChannel;

        if (!channelToForward) {
            return Promise.resolve();
        }

        const {type, userId} = channelToForward.details;

        return Promise.resolve().then(() => {
            if (type === Constants.DM_CHANNEL && userId) {
                return actions.openDirectChannelToUserId(userId);
            }
            return {data: false};
        }).then(({data}) => {
            if (data) {
                channelToForward.details.id = data.id;
            }

            return actions.forwardPost(
                post,
                channelToForward.details,
                comment,
            );
        }).then(() => {
            if (type === Constants.MENTION_MORE_CHANNELS && type === Constants.OPEN_CHANNEL) {
                return actions.joinChannelById(channelToForward.details.id);
            }
            return {data: false};
        }).then(() => {
            // only switch channels when we are not in a private conversation
            if (!isPrivateConversation) {
                return actions.switchToChannel(channelToForward.details);
            }
            return {data: false};
        }).then(() => {
            onHide();
        }).catch((result) => {
            if (result?.error) {
                handlePostError(result.error);
            }
        });
    };

    const postPreviewFooterMessage = formatMessage({
        id: 'forward_post_modal.preview.footer_message',
        defaultMessage: 'Originally posted in ~{channelName}',
    },
    {
        channel: channel.display_name,
    });

    return (
        <GenericModal
            className='a11y__modal forward-post'
            id='forward-post-modal'
            show={true}
            enforceFocus={false}
            autoCloseOnConfirmButton={false}
            compassDesign={true}
            modalHeaderText={formatMessage({
                id: 'forward_post_modal.title',
                defaultMessage: 'Forward message',
            })}
            confirmButtonText={formatMessage({
                id: 'forward_post_modal.button.forward',
                defaultMessage: 'Forward',
            })}
            cancelButtonText={formatMessage({
                id: 'forward_post_modal.button.cancel',
                defaultMessage: 'Cancel',
            })}
            isConfirmDisabled={!canForwardPost}
            handleConfirm={handleSubmit}
            handleCancel={onHide}
            onExited={onHide}
        >
            <div
                className={'forward-post__body'}
                ref={measuredRef}
            >
                {isPrivateConversation ? (
                    notification
                ) : (
                    <ForwardPostChannelSelect
                        onSelect={handleChannelSelect}
                        value={selectedChannel}
                        currentBodyHeight={bodyHeight}
                    />
                )}
                <ForwardPostCommentInput
                    canForwardPost={canForwardPost}
                    channelId={selectedChannelId}
                    comment={comment}
                    onChange={setComment}
                    onError={handlePostError}
                    onSubmit={handleSubmit}
                    onHeightChange={onHeightChange}
                    permaLinkLength={permaLink.length}
                />
                <div className={'forward-post__post-preview'}>
                    <span className={'forward-post__post-preview--title'}>
                        {messagePreviewTitle}
                    </span>
                    <div
                        className='post forward-post__post-preview--override'
                        onClick={preventActionOnPreview}
                    >
                        <PostMessagePreview
                            metadata={previewMetaData}
                            previewPost={previewMetaData.post}
                            handleFileDropdownOpened={noop}
                            preventClickAction={true}
                            previewFooterMessage={postPreviewFooterMessage}
                        />
                    </div>
                    {postError && (
                        <label
                            className={classNames('post-error', {
                                'animation--highlight': hasError,
                            })}
                        >
                            {postError}
                        </label>
                    )}
                </div>
            </div>
        </GenericModal>
    );
};

export default ForwardPostModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect, ConnectedProps} from 'react-redux';

import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {Channel} from '@mattermost/types/channels';
import {ActionResult} from 'mattermost-redux/types/actions';

import {Post} from '@mattermost/types/posts';

import {joinChannelById, switchToChannel} from 'actions/views/channel';
import {forwardPost} from 'actions/views/posts';
import {openDirectChannelToUserId} from 'actions/channel_actions';

import ForwardPostModal from './forward_post_modal';

export type PropsFromRedux = ConnectedProps<typeof connector>;

export type ActionProps = {

    // join the selected channel when necessary
    joinChannelById: (channelId: string) => Promise<ActionResult>;

    // switch to the selected channel
    switchToChannel: (channel: Channel) => Promise<ActionResult>;

    // switch to the selected channel
    openDirectChannelToUserId: (userId: string) => Promise<ActionResult>;

    // action called to forward the post with an optional comment
    forwardPost: (post: Post, channelId: Channel, message?: string) => Promise<ActionResult>;
}

export type OwnProps = {

    // The function called immediately after the modal is hidden
    onExited?: () => void;

    // the post that is going to be forwarded
    post: Post;
};

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<any>, ActionProps>({
            joinChannelById,
            switchToChannel,
            forwardPost,
            openDirectChannelToUserId,
        }, dispatch),
    };
}
const connector = connect(null, mapDispatchToProps);

export default connector(ForwardPostModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {trackEvent} from 'actions/telemetry_actions';

import {EventTypes, TELEMETRY_CATEGORIES} from 'utils/constants';

export type ChangeEvent = KeyboardEvent | MouseEvent;

export const trackDotMenuEvent = (e: ChangeEvent, suffix: string): void => {
    if (e.type === EventTypes.CLICK) {
        trackEvent(TELEMETRY_CATEGORIES.POST_INFO_MORE, EventTypes.CLICK + '_' + suffix);
    } else {
        trackEvent(TELEMETRY_CATEGORIES.POST_INFO_MORE, EventTypes.SHORTCUT + '_ ' + suffix);
    }
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import classNames from 'classnames';
import {FormattedMessage, injectIntl, IntlShape} from 'react-intl';

import Permissions from 'mattermost-redux/constants/permissions';
import {Post} from '@mattermost/types/posts';
import {UserThread} from '@mattermost/types/threads';

import {Locations, ModalIdentifiers, Constants, TELEMETRY_LABELS, Preferences} from 'utils/constants';
import DeletePostModal from 'components/delete_post_modal';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import DelayedAction from 'utils/delayed_action';
import * as PostUtils from 'utils/post_utils';
import * as Utils from 'utils/utils';
import ChannelPermissionGate from 'components/permissions_gates/channel_permission_gate';
import Menu from 'components/widgets/menu/menu';
import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import DotsHorizontalIcon from 'components/widgets/icons/dots_horizontal';
import {ModalData} from 'types/actions';
import {PluginComponent} from 'types/store/plugins';
import ForwardPostModal from '../forward_post_modal';
import Badge from '../widgets/badges/badge';

import {ChangeEvent, trackDotMenuEvent} from './utils';
import './dot_menu.scss';

type ShortcutKeyProps = {
    shortcutKey: string;
};

const ShortcutKey = ({shortcutKey: shortcut}: ShortcutKeyProps) => (
    <span className={'MenuItem__opacity MenuItem__right-decorator'}>
        {shortcut}
    </span>
);

const MENU_BOTTOM_MARGIN = 80;

type Props = {
    intl: IntlShape;
    post: Post;
    teamId: string;
    location?: 'CENTER' | 'RHS_ROOT' | 'RHS_COMMENT' | 'SEARCH' | string;
    isFlagged?: boolean;
    handleCommentClick?: React.EventHandler<any>;
    handleDropdownOpened: (open: boolean) => void;
    handleAddReactionClick?: () => void;
    isMenuOpen?: boolean;
    isReadOnly?: boolean;
    isLicensed?: boolean; // TechDebt: Made non-mandatory while converting to typescript
    postEditTimeLimit?: string; // TechDebt: Made non-mandatory while converting to typescript
    enableEmojiPicker?: boolean; // TechDebt: Made non-mandatory while converting to typescript
    channelIsArchived?: boolean; // TechDebt: Made non-mandatory while converting to typescript
    currentTeamUrl?: string; // TechDebt: Made non-mandatory while converting to typescript
    teamUrl?: string; // TechDebt: Made non-mandatory while converting to typescript
    isMobileView: boolean;
    showForwardPostNewLabel: boolean;

    /**
     * Components for overriding provided by plugins
     */
    components: {
        [componentName: string]: PluginComponent[];
    };

    actions: {

        /**
         * Function flag the post
         */
        flagPost: (postId: string) => void;

        /**
         * Function to unflag the post
         */
        unflagPost: (postId: string) => void;

        /**
         * Function to set the editing post
         */
        setEditingPost: (postId?: string, refocusId?: string, title?: string, isRHS?: boolean) => void;

        /**
         * Function to pin the post
         */
        pinPost: (postId: string) => void;

        /**
         * Function to unpin the post
         */
        unpinPost: (postId: string) => void;

        /**
         * Function to open a modal
         */
        openModal: <P>(modalData: ModalData<P>) => void;

        /**
         * Function to set the unread mark at given post
         */
        markPostAsUnread: (post: Post, location?: 'CENTER' | 'RHS_ROOT' | 'RHS_COMMENT' | string) => void;

        /**
         * Function to set the thread as followed/unfollowed
         */
        setThreadFollow: (userId: string, teamId: string, threadId: string, newState: boolean) => void;

        /**
         * Function to set a global storage item on the store
         */
        setGlobalItem: (name: string, value: any) => void;

    }; // TechDebt: Made non-mandatory while converting to typescript

    canEdit: boolean;
    canDelete: boolean;
    userId: string;
    threadId: UserThread['id'];
    isCollapsedThreadsEnabled: boolean;
    isFollowingThread?: boolean;
    isMentionedInRootPost?: boolean;
    threadReplyCount?: number;
}

type State = {
    openUp: boolean;
    canEdit: boolean;
    canDelete: boolean;
}

export class DotMenuClass extends React.PureComponent<Props, State> {
    public static defaultProps: Partial<Props> = {
        isFlagged: false,
        isReadOnly: false,
        location: Locations.CENTER,
    }
    private editDisableAction: DelayedAction;
    private buttonRef: React.RefObject<HTMLButtonElement>;
    private canPostBeForwarded: boolean;

    constructor(props: Props) {
        super(props);

        this.editDisableAction = new DelayedAction(this.handleEditDisable);

        this.state = {
            openUp: false,
            canEdit: props.canEdit && !props.isReadOnly,
            canDelete: props.canDelete && !props.isReadOnly,
        };

        this.buttonRef = React.createRef<HTMLButtonElement>();

        this.canPostBeForwarded = false;
    }

    static getDerivedStateFromProps(props: Props) {
        const state: Partial<State> = {
            canEdit: props.canEdit && !props.isReadOnly,
            canDelete: props.canDelete && !props.isReadOnly,
        };
        return state;
    }

    disableCanEditPostByTime(): void {
        const {post, isLicensed} = this.props;
        const {canEdit} = this.state;

        const postEditTimeLimit = this.props.postEditTimeLimit || Constants.UNSET_POST_EDIT_TIME_LIMIT;

        if (canEdit && isLicensed) {
            if (postEditTimeLimit !== String(Constants.UNSET_POST_EDIT_TIME_LIMIT)) {
                const milliseconds = 1000;
                const timeLeft = (post.create_at + (Number(postEditTimeLimit) * milliseconds)) - Utils.getTimestamp();
                if (timeLeft > 0) {
                    this.editDisableAction.fireAfter(timeLeft + milliseconds);
                }
            }
        }
    }

    componentDidMount(): void {
        this.disableCanEditPostByTime();
    }

    componentDidUpdate(prevProps: Props): void {
        if (!prevProps.isMenuOpen && this.props.isMenuOpen) {
            window.addEventListener('keydown', this.onShortcutKeyDown);
        }

        if (prevProps.isMenuOpen && !this.props.isMenuOpen) {
            window.removeEventListener('keydown', this.onShortcutKeyDown);
        }
    }

    componentWillUnmount(): void {
        window.removeEventListener('keydown', this.onShortcutKeyDown);
        this.editDisableAction.cancel();
    }

    handleEditDisable = (): void => {
        this.setState({canEdit: false});
    }

    handleFlagMenuItemActivated = (e: ChangeEvent): void => {
        if (this.props.isFlagged) {
            trackDotMenuEvent(e, TELEMETRY_LABELS.UNSAVE);
            this.props.actions.unflagPost(this.props.post.id);
        } else {
            trackDotMenuEvent(e, TELEMETRY_LABELS.SAVE);
            this.props.actions.flagPost(this.props.post.id);
        }
    }

    // listen to clicks/taps on add reaction menu item and pass to parent handler
    handleAddReactionMenuItemActivated = (e: React.MouseEvent): void => {
        e.preventDefault();

        // to be safe, make sure the handler function has been defined
        if (this.props.handleAddReactionClick) {
            this.props.handleAddReactionClick();
        }
    }

    copyLink = (e: ChangeEvent) => {
        trackDotMenuEvent(e, TELEMETRY_LABELS.COPY_LINK);
        Utils.copyToClipboard(`${this.props.teamUrl}/pl/${this.props.post.id}`);
    }

    copyText = (e: ChangeEvent) => {
        trackDotMenuEvent(e, TELEMETRY_LABELS.COPY_TEXT);
        Utils.copyToClipboard(this.props.post.message);
    }

    handlePinMenuItemActivated = (e: ChangeEvent): void => {
        if (this.props.post.is_pinned) {
            trackDotMenuEvent(e, TELEMETRY_LABELS.UNPIN);
            this.props.actions.unpinPost(this.props.post.id);
        } else {
            trackDotMenuEvent(e, TELEMETRY_LABELS.PIN);
            this.props.actions.pinPost(this.props.post.id);
        }
    }

    handleMarkPostAsUnread = (e: ChangeEvent): void => {
        e.preventDefault();
        trackDotMenuEvent(e, TELEMETRY_LABELS.UNREAD);
        this.props.actions.markPostAsUnread(this.props.post, this.props.location);
    }

    handleDeleteMenuItemActivated = (e: ChangeEvent): void => {
        e.preventDefault();

        trackDotMenuEvent(e, TELEMETRY_LABELS.DELETE);
        const deletePostModalData = {
            modalId: ModalIdentifiers.DELETE_POST,
            dialogType: DeletePostModal,
            dialogProps: {
                post: this.props.post,
                isRHS: this.props.location === Locations.RHS_ROOT || this.props.location === Locations.RHS_COMMENT,
            },
        };

        this.props.actions.openModal(deletePostModalData);
    }

    handleForwardMenuItemActivated = (e: ChangeEvent): void => {
        if (!this.canPostBeForwarded) {
            // adding this early return since only hiding the Item from the menu is not enough,
            // since a user can always use the Shortcuts to activate the function as well
            return;
        }

        e.preventDefault();

        trackDotMenuEvent(e, TELEMETRY_LABELS.FORWARD);
        const forwardPostModalData = {
            modalId: ModalIdentifiers.FORWARD_POST_MODAL,
            dialogType: ForwardPostModal,
            dialogProps: {
                post: this.props.post,
            },
        };

        if (this.props.showForwardPostNewLabel) {
            this.props.actions.setGlobalItem(Preferences.FORWARD_POST_VIEWED, false);
        }
        this.props.actions.openModal(forwardPostModalData);
    }

    handleEditMenuItemActivated = (e: ChangeEvent): void => {
        trackDotMenuEvent(e, TELEMETRY_LABELS.EDIT);
        this.props.handleDropdownOpened?.(false);
        this.props.actions.setEditingPost(
            this.props.post.id,
            this.props.location === Locations.CENTER ? 'post_textbox' : 'reply_textbox',
            this.props.post.root_id ? Utils.localizeMessage('rhs_comment.comment', 'Comment') : Utils.localizeMessage('create_post.post', 'Post'),
            this.props.location === Locations.RHS_ROOT || this.props.location === Locations.RHS_COMMENT || this.props.location === Locations.SEARCH,
        );
    }

    handleSetThreadFollow = (e: ChangeEvent) => {
        const {actions, teamId, threadId, userId, isFollowingThread, isMentionedInRootPost} = this.props;
        let followingThread: boolean;

        // This is required as post with mention doesn't have isFollowingThread property set to true but user with mention is following, so we will get null as value kind of hack for this.

        if (isFollowingThread === null) {
            followingThread = !isMentionedInRootPost;
        } else {
            followingThread = !isFollowingThread;
        }

        if (followingThread) {
            trackDotMenuEvent(e, TELEMETRY_LABELS.FOLLOW);
        } else {
            trackDotMenuEvent(e, TELEMETRY_LABELS.UNFOLLOW);
        }
        actions.setThreadFollow(
            userId,
            teamId,
            threadId,
            followingThread,
        );
    }

    handleCommentClick = (e: ChangeEvent) => {
        trackDotMenuEvent(e, TELEMETRY_LABELS.REPLY);
        this.props.handleCommentClick?.(e);
    }

    tooltip = (
        <Tooltip
            id='dotmenu-icon-tooltip'
            className='hidden-xs'
        >
            <FormattedMessage
                id='post_info.dot_menu.tooltip.more_actions'
                defaultMessage='More'
            />
        </Tooltip>
    )

    renderDivider = (suffix: string): React.ReactNode => {
        return (
            <li
                id={`divider_post_${this.props.post.id}_${suffix}`}
                className='MenuItem__divider'
                role='menuitem'
            />
        );
    }

    isKeyboardEvent = (e: KeyboardEvent): any => {
        return (e).getModifierState !== undefined;
    }

    onShortcutKeyDown = (e: KeyboardEvent): void => {
        e.preventDefault();
        if (!this.isKeyboardEvent(e)) {
            return;
        }

        const isShiftKeyPressed = e.shiftKey;

        switch (true) {
        case Utils.isKeyPressed(e, Constants.KeyCodes.R):
            this.handleCommentClick(e);
            this.props.handleDropdownOpened(false);
            break;

        // edit post
        case Utils.isKeyPressed(e, Constants.KeyCodes.E):
            this.handleEditMenuItemActivated(e);
            this.props.handleDropdownOpened(false);
            break;

        // follow thread
        case Utils.isKeyPressed(e, Constants.KeyCodes.F) && !isShiftKeyPressed:
            this.handleSetThreadFollow(e);
            this.props.handleDropdownOpened(false);
            break;

        // forward post
        case Utils.isKeyPressed(e, Constants.KeyCodes.F) && isShiftKeyPressed:
            this.handleForwardMenuItemActivated(e);
            this.props.handleDropdownOpened(false);
            break;

        // copy link
        case Utils.isKeyPressed(e, Constants.KeyCodes.K):
            this.copyLink(e);
            this.props.handleDropdownOpened(false);
            break;

        // copy text
        case Utils.isKeyPressed(e, Constants.KeyCodes.C):
            this.copyText(e);
            this.props.handleDropdownOpened(false);
            break;

        // delete post
        case Utils.isKeyPressed(e, Constants.KeyCodes.DELETE):
            this.handleDeleteMenuItemActivated(e);
            this.props.handleDropdownOpened(false);
            break;

        // pin / unpin
        case Utils.isKeyPressed(e, Constants.KeyCodes.P):
            this.handlePinMenuItemActivated(e);
            this.props.handleDropdownOpened(false);
            break;

        // save / unsave
        case Utils.isKeyPressed(e, Constants.KeyCodes.S):
            this.handleFlagMenuItemActivated(e);
            this.props.handleDropdownOpened(false);
            break;

        // mark as unread
        case Utils.isKeyPressed(e, Constants.KeyCodes.U):
            this.handleMarkPostAsUnread(e);
            this.props.handleDropdownOpened(false);
            break;
        }
    }

    handleDropdownOpened = (open: boolean) => {
        this.props.handleDropdownOpened?.(open);

        if (!open) {
            return;
        }

        const buttonRect = this.buttonRef.current?.getBoundingClientRect();
        let y;
        if (typeof buttonRect?.y === 'undefined') {
            y = typeof buttonRect?.top == 'undefined' ? 0 : buttonRect?.top;
        } else {
            y = buttonRect?.y;
        }
        const windowHeight = window.innerHeight;

        const totalSpace = windowHeight - MENU_BOTTOM_MARGIN;
        const spaceOnTop = y - Constants.CHANNEL_HEADER_HEIGHT;
        const spaceOnBottom = (totalSpace - (spaceOnTop + Constants.POST_AREA_HEIGHT));

        this.setState({
            openUp: (spaceOnTop > spaceOnBottom),
        });
    }

    render(): JSX.Element {
        const isFollowingThread = this.props.isFollowingThread ?? this.props.isMentionedInRootPost;
        const isMobile = this.props.isMobileView;
        const isSystemMessage = PostUtils.isSystemMessage(this.props.post);
        const deleteShortcutText = (
            <span className='MenuItem__opacity'>
                {'delete'}
            </span>
        );

        this.canPostBeForwarded = !(isSystemMessage);

        const forwardPostItemText = (
            <span className={'title-with-new-badge'}>
                <FormattedMessage
                    id='forward_post_button.label'
                    defaultMessage='Forward'
                />
                {this.props.showForwardPostNewLabel && (
                    <Badge variant='success'>
                        <FormattedMessage
                            id='badge.label.new'
                            defaultMessage='NEW'
                        />
                    </Badge>
                )}
            </span>
        );

        return (
            <MenuWrapper
                open={this.props.isMenuOpen}
                onToggle={this.handleDropdownOpened}
                className={'dropdown-menu__dotmenu'}
            >
                <OverlayTrigger
                    className='hidden-xs'
                    delayShow={500}
                    placement='top'
                    overlay={this.tooltip}
                    rootClose={true}
                >
                    <button
                        ref={this.buttonRef}
                        id={`${this.props.location}_button_${this.props.post.id}`}
                        aria-label={Utils.localizeMessage('post_info.dot_menu.tooltip.more_actions', 'Actions').toLowerCase()}
                        className={classNames('post-menu__item', {
                            'post-menu__item--active': this.props.isMenuOpen,
                        })}
                        type='button'
                        aria-expanded='false'
                    >
                        <DotsHorizontalIcon className={'icon icon--small'}/>
                    </button>
                </OverlayTrigger>
                <Menu
                    className={'Menu__content dropdown-menu'}
                    id={`${this.props.location}_dropdown_${this.props.post.id}`}
                    openLeft={true}
                    openUp={this.state.openUp}
                    ariaLabel={Utils.localizeMessage('post_info.menuAriaLabel', 'Post extra options')}
                >
                    <Menu.ItemAction
                        className={'MenuItem'}
                        show={!isSystemMessage && this.props.location === Locations.CENTER}
                        text={Utils.localizeMessage('post_info.reply', 'Reply')}
                        icon={Utils.getMenuItemIcon('icon-reply-outline')}
                        rightDecorator={<ShortcutKey shortcutKey='R'/>}
                        onClick={this.handleCommentClick}
                    />
                    <Menu.ItemAction
                        className={'MenuItem'}
                        show={this.canPostBeForwarded}
                        text={forwardPostItemText}
                        icon={Utils.getMenuItemIcon('icon-arrow-right-bold-outline')}
                        rightDecorator={<ShortcutKey shortcutKey='Shift + F'/>}
                        onClick={this.handleForwardMenuItemActivated}
                    />
                    <ChannelPermissionGate
                        channelId={this.props.post.channel_id}
                        teamId={this.props.teamId}
                        permissions={[Permissions.ADD_REACTION]}
                    >
                        <Menu.ItemAction
                            show={isMobile && !isSystemMessage && !this.props.isReadOnly && this.props.enableEmojiPicker}
                            text={Utils.localizeMessage('rhs_root.mobile.add_reaction', 'Add Reaction')}
                            icon={Utils.getMenuItemIcon('icon-emoticon-plus-outline')}
                            onClick={this.handleAddReactionMenuItemActivated}
                        />
                    </ChannelPermissionGate>
                    <Menu.ItemAction
                        id={`follow_post_thread_${this.props.post.id}`}
                        rightDecorator={<ShortcutKey shortcutKey='F'/>}
                        onClick={this.handleSetThreadFollow}
                        show={(
                            !isSystemMessage &&
                            this.props.isCollapsedThreadsEnabled &&
                                (
                                    this.props.location === Locations.CENTER ||
                                    this.props.location === Locations.RHS_ROOT ||
                                    this.props.location === Locations.RHS_COMMENT
                                )
                        )}
                        {...isFollowingThread ? {
                            icon: Utils.getMenuItemIcon('icon-message-minus-outline'),
                            text: this.props.threadReplyCount ? Utils.localizeMessage('threading.threadMenu.unfollow', 'Unfollow thread') : Utils.localizeMessage('threading.threadMenu.unfollowMessage', 'Unfollow message'),
                        } : {
                            icon: Utils.getMenuItemIcon('icon-message-check-outline'),
                            text: this.props.threadReplyCount ? Utils.localizeMessage('threading.threadMenu.follow', 'Follow thread') : Utils.localizeMessage('threading.threadMenu.followMessage', 'Follow message'),
                        }}
                    />
                    <Menu.ItemAction
                        id={`unread_post_${this.props.post.id}`}
                        show={!isSystemMessage && !this.props.channelIsArchived && this.props.location !== Locations.SEARCH}
                        text={Utils.localizeMessage('post_info.unread', 'Mark as Unread')}
                        icon={Utils.getMenuItemIcon('icon-mark-as-unread')}
                        rightDecorator={<ShortcutKey shortcutKey='U'/>}
                        onClick={this.handleMarkPostAsUnread}
                    />
                    <Menu.ItemAction
                        show={!isSystemMessage}
                        text={this.props.isFlagged ? Utils.localizeMessage('rhs_root.mobile.unflag', 'Remove from Saved') : Utils.localizeMessage('rhs_root.mobile.flag', 'Save')}
                        icon={this.props.isFlagged ? Utils.getMenuItemIcon('icon-bookmark') : Utils.getMenuItemIcon('icon-bookmark-outline')}
                        rightDecorator={<ShortcutKey shortcutKey='S'/>}
                        onClick={this.handleFlagMenuItemActivated}
                    />
                    <Menu.ItemAction
                        id={`unpin_post_${this.props.post.id}`}
                        show={!isSystemMessage && !this.props.isReadOnly && this.props.post.is_pinned}
                        text={Utils.localizeMessage('post_info.unpin', 'Unpin')}
                        icon={Utils.getMenuItemIcon('icon-pin')}
                        rightDecorator={<ShortcutKey shortcutKey='P'/>}
                        onClick={this.handlePinMenuItemActivated}
                    />
                    <Menu.ItemAction
                        id={`pin_post_${this.props.post.id}`}
                        show={!isSystemMessage && !this.props.isReadOnly && !this.props.post.is_pinned}
                        text={Utils.localizeMessage('post_info.pin', 'Pin')}
                        icon={Utils.getMenuItemIcon('icon-pin-outline')}
                        rightDecorator={<ShortcutKey shortcutKey='P'/>}
                        onClick={this.handlePinMenuItemActivated}
                    />
                    {!isSystemMessage && (this.state.canEdit || this.state.canDelete) && this.renderDivider('edit')}
                    <Menu.ItemAction
                        id={`permalink_${this.props.post.id}`}
                        show={!isSystemMessage}
                        text={Utils.localizeMessage('post_info.permalink', 'Copy Link')}
                        icon={Utils.getMenuItemIcon('icon-link-variant')}
                        rightDecorator={<ShortcutKey shortcutKey='K'/>}
                        onClick={this.copyLink}
                    />
                    {!isSystemMessage && this.renderDivider('edit')}
                    <Menu.ItemAction
                        id={`edit_post_${this.props.post.id}`}
                        show={this.state.canEdit}
                        text={Utils.localizeMessage('post_info.edit', 'Edit')}
                        icon={Utils.getMenuItemIcon('icon-pencil-outline')}
                        rightDecorator={<ShortcutKey shortcutKey='E'/>}
                        onClick={this.handleEditMenuItemActivated}
                    />
                    <Menu.ItemAction
                        id={`copy_${this.props.post.id}`}
                        show={!isSystemMessage}
                        text={Utils.localizeMessage('post_info.copy', 'Copy Text')}
                        icon={Utils.getMenuItemIcon('icon-content-copy')}
                        rightDecorator={<ShortcutKey shortcutKey='C'/>}
                        onClick={this.copyText}
                    />
                    <Menu.ItemAction
                        id={`delete_post_${this.props.post.id}`}
                        show={this.state.canDelete}
                        text={Utils.localizeMessage('post_info.del', 'Delete')}
                        icon={Utils.getMenuItemIcon('icon-trash-can-outline', true)}
                        rightDecorator={deleteShortcutText}
                        onClick={this.handleDeleteMenuItemActivated}
                        isDangerous={true}
                    />
                </Menu>
            </MenuWrapper>
        );
    }
}

export default injectIntl(DotMenuClass);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ComponentProps} from 'react';
import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {getLicense, getConfig} from 'mattermost-redux/selectors/entities/general';
import {getChannel} from 'mattermost-redux/selectors/entities/channels';
import {getCurrentUserId, getCurrentUserMentionKeys} from 'mattermost-redux/selectors/entities/users';
import {getCurrentTeamId, getCurrentTeam, getTeam} from 'mattermost-redux/selectors/entities/teams';
import {makeGetThreadOrSynthetic} from 'mattermost-redux/selectors/entities/threads';
import {getPost} from 'mattermost-redux/selectors/entities/posts';
import {isCollapsedThreadsEnabled} from 'mattermost-redux/selectors/entities/preferences';

import {isSystemMessage} from 'mattermost-redux/utils/post_utils';

import {GenericAction} from 'mattermost-redux/types/actions';

import {setThreadFollow} from 'mattermost-redux/actions/threads';

import {ModalData} from 'types/actions';
import {GlobalState} from 'types/store';

import {openModal} from 'actions/views/modals';

import {
    flagPost,
    unflagPost,
    pinPost,
    unpinPost,
    setEditingPost,
    markPostAsUnread,
} from 'actions/post_actions';

import {getIsMobileView} from 'selectors/views/browser';

import * as PostUtils from 'utils/post_utils';

import {isArchivedChannel} from 'utils/channel_utils';
import {getSiteURL} from 'utils/url';

import {Locations, Preferences} from 'utils/constants';
import {allAtMentions} from 'utils/text_formatting';

import {matchUserMentionTriggersWithMessageMentions} from 'utils/post_utils';

import {Post} from '@mattermost/types/posts';
import {setGlobalItem} from '../../actions/storage';
import {getGlobalItem} from '../../selectors/storage';

import DotMenu from './dot_menu';

type Props = {
    post: Post;
    isFlagged?: boolean;
    handleCommentClick?: React.EventHandler<React.MouseEvent | React.KeyboardEvent>;
    handleCardClick?: (post: Post) => void;
    handleDropdownOpened: (open: boolean) => void;
    handleAddReactionClick?: () => void;
    isMenuOpen: boolean;
    isReadOnly?: boolean;
    enableEmojiPicker?: boolean;
    location?: ComponentProps<typeof DotMenu>['location'];
};

function mapStateToProps(state: GlobalState, ownProps: Props) {
    const {post} = ownProps;

    const license = getLicense(state);
    const config = getConfig(state);
    const userId = getCurrentUserId(state);
    const channel = getChannel(state, post.channel_id);
    const currentTeam = getCurrentTeam(state) || {};
    const team = getTeam(state, channel.team_id);
    const teamUrl = `${getSiteURL()}/${team?.name || currentTeam.name}`;

    const systemMessage = isSystemMessage(post);
    const collapsedThreads = isCollapsedThreadsEnabled(state);

    const rootId = post.root_id || post.id;
    let threadId = rootId;
    let isFollowingThread = false;
    let isMentionedInRootPost = false;
    let threadReplyCount = 0;

    if (
        collapsedThreads &&
        rootId && !systemMessage &&
        (

            // default prop location would be CENTER
            !ownProps.location ||
            ownProps.location === Locations.RHS_ROOT ||
            ownProps.location === Locations.RHS_COMMENT ||
            ownProps.location === Locations.CENTER
        )
    ) {
        const root = getPost(state, rootId);
        const getThreadOrSynthetic = makeGetThreadOrSynthetic();
        if (root) {
            const thread = getThreadOrSynthetic(state, root);
            threadReplyCount = thread.reply_count;
            const currentUserMentionKeys = getCurrentUserMentionKeys(state);
            const rootMessageMentionKeys = allAtMentions(root.message);
            isFollowingThread = thread.is_following;
            isMentionedInRootPost = thread.reply_count === 0 &&
                matchUserMentionTriggersWithMessageMentions(currentUserMentionKeys, rootMessageMentionKeys);
            threadId = thread.id;
        }
    }

    const showForwardPostNewLabel = getGlobalItem(state, Preferences.FORWARD_POST_VIEWED, true);

    return {
        channelIsArchived: isArchivedChannel(channel),
        components: state.plugins.components,
        postEditTimeLimit: config.PostEditTimeLimit,
        isLicensed: license.IsLicensed === 'true',
        teamId: getCurrentTeamId(state),
        pluginMenuItems: state.plugins.components.PostDropdownMenu,
        canEdit: PostUtils.canEditPost(state, post, license, config, channel, userId),
        canDelete: PostUtils.canDeletePost(state, post, channel),
        teamUrl,
        userId,
        threadId,
        isFollowingThread,
        isMentionedInRootPost,
        isCollapsedThreadsEnabled: collapsedThreads,
        threadReplyCount,
        isMobileView: getIsMobileView(state),
        showForwardPostNewLabel,
        ...ownProps,
    };
}

type Actions = {
    flagPost: (postId: string) => void;
    unflagPost: (postId: string) => void;
    setEditingPost: (postId?: string, refocusId?: string, title?: string, isRHS?: boolean) => void;
    pinPost: (postId: string) => void;
    unpinPost: (postId: string) => void;
    openModal: <P>(modalData: ModalData<P>) => void;
    markPostAsUnread: (post: Post) => void;
    setThreadFollow: (userId: string, teamId: string, threadId: string, newState: boolean) => void;
    setGlobalItem: (name: string, value: any) => void;
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject, Actions>({
            flagPost,
            unflagPost,
            setEditingPost,
            pinPost,
            unpinPost,
            openModal,
            markPostAsUnread,
            setThreadFollow,
            setGlobalItem,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(DotMenu);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState, CSSProperties} from 'react';
import ReactSelect, {Props as SelectProps, ActionMeta, components} from 'react-select';
import classNames from 'classnames';

import './dropdown_input.scss';

// TODO: This component needs work, should not be used outside of AddressInfo until this comment is removed.

export type ValueType = {
    label: string;
    value: string;
}

type Props<T> = Omit<SelectProps<T>, 'onChange'> & {
    value?: T;
    legend?: string;
    error?: string;
    onChange: (value: T, action: ActionMeta<T>) => void;
    testId?: string;
};

const baseStyles = {
    input: (provided: CSSProperties) => ({
        ...provided,
        color: 'var(--center-channel-color)',
    }),
    control: (provided: CSSProperties) => ({
        ...provided,
        border: 'none',
        boxShadow: 'none',
        padding: '0 2px',
        cursor: 'pointer',
    }),
    indicatorSeparator: (provided: CSSProperties) => ({
        ...provided,
        display: 'none',
    }),
};

const IndicatorsContainer = (props: any) => {
    return (
        <div className='DropdownInput__indicatorsContainer'>
            <components.IndicatorsContainer {...props}>
                <i className='icon icon-chevron-down'/>
            </components.IndicatorsContainer>
        </div>
    );
};

const Control = (props: any) => {
    return (
        <div className='DropdownInput__controlContainer'>
            <components.Control {...props}/>
        </div>
    );
};

const Option = (props: any) => {
    return (
        <div
            className={classNames('DropdownInput__option', {
                selected: props.isSelected,
                focused: props.isFocused,
            })}
        >
            <components.Option {...props}/>
        </div>
    );
};

const renderError = (error?: string) => {
    if (!error) {
        return null;
    }

    return (
        <div className='Input___error'>
            <i className='icon icon-alert-outline'/>
            <span>{error}</span>
        </div>
    );
};

const DropdownInput = <T extends ValueType>(props: Props<T>) => {
    const {value, placeholder, className, addon, name, textPrefix, legend, onChange, styles, options, error, testId, ...otherProps} = props;

    const [focused, setFocused] = useState(false);

    const onInputFocus = (event: React.FocusEvent<HTMLElement>) => {
        const {onFocus} = props;

        setFocused(true);

        if (onFocus) {
            onFocus(event);
        }
    };

    const onInputBlur = (event: React.FocusEvent<HTMLElement>) => {
        const {onBlur} = props;

        setFocused(false);

        if (onBlur) {
            onBlur(event);
        }
    };

    const showLegend = Boolean(focused || value);

    return (
        <div
            className='DropdownInput Input_container'
            data-testid={testId || ''}
        >
            <fieldset
                className={classNames('Input_fieldset', className, {
                    Input_fieldset___error: error,
                    Input_fieldset___legend: showLegend,
                })}
            >
                <legend className={classNames('Input_legend', {Input_legend___focus: showLegend})}>
                    {showLegend ? (legend || placeholder) : null}
                </legend>
                <div
                    className='Input_wrapper'
                    onFocus={onInputFocus}
                    onBlur={onInputBlur}
                >
                    {textPrefix && <span>{textPrefix}</span>}
                    <ReactSelect
                        id={`DropdownInput_${name}`}
                        options={options}
                        placeholder={focused ? '' : placeholder}
                        components={{
                            IndicatorsContainer,
                            Option,
                            Control,
                        }}
                        className={classNames('Input', className, {Input__focus: showLegend})}
                        classNamePrefix={'DropDown'}
                        value={value}
                        onChange={onChange as any} // types are not working correctly for multiselect
                        styles={{...baseStyles, ...styles}}
                        {...otherProps}
                    />
                </div>
                {addon}
            </fieldset>
            {renderError(error)}
        </div>
    );
};

export default DropdownInput;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {MouseEvent} from 'react';
import {FormattedMessage} from 'react-intl';
import {Link} from 'react-router-dom';

type Props = {
    showPreview?: boolean;
    previewMessageLink?: string;
    hasText?: boolean;
    hasExceededCharacterLimit?: boolean;
    isMarkdownPreviewEnabled: boolean;
    currentLocale: string;
    updatePreview?: (showPreview: boolean) => void;
};

function TextboxLinks({
    showPreview,
    previewMessageLink,
    hasText = false,
    hasExceededCharacterLimit = false,
    isMarkdownPreviewEnabled,
    currentLocale,
    updatePreview,
}: Props) {
    const togglePreview = (e: MouseEvent) => {
        e.preventDefault();
        updatePreview?.(!showPreview);
    };

    let editHeader;

    let helpTextClass = '';

    if (hasExceededCharacterLimit) {
        helpTextClass = 'hidden';
    }

    if (previewMessageLink) {
        editHeader = (
            <span>
                {previewMessageLink}
            </span>
        );
    } else {
        editHeader = (
            <FormattedMessage
                id='textbox.edit'
                defaultMessage='Edit message'
            />
        );
    }

    let previewLink = null;
    if (isMarkdownPreviewEnabled) {
        previewLink = (
            <button
                id='previewLink'
                onClick={togglePreview}
                className='style--none textbox-preview-link color--link'
            >
                {showPreview ? (
                    editHeader
                ) : (
                    <FormattedMessage
                        id='textbox.preview'
                        defaultMessage='Preview'
                    />
                )}
            </button>
        );
    }

    const helpText = (
        <div
            style={{visibility: hasText ? 'visible' : 'hidden', opacity: hasText ? '0.45' : '0'}}
            className='help__format-text'
        >
            <b>
                <FormattedMessage
                    id='textbox.bold'
                    defaultMessage='**bold**'
                />
            </b>
            <i>
                <FormattedMessage
                    id='textbox.italic'
                    defaultMessage='*italic*'
                />
            </i>
            <span>
                {'~~'}
                <s>
                    <FormattedMessage
                        id='textbox.strike'
                        defaultMessage='strike'
                    />
                </s>
                {'~~ '}
            </span>
            <span>
                <FormattedMessage
                    id='textbox.inlinecode'
                    defaultMessage='`inline code`'
                />
            </span>
            <span>
                <FormattedMessage
                    id='textbox.preformatted'
                    defaultMessage='```preformatted```'
                />
            </span>
            <span>
                <FormattedMessage
                    id='textbox.quote'
                    defaultMessage='>quote'
                />
            </span>
        </div>
    );

    return (
        <div className={'help__text ' + helpTextClass}>
            {helpText}
            {previewLink}
            <Link
                target='_blank'
                rel='noopener noreferrer'
                to={`/help/messaging?locale=${currentLocale}`}
                className='textbox-help-link'
            >
                <FormattedMessage
                    id='textbox.help'
                    defaultMessage='Help'
                />
            </Link>
        </div>
    );
}

export default TextboxLinks;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {GlobalState} from 'types/store';

import {getCurrentLocale} from 'selectors/i18n';

import TextboxLinks from './textbox_links';

function mapStateToProps(state: GlobalState) {
    return ({
        currentLocale: getCurrentLocale(state),
    });
}

export default connect(mapStateToProps)(TextboxLinks);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

import {ActionResult} from 'mattermost-redux/types/actions';
import {Channel} from '@mattermost/types/channels';
import {ServerError} from '@mattermost/types/errors';

import Textbox, {TextboxElement} from 'components/textbox';
import TextboxClass from 'components/textbox/textbox';
import TextboxLinks from 'components/textbox/textbox_links';
import Constants from 'utils/constants';
import {isMobile} from 'utils/user_agent';
import {insertLineBreakFromKeyEvent, isKeyPressed, isUnhandledLineBreakKeyCombo, localizeMessage} from 'utils/utils';

const KeyCodes = Constants.KeyCodes;

const headerMaxLength = 1024;

type Props = {

    /*
     * Object with info about current channel ,
     */
    channel: Channel;

    /*
     * boolean should be `ctrl` button pressed to send
     */
    ctrlSend: boolean;

    /*
     * Should preview be showed
     */
    shouldShowPreview: boolean;

    markdownPreviewFeatureIsEnabled: boolean;

    /**
     * Called when the modal has been hidden and should be removed.
     */
    onExited: () => void;

    /*
     * Collection of redux actions
     */
    actions: {

        /*
         * patch channel redux-action
         */
        patchChannel: (channelId: string, patch: Partial<Channel>) => Promise<ActionResult>;

        /*
         * Set show preview for textbox
         */
        setShowPreview: (showPreview: boolean) => void;
    };
}

type State = {
    header?: string;
    saving: boolean;
    show: boolean;
    serverError?: ServerError;
    postError?: React.ReactNode;
}

export default class EditChannelHeaderModal extends React.PureComponent<Props, State> {
    private editChannelHeaderTextboxRef: React.RefObject<TextboxClass>;

    constructor(props: Props) {
        super(props);

        this.state = {
            header: props.channel.header,
            saving: false,
            show: true,
        };
        this.editChannelHeaderTextboxRef = React.createRef<TextboxClass>();
    }

    private handleModalKeyDown = (e: React.KeyboardEvent<Modal>): void => {
        if (isKeyPressed(e as unknown as React.KeyboardEvent, KeyCodes.ESCAPE)) {
            this.hideModal();
        }
    }

    private setShowPreview = (newState: boolean): void => {
        this.props.actions.setShowPreview(newState);
    }

    private handleChange = (e: React.ChangeEvent<TextboxElement>): void => {
        this.setState({
            header: e.target.value,
        });
    }

    public handleSave = async (): Promise<void> => {
        const header = this.state.header?.trim() ?? '';
        if (header === this.props.channel.header) {
            this.hideModal();
        } else {
            this.setState({saving: true});
            const {channel, actions} = this.props;
            const {error} = await actions.patchChannel(channel.id!, {header});
            if (error) {
                this.setState({serverError: error, saving: false});
            } else {
                this.hideModal();
            }
        }
    }

    private hideModal = (): void => {
        this.setState({
            show: false,
        });
    }

    private focusTextbox = (): void => {
        if (this.editChannelHeaderTextboxRef.current) {
            this.editChannelHeaderTextboxRef.current.focus();
        }
    }

    private blurTextbox = (): void => {
        if (this.editChannelHeaderTextboxRef.current) {
            this.editChannelHeaderTextboxRef.current.blur();
        }
    }

    private handleEntering = (): void => {
        this.focusTextbox();
    }

    private handleKeyDown = (e: React.KeyboardEvent<Element>): void => {
        const {ctrlSend} = this.props;

        // listen for line break key combo and insert new line character
        if (isUnhandledLineBreakKeyCombo(e)) {
            this.setState({header: insertLineBreakFromKeyEvent(e as React.KeyboardEvent<HTMLTextAreaElement>)});
        } else if (ctrlSend && isKeyPressed(e, KeyCodes.ENTER) && e.ctrlKey === true) {
            this.handleKeyPress(e);
        }
    }

    private handleKeyPress = (e: React.KeyboardEvent<Element>): void => {
        const {ctrlSend} = this.props;
        if (!isMobile() && ((ctrlSend && e.ctrlKey) || !ctrlSend)) {
            if (isKeyPressed(e, KeyCodes.ENTER) && !e.shiftKey && !e.altKey) {
                e.preventDefault();
                this.blurTextbox();
                this.handleSave();
            }
        }
    }

    private handlePostError = (postError: React.ReactNode) => {
        this.setState({postError});
    }

    private renderError = (): (JSX.Element | null) => {
        const {serverError} = this.state;
        if (!serverError) {
            return null;
        }

        let errorMsg;
        if (serverError.server_error_id === 'model.channel.is_valid.header.app_error') {
            errorMsg = (
                <FormattedMessage
                    id='edit_channel_header_modal.error'
                    defaultMessage='The text entered exceeds the character limit. The channel header is limited to {maxLength} characters.'
                    values={{
                        maxLength: headerMaxLength,
                    }}
                />
            );
        } else {
            errorMsg = serverError.message;
        }

        return (
            <div className='form-group has-error'>
                <br/>
                <label className='control-label'>
                    {errorMsg}
                </label>
            </div>
        );
    }

    public render(): JSX.Element {
        let headerTitle = null;
        if (this.props.channel.type === Constants.DM_CHANNEL) {
            headerTitle = (
                <FormattedMessage
                    id='edit_channel_header_modal.title_dm'
                    defaultMessage='Edit Header'
                />
            );
        } else {
            headerTitle = (
                <FormattedMessage
                    id='edit_channel_header_modal.title'
                    defaultMessage='Edit Header for {channel}'
                    values={{
                        channel: this.props.channel.display_name,
                    }}
                />
            );
        }

        return (
            <Modal
                dialogClassName='a11y__modal'
                show={this.state.show}
                keyboard={false}
                onKeyDown={this.handleModalKeyDown}
                onHide={this.hideModal}
                onEntering={this.handleEntering}
                onExited={this.props.onExited}
                role='dialog'
                aria-labelledby='editChannelHeaderModalLabel'
            >
                <Modal.Header closeButton={true}>
                    <Modal.Title
                        componentClass='h1'
                        id='editChannelHeaderModalLabel'
                    >
                        {headerTitle}
                    </Modal.Title>
                </Modal.Header>
                <Modal.Body bsClass='modal-body edit-modal-body'>
                    <div>
                        <p>
                            <FormattedMessage
                                id='edit_channel_header_modal.description'
                                defaultMessage='Edit the text appearing next to the channel name in the header.'
                            />
                        </p>
                        <div className='textarea-wrapper'>
                            <Textbox
                                value={this.state.header!}
                                onChange={this.handleChange}
                                onKeyPress={this.handleKeyPress}
                                onKeyDown={this.handleKeyDown}
                                supportsCommands={false}
                                suggestionListPosition='bottom'
                                createMessage={localizeMessage('edit_channel_header.editHeader', 'Edit the Channel Header...')}
                                handlePostError={this.handlePostError}
                                channelId={this.props.channel.id!}
                                id='edit_textbox'
                                ref={this.editChannelHeaderTextboxRef}
                                characterLimit={1024}
                                preview={this.props.shouldShowPreview}
                                useChannelMentions={false}
                            />
                        </div>
                        <div className='post-create-footer'>
                            <TextboxLinks
                                isMarkdownPreviewEnabled={this.props.markdownPreviewFeatureIsEnabled}
                                showPreview={this.props.shouldShowPreview}
                                updatePreview={this.setShowPreview}
                                hasText={this.state.header ? this.state.header.length > 0 : false}
                                hasExceededCharacterLimit={this.state.header ? this.state.header.length > 1024 : false}
                                previewMessageLink={localizeMessage('edit_channel_header.previewHeader', 'Edit Header')}
                            />
                        </div>
                        <br/>
                        {this.renderError()}
                    </div>
                </Modal.Body>
                <Modal.Footer>
                    <button
                        type='button'
                        className='btn btn-link cancel-button'
                        onClick={this.hideModal}
                    >
                        <FormattedMessage
                            id='edit_channel_header_modal.cancel'
                            defaultMessage='Cancel'
                        />
                    </button>
                    <button
                        disabled={this.state.saving}
                        type='button'
                        className='btn btn-primary save-button'
                        onClick={this.handleSave}
                    >
                        <FormattedMessage
                            id='edit_channel_header_modal.save'
                            defaultMessage='Save'
                        />
                    </button>
                </Modal.Footer>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';
import {connect} from 'react-redux';

import {ActionFunc, ActionResult, GenericAction} from 'mattermost-redux/types/actions';
import {Channel} from '@mattermost/types/channels';
import {getBool} from 'mattermost-redux/selectors/entities/preferences';
import {patchChannel} from 'mattermost-redux/actions/channels';
import {Preferences} from 'mattermost-redux/constants';
import {Constants} from 'utils/constants';
import {isFeatureEnabled} from 'utils/utils';

import {GlobalState} from 'types/store';

import {setShowPreviewOnEditChannelHeaderModal} from 'actions/views/textbox';
import {showPreviewOnEditChannelHeaderModal} from 'selectors/views/textbox';

import EditChannelHeaderModal from './edit_channel_header_modal';

function mapStateToProps(state: GlobalState) {
    return {
        markdownPreviewFeatureIsEnabled: isFeatureEnabled(Constants.PRE_RELEASE_FEATURES.MARKDOWN_PREVIEW, state),
        shouldShowPreview: showPreviewOnEditChannelHeaderModal(state),
        ctrlSend: getBool(state, Preferences.CATEGORY_ADVANCED_SETTINGS, 'send_on_ctrl_enter'),
    };
}

type Actions = {
    patchChannel: (channelId: string, patch: Partial<Channel>) => Promise<ActionResult>;
    setShowPreview: (showPreview: boolean) => void;
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc | GenericAction>, Actions>({
            patchChannel,
            setShowPreview: setShowPreviewOnEditChannelHeaderModal,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(EditChannelHeaderModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ChangeEvent} from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage, injectIntl, IntlShape} from 'react-intl';

import {Channel} from '@mattermost/types/channels';
import {ActionResult} from 'mattermost-redux/types/actions';

import Constants from 'utils/constants';
import * as Utils from 'utils/utils';

type Actions = {
    patchChannel: (channelId: string, patch: Partial<Channel>) => Promise<ActionResult>;
}
type ServerError = {
    message: string;
}
const purposeMaxLength = 250;

type Props = {
    onExited: () => void;
    channel?: Channel;
    ctrlSend: boolean;
    actions: Actions;
    intl: IntlShape;
}

type State = {
    purpose: string;
    serverError: ServerError | null;
    show: boolean;
    submitted: boolean;
    requestStarted: boolean;
}

export class EditChannelPurposeModal extends React.PureComponent<Props, State> {
    private purpose: React.RefObject<HTMLTextAreaElement>;

    constructor(props: Props) {
        super(props);
        this.purpose = React.createRef();

        this.state = {
            purpose: props.channel?.purpose || '',
            serverError: null,
            show: true,
            submitted: false,
            requestStarted: false,
        };
    }

    handleEntering = () => {
        if (this.purpose.current) {
            Utils.placeCaretAtEnd(this.purpose.current);
        }
    }

    onHide = () => {
        this.setState({show: false});
    }

    handleKeyDown = (e: React.KeyboardEvent) => {
        const {ctrlSend} = this.props;

        // listen for line break key combo and insert new line character
        if (Utils.isUnhandledLineBreakKeyCombo(e)) {
            e.preventDefault();
            this.setState({purpose: Utils.insertLineBreakFromKeyEvent(e as React.KeyboardEvent<HTMLTextAreaElement>)});
        } else if (ctrlSend && Utils.isKeyPressed(e, Constants.KeyCodes.ENTER) && e.ctrlKey) {
            e.preventDefault();
            this.handleSave();
        } else if (!ctrlSend && Utils.isKeyPressed(e, Constants.KeyCodes.ENTER) && !e.shiftKey && !e.altKey) {
            e.preventDefault();
            this.handleSave();
        }
    }

    handleSave = async () => {
        const {channel, actions: {patchChannel}} = this.props;
        const {purpose} = this.state;
        if (!channel) {
            return;
        }

        this.setState({requestStarted: true});

        const {data, error} = await patchChannel(channel.id, {purpose});

        this.setState({
            serverError: error,
            requestStarted: false,
        });

        if (data) {
            this.onHide();
        }
    }

    handleChange = (e: ChangeEvent<HTMLTextAreaElement>) => {
        e.preventDefault();
        this.setState({purpose: e.target.value});
    }

    render() {
        let serverError = null;
        const {formatMessage} = this.props.intl;

        if (this.state.serverError) {
            serverError = (
                <div className='form-group has-error'>
                    <br/>
                    <label className='control-label'>{this.state.serverError.message}</label>
                </div>
            );
        }

        let title = (
            <span>
                <FormattedMessage
                    id='edit_channel_purpose_modal.title1'
                    defaultMessage='Edit Purpose'
                />
            </span>
        );
        if (this.props.channel?.display_name) {
            title = (
                <span>
                    <FormattedMessage
                        id='edit_channel_purpose_modal.title2'
                        defaultMessage='Edit Purpose for '
                    />
                    <span className='name'>{this.props.channel.display_name}</span>
                </span>
            );
        }

        let channelPurposeModal = (
            <FormattedMessage
                id='edit_channel_purpose_modal.body'
                defaultMessage='Describe how this channel should be used. This text appears in the channel list in the "More..." menu and helps others decide whether to join.'
            />
        );
        if (this.props.channel?.type === 'P') {
            channelPurposeModal = (
                <FormattedMessage
                    id='edit_channel_private_purpose_modal.body'
                    defaultMessage='This text appears in the \"View Info\" modal of the private channel.'
                />
            );
        }

        const ariaLabelForTitle = formatMessage({id: 'edit_channel_purpose_modal.title1', defaultMessage: 'Edit Purpose'}).toLowerCase();
        return (
            <Modal
                dialogClassName='a11y__modal'
                show={this.state.show}
                onHide={this.onHide}
                onEntering={this.handleEntering}
                onExited={this.props.onExited}
                role='dialog'
                aria-labelledby='editChannelPurposeModalLabel'
            >
                <Modal.Header closeButton={true}>
                    <Modal.Title
                        componentClass='h1'
                        id='editChannelPurposeModalLabel'
                    >
                        {title}
                    </Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    <p>
                        {channelPurposeModal}
                    </p>
                    <textarea
                        ref={this.purpose}
                        className='form-control no-resize'
                        rows={6}
                        maxLength={purposeMaxLength}
                        value={this.state.purpose}
                        onKeyDown={this.handleKeyDown}
                        onChange={this.handleChange}
                        aria-label={ariaLabelForTitle}
                    />
                    {serverError}
                </Modal.Body>
                <Modal.Footer>
                    <button
                        type='button'
                        className='btn btn-link cancel-button'
                        onClick={this.onHide}
                    >
                        <FormattedMessage
                            id='edit_channel_purpose_modal.cancel'
                            defaultMessage='Cancel'
                        />
                    </button>
                    <button
                        type='button'
                        className='btn btn-primary save-button'
                        disabled={this.state.requestStarted}
                        onClick={this.handleSave}
                    >
                        <FormattedMessage
                            id='edit_channel_purpose_modal.save'
                            defaultMessage='Save'
                        />
                    </button>
                </Modal.Footer>
            </Modal>
        );
    }
}

export default injectIntl(EditChannelPurposeModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';
import {connect} from 'react-redux';

import {getBool} from 'mattermost-redux/selectors/entities/preferences';
import {patchChannel} from 'mattermost-redux/actions/channels';
import {ActionFunc, GenericAction, ActionResult} from 'mattermost-redux/types/actions';
import {Channel} from '@mattermost/types/channels';

import {GlobalState} from 'types/store';

import Constants from 'utils/constants';

import EditChannelPurposeModal from './edit_channel_purpose_modal';

function mapStateToProps(state: GlobalState) {
    return {
        ctrlSend: getBool(state, Constants.Preferences.CATEGORY_ADVANCED_SETTINGS, 'send_on_ctrl_enter'),
    };
}

type Actions = {
    patchChannel: (channelId: string, patch: Partial<Channel>) => Promise<ActionResult>;
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc>, Actions>({
            patchChannel,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(EditChannelPurposeModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo} from 'react';
import {useSelector} from 'react-redux';
import {FormattedMessage} from 'react-intl';

import {getBool} from 'mattermost-redux/selectors/entities/preferences';
import {Preferences} from 'mattermost-redux/constants';

import {isMac} from 'utils/utils';
import {GlobalState} from 'types/store';

type Props = {
    onSave: () => void;
    onCancel: () => void;
}

const EditPostFooter = ({onSave, onCancel}: Props) => {
    const ctrlSend = useSelector((state: GlobalState) => getBool(state, Preferences.CATEGORY_ADVANCED_SETTINGS, 'send_on_ctrl_enter'));
    const ctrlSendKey = isMac() ? '+' : 'CTRL+';

    return (
        <div className='post-body__footer'>
            <button
                onClick={onSave}
                className='save'
            >
                <FormattedMessage
                    id='edit_post.action_buttons.save'
                    defaultMessage='Save'
                />
            </button>
            <button
                onClick={onCancel}
                className='cancel'
            >
                <FormattedMessage
                    id='edit_post.action_buttons.cancel'
                    defaultMessage='Cancel'
                />
            </button>
            <FormattedMessage
                id='edit_post.helper_text'
                defaultMessage='<strong>{key}ENTER</strong> to Save, <strong>ESC</strong> to Cancel'
                values={{
                    key: ctrlSend ? ctrlSendKey : '',
                    strong: (x: string) => <strong>{x}</strong>,
                }}
            />
        </div>
    );
};

export default memo(EditPostFooter);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useEffect, useRef, useState} from 'react';
import classNames from 'classnames';
import {useIntl} from 'react-intl';
import {EmoticonPlusOutlineIcon} from '@mattermost/compass-icons/components';

import {Post} from '@mattermost/types/posts';
import {Emoji, SystemEmoji} from '@mattermost/types/emojis';

import {AppEvents, Constants, ModalIdentifiers, StoragePrefixes} from 'utils/constants';
import {
    formatGithubCodePaste,
    formatMarkdownMessage,
    getTable,
    hasHtmlLink,
    isGitHubCodeBlock,
} from 'utils/paste';
import {postMessageOnKeyPress, splitMessageBasedOnCaretPosition} from 'utils/post_utils';
import {applyMarkdown, ApplyMarkdownOptions} from 'utils/markdown/apply_markdown';
import * as Utils from 'utils/utils';

import DeletePostModal from 'components/delete_post_modal';
import EmojiPickerOverlay from 'components/emoji_picker/emoji_picker_overlay';
import Textbox, {TextboxClass, TextboxElement} from 'components/textbox';
import {ModalData} from 'types/actions';
import {PostDraft} from '../../types/store/draft';

import EditPostFooter from './edit_post_footer';

type DialogProps = {
    post?: Post;
    isRHS?: boolean;
};

export type Actions = {
    addMessageIntoHistory: (message: string) => void;
    editPost: (input: Partial<Post>) => Promise<Post>;
    setDraft: (name: string, value: PostDraft | null) => void;
    unsetEditingPost: () => void;
    openModal: (input: ModalData<DialogProps>) => void;
    scrollPostListToBottom: () => void;
}

export type Props = {
    canEditPost?: boolean;
    canDeletePost?: boolean;
    readOnlyChannel?: boolean;
    teamId: string;
    channelId: string;
    codeBlockOnCtrlEnter: boolean;
    ctrlSend: boolean;
    draft: PostDraft;
    config: {
        EnableEmojiPicker?: string;
        EnableGifPicker?: string;
    };
    maxPostSize: number;
    useChannelMentions: boolean;
    editingPost: {
        post: Post | null;
        postId?: string;
        refocusId?: string;
        title?: string;
        isRHS?: boolean;
    };
    actions: Actions;
};

export type State = {
    editText: string;
    selectionRange: {start: number; end: number};
    postError: React.ReactNode;
    errorClass: string | null;
    showEmojiPicker: boolean;
    renderScrollbar: boolean;
    scrollbarWidth: number;
    prevShowState: boolean;
};

const {KeyCodes} = Constants;

const TOP_OFFSET = 0;
const RIGHT_OFFSET = 10;

const EditPost = ({editingPost, actions, canEditPost, config, channelId, draft, ...rest}: Props): JSX.Element | null => {
    const [editText, setEditText] = useState<string>(
        draft.message || editingPost?.post?.message_source || editingPost?.post?.message || '',
    );
    const [selectionRange, setSelectionRange] = useState<State['selectionRange']>({start: editText.length, end: editText.length});
    const [postError, setPostError] = useState<React.ReactNode | null>(null);
    const [errorClass, setErrorClass] = useState<string>('');
    const [showEmojiPicker, setShowEmojiPicker] = useState<boolean>(false);
    const [renderScrollbar, setRenderScrollbar] = useState<boolean>(false);

    const textboxRef = useRef<TextboxClass>(null);
    const emojiButtonRef = useRef<HTMLButtonElement>(null);
    const wrapperRef = useRef<HTMLDivElement>(null);

    // using a ref here makes sure that the unmounting callback (saveDraft) is fired with the correct value.
    // If we would just use the editText value from the state it would be a stale since it is encapsuled in the
    // function closure on initial render
    const draftRef = useRef<PostDraft>(draft);
    const saveDraftFrame = useRef<number|null>();

    const draftStorageId = `${StoragePrefixes.EDIT_DRAFT}${editingPost.postId}`;

    const {formatMessage} = useIntl();

    const saveDraft = useCallback(() => {
        // to be run on unmount and only when there is an active saveDraftFrame timer
        if (saveDraftFrame.current && editingPost.postId) {
            actions.setDraft(draftStorageId, draftRef.current);
            clearTimeout(saveDraftFrame.current);
            saveDraftFrame.current = null;
        }
    }, [actions, draftStorageId, editingPost.postId]);

    useEffect(() => saveDraft, [saveDraft]);

    useEffect(() => {
        if (saveDraftFrame.current) {
            clearTimeout(saveDraftFrame.current);
        }

        saveDraftFrame.current = window.setTimeout(() => {
            actions.setDraft(draftStorageId, draftRef.current);
        }, Constants.SAVE_DRAFT_TIMEOUT);
    }, [actions, draftStorageId, editText]);

    useEffect(() => {
        const focusTextBox = () => textboxRef?.current?.focus();

        document.addEventListener(AppEvents.FOCUS_EDIT_TEXTBOX, focusTextBox);
        return () => document.removeEventListener(AppEvents.FOCUS_EDIT_TEXTBOX, focusTextBox);
    }, []);

    useEffect(() => {
        if (selectionRange.start === selectionRange.end) {
            Utils.setCaretPosition(textboxRef.current?.getInputBox(), selectionRange.start);
        } else {
            Utils.setSelectionRange(textboxRef.current?.getInputBox(), selectionRange.start, selectionRange.end);
        }
    }, [selectionRange]);

    // just a helper so it's not always needed to update with setting both properties to the same value
    const setCaretPosition = (position: number) => setSelectionRange({start: position, end: position});

    const handlePaste = useCallback((e: ClipboardEvent) => {
        const {clipboardData, target} = e;
        if (
            !clipboardData ||
            !clipboardData.items ||
            !canEditPost ||
            (target as HTMLTextAreaElement).id !== 'edit_textbox'
        ) {
            return;
        }

        const hasLinks = hasHtmlLink(clipboardData);
        const table = getTable(clipboardData);
        if (!table && !hasLinks) {
            return;
        }

        e.preventDefault();

        let message = editText;
        let newCaretPosition = selectionRange.start;

        if (table && isGitHubCodeBlock(table.className)) {
            const {formattedMessage, formattedCodeBlock} = formatGithubCodePaste({selectionStart: (target as any).selectionStart, selectionEnd: (target as any).selectionEnd, message, clipboardData});
            message = formattedMessage;
            newCaretPosition = selectionRange.start + formattedCodeBlock.length;
        } else {
            message = formatMarkdownMessage(clipboardData, editText.trim(), newCaretPosition);
            newCaretPosition = message.length - (editText.length - newCaretPosition);
        }

        setEditText(message);
        setCaretPosition(newCaretPosition);
    }, [canEditPost, selectionRange, editText]);

    const isSaveDisabled = () => {
        const {post} = editingPost;
        const hasAttachments = post && post.file_ids && post.file_ids.length > 0;

        if (hasAttachments) {
            return !canEditPost;
        }

        if (editText.trim() !== '') {
            return !canEditPost;
        }

        return !rest.canDeletePost;
    };

    const applyHotkeyMarkdown = (params: ApplyMarkdownOptions) => {
        if (params.selectionStart === null || params.selectionEnd === null) {
            return;
        }

        const res = applyMarkdown(params);

        setEditText(res.message);
        setSelectionRange({start: res.selectionStart, end: res.selectionEnd});
    };

    const handleRefocusAndExit = (refocusId: string|null) => {
        if (refocusId) {
            const element = document.getElementById(refocusId);
            element?.focus();
        }

        actions.unsetEditingPost();
    };

    const handleAutomatedRefocusAndExit = () => handleRefocusAndExit(editingPost.refocusId || null);

    const handleEdit = async () => {
        if (!editingPost.post || isSaveDisabled()) {
            return;
        }

        const updatedPost = {
            message: editText,
            id: editingPost.postId,
            channel_id: editingPost.post.channel_id,
        };

        if (postError) {
            setErrorClass('animation--highlight');
            setTimeout(() => setErrorClass(''), Constants.ANIMATION_TIMEOUT);
            return;
        }

        if (updatedPost.message === (editingPost.post?.message_source || editingPost.post?.message)) {
            handleAutomatedRefocusAndExit();
            return;
        }

        const hasAttachment = Boolean(
            editingPost.post?.file_ids && editingPost.post?.file_ids.length > 0,
        );
        if (updatedPost.message.trim().length === 0 && !hasAttachment) {
            handleRefocusAndExit(null);

            const deletePostModalData = {
                modalId: ModalIdentifiers.DELETE_POST,
                dialogType: DeletePostModal,
                dialogProps: {
                    post: editingPost.post,
                    isRHS: editingPost.isRHS,
                },
            };

            actions.openModal(deletePostModalData);
            return;
        }

        await actions.editPost(updatedPost as Post);

        handleAutomatedRefocusAndExit();
    };

    const handleEditKeyPress = (e: React.KeyboardEvent) => {
        const {ctrlSend, codeBlockOnCtrlEnter} = rest;
        const inputBox = textboxRef.current?.getInputBox();

        const {allowSending, ignoreKeyPress} = postMessageOnKeyPress(
            e,
            editText,
            ctrlSend,
            codeBlockOnCtrlEnter,
            Date.now(),
            0,
            inputBox.selectionStart,
        );

        if (ignoreKeyPress) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }

        if (allowSending && textboxRef.current) {
            e.preventDefault();
            textboxRef.current.blur();
            handleEdit();
        }
    };

    const handleKeyDown = (e: React.KeyboardEvent<TextboxElement>) => {
        const {ctrlSend, codeBlockOnCtrlEnter} = rest;

        const ctrlOrMetaKeyPressed = e.ctrlKey || e.metaKey;
        const ctrlKeyCombo = Utils.cmdOrCtrlPressed(e) && !e.altKey && !e.shiftKey;
        const ctrlAltCombo = Utils.cmdOrCtrlPressed(e, true) && e.altKey;
        const ctrlEnterKeyCombo =
            (ctrlSend || codeBlockOnCtrlEnter) &&
            Utils.isKeyPressed(e, KeyCodes.ENTER) &&
            ctrlOrMetaKeyPressed;
        const markdownLinkKey = Utils.isKeyPressed(e, KeyCodes.K);

        // listen for line break key combo and insert new line character
        if (Utils.isUnhandledLineBreakKeyCombo(e)) {
            e.stopPropagation(); // perhaps this should happen in all of these cases? or perhaps Modal should not be listening?
            setEditText(Utils.insertLineBreakFromKeyEvent(e as React.KeyboardEvent<HTMLTextAreaElement>));
        } else if (ctrlEnterKeyCombo) {
            handleEdit();
        } else if (Utils.isKeyPressed(e, KeyCodes.ESCAPE) && !showEmojiPicker) {
            handleAutomatedRefocusAndExit();
        } else if (ctrlAltCombo && markdownLinkKey) {
            applyHotkeyMarkdown({
                markdownMode: 'link',
                selectionStart: e.currentTarget.selectionStart,
                selectionEnd: e.currentTarget.selectionEnd,
                message: e.currentTarget.value,
            });
        } else if (ctrlKeyCombo && Utils.isKeyPressed(e, KeyCodes.B)) {
            applyHotkeyMarkdown({
                markdownMode: 'bold',
                selectionStart: e.currentTarget.selectionStart,
                selectionEnd: e.currentTarget.selectionEnd,
                message: e.currentTarget.value,
            });
        } else if (ctrlKeyCombo && Utils.isKeyPressed(e, KeyCodes.I)) {
            applyHotkeyMarkdown({
                markdownMode: 'italic',
                selectionStart: e.currentTarget.selectionStart,
                selectionEnd: e.currentTarget.selectionEnd,
                message: e.currentTarget.value,
            });
        }
    };

    const handleSelect = (e: React.SyntheticEvent<TextboxElement>) => {
        if (textboxRef.current) {
            Utils.adjustSelection(textboxRef.current.getInputBox(), e);
        }
    };

    const handleChange = (e: React.ChangeEvent<TextboxElement>) => {
        const message = e.target.value;

        draftRef.current = {
            ...draftRef.current,
            message,
        };

        setEditText(message);
    };

    const handleHeightChange = (height: number, maxHeight: number) => setRenderScrollbar(height > maxHeight);

    const handlePostError = (_postError: React.ReactNode) => {
        if (_postError !== postError) {
            setPostError(_postError);
        }
    };

    const hideEmojiPicker = () => {
        setShowEmojiPicker(false);
        textboxRef.current?.focus();
    };

    const handleEmojiClick = (emoji?: Emoji) => {
        const emojiAlias = emoji && (((emoji as SystemEmoji).short_names && (emoji as SystemEmoji).short_names[0]) || emoji.name);

        if (!emojiAlias) {
            //Oops.. There went something wrong
            return;
        }

        let newMessage = `:${emojiAlias}: `;
        let newCaretPosition = newMessage.length;

        if (editText.length > 0) {
            const {firstPiece, lastPiece} = splitMessageBasedOnCaretPosition(
                selectionRange.start,
                editText,
            );

            // check whether the first piece of the message is empty when cursor
            // is placed at beginning of message and avoid adding an empty string at the beginning of the message
            newMessage = firstPiece === '' ? `:${emojiAlias}: ${lastPiece}` : `${firstPiece} :${emojiAlias}: ${lastPiece}`;
            newCaretPosition = firstPiece === '' ? `:${emojiAlias}: `.length : `${firstPiece} :${emojiAlias}: `.length;
        }

        draftRef.current = {
            ...draftRef.current,
            message: newMessage,
        };

        setEditText(newMessage);
        setCaretPosition(newCaretPosition);
        setShowEmojiPicker(false);
        textboxRef.current?.focus();
    };

    const handleGifClick = (gif: string) => {
        let newMessage = gif;

        if (editText.length > 0) {
            newMessage = (/\s+$/).test(editText) ? `${editText}${gif}` : `${editText} ${gif}`;
        }

        draftRef.current = {
            ...draftRef.current,
            message: newMessage,
        };

        setEditText(newMessage);
        setShowEmojiPicker(false);
        textboxRef.current?.focus();
    };

    const toggleEmojiPicker = (e?: React.MouseEvent<HTMLButtonElement, MouseEvent>): void => {
        e?.stopPropagation();
        setShowEmojiPicker(!showEmojiPicker);
        if (showEmojiPicker) {
            textboxRef.current?.focus();
        }
    };

    const getEmojiContainerRef = useCallback(() => textboxRef.current, [textboxRef]);
    const getEmojiTargetRef = useCallback(() => emojiButtonRef.current, [emojiButtonRef]);

    let emojiPicker = null;
    const emojiButtonAriaLabel = formatMessage({
        id: 'emoji_picker.emojiPicker',
        defaultMessage: 'Emoji Picker',
    }).toLowerCase();

    if (config.EnableEmojiPicker === 'true') {
        emojiPicker = (
            <>
                <EmojiPickerOverlay
                    show={showEmojiPicker}
                    container={getEmojiContainerRef}
                    target={getEmojiTargetRef}
                    onHide={hideEmojiPicker}
                    onEmojiClick={handleEmojiClick}
                    onGifClick={handleGifClick}
                    enableGifPicker={config.EnableGifPicker === 'true'}
                    topOffset={TOP_OFFSET}
                    rightOffset={RIGHT_OFFSET}
                />
                <button
                    aria-label={emojiButtonAriaLabel}
                    id='editPostEmoji'
                    ref={emojiButtonRef}
                    className='style--none post-action'
                    onClick={toggleEmojiPicker}
                >
                    <EmoticonPlusOutlineIcon
                        size={18}
                        color='currentColor'
                    />
                </button>
            </>
        );
    }

    return (
        <div
            className={classNames('post--editing__wrapper', {
                scroll: renderScrollbar,
            })}
            ref={wrapperRef}
        >
            <Textbox
                tabIndex={0}
                rootId={editingPost.post ? Utils.getRootId(editingPost.post) : ''}
                onChange={handleChange}
                onKeyPress={handleEditKeyPress}
                onKeyDown={handleKeyDown}
                onSelect={handleSelect}
                onHeightChange={handleHeightChange}
                handlePostError={handlePostError}
                onPaste={handlePaste}
                value={editText}
                channelId={channelId}
                emojiEnabled={config.EnableEmojiPicker === 'true'}
                createMessage={formatMessage({id: 'edit_post.editPost', defaultMessage: 'Edit the post...'})}
                supportsCommands={false}
                suggestionListPosition='bottom'
                id='edit_textbox'
                ref={textboxRef}
                characterLimit={rest.maxPostSize}
                useChannelMentions={rest.useChannelMentions}
            />
            <div className='post-body__actions'>
                {emojiPicker}
            </div>
            <EditPostFooter
                onSave={handleEdit}
                onCancel={handleAutomatedRefocusAndExit}
            />
            {postError && (
                <div className={classNames('edit-post-footer', {'has-error': postError})}>
                    <label className={classNames('post-error', errorClass)}>{postError}</label>
                </div>
            )}
        </div>
    );
};

export default EditPost;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {addMessageIntoHistory} from 'mattermost-redux/actions/posts';
import {Preferences, Permissions} from 'mattermost-redux/constants';
import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getChannel} from 'mattermost-redux/selectors/entities/channels';
import {haveIChannelPermission} from 'mattermost-redux/selectors/entities/roles';
import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentUserId, isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';
import {getBool} from 'mattermost-redux/selectors/entities/preferences';

import {unsetEditingPost} from 'actions/post_actions';
import {openModal} from 'actions/views/modals';
import {scrollPostListToBottom} from 'actions/views/channel';
import {editPost} from 'actions/views/posts';
import {getEditingPost} from 'selectors/posts';
import {GlobalState} from 'types/store';
import Constants, {StoragePrefixes} from 'utils/constants';
import {setGlobalItem} from '../../actions/storage';
import {getPostDraft} from '../../selectors/rhs';

import EditPost, {Actions} from './edit_post';

function mapStateToProps(state: GlobalState) {
    const config = getConfig(state);
    const editingPost = getEditingPost(state);
    const currentUserId = getCurrentUserId(state);
    const channelId = editingPost.post.channel_id;
    const teamId = getCurrentTeamId(state);
    const draft = getPostDraft(state, StoragePrefixes.EDIT_DRAFT, editingPost.postId);

    const isAuthor = editingPost?.post?.user_id === currentUserId;
    const deletePermission = isAuthor ? Permissions.DELETE_POST : Permissions.DELETE_OTHERS_POSTS;
    const editPermission = isAuthor ? Permissions.EDIT_POST : Permissions.EDIT_OTHERS_POSTS;

    const channel = getChannel(state, channelId);
    const useChannelMentions = haveIChannelPermission(state, teamId, channelId, Permissions.USE_CHANNEL_MENTIONS);

    return {
        canEditPost: haveIChannelPermission(state, teamId, channelId, editPermission),
        canDeletePost: haveIChannelPermission(state, teamId, channelId, deletePermission),
        codeBlockOnCtrlEnter: getBool(state, Preferences.CATEGORY_ADVANCED_SETTINGS, 'code_block_ctrl_enter', true),
        ctrlSend: getBool(state, Preferences.CATEGORY_ADVANCED_SETTINGS, 'send_on_ctrl_enter'),
        draft,
        config,
        editingPost,
        teamId,
        channelId,
        maxPostSize: parseInt(config.MaxPostSize || '0', 10) || Constants.DEFAULT_CHARACTER_LIMIT,
        readOnlyChannel: !isCurrentUserSystemAdmin(state) && channel.name === Constants.DEFAULT_CHANNEL,
        useChannelMentions,
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<any>, Actions>({
            scrollPostListToBottom,
            addMessageIntoHistory,
            editPost,
            setDraft: setGlobalItem,
            unsetEditingPost,
            openModal,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(EditPost);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useSelector} from 'react-redux';

import {getEmojiImageUrl} from 'mattermost-redux/utils/emoji_utils';

import {getEmojiMap} from 'selectors/emojis';
import {GlobalState} from 'types/store';

interface ComponentProps {
    emojiName: string;
    size?: number;
    emojiStyle?: React.CSSProperties;
    onClick?: () => void;
}

const RenderEmoji = ({emojiName, emojiStyle, size, onClick}: ComponentProps) => {
    const emojiMap = useSelector((state: GlobalState) => getEmojiMap(state));

    if (!emojiName) {
        return null;
    }

    const emojiFromMap = emojiMap.get(emojiName);
    if (!emojiFromMap) {
        return null;
    }
    const emojiImageUrl = getEmojiImageUrl(emojiFromMap);

    return (
        <span
            onClick={onClick}
            className='emoticon'
            alt={`:${emojiName}:`}
            data-emoticon={emojiName}
            style={{
                backgroundImage: `url(${emojiImageUrl})`,
                backgroundSize: 'contain',
                height: size,
                width: size,
                maxHeight: size,
                maxWidth: size,
                minHeight: size,
                minWidth: size,
                overflow: 'hidden',
                ...emojiStyle,
            }}
        />
    );
};

RenderEmoji.defaultProps = {
    emoji: '',
    emojiStyle: {},
    size: 16,
};

export default React.memo(RenderEmoji);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

export default class GfycatIcon extends React.PureComponent<React.HTMLAttributes<HTMLSpanElement>> {
    render() {
        return (
            <span {...this.props}>
                <svg
                    width='22px'
                    height='14px'
                    viewBox='0 0 22 14'
                >
                    <g
                        stroke='none'
                        strokeWidth='1'
                        fill='inherit'
                        fillRule='evenodd'
                    >
                        <g
                            transform='translate(-1344.000000, -552.000000)'
                            fill='inherit'
                        >
                            <g transform='translate(1147.000000, 542.000000)'>
                                <g transform='translate(1.000000, 1.000000)'>
                                    <g transform='translate(138.000000, 0.000000)'>
                                        <path d='M63.6748519,23 L62.2292481,23 C61.8176589,23 61.4619872,22.8510143 61.1631497,22.5539741 C60.8633954,22.2569338 60.71306,21.8993681 60.71306,21.4831393 C60.71306,21.0678417 60.8597287,20.710276 61.1539829,20.4132358 C61.4473204,20.1161955 61.800242,19.9672098 62.2118312,19.9672098 L63.6565183,19.9672098 C64.0681075,19.9672098 64.4182791,19.8219488 64.7061166,19.5304955 C64.993954,19.2390422 65.1378727,18.8917193 65.1378727,18.4866644 L65.1378727,15.4371134 C65.1378727,15.0208846 64.993954,14.6670436 64.7061166,14.3755903 C64.4182791,14.084137 64.0745243,13.938876 63.6748519,13.938876 C63.2632628,13.938876 62.9103411,14.0869305 62.6170036,14.3849019 C62.3227494,14.6819421 62.1760807,15.0329897 62.1760807,15.4371134 C62.1760807,15.7294978 62.3016658,16.0563352 62.5519193,16.4185567 L62.575753,16.4530096 C62.8269232,16.8143 62.9515917,17.1420685 62.9515917,17.4344529 C62.9515917,17.8506817 62.8049229,18.2073163 62.5115854,18.5043565 C62.2173313,18.8023279 61.8653263,18.9503824 61.4537371,18.9503824 C60.7836443,18.9503824 60.2198863,18.5164616 59.7615465,17.6486199 C59.373791,16.9232458 59.1794549,16.1857665 59.1794549,15.4371134 C59.1794549,14.188427 59.6176278,13.1213169 60.4930568,12.234852 C61.3684859,11.3493183 62.4226675,10.9060858 63.6565183,10.9060858 C64.8912858,10.9060858 65.9482175,11.3493183 66.8300633,12.234852 C67.7109925,13.1213169 68.1519154,14.188427 68.1519154,15.4371134 L68.1519154,18.4866644 C68.1519154,19.7353508 67.7137425,20.7996674 66.8383134,21.6796142 C65.9628844,22.559561 64.9087028,23 63.6748519,23 Z M80,15.9269039 C80,16.3068174 79.8689148,16.6317925 79.6076611,16.9027602 C79.3454907,17.173728 79.0319863,17.3096774 78.6653144,17.3096774 L76.8438719,17.3096774 L76.8438719,18.6589292 C76.8438719,19.0388427 76.7127867,19.3638178 76.4506164,19.6347855 C76.1893627,19.9057532 75.8749415,20.0417027 75.5082697,20.0417027 C75.1315143,20.0417027 74.8125098,19.9057532 74.5503394,19.6347855 C74.2890857,19.3638178 74.1580005,19.0388427 74.1580005,18.6589292 L74.1580005,13.1464583 C74.1580005,12.00858 74.5485061,11.0355171 75.3276838,10.2272697 C76.1077782,9.41995344 77.0473748,9.01582973 78.1473904,9.01582973 L78.6653144,9.01582973 C79.0319863,9.01582973 79.3454907,9.15177918 79.6076611,9.42274692 C79.8689148,9.69371467 80,10.0186897 80,10.3986033 C80,10.7775856 79.8689148,11.1034919 79.6076611,11.3744596 C79.3454907,11.6454273 79.0319863,11.7804456 78.6653144,11.7804456 L78.162974,11.7804456 C77.7963021,11.7804456 77.481881,11.9163951 77.2206273,12.1873628 C76.9584569,12.4583306 76.8282884,12.7777187 76.8282884,13.1464583 L76.8282884,14.5450615 L78.6653144,14.5450615 C79.0319863,14.5450615 79.3454907,14.681011 79.6076611,14.9519787 C79.8689148,15.2229465 80,15.5479215 80,15.9269039 Z M72.6344789,18.6589292 C72.6344789,19.0388427 72.5043104,19.3638178 72.24214,19.6347855 C71.9808863,19.9057532 71.6664652,20.0417027 71.2997933,20.0417027 C70.9340382,20.0417027 70.616867,19.9057532 70.3501132,19.6347855 C70.0833594,19.3638178 69.9495242,19.0388427 69.9495242,18.6589292 L69.9495242,14.170735 C69.9495242,13.7917526 70.0806094,13.4667775 70.3418631,13.1958098 C70.6040335,12.9239109 70.9175379,12.7888926 71.2842098,12.7888926 C71.6508817,12.7888926 71.9671361,12.9239109 72.2348066,13.1958098 C72.5015604,13.4667775 72.6344789,13.7917526 72.6344789,14.170735 L72.6344789,18.6589292 Z M58.3370263,12.5356169 C58.1023563,11.7441304 58.0042716,10.9163286 58.0042716,10.9163286 C57.9721878,10.6937812 58.1243566,10.547589 58.3425264,10.5904223 C58.3425264,10.5904223 58.5350291,10.6267376 58.8017829,10.6807449 C59.0767868,10.7375457 59.4324585,10.8139009 59.7404628,10.8921184 C60.3473048,11.0448287 60.95323,11.2720319 60.95323,11.2720319 C60.95323,11.2720319 60.2904706,11.6621882 59.7239626,12.3018956 C59.1565379,12.9406718 58.8650338,13.8420353 58.8650338,13.8420353 C58.8650338,13.8420353 58.5716963,13.3280346 58.3370263,12.5356169 Z M69.088762,12.5356169 C69.323432,11.7441304 69.4224334,10.9163286 69.4224334,10.9163286 C69.4536005,10.6937812 69.3014317,10.547589 69.0832619,10.5904223 C69.0832619,10.5904223 68.2921674,10.7384769 67.6853254,10.8921184 C67.0794002,11.0448287 66.4725583,11.2720319 66.4725583,11.2720319 C66.4725583,11.2720319 67.1353177,11.6621882 67.7027424,12.3018956 C68.2692504,12.9406718 68.5616712,13.8420353 68.5616712,13.8420353 C68.5616712,13.8420353 68.8550087,13.3280346 69.088762,12.5356169 Z M72.6344789,10.3818424 C72.6344789,10.7617559 72.5043104,11.086731 72.24214,11.3576987 C71.9808863,11.6286664 71.6664652,11.7646159 71.2997933,11.7646159 C70.9340382,11.7646159 70.616867,11.6286664 70.3501132,11.3576987 C70.0833594,11.086731 69.9495242,10.7617559 69.9495242,10.3818424 C69.9495242,10.00286 70.0806094,9.67788494 70.3418631,9.40691719 C70.6040335,9.13594945 70.9175379,9 71.2842098,9 C71.6508817,9 71.9671361,9.13594945 72.2348066,9.40691719 C72.5015604,9.67788494 72.6344789,10.00286 72.6344789,10.3818424 Z'/>
                                    </g>
                                </g>
                            </g>
                        </g>
                    </g>
                </svg>
            </span>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {EmojiCategory, Emoji, SystemEmoji, CustomEmoji} from '@mattermost/types/emojis';

import {
    CATEGORY_HEADER_ROW,
    EMOJIS_ROW,
} from 'components/emoji_picker/constants';

export type Category = {
    className: string;
    emojiIds?: string[];
    id: string;
    message: string;
    name: EmojiCategory;
};

export type Categories = Record<EmojiCategory, Category>;

export type CategoryOrEmojiRow = CategoryHeaderRow | EmojiRow;

export type CategoryHeaderRow = {
    index: number;
    type: typeof CATEGORY_HEADER_ROW;
    items: Array<{
        categoryIndex: number;
        categoryName: EmojiCategory;
        emojiIndex: -1;
        emojiId: '';
        item: undefined;
    }>;
}

export type EmojiRow = {
    index: number;
    type: typeof EMOJIS_ROW;
    items: Array<{
        categoryIndex: number;
        categoryName: EmojiCategory;
        emojiIndex: number;
        emojiId: CustomEmoji['id'] | SystemEmoji['unified'];
        item: Emoji;
    }>;
}

export type EmojiCursor = {
    rowIndex: number;
    emojiId: CustomEmoji['id'] | SystemEmoji['unified'];
    emoji: Emoji | undefined;
};

export type EmojiPosition = {
    rowIndex: number;
    emojiId: CustomEmoji['id'] | SystemEmoji['unified'];
    categoryName: EmojiCategory;
}

export enum NavigationDirection {
    NextEmoji = 'next',
    PreviousEmoji = 'previous',
    NextEmojiRow = 'nextRow',
    PreviousEmojiRow = 'previousRow',
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {EmojiCategory} from '@mattermost/types/emojis';

import * as Emoji from 'utils/emoji';

import {Category, Categories} from '../types';

export const RECENT = 'recent';
export const SEARCH_RESULTS = 'searchResults';
export const SMILEY_EMOTION = 'smileys-emotion';
export const CUSTOM = 'custom';

const categoryClass: Map<EmojiCategory, string> = new Map([
    [RECENT, 'icon-clock-outline'],
    [SMILEY_EMOTION, 'icon-emoticon-happy-outline'],
    ['people-body', 'icon-account-outline'],
    ['animals-nature', 'icon-leaf-outline'],
    ['food-drink', 'icon-food-apple'],
    ['activities', 'icon-basketball'],
    ['travel-places', 'icon-airplane-variant'],
    ['objects', 'icon-lightbulb-outline'],
    ['symbols', 'icon-heart-outline'],
    ['flags', 'icon-flag-outline'],
    [CUSTOM, 'icon-emoticon-custom-outline'],
    [SEARCH_RESULTS, ''],
]);

function createCategory(name: EmojiCategory): Category {
    return {
        name,
        id: Emoji.CategoryTranslations.get(name) || '',
        className: categoryClass.get(name) || '',
        message: Emoji.CategoryMessage.get(name)!,
    };
}

export const RECENT_EMOJI_CATEGORY: Pick<Categories, 'recent'> = {recent: createCategory(RECENT)};
export const SEARCH_EMOJI_CATEGORY: Pick<Categories, typeof SEARCH_RESULTS> = {searchResults: createCategory(SEARCH_RESULTS)};

export const CATEGORIES: Categories = Emoji.CategoryNames.
    filter((category) => !(category === 'recent' || category === 'searchResults')).
    reduce((previousCategory, currentCategory) => {
        return {
            ...previousCategory,
            [currentCategory]: createCategory(currentCategory as EmojiCategory),
        };
    }, {} as Categories);

export const EMOJI_PER_ROW = 9; // needs to match variable `$emoji-per-row` in _variables.scss
export const ITEM_HEIGHT = 36; //as per .emoji-picker__item height in _emoticons.scss
export const EMOJI_CONTAINER_HEIGHT = 290; // If this changes, the spaceRequiredAbove and spaceRequiredBelow props passed to the EmojiPickerOverlay must be updated

export const CATEGORY_HEADER_ROW = 'categoryHeaderRow';
export const EMOJIS_ROW = 'emojisRow';

export const EMOJI_SCROLL_THROTTLE_DELAY = 150;
export const EMOJI_ROWS_OVERSCAN_COUNT = 1;

export const CUSTOM_EMOJIS_PER_PAGE = 200;
export const CUSTOM_EMOJI_SEARCH_THROTTLE_TIME_MS = 1000;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import isEmpty from 'lodash/isEmpty';

import {isSystemEmoji} from 'mattermost-redux/utils/emoji_utils';
import {Emoji, EmojiCategory, SystemEmoji} from '@mattermost/types/emojis';

import {
    Categories,
    Category,
    CategoryOrEmojiRow,
    CategoryHeaderRow,
    EmojiRow,
    EmojiPosition,
    EmojiCursor,
} from 'components/emoji_picker/types';

import {EmojiIndicesByCategory, Emojis as EmojisJson} from 'utils/emoji';
import {compareEmojis, convertEmojiSkinTone, emojiMatchesSkin, getSkin} from 'utils/emoji_utils';
import EmojiMap from 'utils/emoji_map';

import {
    EMOJI_PER_ROW,
    CATEGORY_HEADER_ROW,
    EMOJIS_ROW,
    SEARCH_RESULTS,
    RECENT,
    RECENT_EMOJI_CATEGORY,
    CATEGORIES,
} from 'components/emoji_picker/constants';

export function isCategoryHeaderRow(row: CategoryOrEmojiRow): row is CategoryHeaderRow {
    return row.type === CATEGORY_HEADER_ROW;
}

function updateSkinTone(initialEmoji: SystemEmoji, skinTone: string): Emoji {
    const initialEmojiSkin = getSkin(initialEmoji);
    if (initialEmojiSkin && initialEmojiSkin !== skinTone) {
        const emojiWithUpdatedSkinTone = convertEmojiSkinTone(initialEmoji, skinTone);
        if (emojiWithUpdatedSkinTone && emojiWithUpdatedSkinTone.unified) {
            return emojiWithUpdatedSkinTone;
        }
    }
    return initialEmoji;
}

function convertEmojisToUserSkinTone(emojiIds: string[], allEmojis: Record<string, Emoji>, userSkinTone: string): Emoji[] {
    return emojiIds.map((emojiId) => {
        const emoji = allEmojis[emojiId];
        return isSystemEmoji(emoji) ? updateSkinTone(emoji, userSkinTone) : emoji;
    });
}

function isEmojiIdEqual(firstEmoji: Emoji, secondEmoji: Emoji): boolean {
    const firstEmojiId = isSystemEmoji(firstEmoji) ? firstEmoji.unified : firstEmoji.id;
    const secondEmojId = isSystemEmoji(secondEmoji) ? secondEmoji.unified : secondEmoji.id;
    return firstEmojiId === secondEmojId;
}

export function getFilteredEmojis(allEmojis: Record<string, Emoji>, filter: string, recentEmojisString: string[], userSkinTone: string): Emoji[] {
    const filteredEmojisWithRecent = Object.values(allEmojis).filter((emoji) => {
        const aliases = isSystemEmoji(emoji) ? emoji.short_names : [emoji.name];

        for (let i = 0; i < aliases.length; i++) {
            if (aliases[i].toLowerCase().includes(filter)) {
                return true;
            }
        }

        return false;
    });

    // Form a separate array of recent emojis
    const recentEmojis = convertEmojisToUserSkinTone(recentEmojisString, allEmojis, userSkinTone);

    const filteredRecentEmojis = filteredEmojisWithRecent.filter((emoji) => {
        return recentEmojis.some((recentEmojis) => isEmojiIdEqual(recentEmojis, emoji));
    });

    const sortedRecentEmojis = filteredRecentEmojis.sort((firstEmoji, secondEmoji) =>
        compareEmojis(firstEmoji, secondEmoji, filter),
    );

    // Seprate out recent emojis from the rest of the emoji result
    const filtertedEmojisMinusRecent = filteredEmojisWithRecent.filter((emoji) => {
        return !recentEmojis.some((recentEmojis) => isEmojiIdEqual(recentEmojis, emoji));
    });

    const sortedFiltertedEmojisMinusRecent = filtertedEmojisMinusRecent.sort((firstEmoji, secondEmoji) =>
        compareEmojis(firstEmoji, secondEmoji, filter),
    );

    const filteredEmojis = [...sortedRecentEmojis, ...sortedFiltertedEmojisMinusRecent];

    const filteredEmojisUserSkinTone = filteredEmojis.filter((emoji) => {
        return emojiMatchesSkin(emoji, userSkinTone);
    });

    return filteredEmojisUserSkinTone;
}

function getEmojisByCategory(
    allEmojis: Record<string, Emoji>,
    category: Category,
): Emoji[] {
    const emojiIds = category?.emojiIds ?? [];

    if (emojiIds.length === 0) {
        return [];
    }

    // For all other categories, return emojis of the categoryies from allEmojis
    return emojiIds.map((emojiId) => allEmojis[emojiId]);
}

export function getUpdatedCategoriesAndAllEmojis(
    emojiMap: EmojiMap,
    recentEmojis: string[],
    userSkinTone: string,
    allEmojis: Record<string, Emoji>,
): [Categories, Record<string, Emoji>] {
    const customEmojiMap = emojiMap.customEmojis;
    const categories: Categories = recentEmojis.length ? {...RECENT_EMOJI_CATEGORY, ...CATEGORIES} : CATEGORIES;

    Object.keys(categories).forEach((categoryName) => {
        let categoryEmojis: Emoji[] = [];

        if (categoryName === 'recent' && recentEmojis.length) {
            categoryEmojis = [...recentEmojis].
                reverse().
                filter((name) => {
                    return emojiMap.has(name);
                }).
                map((name) => {
                    return emojiMap.get(name)!;
                });
        } else {
            const indices = (EmojiIndicesByCategory.get(userSkinTone) as Map<string, number[]>).get(categoryName) || [];
            categoryEmojis = indices.map((index) => EmojisJson[index]);

            if (categoryName === 'custom') {
                categoryEmojis = categoryEmojis.concat([...customEmojiMap.values()]);
            }
        }

        // populate each category with emojiIds
        categories[categoryName as EmojiCategory].emojiIds = categoryEmojis.
            map((emoji: Emoji) => (isSystemEmoji(emoji) ? emoji.unified.toLowerCase() : emoji.id));

        // populate allEmojis with emoji objects
        categoryEmojis.forEach((currentEmoji: Emoji) => {
            const currentEmojiId = isSystemEmoji(currentEmoji) ? currentEmoji.unified.toLowerCase() : currentEmoji.id;
            allEmojis[currentEmojiId] = {...allEmojis[currentEmojiId], ...currentEmoji};

            if (!isSystemEmoji(currentEmoji)) {
                allEmojis[currentEmojiId] = {...allEmojis[currentEmojiId], category: 'custom'};
            }
        });
    });

    const updatedAllEmojis = Object.assign({}, allEmojis);

    return [categories, updatedAllEmojis];
}

export function calculateCategoryRowIndex(categories: Categories, categoryName: EmojiCategory) {
    const categoryIndex = Object.keys(categories).findIndex((category) => category === categoryName);

    const categoriesTillCurrentCategory = Object.values(categories).slice(0, categoryIndex);

    const rowIndex = categoriesTillCurrentCategory.reduce((previousIndexSum, currentCategory) => {
        const emojisInCurrentCategory = currentCategory?.emojiIds?.length ?? 0;

        const numberOfEmojiRowsInCurrentCategory = Math.ceil(emojisInCurrentCategory / EMOJI_PER_ROW);

        return previousIndexSum + numberOfEmojiRowsInCurrentCategory + 1;
    }, 0);

    return rowIndex;
}

export function splitEmojisToRows(emojis: Emoji[], categoryIndex: number, categoryName: EmojiCategory, rowIndexCounter: number): [EmojiRow[], number] {
    if (emojis.length === 0) {
        return [[], rowIndexCounter - 1];
    }

    const emojiRows: EmojiRow[] = [];
    let emojisIndividualRow: EmojiRow['items'] = [];
    let emojiRowIndexCounter = rowIndexCounter;

    // create `EMOJI_PER_ROW` row lenght array of emojis
    emojis.forEach((emoji, emojiIndex) => {
        emojisIndividualRow.push({
            categoryIndex,
            categoryName,
            emojiIndex,
            emojiId: isSystemEmoji(emoji) ? emoji.unified : emoji.id,
            item: emoji,
        });

        if ((emojiIndex + 1) % EMOJI_PER_ROW === 0) {
            emojiRows.push({
                index: emojiRowIndexCounter,
                type: EMOJIS_ROW,
                items: emojisIndividualRow,
            });

            emojiRowIndexCounter++;
            emojisIndividualRow = [];
        }
    });

    // if there are emojis left over that is less than `EMOJI_PER_ROW`, add them in next row
    if (emojisIndividualRow.length) {
        emojiRows.push({
            index: emojiRowIndexCounter,
            type: EMOJIS_ROW,
            items: emojisIndividualRow,
        });

        emojiRowIndexCounter++;
    }

    return [emojiRows, emojiRowIndexCounter];
}

export function createEmojisPositions(categoryOrEmojiRows: CategoryOrEmojiRow[]): EmojiPosition[] {
    const emojisPositions2DArray: EmojiPosition[][] = [];

    categoryOrEmojiRows.forEach((categoryOrEmojiRow) => {
        if (!isCategoryHeaderRow(categoryOrEmojiRow)) {
            const rowIndex = categoryOrEmojiRow.index;
            const emojisOfARow: EmojiPosition[] = categoryOrEmojiRow.items.map((emojiItem) => ({
                rowIndex,
                emojiId: emojiItem.emojiId,
                categoryName: emojiItem.categoryName,
            }));

            emojisPositions2DArray.push(emojisOfARow);
        }
    });

    const emojisPositions = emojisPositions2DArray.flat();
    return emojisPositions;
}

export function createCategoryAndEmojiRows(
    allEmojis: Record<string, Emoji>,
    categories: Categories,
    filter: string,
    userSkinTone: string,
): [CategoryOrEmojiRow[], EmojiPosition[]] {
    if (isEmpty(allEmojis) || isEmpty(categories)) {
        return [[], []];
    }

    // If search is active, return filtered emojis
    if (filter.length) {
        const searchCategoryRow: CategoryHeaderRow = {
            index: 0,
            type: CATEGORY_HEADER_ROW,
            items: [{
                categoryIndex: 0,
                categoryName: SEARCH_RESULTS,
                emojiIndex: -1,
                emojiId: '',
                item: undefined,
            }],
        };

        const recentEmojiIds = categories?.[RECENT]?.emojiIds ?? [];
        const filteredEmojis = getFilteredEmojis(allEmojis, filter, recentEmojiIds, userSkinTone);
        const [searchEmojisRows] = splitEmojisToRows(filteredEmojis, 0, SEARCH_RESULTS, 1);

        const searchEmojiRowsWithCategoryHeader: CategoryOrEmojiRow[] = [searchCategoryRow, ...searchEmojisRows];

        const emojisPositions = createEmojisPositions(searchEmojiRowsWithCategoryHeader);

        return [searchEmojiRowsWithCategoryHeader, emojisPositions];
    }

    let sortedEmojis: Emoji[] = [];

    let rowIndexCounter = 0;
    let categoryOrEmojisRows: CategoryOrEmojiRow[] = [];
    Object.keys(categories).forEach((categoryName, categoryIndex) => {
        const emojis = getEmojisByCategory(
            allEmojis,
            categories[categoryName as EmojiCategory],
        );

        sortedEmojis = [...sortedEmojis, ...emojis];

        // Add for the category header
        const categoryRow: CategoryHeaderRow = {
            index: rowIndexCounter,
            type: CATEGORY_HEADER_ROW,
            items: [{
                categoryIndex,
                categoryName: categoryName as EmojiCategory,
                emojiIndex: -1,
                emojiId: '',
                item: undefined,
            }],
        };

        categoryOrEmojisRows = [...categoryOrEmojisRows, categoryRow];
        rowIndexCounter += 1;

        const [emojiRows, increasedRowIndexCounter] = splitEmojisToRows(emojis, categoryIndex, categoryName as EmojiCategory, rowIndexCounter);

        rowIndexCounter = increasedRowIndexCounter;

        categoryOrEmojisRows = [...categoryOrEmojisRows, ...emojiRows];
    });

    const emojisPositions = createEmojisPositions(categoryOrEmojisRows);

    return [categoryOrEmojisRows, emojisPositions];
}

export function getCursorProperties(cursorRowIndex: EmojiCursor['rowIndex'], cursorEmojiId: EmojiCursor['emojiId'], categoryOrEmojisRows: EmojiRow[]): [string, number, number] {
    if (cursorEmojiId.length === 0 || cursorRowIndex === -1) {
        return ['', -1, -1];
    }

    const emojisRowOfCursor = categoryOrEmojisRows?.[cursorRowIndex]?.items ?? [];

    // The row should atleast contain one emoji
    if (emojisRowOfCursor.length < 1) {
        return ['', -1, -1];
    }

    const cursorCategory = emojisRowOfCursor[0]?.categoryName ?? '';
    const cursorCategoryIndex = emojisRowOfCursor[0]?.categoryIndex ?? -1;

    const cursorEmojiIndex = emojisRowOfCursor.find((emojiItem) => {
        return emojiItem.emojiId === cursorEmojiId;
    })?.emojiIndex ?? -1;

    return [cursorCategory, cursorCategoryIndex, cursorEmojiIndex];
}

export default __webpack_public_path__ + "files/bb70781ccd4fbf5f99bf8a8060f82662.gif";
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo} from 'react';
import {FormattedMessage} from 'react-intl';

import {Emoji} from '@mattermost/types/emojis';
import {getEmojiImageUrl, isSystemEmoji} from 'mattermost-redux/utils/emoji_utils';

import imgTrans from 'images/img_trans.gif';

interface Props {
    emoji?: Emoji;
}

function EmojiPickerPreview({emoji}: Props) {
    if (!emoji) {
        return (
            <div className='emoji-picker__preview emoji-picker__preview-placeholder'>
                <FormattedMessage
                    id='emoji_picker.emojiPicker'
                    defaultMessage='Select an Emoji'
                />
            </div>
        );
    }

    let aliases;
    let previewImage;

    if (isSystemEmoji(emoji)) {
        aliases = emoji.short_names;
        previewImage = (
            <span className='sprite-preview'>
                <img
                    id='emojiPickerSpritePreview'
                    alt={'emoji category image'}
                    src={imgTrans}
                    className={'emojisprite-preview emoji-category-' + emoji.category + ' emoji-' + emoji.unified.toLowerCase()}
                />
            </span>
        );
    } else {
        aliases = [emoji.name];
        previewImage = (
            <img
                id='emojiPickerSpritePreview'
                alt={'emoji preview image'}
                className='emoji-picker__preview-image'
                src={getEmojiImageUrl(emoji)}
            />
        );
    }

    return (
        <div className='emoji-picker__preview'>
            <div className='emoji-picker__preview-image-box'>
                {previewImage}
            </div>
            <div className='emoji-picker__preview-image-label-box'>
                <span
                    className='emoji-picker__preview-name'
                    data-testid='emoji_picker_preview'
                >
                    {':' + aliases.join(': :') + ':'}
                </span>
            </div>
        </div>
    );
}

export default memo(EmojiPickerPreview);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {
    ChangeEvent,
    forwardRef,
    KeyboardEvent,
    memo,
} from 'react';
import {useIntl} from 'react-intl';

import {NavigationDirection} from 'components/emoji_picker/types';
import {EMOJI_PER_ROW} from 'components/emoji_picker/constants';

interface Props {
    value: string;
    cursorCategoryIndex: number;
    cursorEmojiIndex: number;
    focus: () => void;
    onEnter: () => void;
    onChange: (value: string) => void;
    onKeyDown: (moveTo: NavigationDirection) => void;
    resetCursorPosition: () => void;
}

const EmojiPickerSearch = forwardRef<HTMLInputElement, Props>(({value, cursorCategoryIndex, cursorEmojiIndex, onChange, resetCursorPosition, onKeyDown, focus, onEnter}: Props, ref) => {
    const {formatMessage} = useIntl();

    const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
        event.preventDefault();

        // remove trailing and leading colons
        const value = event.target.value.toLowerCase().replace(/^:|:$/g, '');
        onChange(value);

        resetCursorPosition();
    };

    const handleKeyDown = (event: KeyboardEvent<HTMLInputElement>) => {
        switch (event.key) {
        case 'ArrowRight':
            // If the cursor is at the end of the textbox and an emoji is currently selected, move it to the next emoji
            if ((event.currentTarget?.selectionStart ?? 0) + 1 > value.length || (cursorCategoryIndex !== -1 || cursorEmojiIndex !== -1)) {
                event.stopPropagation();
                event.preventDefault();

                onKeyDown(NavigationDirection.NextEmoji);
            }
            break;
        case 'ArrowLeft':
            if (cursorCategoryIndex > 0 || cursorEmojiIndex > 0) {
                event.stopPropagation();
                event.preventDefault();

                onKeyDown(NavigationDirection.PreviousEmoji);
            } else if (cursorCategoryIndex === 0 && cursorEmojiIndex === 0) {
                resetCursorPosition();
                event.currentTarget.selectionStart = value.length;
                event.currentTarget.selectionEnd = value.length;

                event.stopPropagation();
                event.preventDefault();

                focus();
            }
            break;
        case 'ArrowUp':
            event.stopPropagation();
            event.preventDefault();

            if (event.shiftKey) {
                // If Shift + Ctrl/Cmd + Up is pressed at any time, select/highlight the string to the left of the cursor.
                event.currentTarget.selectionStart = 0;
            } else if (cursorCategoryIndex === -1) {
                // If cursor is on the textbox, set the cursor to the beginning of the string.
                event.currentTarget.selectionStart = 0;
                event.currentTarget.selectionEnd = 0;
            } else if (cursorCategoryIndex === 0 && cursorEmojiIndex < EMOJI_PER_ROW) {
                // If the cursor is highlighting an emoji in the top row,
                // move the cursor back into the text box to the end of the string.
                resetCursorPosition();
                event.currentTarget.selectionStart = value.length;
                event.currentTarget.selectionEnd = value.length;
                focus();
            } else {
                // Otherwise, move the emoji selector up a row.
                onKeyDown(NavigationDirection.PreviousEmojiRow);
            }
            break;
        case 'ArrowDown':
            event.stopPropagation();
            event.preventDefault();

            if (event.shiftKey) {
                // If Shift + Ctrl/Cmd + Down is pressed at any time, select/highlight the string to the right of the cursor.
                event.currentTarget.selectionEnd = value.length;
            } else if (value && event.currentTarget.selectionStart === 0) {
                // If the cursor is at the beginning of the string, move the cursor to the end of the string.
                event.currentTarget.selectionStart = value.length;
                event.currentTarget.selectionEnd = value.length;
            } else {
                // Otherwise, move the selection down in the emoji picker.
                onKeyDown(NavigationDirection.NextEmojiRow);
            }
            break;
        case 'Enter': {
            event.stopPropagation();
            event.preventDefault();

            onEnter();
            break;
        }
        }
    };

    return (
        <div className='emoji-picker__text-container'>
            <span className='icon-magnify icon emoji-picker__search-icon'/>
            <input
                ref={ref}
                id='emojiPickerSearch'
                aria-label={formatMessage({id: 'emoji_picker.search_emoji', defaultMessage: 'Search for an emoji'})}
                className='emoji-picker__search'
                data-testid='emojiInputSearch'
                type='text'
                onChange={handleChange}
                onKeyDown={handleKeyDown}
                autoComplete='off'
                placeholder={formatMessage({id: 'emoji_picker.search', defaultMessage: 'Search Emoji'})}
                value={value}
            />
        </div>
    );
},
);

EmojiPickerSearch.displayName = 'EmojiPickerSearch';

export default memo(EmojiPickerSearch);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage, injectIntl, IntlShape} from 'react-intl';
import classNames from 'classnames';
import {CSSTransition} from 'react-transition-group';

import {CloseIcon} from '@mattermost/compass-icons/components';

import {Constants} from 'utils/constants';
import * as Emoji from 'utils/emoji';
import imgTrans from 'images/img_trans.gif';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';

const skinsList = [
    ['raised_hand_with_fingers_splayed_dark_skin_tone', '1F3FF'],
    ['raised_hand_with_fingers_splayed_medium_dark_skin_tone', '1F3FE'],
    ['raised_hand_with_fingers_splayed_medium_skin_tone', '1F3FD'],
    ['raised_hand_with_fingers_splayed_medium_light_skin_tone', '1F3FC'],
    ['raised_hand_with_fingers_splayed_light_skin_tone', '1F3FB'],
    ['raised_hand_with_fingers_splayed', 'default'],
];

const skinToneEmojis = new Map(skinsList.map((pair) => [pair[1], Emoji.Emojis[Emoji.EmojiIndicesByAlias.get(pair[0])!]]));

type Props = {
    userSkinTone: string;
    onSkinSelected: (skin: string) => void;
    intl: IntlShape;
};

type State = {
    pickerExtended: boolean;
}

export class EmojiPickerSkin extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            pickerExtended: false,
        };
    }

    ariaLabel = (skin: string) => {
        return this.props.intl.formatMessage({
            id: 'emoji_skin_item.emoji_aria_label',
            defaultMessage: '{skinName} emoji',
        },
        {
            skinName: Emoji.SkinTranslations.get(skin),
        });
    }

    hideSkinTonePicker = (skin: string) => {
        this.setState({pickerExtended: false});
        if (skin !== this.props.userSkinTone) {
            this.props.onSkinSelected(skin);
        }
    }

    showSkinTonePicker = () => {
        this.setState({pickerExtended: true});
    }

    extended() {
        const closeButtonLabel = this.props.intl.formatMessage({
            id: 'emoji_skin.close',
            defaultMessage: 'Close skin tones',
        });
        const choices = skinsList.map((skinPair) => {
            const skin = skinPair[1];
            const emoji = skinToneEmojis.get(skin)!;
            const spriteClassName = classNames('emojisprite', `emoji-category-${emoji.category}`, `emoji-${emoji.unified.toLowerCase()}`);

            return (
                <button
                    className='style--none skin-tones__icon'
                    data-testid={`skin-pick-${skin}`}
                    aria-label={this.ariaLabel(skin)}
                    key={skin}
                    onClick={() => this.hideSkinTonePicker(skin)}
                >
                    <img
                        src={imgTrans}
                        className={spriteClassName}
                    />
                </button>
            );
        });
        return (
            <>
                <div className='skin-tones__close'>
                    <button
                        className='skin-tones__close-icon style--none'
                        onClick={() => this.hideSkinTonePicker(this.props.userSkinTone)}
                        aria-label={closeButtonLabel}
                    >
                        <CloseIcon
                            size={16}
                            color={'rgba(var(--center-channel-color-rgb), 0.56)'}
                        />
                    </button>
                    <div className='skin-tones__close-text'>
                        <FormattedMessage
                            id={Emoji.SkinTranslations.get('default')}
                        />
                    </div>
                </div>
                <div className='skin-tones__icons'>
                    {choices}
                </div>
            </>
        );
    }
    collapsed() {
        const emoji = skinToneEmojis.get(this.props.userSkinTone)!;
        const spriteClassName = classNames('emojisprite', `emoji-category-${emoji.category}`, `emoji-${emoji.unified.toLowerCase()}`);
        const expandButtonLabel = this.props.intl.formatMessage({
            id: 'emoji_picker.skin_tone',
            defaultMessage: 'Skin tone',
        });

        const tooltip = (
            <Tooltip
                id='skinTooltip'
                className='emoji-tooltip'
            >
                <span>
                    {expandButtonLabel}
                </span>
            </Tooltip>
        );

        return (
            <OverlayTrigger
                trigger={['hover', 'focus']}
                delayShow={Constants.OVERLAY_TIME_DELAY}
                placement='top'
                overlay={tooltip}
            >
                <button
                    data-testid={`skin-picked-${this.props.userSkinTone}`}
                    className='style--none skin-tones__icon skin-tones__expand-icon'
                    onClick={this.showSkinTonePicker}
                    aria-label={expandButtonLabel}
                >
                    <img
                        alt={'emoji skin tone picker'}
                        src={imgTrans}
                        className={spriteClassName}
                    />
                </button>
            </OverlayTrigger>
        );
    }

    render() {
        return (
            <CSSTransition
                in={this.state.pickerExtended}
                classNames='skin-tones-animation'
                timeout={200}
            >
                <div className={classNames('skin-tones', {'skin-tones--active': this.state.pickerExtended})}>
                    <div className={classNames('skin-tones__content', {'skin-tones__content__single': !this.state.pickerExtended})}>
                        {this.state.pickerExtended ? this.extended() : this.collapsed()}
                    </div>
                </div>
            </CSSTransition>
        );
    }
}

export default injectIntl(EmojiPickerSkin);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo} from 'react';
import {FormattedMessage} from 'react-intl';
import classNames from 'classnames';

import {Category, CategoryOrEmojiRow} from 'components/emoji_picker/types';
import {EmojiCategory} from '@mattermost/types/emojis';

import {Constants} from 'utils/constants';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';

interface Props {
    category: Category;
    categoryRowIndex: CategoryOrEmojiRow['index'];
    selected: boolean;
    enable: boolean;
    onClick: (categoryRowIndex: CategoryOrEmojiRow['index'], categoryName: EmojiCategory, firstEmojiId: string) => void;
}

function EmojiPickerCategory({category, categoryRowIndex, selected, enable, onClick}: Props) {
    const handleClick = (event: React.MouseEvent) => {
        event.preventDefault();

        if (enable) {
            const firstEmojiId = category?.emojiIds?.[0] ?? '';

            onClick(categoryRowIndex, category.name, firstEmojiId);
        }
    };

    const className = classNames('emoji-picker__category', {
        'emoji-picker__category--selected': selected,
        disable: !enable,
    });

    return (
        <OverlayTrigger
            trigger={['hover', 'focus']}
            delayShow={Constants.OVERLAY_TIME_DELAY}
            placement='bottom'
            overlay={
                <Tooltip
                    id='skinTooltip'
                    className='emoji-tooltip'
                >
                    <FormattedMessage
                        id={`emoji_picker.${category.name}`}
                        defaultMessage={category.message}
                    />
                </Tooltip>
            }
        >
            <a
                className={className}
                href='#'
                onClick={handleClick}
                aria-label={category.id}
            >
                <i className={category.className}/>
            </a>
        </OverlayTrigger>
    );
}

export default memo(EmojiPickerCategory);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {KeyboardEvent, memo} from 'react';

import {EmojiCategory} from '@mattermost/types/emojis';

import {
    Categories,
    CategoryOrEmojiRow,
    NavigationDirection,
} from 'components/emoji_picker/types';
import {calculateCategoryRowIndex} from 'components/emoji_picker/utils';
import EmojiPickerCategory from 'components/emoji_picker/components/emoji_picker_category';

interface Props {
    isFiltering: boolean;
    active: EmojiCategory;
    categories: Categories;
    onClick: (categoryRowIndex: CategoryOrEmojiRow['index'], categoryName: EmojiCategory, firstEmojiId: string) => void;
    onKeyDown: (moveTo: NavigationDirection) => void;
    focusOnSearchInput: () => void;
}

function EmojiPickerCategories({
    categories,
    isFiltering,
    active,
    onClick,
    onKeyDown,
    focusOnSearchInput,
}: Props) {
    const handleKeyDown = (event: KeyboardEvent<HTMLDivElement>) => {
        switch (event.key) {
        case 'ArrowRight':
            event.stopPropagation();
            event.preventDefault();
            onKeyDown(NavigationDirection.NextEmoji);
            focusOnSearchInput();
            break;
        case 'ArrowLeft':
            event.stopPropagation();
            event.preventDefault();
            onKeyDown(NavigationDirection.PreviousEmoji);
            focusOnSearchInput();
            break;
        case 'ArrowUp':
            event.stopPropagation();
            event.preventDefault();
            onKeyDown(NavigationDirection.PreviousEmojiRow);
            focusOnSearchInput();
            break;
        case 'ArrowDown':
            event.stopPropagation();
            event.preventDefault();
            onKeyDown(NavigationDirection.NextEmojiRow);
            focusOnSearchInput();
            break;
        }
    };

    const categoryNames = Object.keys(categories) as EmojiCategory[];

    const activeCategory = isFiltering ? categoryNames[0] : active;

    return (
        <div
            id='emojiPickerCategories'
            className='emoji-picker__categories'
            onKeyDown={handleKeyDown}
        >
            {categoryNames.map((categoryName) => {
                const category = categories[categoryName];

                return (
                    <EmojiPickerCategory
                        key={`${category.id}-${category.name}`}
                        category={category}
                        categoryRowIndex={calculateCategoryRowIndex(categories, categoryName as EmojiCategory)}
                        onClick={onClick}
                        selected={activeCategory === category.name}
                        enable={!isFiltering}
                    />
                );
            },

            )}
        </div>
    );
}

export default memo(EmojiPickerCategories);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo} from 'react';
import {FormattedMessage} from 'react-intl';
import {Link} from 'react-router-dom';

import Permissions from 'mattermost-redux/constants/permissions';

import AnyTeamPermissionGate from 'components/permissions_gates/any_team_permission_gate';

interface Props {
    customEmojisEnabled: boolean;
    currentTeamName: string;
    handleEmojiPickerClose: () => void;
}

function EmojiPickerCustomEmojiButton({customEmojisEnabled, currentTeamName, handleEmojiPickerClose}: Props) {
    if (!customEmojisEnabled) {
        return null;
    }

    if (currentTeamName.length === 0) {
        return null;
    }

    return (
        <AnyTeamPermissionGate permissions={[Permissions.CREATE_EMOJIS]}>
            <div className='emoji-picker__custom'>
                <Link
                    className='btn btn-link'
                    to={`/${currentTeamName}/emoji`}
                    onClick={handleEmojiPickerClose}
                >
                    <FormattedMessage
                        id='emoji_picker.custom_emoji'
                        defaultMessage='Custom Emoji'
                    />
                </Link>
            </div>
        </AnyTeamPermissionGate>
    );
}

export default memo(EmojiPickerCustomEmojiButton);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {CSSProperties, memo} from 'react';
import {FormattedMessage} from 'react-intl';

import {EmojiCategory} from '@mattermost/types/emojis';

interface Props {
    categoryName: EmojiCategory;
    style: CSSProperties;
}

function EmojiPickerCategoryRow({categoryName, style}: Props) {
    return (
        <div
            className='emoji-picker-items__container'
            style={style}
        >
            <div
                className='emoji-picker__category-header'
                id={`emojipickercat-${categoryName}`}
            >
                <FormattedMessage id={`emoji_picker.${categoryName}`}/>
            </div>
        </div>
    );
}

export default memo(EmojiPickerCategoryRow);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo, useCallback} from 'react';
import {useIntl} from 'react-intl';
import classNames from 'classnames';
import throttle from 'lodash/throttle';

import {getEmojiImageUrl, isSystemEmoji} from 'mattermost-redux/utils/emoji_utils';
import {Emoji} from '@mattermost/types/emojis';

import imgTrans from 'images/img_trans.gif';
import {EmojiCursor} from 'components/emoji_picker/types';
import {EMOJI_SCROLL_THROTTLE_DELAY} from 'components/emoji_picker/constants';

interface Props {
    emoji: Emoji;
    rowIndex: number;
    isSelected?: boolean;
    onClick: (emoji: Emoji) => void;
    onMouseOver: (cursor: EmojiCursor) => void;
}

function EmojiPickerItem({emoji, rowIndex, isSelected, onClick, onMouseOver}: Props) {
    const {formatMessage} = useIntl();

    const handleMouseOver = () => {
        if (!isSelected) {
            let emojiId = '';
            if (isSystemEmoji(emoji)) {
                emojiId = emoji.unified;
            } else {
                emojiId = emoji.id;
            }
            onMouseOver({rowIndex, emojiId, emoji});
        }
    };

    const throttledMouseOver = useCallback(
        throttle(handleMouseOver, EMOJI_SCROLL_THROTTLE_DELAY, {
            leading: true,
            trailing: false,
        }), []);

    const handleClick = () => {
        onClick(emoji);
    };

    const itemClassName = classNames('emoji-picker__item', {
        selected: isSelected,
    });

    let content;

    if (isSystemEmoji(emoji)) {
        const emojiName = emoji.short_name ? emoji.short_name : emoji.name;
        const emojiUnified = emoji.unified ? emoji.unified.toLowerCase() : emoji.name.toLowerCase();

        content = (
            <img
                alt={'emoji image'}
                data-testid={emoji.short_names}
                src={imgTrans}
                className={`emojisprite emoji-category-${emoji.category} emoji-${emojiUnified}`}
                id={`emoji-${emojiUnified}`}
                aria-label={formatMessage(
                    {
                        id: 'emoji_picker_item.emoji_aria_label',
                        defaultMessage: '{emojiName} emoji',
                    },
                    {
                        emojiName: (emojiName).replace(/_/g, ' '),
                    },
                )}
                role='button'
            />
        );
    } else {
        content = (
            <img
                alt={'custom emoji image'}
                data-testid={emoji.name}
                src={getEmojiImageUrl(emoji)}
                className={'emoji-category--custom'}
            />
        );
    }

    return (
        <div
            className={itemClassName}
            onClick={handleClick}
            onMouseOver={throttledMouseOver}
        >
            <div data-testid='emojiItem'>
                {content}
            </div>
        </div>
    );
}

function areEqual(prevProps: Props, nextProps: Props) {
    return (
        prevProps.isSelected === nextProps.isSelected
    );
}

export default memo(EmojiPickerItem, areEqual);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo} from 'react';
import {ListChildComponentProps, areEqual} from 'react-window';

import {CustomEmoji, Emoji, SystemEmoji} from '@mattermost/types/emojis';

import {CategoryOrEmojiRow, EmojiCursor} from 'components/emoji_picker/types';
import {isCategoryHeaderRow} from 'components/emoji_picker/utils';
import EmojiPickerCategorySection from 'components/emoji_picker/components/emoji_picker_category_row';
import EmojiPickerItem from 'components/emoji_picker/components/emoji_picker_item';

interface Props extends ListChildComponentProps<CategoryOrEmojiRow[]> {
    cursorRowIndex: number;
    cursorEmojiId: SystemEmoji['unified'] | CustomEmoji['id'];
    onEmojiClick: (emoji: Emoji) => void;
    onEmojiMouseOver: (cursor: EmojiCursor) => void;
}

function EmojiPickerCategoryOrEmojiRow({index, style, data, cursorRowIndex, cursorEmojiId, onEmojiClick, onEmojiMouseOver}: Props) {
    const row = data[index];

    if (isCategoryHeaderRow(row)) {
        return (
            <EmojiPickerCategorySection
                categoryName={row.items[0].categoryName}
                style={style}
            />
        );
    }

    return (
        <div
            style={style}
            className='emoji-picker__row'
        >
            {row.items.map((emojiColumn) => {
                const emoji = emojiColumn.item;
                const isSelected = emojiColumn.emojiId.toLowerCase() === cursorEmojiId.toLowerCase() && cursorRowIndex === index;

                return (
                    <EmojiPickerItem
                        key={`${emojiColumn.categoryName}-${emojiColumn.emojiId}`}
                        emoji={emoji}
                        rowIndex={row.index}
                        isSelected={isSelected}
                        onClick={onEmojiClick}
                        onMouseOver={onEmojiMouseOver}
                    />
                );
            })}
        </div>
    );
}

export default memo(EmojiPickerCategoryOrEmojiRow, areEqual);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {forwardRef, memo, useCallback} from 'react';
import AutoSizer from 'react-virtualized-auto-sizer';
import {FixedSizeList, ListItemKeySelector, ListOnScrollProps} from 'react-window';
import InfiniteLoader from 'react-window-infinite-loader';
import throttle from 'lodash/throttle';

import {Emoji, EmojiCategory, CustomEmoji, SystemEmoji} from '@mattermost/types/emojis';
import {ServerError} from '@mattermost/types/errors';

import {CategoryOrEmojiRow, EmojiCursor} from 'components/emoji_picker/types';
import {ITEM_HEIGHT, EMOJI_ROWS_OVERSCAN_COUNT, EMOJI_CONTAINER_HEIGHT, CUSTOM_EMOJIS_PER_PAGE, EMOJI_SCROLL_THROTTLE_DELAY} from 'components/emoji_picker/constants';
import {isCategoryHeaderRow} from 'components/emoji_picker/utils';
import EmojiPickerCategoryOrEmojiRow from 'components/emoji_picker/components/emoji_picker_category_or_emoji_row';

interface Props {
    categoryOrEmojisRows: CategoryOrEmojiRow[];
    isFiltering: boolean;
    activeCategory: EmojiCategory;
    cursorRowIndex: number;
    cursorEmojiId: SystemEmoji['unified'] | CustomEmoji['name'];
    customEmojisEnabled: boolean;
    customEmojiPage: number;
    setActiveCategory: (category: EmojiCategory) => void;
    onEmojiClick: (emoji: Emoji) => void;
    onEmojiMouseOver: (cursor: EmojiCursor) => void;
    incrementEmojiPickerPage: () => void;
    getCustomEmojis: (page?: number, perPage?: number, sort?: string, loadUsers?: boolean) => Promise<{ data: CustomEmoji[]; error: ServerError }>;
}

const EmojiPickerCurrentResults = forwardRef<InfiniteLoader, Props>(({categoryOrEmojisRows, isFiltering, activeCategory, cursorRowIndex, cursorEmojiId, customEmojisEnabled, customEmojiPage, setActiveCategory, onEmojiClick, onEmojiMouseOver, getCustomEmojis, incrementEmojiPickerPage}: Props, ref) => {
    // Function to create unique key for each row
    const getItemKey = (index: Parameters<ListItemKeySelector>[0], rowsData: Parameters<ListItemKeySelector<CategoryOrEmojiRow[]>>[1]) => {
        const data = rowsData[index];

        if (isCategoryHeaderRow(data)) {
            const categoryRow = data.items[0];
            return `${categoryRow.categoryIndex}-${categoryRow.categoryName}`;
        }

        const emojisRow = data.items;
        const emojiNamesArray = emojisRow.map((emoji) => `${emoji.categoryIndex}-${emoji.emojiId}`);
        return emojiNamesArray.join('--');
    };

    const handleScroll = (scrollOffset: ListOnScrollProps['scrollOffset'], activeCategory: EmojiCategory, isFiltering: boolean, categoryOrEmojisRows: CategoryOrEmojiRow[]) => {
        if (isFiltering) {
            return;
        }

        const approxRowsFromTop = Math.ceil(scrollOffset / ITEM_HEIGHT);
        const closestCategory = categoryOrEmojisRows?.[approxRowsFromTop]?.items[0]?.categoryName;

        if (closestCategory === activeCategory || !closestCategory) {
            return;
        }

        setActiveCategory(closestCategory);
    };

    const throttledScroll = useCallback(throttle(({scrollOffset}: ListOnScrollProps) => {
        handleScroll(scrollOffset, activeCategory, isFiltering, categoryOrEmojisRows);
    }, EMOJI_SCROLL_THROTTLE_DELAY, {leading: false, trailing: true},
    ), [activeCategory, isFiltering, categoryOrEmojisRows]);

    const handleIsItemLoaded = (index: number): boolean => {
        return index < categoryOrEmojisRows.length;
    };

    const handleLoadMoreItems = async () => {
        if (customEmojisEnabled === false) {
            return;
        }

        const {data} = await getCustomEmojis(customEmojiPage, CUSTOM_EMOJIS_PER_PAGE);

        // If data came back empty, or data is less than the perPage, then we know there are no more pages
        if (!data || data.length < CUSTOM_EMOJIS_PER_PAGE) {
            return;
        }

        incrementEmojiPickerPage();
    };

    return (
        <div
            className='emoji-picker__items'
            style={{height: EMOJI_CONTAINER_HEIGHT}}
        >
            <div className='emoji-picker__container'>
                <AutoSizer>
                    {({height, width}) => (
                        <InfiniteLoader
                            ref={ref}
                            itemCount={categoryOrEmojisRows.length + 1} // +1 for the loading row
                            isItemLoaded={handleIsItemLoaded}
                            loadMoreItems={handleLoadMoreItems}
                        >
                            {({onItemsRendered, ref}) => (
                                <FixedSizeList
                                    ref={ref}
                                    onItemsRendered={onItemsRendered}
                                    height={height}
                                    width={width}
                                    layout='vertical'
                                    overscanCount={EMOJI_ROWS_OVERSCAN_COUNT}
                                    itemCount={categoryOrEmojisRows.length}
                                    itemData={categoryOrEmojisRows}
                                    itemKey={getItemKey}
                                    itemSize={ITEM_HEIGHT}
                                    onScroll={throttledScroll}
                                >
                                    {({index, style, data}) => (
                                        <EmojiPickerCategoryOrEmojiRow
                                            index={index}
                                            style={style}
                                            data={data}
                                            cursorRowIndex={cursorRowIndex}
                                            cursorEmojiId={cursorEmojiId}
                                            onEmojiClick={onEmojiClick}
                                            onEmojiMouseOver={onEmojiMouseOver}
                                        />
                                    )}
                                </FixedSizeList>
                            )}
                        </InfiniteLoader>
                    )}
                </AutoSizer>
            </div>
        </div>
    );
});

EmojiPickerCurrentResults.displayName = 'EmojiPickerCurrentResults';

export default memo(EmojiPickerCurrentResults);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useRef, useState, useEffect, useCallback, memo, useMemo} from 'react';
import {FormattedMessage} from 'react-intl';
import type {FixedSizeList} from 'react-window';
import type InfiniteLoader from 'react-window-infinite-loader';
import {throttle} from 'lodash';

import {Emoji, EmojiCategory} from '@mattermost/types/emojis';
import {isSystemEmoji} from 'mattermost-redux/utils/emoji_utils';

import {NoResultsVariant} from 'components/no_results_indicator/types';
import {CategoryOrEmojiRow, Categories, EmojiCursor, NavigationDirection, EmojiPosition, EmojiRow} from 'components/emoji_picker/types';
import {
    CATEGORIES,
    RECENT_EMOJI_CATEGORY,
    RECENT,
    SMILEY_EMOTION,
    SEARCH_RESULTS,
    EMOJI_PER_ROW,
    CUSTOM_EMOJI_SEARCH_THROTTLE_TIME_MS,
} from 'components/emoji_picker/constants';
import {createCategoryAndEmojiRows, getCursorProperties, getUpdatedCategoriesAndAllEmojis} from 'components/emoji_picker/utils';
import NoResultsIndicator from 'components/no_results_indicator';
import EmojiPickerPreview from 'components/emoji_picker/components/emoji_picker_preview';
import EmojiPickerSearch from 'components/emoji_picker/components/emoji_picker_search';
import EmojiPickerSkin from 'components/emoji_picker/components/emoji_picker_skin';
import EmojiPickerCategories from 'components/emoji_picker/components/emoji_picker_categories';
import EmojiPickerCustomEmojiButton from 'components/emoji_picker/components/emoji_picker_custom_emoji_button';
import EmojiPickerCurrentResults from 'components/emoji_picker/components/emoji_picker_current_results';

import type {PropsFromRedux} from './index';

interface Props extends PropsFromRedux {
    filter: string;
    visible: boolean;
    onEmojiClick: (emoji: Emoji) => void;
    handleFilterChange: (filter: string) => void;
    handleEmojiPickerClose: () => void;
}

const EmojiPicker = ({
    filter,
    visible,
    onEmojiClick,
    handleFilterChange,
    handleEmojiPickerClose,
    customEmojisEnabled = false,
    customEmojiPage = 0,
    emojiMap,
    recentEmojis,
    userSkinTone,
    currentTeamName,
    actions: {
        getCustomEmojis,
        searchCustomEmojis,
        incrementEmojiPickerPage,
        setUserSkinTone,
    },
}: Props) => {
    const getInitialActiveCategory = () => (recentEmojis.length ? RECENT : SMILEY_EMOTION);
    const [activeCategory, setActiveCategory] = useState<EmojiCategory>(getInitialActiveCategory);

    const [cursor, setCursor] = useState<EmojiCursor>({
        rowIndex: -1,
        emojiId: '',
        emoji: undefined,
    });

    // On the first load, categories doesnt contain emojiIds until later when getUpdatedCategoriesAndAllEmojis is called
    const getInitialCategories = () => (recentEmojis.length ? {...RECENT_EMOJI_CATEGORY, ...CATEGORIES} : CATEGORIES);
    const [categories, setCategories] = useState<Categories>(getInitialCategories);

    const [allEmojis, setAllEmojis] = useState<Record<string, Emoji>>({});

    const [categoryOrEmojisRows, setCategoryOrEmojisRows] = useState<CategoryOrEmojiRow[]>([]);

    // contains all emojis visible on screen sorted by category
    const [emojiPositions, setEmojiPositionsArray] = useState<EmojiPosition[]>([]);

    const searchInputRef = useRef<HTMLInputElement>(null);

    const infiniteLoaderRef = React.useRef<InfiniteLoader & {_listRef: FixedSizeList<CategoryOrEmojiRow[]>}>(null);

    const shouldRunCreateCategoryAndEmojiRows = useRef<boolean>();

    const throttledSearchCustomEmoji = useRef(throttle((newFilter, customEmojisEnabled) => {
        if (customEmojisEnabled && newFilter && newFilter.trim().length) {
            searchCustomEmojis(newFilter);
        }
    }, CUSTOM_EMOJI_SEARCH_THROTTLE_TIME_MS));

    useEffect(() => {
        // Delay taking focus because this briefly renders offscreen when using an Overlay
        // so focusing it immediately on mount can cause weird scrolling
        const searchFocusAnimationFrame = window.requestAnimationFrame(() => {
            searchInputRef.current?.focus();
        });

        const rootComponent = document.getElementById('root');
        rootComponent?.classList.add('emoji-picker--active');

        return () => {
            rootComponent?.classList.remove('emoji-picker--active');
            window.cancelAnimationFrame(searchFocusAnimationFrame);
        };
    }, []);

    useEffect(() => {
        shouldRunCreateCategoryAndEmojiRows.current = true;

        const [updatedCategories, updatedAllEmojis] = getUpdatedCategoriesAndAllEmojis(emojiMap, recentEmojis, userSkinTone, allEmojis);
        setAllEmojis(updatedAllEmojis);
        setCategories(updatedCategories);
    }, [emojiMap, userSkinTone, recentEmojis]);

    useEffect(() => {
        shouldRunCreateCategoryAndEmojiRows.current = false;

        const [updatedCategoryOrEmojisRows, updatedEmojiPositions] = createCategoryAndEmojiRows(allEmojis, categories, filter, userSkinTone);

        setCategoryOrEmojisRows(updatedCategoryOrEmojisRows);
        setEmojiPositionsArray(updatedEmojiPositions);
        throttledSearchCustomEmoji.current(filter, customEmojisEnabled);
    }, [filter, shouldRunCreateCategoryAndEmojiRows.current, customEmojisEnabled]);

    // Hack for getting focus on search input when tab changes to emoji from gifs
    useEffect(() => {
        searchInputRef.current?.focus();
    }, [visible]);

    // clear out the active category on search input
    useEffect(() => {
        if (activeCategory !== getInitialActiveCategory()) {
            setActiveCategory(getInitialActiveCategory());
        }

        // eslint-disable-next-line no-underscore-dangle
        infiniteLoaderRef?.current?._listRef?.scrollToItem(0, 'start');
    }, [filter]);

    // scroll as little as possible on cursor navigation
    useEffect(() => {
        if (cursor.emojiId) {
            // eslint-disable-next-line no-underscore-dangle
            infiniteLoaderRef?.current?._listRef?.scrollToItem(cursor.rowIndex, 'auto');
        }
    }, [cursor.rowIndex]);

    const focusOnSearchInput = useCallback(() => {
        searchInputRef.current?.focus();
    }, []);

    const getEmojiById = (emojiId: string) => {
        if (!emojiId) {
            return null;
        }
        const emoji = allEmojis[emojiId] || allEmojis[emojiId.toUpperCase()] || allEmojis[emojiId.toLowerCase()];
        return emoji;
    };

    const handleCategoryClick = useCallback((categoryRowIndex: CategoryOrEmojiRow['index'], categoryName: EmojiCategory, emojiId: string) => {
        if (!categoryName || categoryName === activeCategory || !emojiId) {
            return;
        }

        setActiveCategory(categoryName);

        // eslint-disable-next-line no-underscore-dangle
        infiniteLoaderRef?.current?._listRef?.scrollToItem(categoryRowIndex, 'start');

        const cursorEmoji = getEmojiById(emojiId);
        if (cursorEmoji) {
            setCursor({
                rowIndex: categoryRowIndex + 1, // +1 because next row is the emoji row
                emojiId,
                emoji: cursorEmoji,
            });
        }
    }, [activeCategory]);

    const resetCursor = useCallback(() => {
        setCursor({
            rowIndex: -1,
            emojiId: '',
            emoji: undefined,
        });
    }, []);

    const [cursorCategory, cursorCategoryIndex, cursorEmojiIndex] = getCursorProperties(cursor.rowIndex, cursor.emojiId, categoryOrEmojisRows as EmojiRow[]);

    function calculateNewCursorForUpArrow(cursorCategory: string, emojiPositions: EmojiPosition[], currentCursorsPositionIndex: number, categories: Categories, focusOnSearchInput: () => void) {
        if ((currentCursorsPositionIndex - EMOJI_PER_ROW) >= 0) {
            // Emoji is present up a row in same x position
            const upTheRowCategoryName = emojiPositions[currentCursorsPositionIndex - EMOJI_PER_ROW].categoryName as EmojiCategory;

            if (upTheRowCategoryName !== cursorCategory) {
                // If up the row emoji is in different category, move to that category's last emoji
                const upTheRowCategorysEmojis = categories[upTheRowCategoryName].emojiIds || [];
                const lastEmojiIdUpTheRow = upTheRowCategorysEmojis[upTheRowCategorysEmojis.length - 1];
                const lastEmojiPositionUpTheRow = emojiPositions.find((emojiPosition) => {
                    return emojiPosition.emojiId.toLowerCase() === lastEmojiIdUpTheRow.toLowerCase() && emojiPosition.categoryName === upTheRowCategoryName;
                });
                return lastEmojiPositionUpTheRow;
            }

            // If up the row emoji is in same category, move up in same category
            return emojiPositions[currentCursorsPositionIndex - EMOJI_PER_ROW];
        }

        // When emojis in the assumingly top row are less than EMOJI_PER_ROW,
        // Check if those are of different category
        const startingEmojisOfDifferentCategory = emojiPositions.slice(0, currentCursorsPositionIndex).reverse().find((emojiPosition) => {
            return emojiPosition.categoryName !== cursorCategory;
        });

        if (startingEmojisOfDifferentCategory) {
            return startingEmojisOfDifferentCategory;
        }

        // We are already at the first row, so focus on search
        focusOnSearchInput();
        return undefined;
    }

    function calculateNewCursorForRightOrLeftArrow(moveTo: NavigationDirection, emojiPositions: EmojiPosition[], currentCursorIndexInEmojis: number, focusOnSearchInput: () => void) {
        if (moveTo === NavigationDirection.NextEmoji && ((currentCursorIndexInEmojis + 1) < emojiPositions.length)) {
            // When next emoji is present, move to next emoji
            return emojiPositions[currentCursorIndexInEmojis + 1];
        }
        if (moveTo === NavigationDirection.PreviousEmoji && ((currentCursorIndexInEmojis - 1) >= 0)) {
            // When previous emoji is present, move to previous emoji
            return emojiPositions[currentCursorIndexInEmojis - 1];
        }
        if (moveTo === NavigationDirection.PreviousEmoji && ((currentCursorIndexInEmojis - 1) < 0)) {
            // If cursor was at first emoji then focus on search input
            focusOnSearchInput();
            return undefined;
        }

        return undefined;
    }

    function calculateNewCursorForDownArrow(cursorCategory: string, emojiPositions: EmojiPosition[], currentCursorsPositionIndex: number, categories: Categories) {
        if ((currentCursorsPositionIndex + EMOJI_PER_ROW) < emojiPositions.length) {
            // Emoji is present down a row in same x position
            const downTheRowCategoryName = emojiPositions[currentCursorsPositionIndex + EMOJI_PER_ROW].categoryName as EmojiCategory;

            if (downTheRowCategoryName !== cursorCategory) {
                // If down the row emoji is in different category, move to that category's first emoji
                const downTheRowCategorysEmojis = categories[downTheRowCategoryName].emojiIds || [];
                const firstEmojiIdDownTheRow = downTheRowCategorysEmojis[0];
                const firstEmojiPositionDownTheRow = emojiPositions.find((emojiPosition) => {
                    return emojiPosition.emojiId.toLowerCase() === firstEmojiIdDownTheRow.toLowerCase() && emojiPosition.categoryName === downTheRowCategoryName;
                });
                return firstEmojiPositionDownTheRow;
            }

            // If down the row emoji is in same category, move to down in same category
            return emojiPositions[currentCursorsPositionIndex + EMOJI_PER_ROW];
        }

        // When emoji down the row is not present.
        // Check if the remaining emojis are of different category
        const endingEmojisOfDifferentCategory = emojiPositions.slice(currentCursorsPositionIndex + 1, emojiPositions.length).find((emojiPosition) => {
            return emojiPosition.categoryName !== cursorCategory;
        });

        if (endingEmojisOfDifferentCategory) {
            return endingEmojisOfDifferentCategory;
        }

        return undefined;
    }

    const handleKeyboardEmojiNavigation = (moveTo: NavigationDirection) => {
        // No navigateable emoji are present in the resutls
        if (emojiPositions.length === 0) {
            return;
        }

        let newCursor;
        if (cursor.emojiId.length !== 0 && cursor.rowIndex !== -1) {
            // If cursor is on an emoji
            const currentCursorsPositionIndex = emojiPositions.findIndex((emojiPosition) =>
                emojiPosition.rowIndex === cursor.rowIndex && emojiPosition.emojiId.toLowerCase() === cursor.emojiId.toLowerCase());

            if (currentCursorsPositionIndex === -1) {
                newCursor = undefined;
            } else if (moveTo === NavigationDirection.NextEmoji || moveTo === NavigationDirection.PreviousEmoji) {
                newCursor = calculateNewCursorForRightOrLeftArrow(moveTo, emojiPositions, currentCursorsPositionIndex, focusOnSearchInput);
            } else if (moveTo === NavigationDirection.NextEmojiRow) {
                newCursor = calculateNewCursorForDownArrow(cursorCategory, emojiPositions, currentCursorsPositionIndex, categories);
            } else if (moveTo === NavigationDirection.PreviousEmojiRow) {
                newCursor = calculateNewCursorForUpArrow(cursorCategory, emojiPositions, currentCursorsPositionIndex, categories, focusOnSearchInput);
            }
        } else if (cursor.emojiId.length === 0 && cursor.rowIndex === -1) {
            if (moveTo === NavigationDirection.NextEmoji || moveTo === NavigationDirection.NextEmojiRow) {
                // if no cursor is selected, set the first emoji on arrows right & down
                if (emojiPositions.length !== 0) {
                    newCursor = emojiPositions[0];
                }
            }
        }

        // If newCursorIndex is less than 0, abort and do nothing
        if (newCursor === undefined) {
            return;
        }

        const newCursorEmoji = getEmojiById(newCursor.emojiId);
        if (!newCursorEmoji) {
            return;
        }

        setCursor({
            rowIndex: newCursor.rowIndex,
            emojiId: newCursor.emojiId,
            emoji: newCursorEmoji,
        });
    };

    const handleEnterOnEmoji = useCallback(() => {
        const clickedEmoji = cursor.emoji;

        if (clickedEmoji) {
            onEmojiClick(clickedEmoji);
        }
    }, [cursor.emojiId]);

    const handleEmojiOnMouseOver = (mouseOverCursor: EmojiCursor) => {
        if (mouseOverCursor.emojiId !== cursor.emojiId || cursor.emojiId === '') {
            setCursor(mouseOverCursor);
        }
    };

    const cursorEmojiName = useMemo(() => {
        const {emoji} = cursor;

        if (!emoji) {
            return '';
        }

        const name = isSystemEmoji(emoji) ? emoji.short_name : emoji.name;
        return name.replace(/_/g, ' ');
    }, [cursor.emojiId]);

    const areSearchResultsEmpty = filter.length !== 0 && categoryOrEmojisRows.length === 1 && categoryOrEmojisRows?.[0]?.items?.[0]?.categoryName === SEARCH_RESULTS;

    return (
        <div
            className='emoji-picker__inner'
            role='application'
        >
            <div
                aria-live='assertive'
                className='sr-only'
            >
                <FormattedMessage
                    id='emoji_picker_item.emoji_aria_label'
                    defaultMessage='{emojiName} emoji'
                    values={{
                        emojiName: cursorEmojiName,
                    }}
                />
            </div>
            <div className='emoji-picker__search-container'>
                <EmojiPickerSearch
                    ref={searchInputRef}
                    value={filter}
                    cursorCategoryIndex={cursorCategoryIndex}
                    cursorEmojiIndex={cursorEmojiIndex}
                    focus={focusOnSearchInput}
                    onEnter={handleEnterOnEmoji}
                    onChange={handleFilterChange}
                    onKeyDown={handleKeyboardEmojiNavigation}
                    resetCursorPosition={resetCursor}
                />
                <EmojiPickerSkin
                    userSkinTone={userSkinTone}
                    onSkinSelected={setUserSkinTone}
                />
            </div>
            <EmojiPickerCategories
                isFiltering={filter.length > 0}
                active={activeCategory}
                categories={categories}
                onClick={handleCategoryClick}
                onKeyDown={handleKeyboardEmojiNavigation}
                focusOnSearchInput={focusOnSearchInput}
            />
            {areSearchResultsEmpty ? (
                <NoResultsIndicator
                    variant={NoResultsVariant.ChannelSearch}
                    titleValues={{channelName: `"${filter}"`}}
                />
            ) : (
                <EmojiPickerCurrentResults
                    ref={infiniteLoaderRef}
                    isFiltering={filter.length > 0}
                    activeCategory={activeCategory}
                    categoryOrEmojisRows={categoryOrEmojisRows}
                    cursorEmojiId={cursor.emojiId}
                    cursorRowIndex={cursor.rowIndex}
                    setActiveCategory={setActiveCategory}
                    onEmojiClick={onEmojiClick}
                    onEmojiMouseOver={handleEmojiOnMouseOver}
                    getCustomEmojis={getCustomEmojis}
                    customEmojiPage={customEmojiPage}
                    incrementEmojiPickerPage={incrementEmojiPickerPage}
                    customEmojisEnabled={customEmojisEnabled}
                />
            )}
            <div className='emoji-picker__footer'>
                <EmojiPickerPreview
                    emoji={cursor.emoji}
                />
                <EmojiPickerCustomEmojiButton
                    currentTeamName={currentTeamName}
                    customEmojisEnabled={customEmojisEnabled}
                    handleEmojiPickerClose={handleEmojiPickerClose}
                />
            </div>
        </div>
    );
};

export default memo(EmojiPicker);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect, ConnectedProps} from 'react-redux';
import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';

import {ActionFunc, GenericAction} from 'mattermost-redux/types/actions';
import {getCustomEmojisEnabled} from 'mattermost-redux/selectors/entities/emojis';
import {getCustomEmojis, searchCustomEmojis} from 'mattermost-redux/actions/emojis';
import {CustomEmoji} from '@mattermost/types/emojis';
import {ServerError} from '@mattermost/types/errors';

import {GlobalState} from 'types/store';

import {incrementEmojiPickerPage, setUserSkinTone} from 'actions/emoji_actions';
import {getEmojiMap, getRecentEmojisNames, getUserSkinTone} from 'selectors/emojis';
import {getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';

import EmojiPicker from './emoji_picker';

function mapStateToProps(state: GlobalState) {
    return {
        customEmojisEnabled: getCustomEmojisEnabled(state),
        customEmojiPage: state.views.emoji.emojiPickerCustomPage,
        emojiMap: getEmojiMap(state),
        recentEmojis: getRecentEmojisNames(state),
        userSkinTone: getUserSkinTone(state),
        currentTeamName: getCurrentTeam(state)?.name ?? '',
    };
}

type Actions = {
    getCustomEmojis: (page?: number, perPage?: number, sort?: string, loadUsers?: boolean) => Promise<{ data: CustomEmoji[]; error: ServerError }>;
    searchCustomEmojis: (term: string, options?: any, loadUsers?: boolean) => ActionFunc;
    incrementEmojiPickerPage: () => void;
    setUserSkinTone: (skin: string) => void;
};

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject, Actions>({
            getCustomEmojis,
            searchCustomEmojis,
            incrementEmojiPickerPage,
            setUserSkinTone,
        }, dispatch),
    };
}

const connector = connect(mapStateToProps, mapDispatchToProps);

export type PropsFromRedux = ConnectedProps<typeof connector>;

export default connector(EmojiPicker);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {MouseEventHandler} from 'react';
import {FormattedMessage} from 'react-intl';

type Props = {
    handleEmojiPickerClose: MouseEventHandler;
}

export default class EmojiPickerHeader extends React.PureComponent<Props> {
    render(): React.ReactNode {
        return (
            <div className='emoji-picker__header modal-header'>
                <button
                    type='button'
                    className='close emoji-picker__header-close-button'
                    onClick={this.props.handleEmojiPickerClose}
                >
                    <span aria-hidden='true'>{''}</span>
                    <span className='sr-only'>
                        <FormattedMessage
                            id={'emoji_picker.close'}
                            defaultMessage={'Close'}
                        />
                    </span>
                </button>
                <h4 className='modal-title emoji-picker__header-title'>
                    <FormattedMessage
                        id={'emoji_picker.header'}
                        defaultMessage={'Emoji Picker'}
                    />
                </h4>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import PropTypes from 'prop-types';
import React, {PureComponent} from 'react';
import {Tab, Tabs} from 'react-bootstrap';

import EmojiIcon from 'components/widgets/icons/emoji_icon';
import GfycatIcon from 'components/widgets/icons/gfycat_icon';
import {makeAsyncComponent} from 'components/async_load';
import EmojiPicker from 'components/emoji_picker';
import EmojiPickerHeader from 'components/emoji_picker/components/emoji_picker_header';

const GifPicker = makeAsyncComponent('GifPicker', React.lazy(() => import('components/gif_picker/gif_picker')));

export default class EmojiPickerTabs extends PureComponent {
    static propTypes = {
        style: PropTypes.object,
        rightOffset: PropTypes.number,
        topOffset: PropTypes.number,
        leftOffset: PropTypes.number,
        placement: PropTypes.oneOf(['top', 'bottom', 'left', 'right']),
        customEmojis: PropTypes.object,
        onEmojiClose: PropTypes.func.isRequired,
        onEmojiClick: PropTypes.func.isRequired,
        onGifClick: PropTypes.func,
        enableGifPicker: PropTypes.bool,
    };

    static defaultProps = {
        rightOffset: 0,
        topOffset: 0,
        leftOffset: 0,
    };

    constructor(props) {
        super(props);

        this.state = {
            emojiTabVisible: true,
            filter: '',
        };
    }

    handleEnterEmojiTab = () => {
        this.setState({
            emojiTabVisible: true,
        });
    };

    handleExitEmojiTab = () => {
        this.setState({
            emojiTabVisible: false,
        });
    };

    handleEmojiPickerClose = () => {
        this.props.onEmojiClose();
    };

    handleFilterChange = (filter) => {
        this.setState({filter});
    };

    render() {
        let pickerStyle;
        if (this.props.style && !(this.props.style.left === 0 && this.props.style.top === 0)) {
            if (this.props.placement === 'top' || this.props.placement === 'bottom') {
                // Only take the top/bottom position passed by React Bootstrap since we want to be right-aligned
                pickerStyle = {
                    top: this.props.style.top,
                    bottom: this.props.style.bottom,
                    right: this.props.rightOffset,
                };
            } else {
                pickerStyle = {...this.props.style};
            }

            pickerStyle.top = pickerStyle.top ? pickerStyle.top + this.props.topOffset : this.props.topOffset;

            if (pickerStyle.left) {
                pickerStyle.left += this.props.leftOffset;
            }
        }

        let pickerClass = 'emoji-picker';
        if (this.props.placement === 'bottom') {
            pickerClass += ' bottom';
        }

        if (this.props.enableGifPicker && typeof this.props.onGifClick != 'undefined') {
            return (
                <Tabs
                    defaultActiveKey={1}
                    id='emoji-picker-tabs'
                    style={pickerStyle}
                    className={pickerClass}
                    justified={true}
                >
                    <EmojiPickerHeader handleEmojiPickerClose={this.handleEmojiPickerClose}/>
                    <Tab
                        eventKey={1}
                        onEnter={this.handleEnterEmojiTab}
                        onExit={this.handleExitEmojiTab}
                        title={
                            <div className={'custom-emoji-tab__icon__text'}>
                                <EmojiIcon
                                    className='custom-emoji-tab__icon'
                                />
                                <div>
                                    {'Emojis'}
                                </div>
                            </div>
                        }
                        tabClassName={'custom-emoji-tab'}
                    >
                        <EmojiPicker
                            filter={this.state.filter}
                            visible={this.state.emojiTabVisible}
                            onEmojiClick={this.props.onEmojiClick}
                            handleFilterChange={this.handleFilterChange}
                        />
                    </Tab>
                    <Tab
                        eventKey={2}
                        title={<GfycatIcon/>}
                        mountOnEnter={true}
                        unmountOnExit={true}
                        tabClassName={'custom-emoji-tab'}
                    >
                        <GifPicker
                            onGifClick={this.props.onGifClick}
                            defaultSearchText={this.state.filter}
                            handleSearchTextChange={this.handleFilterChange}
                        />
                    </Tab>
                </Tabs>
            );
        }

        return (
            <div
                id='emojiPicker'
                style={pickerStyle}
                className={`a11y__popup ${pickerClass} emoji-picker--single`}
            >
                <EmojiPickerHeader handleEmojiPickerClose={this.handleEmojiPickerClose}/>
                <EmojiPicker
                    filter={this.state.filter}
                    visible={this.state.emojiTabVisible}
                    onEmojiClick={this.props.onEmojiClick}
                    handleFilterChange={this.handleFilterChange}
                    handleEmojiPickerClose={this.handleEmojiPickerClose}
                />
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode} from 'react';
import {Overlay} from 'react-bootstrap';
import memoize from 'memoize-one';

import {popOverOverlayPosition} from 'utils/position_utils';
import {Constants} from 'utils/constants';

import {Emoji} from '@mattermost/types/emojis';

import EmojiPickerTabs from './emoji_picker_tabs.jsx';

type Props = {
    show: boolean;
    container?: () => ReactNode | ReactNode;
    target: () => ReactNode | ReactNode;
    onEmojiClick: (emoji: Emoji) => void;
    onGifClick?: (gif: string) => void;
    onHide: () => void;
    topOffset?: number;
    rightOffset?: number;
    leftOffset?: number;
    spaceRequiredAbove?: number;
    spaceRequiredBelow?: number;
    enableGifPicker?: boolean;
    defaultHorizontalPosition?: 'left' | 'right';
}

export default class EmojiPickerOverlay extends React.PureComponent<Props> {
    // An emoji picker in the center channel is contained within the post list, so it needs space
    // above for the channel header and below for the post textbox
    static CENTER_SPACE_REQUIRED_ABOVE = 476;
    static CENTER_SPACE_REQUIRED_BELOW = 497;

    // An emoji picker in the RHS isn't constrained by the RHS, so it just needs space to fit
    // the emoji picker itself
    static RHS_SPACE_REQUIRED_ABOVE = 420;
    static RHS_SPACE_REQUIRED_BELOW = 420;

    // Reasonable defaults calculated from from the center channel
    static defaultProps = {
        spaceRequiredAbove: EmojiPickerOverlay.CENTER_SPACE_REQUIRED_ABOVE,
        spaceRequiredBelow: EmojiPickerOverlay.CENTER_SPACE_REQUIRED_BELOW,
        enableGifPicker: false,
    };

    emojiPickerPosition = memoize((emojiTrigger, show) => {
        let calculatedRightOffset = Constants.DEFAULT_EMOJI_PICKER_RIGHT_OFFSET;

        if (!show) {
            return calculatedRightOffset;
        }

        if (emojiTrigger) {
            calculatedRightOffset = window.innerWidth - emojiTrigger.getBoundingClientRect().left - Constants.DEFAULT_EMOJI_PICKER_LEFT_OFFSET;

            if (calculatedRightOffset < Constants.DEFAULT_EMOJI_PICKER_RIGHT_OFFSET) {
                calculatedRightOffset = Constants.DEFAULT_EMOJI_PICKER_RIGHT_OFFSET;
            }
        }

        return calculatedRightOffset;
    });

    getPlacement = memoize((target, spaceRequiredAbove, spaceRequiredBelow, defaultHorizontalPosition, show) => {
        if (!show) {
            return 'top';
        }

        if (target) {
            const targetBounds = target.getBoundingClientRect();
            return popOverOverlayPosition(targetBounds, window.innerHeight, spaceRequiredAbove, spaceRequiredBelow, defaultHorizontalPosition);
        }

        return 'top';
    });

    render() {
        const {target, rightOffset, spaceRequiredAbove, spaceRequiredBelow, defaultHorizontalPosition, show} = this.props;

        const calculatedRightOffset = typeof rightOffset === 'undefined' ? this.emojiPickerPosition(target(), show) : rightOffset;
        const placement = this.getPlacement(target(), spaceRequiredAbove, spaceRequiredBelow, defaultHorizontalPosition, show);

        return (
            <Overlay
                show={show}
                placement={placement}
                rootClose={true}
                container={this.props.container}
                onHide={this.props.onHide}
                target={target}
                animation={false}
            >
                <EmojiPickerTabs
                    enableGifPicker={this.props.enableGifPicker}
                    onEmojiClose={this.props.onHide}
                    onEmojiClick={this.props.onEmojiClick}
                    onGifClick={this.props.onGifClick}
                    rightOffset={calculatedRightOffset}
                    topOffset={this.props.topOffset}
                    leftOffset={this.props.leftOffset}
                />
            </Overlay>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

type Props = {
    url: string;
    messageId: string;
    defaultMessage: string;
}

const ErrorLink: React.FC<Props> = ({url, messageId, defaultMessage}: Props) => {
    return (
        <a
            href={url}
            rel='noopener noreferrer'
            target='_blank'
        >
            <FormattedMessage
                id={messageId}
                defaultMessage={defaultMessage}
            />
        </a>
    );
};

ErrorLink.defaultProps = {
    url: '',
    messageId: '',
    defaultMessage: '',
};

export default ErrorLink;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {PostImage} from '@mattermost/types/posts';

import {getImageSrc} from 'utils/post_utils';

interface Props {
    children: (src: string) => React.ReactNode;
    enableSVGs: boolean;
    hasImageProxy: boolean;
    imageMetadata?: PostImage;
    src: string;
}

export default class ExternalImage extends React.PureComponent<Props> {
    isSVGImage = () => {
        if (!this.props.imageMetadata) {
            // Just check if the string contains an svg extension instead of if it ends with one because it avoids
            // having to deal with query strings and proxied image URLs
            return this.props.src.indexOf('.svg') !== -1;
        }

        return this.props.imageMetadata.format === 'svg';
    }

    shouldRenderImage = () => {
        // Return true unless the image is an SVG and we have SVG rendering disabled
        return this.props.enableSVGs || !this.isSVGImage();
    }

    render() {
        let src = getImageSrc(this.props.src, this.props.hasImageProxy);

        if (!this.shouldRenderImage()) {
            src = '';
        }

        return this.props.children(src);
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getConfig} from 'mattermost-redux/selectors/entities/general';

import {GlobalState} from 'types/store';

import ExternalImage from './external_image';

function mapStateToProps(state: GlobalState) {
    const config = getConfig(state);

    return {
        enableSVGs: config.EnableSVGs === 'true',
        hasImageProxy: config.HasImageProxy === 'true',
    };
}

export default connect(mapStateToProps)(ExternalImage);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {getFileThumbnailUrl, getFileUrl} from 'mattermost-redux/utils/file_utils';
import {FileInfo} from '@mattermost/types/files';

import Constants, {FileTypes} from 'utils/constants';
import {
    getFileType,
    getIconClassName,
    isGIFImage,
} from 'utils/utils';

type Props = {
    enableSVGs: boolean;
    fileInfo: FileInfo;
}

export default class FileThumbnail extends React.PureComponent<Props> {
    render() {
        const {fileInfo} = this.props;
        const type = getFileType(fileInfo.extension);

        let thumbnail;
        if (type === FileTypes.IMAGE) {
            let className = 'post-image';

            if (fileInfo.width < Constants.THUMBNAIL_WIDTH && fileInfo.height < Constants.THUMBNAIL_HEIGHT) {
                className += ' small';
            } else {
                className += ' normal';
            }

            let thumbnailUrl = getFileThumbnailUrl(fileInfo.id);
            if (isGIFImage(fileInfo.extension) && !fileInfo.has_preview_image) {
                thumbnailUrl = getFileUrl(fileInfo.id);
            }

            return (
                <div
                    className={className}
                    style={{
                        backgroundImage: `url(${thumbnailUrl})`,
                        backgroundSize: 'cover',
                    }}
                />
            );
        } else if (fileInfo.extension === FileTypes.SVG && this.props.enableSVGs) {
            thumbnail = (
                <img
                    alt={'file thumbnail image'}
                    className='post-image normal'
                    src={getFileUrl(fileInfo.id)}
                />
            );
        } else {
            thumbnail = <div className={'file-icon ' + getIconClassName(type)}/>;
        }

        return thumbnail;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getConfig} from 'mattermost-redux/selectors/entities/general';

import {GlobalState} from 'types/store';

import FileThumbnail from './file_thumbnail';

function mapStateToProps(state: GlobalState) {
    return {
        enableSVGs: getConfig(state).EnableSVGs === 'true',
    };
}

export default connect(mapStateToProps)(FileThumbnail);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function AttachmentIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='16px'
                height='16px'
                viewBox='0 0 16 16'
                role='img'
                aria-label={formatMessage({id: 'generic_icons.attach', defaultMessage: 'Attachment Icon'})}
            >
                <g
                    fill='inherit'
                    fillRule='evenodd'
                >
                    <g
                        transform='translate(-1029.000000, -954.000000)'
                        fillRule='nonzero'
                        fill='inherit'
                    >
                        <g transform='translate(25.000000, 937.000000)'>
                            <g transform='translate(1004.000000, 17.000000)'>
                                <path d='M5.35,15.56 C3.98,15.56 2.61,15.039 1.567,13.997 C0.557,12.984 0,11.642 0,10.212 C0,8.783 0.557,7.44 1.566,6.429 L6.869,1.126 C8.371,-0.376 10.812,-0.375 12.314,1.125 C13.815,2.627 13.815,5.069 12.314,6.57 L7.011,11.873 C6.094,12.792 4.603,12.79 3.687,11.873 C2.771,10.958 2.771,9.467 3.687,8.551 L8.99,3.248 C9.323,2.916 9.861,2.916 10.193,3.248 C10.525,3.579 10.525,4.118 10.193,4.449 L4.89,9.752 C4.637,10.006 4.637,10.418 4.89,10.672 C5.143,10.923 5.555,10.925 5.809,10.672 L11.113,5.369 C11.952,4.53 11.952,3.166 11.113,2.327 C10.276,1.49 8.911,1.488 8.073,2.327 L2.769,7.631 C2.079,8.32 1.699,9.237 1.699,10.212 C1.699,11.188 2.079,12.104 2.768,12.794 C4.19,14.216 6.502,14.216 7.925,12.798 L7.929,12.794 C7.929,12.793 7.929,12.793 7.929,12.793 L15.355,5.369 C15.687,5.037 16.224,5.037 16.556,5.369 C16.888,5.7 16.888,6.239 16.556,6.57 L8.779,14.348 L8.761,14.332 C7.776,15.15 6.562,15.56 5.35,15.56 Z'/>
                            </g>
                        </g>
                    </g>
                </g>
            </svg>
        </span>
    );
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {getFileDownloadUrl} from 'mattermost-redux/utils/file_utils';
import {FileInfo} from '@mattermost/types/files';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import AttachmentIcon from 'components/widgets/icons/attachment_icon';
import {trimFilename} from 'utils/file_utils';
import {localizeMessage} from 'utils/utils';

type Props = {

    /*
     * File detailed information
     */
    fileInfo: FileInfo;

    /*
     * Handler for when the thumbnail is clicked passed the index above
     */
    handleImageClick?: (event: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => void;

    /*
     * Display in compact format
     */
    compactDisplay?: boolean;

    /*
     * If it should display link to download on file name
     */
    canDownload?: boolean;

    /*
     * Optional children like download icon
     */
    children?: React.ReactNode;

    /*
     * Optional class like for icon
     */
    iconClass?: string;
}

export default class FilenameOverlay extends React.PureComponent<Props> {
    render() {
        const {
            canDownload,
            children,
            compactDisplay,
            fileInfo,
            handleImageClick,
            iconClass,
        } = this.props;

        const fileName = fileInfo.name;
        const trimmedFilename = trimFilename(fileName);

        let filenameOverlay;
        if (compactDisplay) {
            filenameOverlay = (
                <OverlayTrigger
                    delayShow={1000}
                    placement='top'
                    overlay={<Tooltip id='file-name__tooltip'>{fileName}</Tooltip>}
                >
                    <a
                        id='file-attachment-link'
                        href='#'
                        onClick={handleImageClick}
                        className='post-image__name'
                        rel='noopener noreferrer'
                    >
                        <AttachmentIcon className='icon'/>
                        {trimmedFilename}
                    </a>
                </OverlayTrigger>
            );
        } else if (canDownload) {
            filenameOverlay = (
                <div className={iconClass || 'post-image__name'}>
                    <OverlayTrigger
                        delayShow={1000}
                        placement='top'
                        overlay={
                            <Tooltip id='file-name__tooltip'>
                                {localizeMessage('view_image_popover.download', 'Download')}
                            </Tooltip>
                        }
                    >
                        <a
                            href={getFileDownloadUrl(fileInfo.id)}
                            aria-label={localizeMessage('view_image_popover.download', 'Download').toLowerCase()}
                            download={fileName}
                            target='_blank'
                            rel='noopener noreferrer'
                        >
                            {children || trimmedFilename}
                        </a>
                    </OverlayTrigger>
                </div>
            );
        } else {
            filenameOverlay = (
                <span className='post-image__name'>
                    {trimmedFilename}
                </span>
            );
        }

        return (filenameOverlay);
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

import SuccessIcon from 'components/widgets/icons/fa_success_icon';

type Props = {
    show: boolean;
    onHide: () => void;
    onExited: () => void;
    title: string;
    helpText?: string;
    link: string;
}

type State = {
    copiedLink: boolean;
}

export default class GetLinkModal extends React.PureComponent<Props, State> {
    private textAreaRef = React.createRef<HTMLTextAreaElement>();
    public static defaultProps = {
        helpText: null,
    };

    public constructor(props: Props) {
        super(props);
        this.state = {
            copiedLink: false,
        };
    }

    public onHide = (): void => {
        this.setState({copiedLink: false});
        this.props.onHide();
    }

    public copyLink = (): void => {
        const textarea = this.textAreaRef.current;

        if (textarea) {
            textarea.focus();
            textarea.setSelectionRange(0, this.props.link.length);

            try {
                this.setState({copiedLink: document.execCommand('copy')});
            } catch (err) {
                this.setState({copiedLink: false});
            }
        }
    }

    public render(): JSX.Element {
        let helpText = null;
        if (this.props.helpText) {
            helpText = (
                <p>
                    {this.props.helpText}
                    <br/>
                    <br/>
                </p>
            );
        }

        let copyLink = null;

        if (document.queryCommandSupported('copy')) {
            copyLink = (
                <button
                    id='linkModalCopyLink'
                    data-copy-btn='true'
                    type='button'
                    className='btn btn-primary pull-left'
                    onClick={this.copyLink}
                >
                    <FormattedMessage
                        id='get_link.copy'
                        defaultMessage='Copy Link'
                    />
                </button>
            );
        }

        const linkText = (
            <textarea
                id='linkModalTextArea'
                className='form-control no-resize min-height'
                ref={this.textAreaRef}
                dir='auto'
                value={this.props.link}
                onClick={this.copyLink}
                readOnly={true}
            />
        );

        let copyLinkConfirm = null;
        if (this.state.copiedLink) {
            copyLinkConfirm = (
                <p className='alert alert-success alert--confirm'>
                    <SuccessIcon/>
                    <FormattedMessage
                        id='get_link.clipboard'
                        defaultMessage=' Link copied'
                    />
                </p>
            );
        }

        return (
            <Modal
                dialogClassName='a11y__modal'
                show={this.props.show}
                onHide={this.onHide}
                onExited={this.props.onExited}
                role='dialog'
                aria-labelledby='getLinkModalLabel'
            >
                <Modal.Header
                    id='getLinkModalLabel'
                    closeButton={true}
                >
                    <h4 className='modal-title'>{this.props.title}</h4>
                </Modal.Header>
                <Modal.Body>
                    {helpText}
                    {linkText}
                </Modal.Body>
                <Modal.Footer>
                    <button
                        id='linkModalCloseButton'
                        type='button'
                        className='btn btn-link'
                        onClick={this.onHide}
                    >
                        <FormattedMessage
                            id='get_link.close'
                            defaultMessage='Close'
                        />
                    </button>
                    {copyLink}
                    {copyLinkConfirm}
                </Modal.Footer>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import GetLinkModal from 'components/get_link_modal';

import * as Utils from 'utils/utils';

import type {PropsFromRedux} from './index';

interface Props extends PropsFromRedux {
    onExited: () => void;
    fileId: string;
}

type State = {
    show: boolean;
}

export default class GetPublicLinkModal extends React.PureComponent<Props, State> {
    public static defaultProps: Partial<Props> = {
        link: '',
    };

    public constructor(props: Props) {
        super(props);

        this.state = {
            show: true,
        };
    }

    public componentDidMount() {
        this.props.actions.getFilePublicLink(this.props.fileId);
    }

    public onHide = () => {
        this.setState({
            show: false,
        });
    }

    public render() {
        return (
            <GetLinkModal
                show={this.state.show}
                onHide={this.onHide}
                onExited={this.props.onExited}
                title={Utils.localizeMessage('get_public_link_modal.title', 'Copy Public Link')}
                helpText={Utils.localizeMessage('get_public_link_modal.help', 'The link below allows anyone to see this file without being registered on this server.')}
                link={this.props.link}
            />
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect, ConnectedProps} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {getFilePublicLink} from 'mattermost-redux/actions/files';
import * as Selectors from 'mattermost-redux/selectors/entities/files';

import {GlobalState} from '@mattermost/types/store';
import {GenericAction} from 'mattermost-redux/types/actions';

import GetPublicLinkModal from './get_public_link_modal';

function mapStateToProps(state: GlobalState) {
    const filePublicLink: unknown = Selectors.getFilePublicLink(state)?.link;
    return {
        link: filePublicLink as string,
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            getFilePublicLink,
        }, dispatch),
    };
}

const connector = connect(mapStateToProps, mapDispatchToProps);

export type PropsFromRedux = ConnectedProps<typeof connector>;

export default connector(GetPublicLinkModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState, useRef} from 'react';
import ReactDOM from 'react-dom';
import classNames from 'classnames';
import {useHover, useInteractions, useFloating, arrow, offset, autoPlacement, Strategy, Placement} from '@floating-ui/react-dom-interactions';

import {Constants} from 'utils/constants';

interface TooltipOptions {
    message: React.ReactNode | React.ReactNodeArray;
    strategy?: Strategy;
    placement: Placement;
    allowedPlacements?: Placement[];
    hoverDelay?: Exclude<Parameters<typeof useHover>[1], undefined>['delay'];
    zIndex?: number;
    mountPoint?: string | Element;
}

const defaultOptions: Required<Pick<TooltipOptions, 'strategy' | 'hoverDelay' | 'zIndex' | 'mountPoint'>> = {
    strategy: 'fixed',
    hoverDelay: {
        open: Constants.OVERLAY_TIME_DELAY,
        close: 0,
    },
    zIndex: 1,
    mountPoint: 'root',
};

const transitionTime = 150;

export default function useTooltip(options: TooltipOptions) {
    const [open, setOpen] = useState(false);
    const [visible, setVisible] = useState(false);
    const transition = useRef<NodeJS.Timeout>(null);
    const arrowRef = useRef(null);
    const effectiveStrategy = options.strategy || defaultOptions.strategy;
    const effectiveMountpoint = options.mountPoint || defaultOptions.mountPoint;
    const effectiveAllowedPlacements = options.allowedPlacements ?? [options.placement];
    const {
        x,
        y,
        reference,
        floating,
        strategy,
        placement,
        middlewareData: {
            arrow: {
                x: arrowX,
                y: arrowY,
            } = {},
        },
        context,
    } = useFloating({
        open,
        onOpenChange: (nowOpen) => {
            if (transition.current) {
                clearTimeout(transition.current);
            }
            if (nowOpen) {
                setOpen(nowOpen);
                setVisible(true);
            } else {
                setVisible(false);
                setTimeout(() => {
                    setOpen(nowOpen);
                }, transitionTime);
            }
        },
        middleware: [
            autoPlacement({
                allowedPlacements: effectiveAllowedPlacements,
                autoAlignment: false,
            }),
            offset(10),
            arrow({
                element: arrowRef,
                padding: 4,
            }),
        ],
        placement: options.placement,
        strategy: effectiveStrategy,
    });

    const {getReferenceProps, getFloatingProps} = useInteractions([
        useHover(
            context,
            {
                delay: options.hoverDelay || defaultOptions.hoverDelay,
            },
        ),
    ]);

    const content = (
        <div
            {...getFloatingProps({
                ref: floating,
                className: classNames(
                    'floating-ui-tooltip',
                    {
                        'floating-ui-tooltip--visible': visible,
                    },
                ),
                style: {
                    position: strategy,
                    top: y ?? 0,
                    left: x ?? 0,
                    zIndex: typeof options.zIndex === 'number' ? options.zIndex : defaultOptions.zIndex,
                },
            })}
        >
            {options.message}
            <div
                ref={arrowRef}
                className='floating-ui-tooltip-arrow'
                style={placement === 'top' ? {left: arrowX, top: arrowY} : {left: '-4px', top: arrowY}}
            />
        </div>
    );

    let tooltip: React.ReactNode | React.ReactNodeArray = false;

    if (open) {
        if (effectiveStrategy === 'fixed') {
            tooltip = ReactDOM.createPortal(
                content,
                typeof effectiveMountpoint === 'string' ? document.getElementById(effectiveMountpoint) as Element : effectiveMountpoint,
            );
        }
    }

    return {
        reference,
        getReferenceProps,
        tooltip,
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

import useGetLimits from 'components/common/hooks/useGetLimits';
import {asGBString} from 'utils/limits';

export default function ArchivedTooltip() {
    const intl = useIntl();
    return (
        <>
            <div className='post-image__archived-tooltip-title'>
                {intl.formatMessage({
                    id: 'workspace_limits.archived_file.tooltip_title',
                    defaultMessage: 'Unarchive this file by upgrading',
                })}
            </div>
            <div className='post-image__archived-tooltip-description'>
                {intl.formatMessage(
                    {
                        id: 'workspace_limits.archived_file.tooltip_description',
                        defaultMessage: 'Your workspace has hit the file storage limit of {storageLimit}. To view this again, upgrade to a paid plan',
                    },
                    {
                        storageLimit: asGBString(useGetLimits()[0].files?.total_storage || 0, intl.formatNumber),
                    },
                )}
            </div>
        </>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useRef, useState, useEffect} from 'react';
import classNames from 'classnames';
import {FormattedMessage, useIntl} from 'react-intl';

import {ArchiveOutlineIcon} from '@mattermost/compass-icons/components';

import {getFileThumbnailUrl, getFileUrl} from 'mattermost-redux/utils/file_utils';
import {FileInfo} from '@mattermost/types/files';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import Menu from 'components/widgets/menu/menu';
import GetPublicModal from 'components/get_public_link_modal';
import useTooltip from 'components/common/hooks/useTooltip';

import {Constants, FileTypes, ModalIdentifiers} from 'utils/constants';
import {trimFilename} from 'utils/file_utils';

import {
    fileSizeToString,
    getFileType,
    loadImage,
    localizeMessage,
} from 'utils/utils';

import ArchivedTooltip from './archived_tooltip';

import FilenameOverlay from './filename_overlay';
import FileThumbnail from './file_thumbnail';

import type {PropsFromRedux} from './index';

interface Props extends PropsFromRedux {

    /*
    * File detailed information
    */
    fileInfo: FileInfo;

    /*
    * The index of this attachment preview in the parent FileAttachmentList
    */
    index: number;

    /*
    * Handler for when the thumbnail is clicked passed the index above
    */
    handleImageClick?: (index: number) => void;

    /*
    * Display in compact format
    */
    compactDisplay?: boolean;
    handleFileDropdownOpened?: (open: boolean) => void;
}

export default function FileAttachment(props: Props) {
    const mounted = useRef(true);
    const intl = useIntl();
    const [loaded, setLoaded] = useState(getFileType(props.fileInfo.extension) !== FileTypes.IMAGE);
    const [loadFilesCalled, setLoadFilesCalled] = useState(false);
    const [keepOpen, setKeepOpen] = useState(false);
    const [openUp, setOpenUp] = useState(false);

    const {
        reference,
        getReferenceProps,
        tooltip: archivedTooltip,
    } = useTooltip({
        message: <ArchivedTooltip/>,
        placement: 'right',
        allowedPlacements: ['right', 'top'],
    });

    const buttonRef = useRef<HTMLButtonElement | null>(null);

    const handleImageLoaded = () => {
        if (mounted.current) {
            setLoaded(true);
        }
    };

    const loadFiles = () => {
        const fileInfo = props.fileInfo;
        if (fileInfo.archived) {
            // if archived, file preview will not be accessible anyway.
            // So skip trying to load.
            return;
        }
        const fileType = getFileType(fileInfo.extension);

        if (fileType === FileTypes.IMAGE) {
            const thumbnailUrl = getFileThumbnailUrl(fileInfo.id);

            loadImage(thumbnailUrl, handleImageLoaded);
        } else if (fileInfo.extension === FileTypes.SVG && props.enableSVGs) {
            loadImage(getFileUrl(fileInfo.id), handleImageLoaded);
        }
    };

    useEffect(() => {
        if (!loadFilesCalled) {
            setLoadFilesCalled(true);
            loadFiles();
        }
    }, [loadFilesCalled]);

    useEffect(() => {
        if (!loaded && props.fileInfo.id) {
            loadFiles();
        }
    }, [props.fileInfo.id, loaded]);

    useEffect(() => {
        return () => {
            mounted.current = false;
        };
    }, []);

    useEffect(() => {
        if (props.fileInfo.id) {
            setLoaded(getFileType(props.fileInfo.extension) !== FileTypes.IMAGE && !(props.enableSVGs && props.fileInfo.extension === FileTypes.SVG));
        }
    }, [props.fileInfo.extension, props.fileInfo.id, props.enableSVGs]);

    const onAttachmentClick = (e: React.MouseEvent<HTMLElement, MouseEvent>) => {
        if (props.fileInfo.archived) {
            return;
        }
        e.preventDefault();

        if ('blur' in e.target) {
            (e.target as HTMLElement).blur();
        }

        if (props.handleImageClick) {
            props.handleImageClick(props.index);
        }
    };

    const handleDropdownOpened = (open: boolean) => {
        props.handleFileDropdownOpened?.(open);
        setKeepOpen(open);

        if (open) {
            setMenuPosition();
        }
    };

    const setMenuPosition = () => {
        if (!buttonRef.current) {
            return;
        }

        const anchorRect = buttonRef.current?.getBoundingClientRect();
        let y;
        if (typeof anchorRect?.y === 'undefined') {
            y = typeof anchorRect?.top === 'undefined' ? 0 : anchorRect?.top;
        } else {
            y = anchorRect?.y;
        }
        const windowHeight = window.innerHeight;

        const totalSpace = windowHeight - 80;
        const spaceOnTop = y - Constants.CHANNEL_HEADER_HEIGHT;
        const spaceOnBottom = (totalSpace - (spaceOnTop + Constants.POST_AREA_HEIGHT));

        setOpenUp(spaceOnTop > spaceOnBottom);
    };

    const handleGetPublicLink = () => {
        props.actions.openModal({
            modalId: ModalIdentifiers.GET_PUBLIC_LINK_MODAL,
            dialogType: GetPublicModal,
            dialogProps: {
                fileId: props.fileInfo.id,
            },
        });
    };

    const renderFileMenuItems = () => {
        const {enablePublicLink, fileInfo, pluginMenuItems} = props;

        let divider;
        const defaultItems = [];
        if (enablePublicLink) {
            defaultItems.push(
                <Menu.ItemAction
                    data-title='Public Image'
                    onClick={handleGetPublicLink}
                    ariaLabel={localizeMessage('view_image_popover.publicLink', 'Get a public link')}
                    text={localizeMessage('view_image_popover.publicLink', 'Get a public link')}
                />,
            );
        }

        const pluginItems = pluginMenuItems?.filter((item) => item?.match(fileInfo)).map((item) => {
            return (
                <Menu.ItemAction
                    id={item.id + '_pluginmenuitem'}
                    key={item.id + '_pluginmenuitem'}
                    onClick={() => item?.action(fileInfo)}
                    text={item.text}
                />
            );
        });

        const isMenuVisible = defaultItems?.length || pluginItems?.length;
        if (!isMenuVisible) {
            return null;
        }

        const isDividerVisible = defaultItems?.length && pluginItems?.length;
        if (isDividerVisible) {
            divider = (
                <li
                    id={`divider_file_${fileInfo.id}_plugins`}
                    className='MenuItem__divider'
                    role='menuitem'
                />
            );
        }

        const tooltip = (
            <Tooltip id='file-name__tooltip'>
                {localizeMessage('file_search_result_item.more_actions', 'More Actions')}
            </Tooltip>
        );

        return (
            <MenuWrapper
                onToggle={handleDropdownOpened}
                stopPropagationOnToggle={true}
            >
                <OverlayTrigger
                    className='hidden-xs'
                    delayShow={1000}
                    placement='top'
                    overlay={tooltip}
                >
                    <button
                        ref={buttonRef}
                        id={`file_action_button_${props.fileInfo.id}`}
                        aria-label={localizeMessage('file_search_result_item.more_actions', 'More Actions').toLowerCase()}
                        className={classNames(
                            'file-dropdown-icon', 'dots-icon',
                            {'a11y--active': keepOpen},
                        )}
                        aria-expanded={keepOpen}
                    >
                        <i className='icon icon-dots-vertical'/>
                    </button>
                </OverlayTrigger>
                <Menu
                    id={`file_dropdown_${props.fileInfo.id}`}
                    ariaLabel={'file menu'}
                    openLeft={true}
                    openUp={openUp}
                >
                    {defaultItems}
                    {divider}
                    {pluginItems}
                </Menu>
            </MenuWrapper>
        );
    };

    const {compactDisplay, fileInfo} = props;

    let fileThumbnail;
    let fileDetail;
    let fileActions;
    const ariaLabelImage = `${localizeMessage('file_attachment.thumbnail', 'file thumbnail')} ${fileInfo.name}`.toLowerCase();

    if (!compactDisplay) {
        fileThumbnail = (
            <a
                aria-label={ariaLabelImage}
                className='post-image__thumbnail'
                href='#'
                onClick={onAttachmentClick}
            >
                {loaded ? (
                    <FileThumbnail fileInfo={fileInfo}/>
                ) : (
                    <div className='post-image__load'/>
                )}
            </a>
        );

        if (fileInfo.archived) {
            fileThumbnail = (
                <ArchiveOutlineIcon
                    size={48}
                    color={'rgba(var(--center-channel-text-rgb), 0.48)'}
                    data-testid='archived-file-icon'
                />
            );
        }

        fileDetail = (
            <div
                className='post-image__detail_wrapper'
                onClick={onAttachmentClick}
            >
                <div className='post-image__detail'>
                    <span
                        className={classNames('post-image__name', {
                            'post-image__name--archived': fileInfo.archived,
                        })}
                    >
                        {fileInfo.name}
                    </span>
                    {fileInfo.archived ?
                        <span className={'post-image__archived'}>

                            <FormattedMessage
                                id='workspace_limits.archived_file.archived'
                                defaultMessage='This file is archived'
                            />
                        </span> :
                        <>
                            <span className='post-image__type'>{fileInfo.extension.toUpperCase()}</span>
                            <span className='post-image__size'>{fileSizeToString(fileInfo.size)}</span>
                        </>
                    }
                </div>
            </div>
        );

        if (!fileInfo.archived) {
            fileActions = renderFileMenuItems();
        }
    }

    let filenameOverlay;
    if (props.canDownloadFiles && !fileInfo.archived) {
        filenameOverlay = (
            <FilenameOverlay
                fileInfo={fileInfo}
                compactDisplay={compactDisplay}
                canDownload={props.canDownloadFiles}
                handleImageClick={onAttachmentClick}
                iconClass={'post-image__download'}
            >
                <i className='icon icon-download-outline'/>
            </FilenameOverlay>
        );
    } else if (fileInfo.archived && compactDisplay) {
        const fileName = fileInfo.name;
        const trimmedFilename = trimFilename(fileName);
        fileThumbnail = (
            <ArchiveOutlineIcon
                size={16}
                color={'rgba(var(--center-channel-text-rgb), 0.48)'}
                data-testid='archived-file-icon'
            />
        );
        filenameOverlay =
            (<span className='post-image__archived-name'>
                <span className='post-image__archived-filename'>
                    {trimmedFilename}
                </span>
                <span className='post-image__archived-label'>
                    {intl.formatMessage({
                        id: 'workspace_limits.archived_file.archived_compact',
                        defaultMessage: '(archived)',
                    })}
                </span>
            </span>);
    }

    const content =
        (
            <div
                ref={fileInfo.archived ? reference : undefined}
                {...(fileInfo.archived ? getReferenceProps() : {})}
                className={
                    classNames([
                        'post-image__column',
                        {'keep-open': keepOpen},
                        {'post-image__column--archived': fileInfo.archived},
                    ])
                }
            >
                {fileThumbnail}
                <div className='post-image__details'>
                    {fileDetail}
                    {fileActions}
                    {filenameOverlay}
                </div>
            </div>
        );

    if (fileInfo.archived) {
        return (
            <>
                {content}
                {archivedTooltip}
            </>
        );
    }
    return content;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {bindActionCreators, Dispatch} from 'redux';
import {connect, ConnectedProps} from 'react-redux';

import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {GenericAction} from 'mattermost-redux/types/actions';

import {getFilesDropdownPluginMenuItems} from 'selectors/plugins';

import {GlobalState} from 'types/store';

import {openModal} from 'actions/views/modals';

import {canDownloadFiles} from 'utils/file_utils';

import FileAttachment from './file_attachment';

function mapStateToProps(state: GlobalState) {
    const config = getConfig(state);

    return {
        canDownloadFiles: canDownloadFiles(config),
        enableSVGs: config.EnableSVGs === 'true',
        enablePublicLink: config.EnablePublicLink === 'true',
        pluginMenuItems: getFilesDropdownPluginMenuItems(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            openModal,
        }, dispatch),
    };
}

const connector = connect(mapStateToProps, mapDispatchToProps);

export type PropsFromRedux = ConnectedProps<typeof connector>;

export default connector(FileAttachment);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import classNames from 'classnames';

import {getFilePreviewUrl, getFileUrl} from 'mattermost-redux/utils/file_utils';
import {FileInfo} from '@mattermost/types/files';

import SizeAwareImage from 'components/size_aware_image';
import {FileTypes, ModalIdentifiers} from 'utils/constants';
import {
    getFileType,
} from 'utils/utils';

import FilePreviewModal from 'components/file_preview_modal';

import type {PropsFromRedux} from './index';

const PREVIEW_IMAGE_MIN_DIMENSION = 50;

interface Props extends PropsFromRedux {
    postId: string;
    fileInfo: FileInfo;
    isRhsOpen: boolean;
    enablePublicLink: boolean;
    compactDisplay?: boolean;
    isEmbedVisible?: boolean;
    isInPermalink?: boolean;
}

type State = {
    loaded: boolean;
    dimensions: {
        width: number;
        height: number;
    };
}

export default class SingleImageView extends React.PureComponent<Props, State> {
    private mounted = false;
    static defaultProps = {
        compactDisplay: false,
    };

    constructor(props: Props) {
        super(props);
        this.state = {
            loaded: false,
            dimensions: {
                width: props.fileInfo?.width || 0,
                height: props.fileInfo?.height || 0,
            },
        };
    }

    componentDidMount() {
        this.mounted = true;
    }

    static getDerivedStateFromProps(props: Props, state: State) {
        if ((props.fileInfo?.width !== state.dimensions.width) || props.fileInfo.height !== state.dimensions.height) {
            return {
                dimensions: {
                    width: props.fileInfo?.width,
                    height: props.fileInfo?.height,
                },
            };
        }
        return null;
    }

    componentWillUnmount() {
        this.mounted = false;
    }

    imageLoaded = () => {
        if (this.mounted) {
            this.setState({loaded: true});
        }
    }

    handleImageClick = (e: React.MouseEvent<HTMLDivElement>) => {
        e.preventDefault();

        this.props.actions.openModal({
            modalId: ModalIdentifiers.FILE_PREVIEW_MODAL,
            dialogType: FilePreviewModal,
            dialogProps: {
                fileInfos: [this.props.fileInfo],
                postId: this.props.postId,
                startIndex: 0,
            },
        });
    }

    toggleEmbedVisibility = () => {
        this.props.actions.toggleEmbedVisibility(this.props.postId);
    }

    getFilePublicLink = () => {
        return this.props.actions.getFilePublicLink(this.props.fileInfo.id);
    }

    render() {
        const {fileInfo, compactDisplay, isInPermalink} = this.props;
        const {
            loaded,
        } = this.state;

        if (fileInfo === undefined) {
            return <></>;
        }

        const {has_preview_image: hasPreviewImage, id} = fileInfo;
        const fileURL = getFileUrl(id);
        const previewURL = hasPreviewImage ? getFilePreviewUrl(id) : fileURL;

        const previewHeight = fileInfo.height;
        const previewWidth = fileInfo.width;

        let minPreviewClass = '';
        if (
            previewWidth < PREVIEW_IMAGE_MIN_DIMENSION ||
            previewHeight < PREVIEW_IMAGE_MIN_DIMENSION
        ) {
            minPreviewClass = 'min-preview ';

            if (previewHeight > previewWidth) {
                minPreviewClass += 'min-preview--portrait ';
            }
        }

        // Add compact display class to image class if in compact mode
        if (compactDisplay) {
            minPreviewClass += ' compact-display';
        }

        const toggle = (
            <button
                key='toggle'
                className='style--none single-image-view__toggle'
                data-expanded={this.props.isEmbedVisible}
                aria-label='Toggle Embed Visibility'
                onClick={this.toggleEmbedVisibility}
            >
                <span
                    className={classNames('icon', {
                        'icon-menu-down': this.props.isEmbedVisible,
                        'icon-menu-right': !this.props.isEmbedVisible,
                    })}
                />
            </button>
        );

        const fileHeader = (
            <div
                className={classNames('image-header', {
                    'image-header--expanded': this.props.isEmbedVisible,
                })}
            >
                {toggle}
                {!this.props.isEmbedVisible && (
                    <div
                        data-testid='image-name'
                        className={classNames('image-name', {
                            'compact-display': compactDisplay,
                        })}
                    >
                        <div
                            id='image-name-text'
                            onClick={this.handleImageClick}
                        >
                            {fileInfo.name}
                        </div>
                    </div>
                )}
            </div>
        );

        let fadeInClass = '';
        let permalinkClass = '';

        const fileType = getFileType(fileInfo.extension);
        let styleIfSvgWithDimensions = {};
        let imageContainerStyle = {};
        let svgClass = '';
        if (fileType === FileTypes.SVG) {
            svgClass = 'svg';
            if (this.state.dimensions.height) {
                styleIfSvgWithDimensions = {
                    width: '100%',
                };
            } else {
                imageContainerStyle = {
                    height: 350,
                    maxWidth: '100%',
                };
            }
        }

        if (loaded) {
            fadeInClass = 'image-fade-in';
        }

        if (isInPermalink) {
            permalinkClass = 'image-permalink';
        }

        return (
            <div
                className={classNames('file-view--single', permalinkClass)}
            >
                <div
                    className='file__image'
                >
                    {fileHeader}
                    {this.props.isEmbedVisible &&
                    <div
                        className={classNames('image-container', permalinkClass)}
                        style={imageContainerStyle}
                    >
                        <div
                            className={classNames('image-loaded', fadeInClass, svgClass)}
                            style={styleIfSvgWithDimensions}
                        >
                            <div className={classNames(permalinkClass)}>
                                <SizeAwareImage
                                    onClick={this.handleImageClick}
                                    className={classNames(minPreviewClass, permalinkClass)}
                                    src={previewURL}
                                    dimensions={this.state.dimensions}
                                    fileInfo={this.props.fileInfo}
                                    fileURL={fileURL}
                                    onImageLoaded={this.imageLoaded}
                                    showLoader={this.props.isEmbedVisible}
                                    handleSmallImageContainer={true}
                                    enablePublicLink={this.props.enablePublicLink}
                                    getFilePublicLink={this.getFilePublicLink}
                                />
                            </div>
                        </div>
                    </div>
                    }
                </div>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect, ConnectedProps} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {GenericAction} from 'mattermost-redux/types/actions';
import {getConfig} from 'mattermost-redux/selectors/entities/general';

import {GlobalState} from 'types/store';

import {toggleEmbedVisibility} from 'actions/post_actions';
import {openModal} from 'actions/views/modals';
import {getFilePublicLink} from 'mattermost-redux/actions/files';

import {getIsRhsOpen} from 'selectors/rhs';

import SingleImageView from 'components/single_image_view/single_image_view';

function mapStateToProps(state: GlobalState) {
    const isRhsOpen = getIsRhsOpen(state);
    const config = getConfig(state);

    return {
        isRhsOpen,
        enablePublicLink: config.EnablePublicLink === 'true',
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            toggleEmbedVisibility,
            openModal,
            getFilePublicLink,
        }, dispatch),
    };
}

const connector = connect(mapStateToProps, mapDispatchToProps);

export type PropsFromRedux = ConnectedProps<typeof connector>;

export default connector(SingleImageView);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useMemo} from 'react';

import {sortFileInfos} from 'mattermost-redux/utils/file_utils';

import {FileTypes, ModalIdentifiers} from 'utils/constants';
import {getFileType} from 'utils/utils';

import FileAttachment from 'components/file_attachment';
import SingleImageView from 'components/single_image_view';
import FilePreviewModal from 'components/file_preview_modal';

import type {OwnProps, PropsFromRedux} from './index';

type Props = OwnProps & PropsFromRedux;

export default function FileAttachmentList(props: Props) {
    const handleImageClick = (indexClicked: number) => {
        props.actions.openModal({
            modalId: ModalIdentifiers.FILE_PREVIEW_MODAL,
            dialogType: FilePreviewModal,
            dialogProps: {
                postId: props.post.id,
                fileInfos: props.fileInfos,
                startIndex: indexClicked,
            },
        });
    };

    const {
        compactDisplay,
        enableSVGs,
        fileInfos,
        fileCount,
        locale,
        isInPermalink,
    } = props;

    const sortedFileInfos = useMemo(() => sortFileInfos(fileInfos ? [...fileInfos] : [], locale), [fileInfos, locale]);
    if (fileInfos && fileInfos.length === 1 && !fileInfos[0].archived) {
        const fileType = getFileType(fileInfos[0].extension);

        if (fileType === FileTypes.IMAGE || (fileType === FileTypes.SVG && enableSVGs)) {
            return (
                <SingleImageView
                    fileInfo={fileInfos[0]}
                    isEmbedVisible={props.isEmbedVisible}
                    postId={props.post.id}
                    compactDisplay={compactDisplay}
                    isInPermalink={isInPermalink}
                />
            );
        }
    } else if (fileCount === 1 && props.isEmbedVisible && !fileInfos?.[0]) {
        return (
            <div style={style.minHeightPlaceholder}/>
        );
    }

    const postFiles = [];
    if (sortedFileInfos && sortedFileInfos.length > 0) {
        for (let i = 0; i < sortedFileInfos.length; i++) {
            const fileInfo = sortedFileInfos[i];
            postFiles.push(
                <FileAttachment
                    key={fileInfo.id}
                    fileInfo={sortedFileInfos[i]}
                    index={i}
                    handleImageClick={handleImageClick}
                    compactDisplay={compactDisplay}
                    handleFileDropdownOpened={props.handleFileDropdownOpened}
                />,
            );
        }
    } else if (fileCount > 0) {
        for (let i = 0; i < fileCount; i++) {
            // Add a placeholder to avoid pop-in once we get the file infos for this post
            postFiles.push(
                <div
                    key={`fileCount-${i}`}
                    className='post-image__column post-image__column--placeholder'
                />,
            );
        }
    }

    return (
        <div
            data-testid='fileAttachmentList'
            className='post-image__columns clearfix'
        >
            {postFiles}
        </div>
    );
}

const style = {
    minHeightPlaceholder: {minHeight: '385px'},
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect, ConnectedProps} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {makeGetFilesForPost} from 'mattermost-redux/selectors/entities/files';
import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {Post} from '@mattermost/types/posts';
import {GenericAction} from 'mattermost-redux/types/actions';

import {GlobalState} from 'types/store';

import {getCurrentLocale} from 'selectors/i18n';
import {isEmbedVisible} from 'selectors/posts';

import {openModal} from 'actions/views/modals';

import FileAttachmentList from './file_attachment_list';

export type OwnProps = {
    post: Post;
    compactDisplay?: boolean;
    isInPermalink?: boolean;
    handleFileDropdownOpened?: (open: boolean) => void;
}

function makeMapStateToProps() {
    const selectFilesForPost = makeGetFilesForPost();

    return function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
        const postId = ownProps.post ? ownProps.post.id : '';
        const fileInfos = selectFilesForPost(state, postId);

        let fileCount = 0;
        if (ownProps.post.metadata && ownProps.post.metadata.files) {
            fileCount = (ownProps.post.metadata.files || []).length;
        } else if (ownProps.post.file_ids) {
            fileCount = ownProps.post.file_ids.length;
        } else if (ownProps.post.filenames) {
            fileCount = ownProps.post.filenames.length;
        }

        return {
            enableSVGs: getConfig(state).EnableSVGs === 'true',
            fileInfos,
            fileCount,
            isEmbedVisible: isEmbedVisible(state, ownProps.post.id),
            locale: getCurrentLocale(state),
        };
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            openModal,
        }, dispatch),
    };
}

const connector = connect(makeMapStateToProps, mapDispatchToProps);

export type PropsFromRedux = ConnectedProps<typeof connector>;

export default connector(FileAttachmentList);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState} from 'react';
import styled from 'styled-components';
import {FormattedMessage, useIntl} from 'react-intl';
import {useDispatch, useSelector} from 'react-redux';

import {getCurrentUser, isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';
import {get as selectPreference} from 'mattermost-redux/selectors/entities/preferences';
import {isCurrentLicenseCloud, getSubscriptionProduct as selectSubscriptionProduct} from 'mattermost-redux/selectors/entities/cloud';
import {savePreferences} from 'mattermost-redux/actions/preferences';

import {GlobalState} from 'types/store';

import useGetUsage from 'components/common/hooks/useGetUsage';
import useGetLimits from 'components/common/hooks/useGetLimits';
import useOpenPricingModal from 'components/common/hooks/useOpenPricingModal';
import NotifyAdminCTA from 'components/notify_admin_cta/notify_admin_cta';
import AlertBanner from 'components/alert_banner';
import Tooltip from 'components/tooltip';

import {CloudProducts, LicenseSkus, PaidFeatures, Preferences} from 'utils/constants';
import {asGBString} from 'utils/limits';

interface FileLimitSnoozePreference {
    lastSnoozeTimestamp: number;
}

const snoozeCoolOffDays = 10;
const snoozeCoolOffDaysMillis = snoozeCoolOffDays * 24 * 60 * 60 * 1000;

const StyledDiv = styled.div`
width: 100%;
padding: 0 24px;
margin: 12px auto;
`;

function FileLimitStickyBanner() {
    const [show, setShow] = useState(true);
    const {formatMessage, formatNumber} = useIntl();
    const dispatch = useDispatch();

    const usage = useGetUsage();
    const [cloudLimits] = useGetLimits();
    const openPricingModal = useOpenPricingModal();

    const user = useSelector(getCurrentUser);
    const isAdmin = useSelector(isCurrentUserSystemAdmin);
    const isCloud = useSelector(isCurrentLicenseCloud);
    const product = useSelector(selectSubscriptionProduct);
    const isStarter = product?.sku === CloudProducts.STARTER;

    const snoozePreferenceVal = useSelector((state: GlobalState) => selectPreference(state, Preferences.CLOUD_USER_EPHEMERAL_INFO, 'file_limit_banner_snooze'));

    let shouldShowAgain = true;
    if (snoozePreferenceVal !== '') {
        const snoozeInfo = JSON.parse(snoozePreferenceVal) as FileLimitSnoozePreference;
        const timeDiff = Date.now() - snoozeInfo.lastSnoozeTimestamp;
        shouldShowAgain = timeDiff >= snoozeCoolOffDaysMillis;
    }

    if (!show) {
        return null;
    }

    if (!shouldShowAgain) {
        return null;
    }

    if (!isCloud || !isStarter) {
        return null;
    }

    const fileStorageLimit = cloudLimits?.files?.total_storage;
    const currentFileStorageUsage = usage.files.totalStorage;
    if ((fileStorageLimit === undefined) || !(currentFileStorageUsage > fileStorageLimit)) {
        return null;
    }

    const snoozeBanner = () => {
        const fileLimitBannerSnoozeInfo: FileLimitSnoozePreference = {
            lastSnoozeTimestamp: Date.now(),
        };

        dispatch(savePreferences(user.id, [
            {
                category: Preferences.CLOUD_USER_EPHEMERAL_INFO,
                name: 'file_limit_banner_snooze',
                user_id: user.id,
                value: JSON.stringify(fileLimitBannerSnoozeInfo),
            },
        ]));

        setShow(false);
    };

    const title = (
        <FormattedMessage
            id={'create_post.file_limit_sticky_banner.messageTitle'}
            defaultMessage={'Your free plan is limited to {storageGB} of files.'}
            values={{
                storageGB: asGBString(fileStorageLimit, formatNumber),
            }}
        />
    );

    const adminMessage =
        (
            <FormattedMessage
                id={'create_post.file_limit_sticky_banner.admin_message'}
                defaultMessage={'New uploads will automatically archive older files. To view them again, you can delete older files or <a>upgrade to a paid plan.</a>'}
                values={{
                    a: (chunks: React.ReactNode) => {
                        return (
                            <a
                                onClick={
                                    (e) => {
                                        e.preventDefault();
                                        openPricingModal({trackingLocation: 'file_limit_sticky_banner'});
                                    }
                                }
                            >{chunks}</a>
                        );
                    },
                }}
            />
        );

    const nonAdminMessage =
        (
            <FormattedMessage
                id={'create_post.file_limit_sticky_banner.non_admin_message'}
                defaultMessage={'New uploads will automatically archive older files. To view them again, <a>notify your admin to upgrade to a paid plan.</a>'}
                values={{
                    a: (chunks: React.ReactNode) => (
                        <NotifyAdminCTA
                            ctaText={chunks}
                            notifyRequestData={{
                                required_plan: LicenseSkus.Professional,
                                required_feature: PaidFeatures.UNLIMITED_FILE_STORAGE,
                                trial_notification: false,
                            }}
                            callerInfo='file_limit_sticky_banner'
                        />),
                }}
            />
        );

    const tooltip = (
        <Tooltip id='file_limit_banner_snooze'>
            {formatMessage({id: 'create_post.file_limit_sticky_banner.snooze_tooltip', defaultMessage: 'Snooze for {snoozeDays} days'}, {snoozeDays: snoozeCoolOffDays})}
        </Tooltip>
    );

    return (
        <StyledDiv id='cloud_file_limit_banner'>
            <AlertBanner
                mode={'warning'}
                variant={'app'}
                onDismiss={snoozeBanner}
                closeBtnTooltip={tooltip}
                title={title}
                message={isAdmin ? adminMessage : nonAdminMessage}
            />
        </StyledDiv>
    );
}

export default FileLimitStickyBanner;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';
import {ProgressBar} from 'react-bootstrap';

import FilenameOverlay from 'components/file_attachment/filename_overlay';
import {getFileTypeFromMime} from 'utils/file_utils';
import * as Utils from 'utils/utils';

import {FilePreviewInfo} from './file_preview';

type Props = {
    handleRemove: (id: string) => void;
    clientId: string;
    fileInfo: FilePreviewInfo;
}

export default class FileProgressPreview extends React.PureComponent<Props> {
    handleRemove = () => {
        this.props.handleRemove(this.props.clientId);
    }

    render() {
        let percent = 0;
        let fileNameComponent;
        let previewImage;
        let progressBar;
        const {fileInfo, clientId} = this.props;

        if (fileInfo) {
            percent = fileInfo.percent ? fileInfo.percent : 0;
            const percentTxt = ` (${percent.toFixed(0)}%)`;
            const fileType = getFileTypeFromMime(fileInfo.type || '');
            previewImage = <div className={'file-icon ' + Utils.getIconClassName(fileType)}/>;

            fileNameComponent = (
                <React.Fragment>
                    <FilenameOverlay
                        fileInfo={fileInfo}
                        compactDisplay={false}
                        canDownload={false}
                    />
                    <span className='post-image__uploadingTxt'>
                        {percent === 100 ? (
                            <FormattedMessage
                                id='create_post.fileProcessing'
                                defaultMessage='Processing...'
                            />
                        ) : (
                            <React.Fragment>
                                <FormattedMessage
                                    id='admin.plugin.uploading'
                                    defaultMessage='Uploading...'
                                />
                                <span>{percentTxt}</span>
                            </React.Fragment>
                        )}
                    </span>
                </React.Fragment>
            );

            if (percent) {
                progressBar = (
                    <ProgressBar
                        className='post-image__progressBar'
                        now={percent}
                        active={percent === 100}
                    />
                );
            }
        }

        return (
            <div
                ref={clientId}
                key={clientId}
                className='file-preview post-image__column'
                data-client-id={clientId}
            >
                <div className='post-image__thumbnail'>
                    {previewImage}
                </div>
                <div className='post-image__details'>
                    <div className='post-image__detail_wrapper'>
                        <div className='post-image__detail'>
                            {fileNameComponent}
                        </div>
                    </div>
                    <div>
                        <a
                            className='file-preview__remove'
                            onClick={this.handleRemove}
                        >
                            <i className='icon icon-close'/>
                        </a>
                    </div>
                    {progressBar}
                </div>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/* eslint-disable react/no-string-refs */

import React, {ReactNode} from 'react';

import {getFileThumbnailUrl, getFileUrl} from 'mattermost-redux/utils/file_utils';
import {FileInfo} from '@mattermost/types/files';

import FilenameOverlay from 'components/file_attachment/filename_overlay';
import Constants, {FileTypes} from 'utils/constants';
import * as Utils from 'utils/utils';

import FileProgressPreview from './file_progress_preview';

type UploadInfo = {
    name: string;
    percent?: number;
    type?: string;
}
export type FilePreviewInfo = FileInfo & UploadInfo;

type Props = {
    enableSVGs: boolean;
    onRemove?: (id: string) => void;
    fileInfos: FilePreviewInfo[];
    uploadsInProgress?: string[];
    uploadsProgressPercent?: {[clientID: string]: FilePreviewInfo};
}

export default class FilePreview extends React.PureComponent<Props> {
    static defaultProps = {
        fileInfos: [],
        uploadsInProgress: [],
        uploadsProgressPercent: {},
    };

    handleRemove = (id: string) => {
        this.props.onRemove?.(id);
    }

    render() {
        const previews: ReactNode[] = [];

        this.props.fileInfos.forEach((info) => {
            const type = Utils.getFileType(info.extension);

            let className = 'file-preview post-image__column';
            let previewImage;
            if (type === FileTypes.SVG && this.props.enableSVGs) {
                previewImage = (
                    <img
                        alt={'file preview'}
                        className='post-image normal'
                        src={getFileUrl(info.id)}
                    />
                );
            } else if (type === FileTypes.IMAGE) {
                let imageClassName = 'post-image';

                if ((info.width && info.width < Constants.THUMBNAIL_WIDTH) && (info.height && info.height < Constants.THUMBNAIL_HEIGHT)) {
                    imageClassName += ' small';
                } else {
                    imageClassName += ' normal';
                }

                let thumbnailUrl = getFileThumbnailUrl(info.id);
                if (Utils.isGIFImage(info.extension) && !info.has_preview_image) {
                    thumbnailUrl = getFileUrl(info.id);
                }

                previewImage = (
                    <div
                        className={imageClassName}
                        style={{
                            backgroundImage: `url(${thumbnailUrl})`,
                            backgroundSize: 'cover',
                        }}
                    />
                );
            } else {
                className += ' custom-file';
                previewImage = <div className={'file-icon ' + Utils.getIconClassName(type)}/>;
            }

            previews.push(
                <div
                    key={info.id}
                    className={className}
                >
                    <div className='post-image__thumbnail'>
                        {previewImage}
                    </div>
                    <div className='post-image__details'>
                        <div className='post-image__detail_wrapper'>
                            <div className='post-image__detail'>
                                <FilenameOverlay
                                    fileInfo={info}
                                    compactDisplay={false}
                                    canDownload={false}
                                />
                                {info.extension && <span className='post-image__type'>{info.extension.toUpperCase()}</span>}
                                <span className='post-image__size'>{Utils.fileSizeToString(info.size)}</span>
                            </div>
                        </div>
                        <div>
                            {Boolean(this.props.onRemove) && (
                                <a
                                    className='file-preview__remove'
                                    onClick={this.handleRemove.bind(this, info.id)}
                                >
                                    <i className='icon icon-close'/>
                                </a>
                            )}
                        </div>
                    </div>
                </div>,
            );
        });

        if (this.props.uploadsInProgress && this.props.uploadsProgressPercent) {
            const uploadsProgressPercent = this.props.uploadsProgressPercent;
            this.props.uploadsInProgress.forEach((clientId) => {
                const fileInfo = uploadsProgressPercent[clientId];
                if (fileInfo) {
                    previews.push(
                        <FileProgressPreview
                            key={clientId}
                            clientId={clientId}
                            fileInfo={fileInfo}
                            handleRemove={this.handleRemove}
                        />,
                    );
                }
            });
        }

        return (
            <div className='file-preview__container'>
                {previews}
            </div>
        );
    }
}
/* eslint-enable react/no-string-refs */

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getConfig} from 'mattermost-redux/selectors/entities/general';

import {GlobalState} from 'types/store';

import FilePreview from './file_preview';

function mapStateToProps(state: GlobalState) {
    const config = getConfig(state);

    return {
        enableSVGs: config.EnableSVGs === 'true',
    };
}

export default connect(mapStateToProps)(FilePreview);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {connect} from 'react-redux';

import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getPost} from 'mattermost-redux/selectors/entities/posts';
import {makeAsyncComponent} from 'components/async_load';

import {Post} from '@mattermost/types/posts';

import {getIsMobileView} from 'selectors/views/browser';

import {GlobalState} from 'types/store';
import {FilePreviewComponent} from 'types/store/plugins';

import {canDownloadFiles} from 'utils/file_utils';

import type {Props} from './file_preview_modal';

const FilePreviewModal = makeAsyncComponent('FilePreviewModal', React.lazy<React.ComponentType<Props>>(() => import('./file_preview_modal')));

type OwnProps = {
    post?: Post;
    postId?: string;
}

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const config = getConfig(state);

    return {
        canDownloadFiles: canDownloadFiles(config),
        enablePublicLink: config.EnablePublicLink === 'true',
        isMobileView: getIsMobileView(state),
        pluginFilePreviewComponents: state.plugins.components.FilePreview as unknown as FilePreviewComponent[],
        post: ownProps.post || getPost(state, ownProps.postId || ''),
    };
}

export default connect(mapStateToProps)(FilePreviewModal);

export default __webpack_public_path__ + "files/55d77b94009ea98824ee008af39dedb2.png";
export default __webpack_public_path__ + "files/7a26b407c4ec2bbbaecd3f0f314de7bd.png";
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import fileOverlayImage from 'images/filesOverlay.png';
import overlayLogoImage from 'images/logoWhite.png';

import {t} from 'utils/i18n';

import LocalizedIcon from './localized_icon';

type Props = {
    overlayType: string;
}

const FileUploadOverlay: React.FC<Props> = (props: Props) => {
    let overlayClass = 'file-overlay hidden';
    if (props.overlayType === 'right') {
        overlayClass += ' right-file-overlay';
    } else if (props.overlayType === 'center') {
        overlayClass += ' center-file-overlay';
    }

    return (
        <div className={overlayClass}>
            <div className='overlay__indent'>
                <div className='overlay__circle'>
                    <img
                        className='overlay__files'
                        src={fileOverlayImage}
                        alt='Files'
                    />
                    <span>
                        <LocalizedIcon
                            className='fa fa-upload'
                            title={{id: t('generic_icons.upload'), defaultMessage: 'Upload Icon'}}
                        />
                        <FormattedMessage
                            id='upload_overlay.info'
                            defaultMessage='Drop a file to upload it.'
                        />
                    </span>
                    <img
                        className='overlay__logo'
                        src={overlayLogoImage}
                        width='100'
                        alt='Logo'
                    />
                </div>
            </div>
        </div>
    );
};

export default FileUploadOverlay;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

// accepts either a single error or an array of errors
type Props = {
    type?: React.ReactNode;
    error?: React.ReactNode;
    textClassName?: string;
    iconClassName?: string;
    margin?: boolean;
    errors?: React.ReactNode[];
}

export default class FormError extends React.PureComponent<Props> {
    public static defaultProps = {
        error: null,
        errors: [],
    }
    public render() {
        const {error = null, errors = [], iconClassName, margin, textClassName, type} = this.props;

        if (!error && errors.length === 0) {
            return null;
        }

        // look for the first truthy error to display
        let message = error;

        if (!message) {
            for (const err of errors) {
                if (err) {
                    message = err;
                }
            }
        }

        if (!message) {
            return null;
        }

        if (type === 'modal') {
            return (
                <div className='form-group'>
                    <label className='col-sm-12 has-error'>
                        {message}
                    </label>
                </div>
            );
        }

        if (type === 'backstage') {
            return (
                <div className='pull-left has-error'>
                    <label className='control-label'>
                        {message}
                    </label>
                </div>
            );
        }

        if (margin) {
            return (
                <div className='form-group has-error'>
                    <label className='control-label'>
                        {message}
                    </label>
                </div>
            );
        }

        return (
            <div className={`col-sm-12 ${textClassName || 'has-error'}`}>
                <label className='control-label'>
                    <i className={`fa ${iconClassName || 'fa-exclamation-circle'}`}/> {message}
                </label>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';
import marked from 'marked';

import {shouldOpenInNewTab, getSiteURL} from 'utils/url';

const TARGET_BLANK_URL_PREFIX = '!';

export class CustomRenderer extends marked.Renderer {
    private disableLinks: boolean;

    constructor(disableLinks = false) {
        super();
        this.disableLinks = disableLinks;
    }

    link(href: string, title: string, text: string) {
        const siteURL = getSiteURL();
        const openInNewTab = shouldOpenInNewTab(href, siteURL);

        if (this.disableLinks) {
            return text;
        }
        if (href[0] === TARGET_BLANK_URL_PREFIX) {
            return `<a href="${href.substring(1, href.length)}" rel="noopener noreferrer" target="_blank">${text}</a>`;
        }
        if (openInNewTab) {
            return `<a href="${href}" rel="noopener noreferrer" target="_blank">${text}</a>`;
        }
        return `<a href="${href}">${text}</a>`;
    }

    paragraph(text: string) {
        return text;
    }
}

type Props = {
    defaultMessage?: string;
    disableLinks?: boolean;
    id?: string;
    values?: Record<string, any>;
}

/**
 *
 * Translations component with the same API as react-intl's <FormattedMessage> component except the message string
 * accepts Markdown.
 *
 * @deprecated Use FormattedMessage with {@link https://formatjs.io/docs/react-intl/components/#rich-text-formatting rich text formatting} instead
 * of including Markdown in translation strings.
 */
export default function FormattedMarkdownMessage({
    id,
    defaultMessage,
    values,
    disableLinks,
}: Props) {
    const intl = useIntl();

    const origMsg = intl.formatMessage({id, defaultMessage}, values);

    const markedUpMessage = marked(origMsg, {
        breaks: true,
        sanitize: true,
        renderer: new CustomRenderer(disableLinks),
    });

    return (<span dangerouslySetInnerHTML={{__html: markedUpMessage}}/>);
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {GenericModal} from '@mattermost/components';

import './generic_modal.scss';

export default GenericModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {MutableRefObject, useEffect, useRef} from 'react';
import {useSelector} from 'react-redux';

import {getCurrentUser, isFirstAdmin, isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';
import {UserProfile} from '@mattermost/types/users';
import {isModalOpen} from 'selectors/views/modals';
import {GlobalState} from 'types/store';

/**
 * Hook that alerts clicks outside of the passed ref.
 */
export function useClickOutsideRef(ref: MutableRefObject<HTMLElement | null>, handler: () => void): void {
    useEffect(() => {
        function onMouseDown(event: MouseEvent) {
            const target = event.target as any;
            if (ref.current && target instanceof Node && !ref.current.contains(target)) {
                handler();
            }
        }

        // Bind the event listener
        document.addEventListener('mousedown', onMouseDown);
        return () => {
            // Unbind the event listener on clean up
            document.removeEventListener('mousedown', onMouseDown);
        };
    }, [ref, handler]);
}

export const useFirstAdminUser = (): boolean => {
    return useSelector(isFirstAdmin);
};

export const useIsCurrentUserSystemAdmin = (): boolean => {
    return useSelector(isCurrentUserSystemAdmin);
};

export const useIsLoggedIn = (): boolean => {
    return Boolean(useSelector<GlobalState, UserProfile>(getCurrentUser));
};

/**
 * Hook that returns the current open state of the specified modal
 * - returns both the direct boolean for regular use and a ref that contains the boolean for usage in a callback
 */
export const useIsModalOpen = (modalIdentifier: string): [boolean, React.RefObject<boolean>] => {
    const modalOpenState = useSelector((state: GlobalState) => isModalOpen(state, modalIdentifier));
    const modalOpenStateRef = useRef(modalOpenState);

    useEffect(() => {
        modalOpenStateRef.current = modalOpenState;
    }, [modalOpenState]);

    return [modalOpenState, modalOpenStateRef];
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// https://stackoverflow.com/a/54485712
const Nbsp: React.FC = () => '\u00A0' as unknown as React.ReactElement;
export default Nbsp;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import Setting from './setting';

type Props = {
    id: string;
    options: Array<{text: string; value: string}>;
    label: React.ReactNode;
    onChange(name: string, value: any): void;
    value?: string;
    labelClassName?: string;
    inputClassName?: string;
    helpText?: React.ReactNode;

}

export default class RadioSetting extends React.PureComponent<Props> {
    public static defaultProps: Partial<Props> = {
        labelClassName: '',
        inputClassName: '',
        options: [],
    };

    private handleChange: React.ChangeEventHandler<HTMLInputElement> = (e) => {
        this.props.onChange(this.props.id, e.target.value);
    }

    public render(): JSX.Element {
        return (
            <Setting
                label={this.props.label}
                labelClassName={this.props.labelClassName}
                inputClassName={this.props.inputClassName}
                helpText={this.props.helpText}
                inputId={this.props.id}
            >
                {
                    this.props.options.map(({value, text}) => {
                        return (
                            <div
                                className='radio'
                                key={value}
                            >
                                <label>
                                    <input
                                        type='radio'
                                        value={value}
                                        name={this.props.id}
                                        checked={value === this.props.value}
                                        onChange={this.handleChange}
                                    />
                                    {text}
                                </label>
                            </div>
                        );
                    })
                }
            </Setting>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {FormattedMessage} from 'react-intl';

import MenuActionProvider from 'components/suggestion/menu_action_provider';
import GenericUserProvider from 'components/suggestion/generic_user_provider';
import GenericChannelProvider from 'components/suggestion/generic_channel_provider.jsx';

import TextSetting, {InputTypes} from 'components/widgets/settings/text_setting';
import AutocompleteSelector from 'components/autocomplete_selector';
import ModalSuggestionList from 'components/suggestion/modal_suggestion_list.jsx';
import BoolSetting from 'components/widgets/settings/bool_setting';
import RadioSetting from 'components/widgets/settings/radio_setting';
import {Channel} from '@mattermost/types/channels';
import Provider from 'components/suggestion/provider';
import {UserAutocomplete} from '@mattermost/types/autocomplete';

const TEXT_DEFAULT_MAX_LENGTH = 150;
const TEXTAREA_DEFAULT_MAX_LENGTH = 3000;

export type Props = {
    displayName: string;
    name: string;
    type: string;
    subtype?: string;
    placeholder?: string;
    helpText?: string;
    errorText?: React.ReactNode;
    maxLength?: number;
    dataSource?: string;
    optional?: boolean;
    options?: Array<{
        text: string;
        value: string;
    }>;
    value?: string | boolean;
    onChange: (name: string, selected: string) => void;
    autoFocus?: boolean;
    actions: {
        autocompleteChannels: (term: string, success: (channels: Channel[]) => void, error: () => void) => Promise<void>;
        autocompleteUsers: (search: string) => Promise<UserAutocomplete>;
    };
}

type State = {
    value: string;
}

type Selected = {
    id: string;
    username: string;
    display_name: string;
    value: string;
    text: string;
}

export default class DialogElement extends React.PureComponent<Props, State> {
    private providers: Provider[];

    constructor(props: Props) {
        super(props);

        let defaultText = '';
        this.providers = [];
        if (props.type === 'select') {
            if (props.dataSource === 'users') {
                this.providers = [new GenericUserProvider(props.actions.autocompleteUsers)];
            } else if (props.dataSource === 'channels') {
                this.providers = [new GenericChannelProvider(props.actions.autocompleteChannels)];
            } else if (props.options) {
                this.providers = [new MenuActionProvider(props.options)];
            }

            if (props.value && props.options) {
                const defaultOption = props.options.find(
                    (option) => option.value === props.value,
                );
                defaultText = defaultOption ? defaultOption.text : '';
            }
        }

        this.state = {
            value: defaultText,
        };
    }

    private handleSelected = (selected: Selected) => {
        const {name, dataSource} = this.props;

        if (dataSource === 'users') {
            this.props.onChange(name, selected.id);
            this.setState({value: selected.username});
        } else if (dataSource === 'channels') {
            this.props.onChange(name, selected.id);
            this.setState({value: selected.display_name});
        } else {
            this.props.onChange(name, selected.value);
            this.setState({value: selected.text});
        }
    }

    public render(): JSX.Element | null {
        const {
            name,
            subtype,
            displayName,
            value,
            placeholder,
            onChange,
            helpText,
            errorText,
            optional,
            options,
        } = this.props;

        let {type, maxLength} = this.props;

        let displayNameContent: React.ReactNode = displayName;
        if (optional) {
            displayNameContent = (
                <React.Fragment>
                    {displayName + ' '}
                    <span className='font-weight--normal light'>
                        <FormattedMessage
                            id='interactive_dialog.element.optional'
                            defaultMessage='(optional)'
                        />
                    </span>
                </React.Fragment>
            );
        } else {
            displayNameContent = (
                <React.Fragment>
                    {displayName}
                    <span className='error-text'>{' *'}</span>
                </React.Fragment>
            );
        }

        let helpTextContent: React.ReactNode = helpText;
        if (errorText) {
            helpTextContent = (
                <React.Fragment>
                    {helpText}
                    <div className='error-text mt-3'>
                        {errorText}
                    </div>
                </React.Fragment>
            );
        }

        if (type === 'text' || type === 'textarea') {
            if (type === 'text') {
                maxLength = maxLength || TEXT_DEFAULT_MAX_LENGTH;

                if (subtype && TextSetting.validTypes.includes(subtype)) {
                    type = subtype;
                } else {
                    type = 'input';
                }
            } else {
                maxLength = maxLength || TEXTAREA_DEFAULT_MAX_LENGTH;
            }

            const textValue = value as string;
            return (
                <TextSetting
                    autoFocus={this.props.autoFocus}
                    id={name}
                    type={type as InputTypes}
                    label={displayNameContent}
                    maxLength={maxLength}
                    value={textValue || ''}
                    placeholder={placeholder}
                    helpText={helpTextContent}
                    onChange={onChange}
                    resizable={false}
                />
            );
        } else if (type === 'select') {
            return (
                <AutocompleteSelector
                    id={name}
                    providers={this.providers}
                    onSelected={this.handleSelected}
                    label={displayNameContent}
                    helpText={helpTextContent}
                    placeholder={placeholder}
                    value={this.state.value}
                    listComponent={ModalSuggestionList}
                    listPosition='bottom'
                />
            );
        } else if (type === 'bool') {
            const boolValue = value as boolean;
            return (
                <BoolSetting
                    autoFocus={this.props.autoFocus}
                    id={name}
                    label={displayNameContent}
                    value={boolValue || false}
                    helpText={helpTextContent}
                    placeholder={placeholder}
                    onChange={onChange}
                />
            );
        } else if (type === 'radio') {
            const textValue = value as string;
            return (
                <RadioSetting
                    id={name}
                    label={displayNameContent}
                    helpText={helpTextContent}
                    options={options}
                    value={textValue}
                    onChange={onChange}
                />
            );
        }

        return null;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {autocompleteChannels} from 'actions/channel_actions';
import {autocompleteUsers} from 'actions/user_actions';

import {ActionFunc, GenericAction} from 'mattermost-redux/types/actions';

import DialogElement, {Props} from './dialog_element';

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc>, Props['actions']>({
            autocompleteChannels,
            autocompleteUsers,
        }, dispatch),
    };
}

export default connect(null, mapDispatchToProps)(DialogElement);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import * as Markdown from 'utils/markdown';
import {getSiteURL} from 'utils/url';
import EmojiMap from 'utils/emoji_map';

type Props = {
    id: string;
    value: string;
    emojiMap: EmojiMap;
}

export default function DialogIntroductionText({id, value, emojiMap}: Props): JSX.Element {
    const formattedMessage = Markdown.format(
        value,
        {
            breaks: true,
            sanitize: true,
            gfm: true,
            siteURL: getSiteURL(),
        },
        emojiMap,
    );

    return (
        <span
            id={id}
            dangerouslySetInnerHTML={{__html: formattedMessage}}
        />
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import PropTypes from 'prop-types';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

import {
    checkDialogElementForError,
    checkIfErrorsMatchElements,
} from 'mattermost-redux/utils/integration_utils';

import SpinnerButton from 'components/spinner_button';

import {localizeMessage} from 'utils/utils';

import DialogElement from './dialog_element';
import DialogIntroductionText from './dialog_introduction_text';

export default class InteractiveDialog extends React.PureComponent {
    static propTypes = {
        url: PropTypes.string.isRequired,
        callbackId: PropTypes.string,
        elements: PropTypes.arrayOf(PropTypes.object),
        title: PropTypes.string.isRequired,
        introductionText: PropTypes.string,
        iconUrl: PropTypes.string,
        submitLabel: PropTypes.string,
        notifyOnCancel: PropTypes.bool,
        state: PropTypes.string,
        onExited: PropTypes.func,
        actions: PropTypes.shape({
            submitInteractiveDialog: PropTypes.func.isRequired,
        }).isRequired,
        emojiMap: PropTypes.object.isRequired,
    };

    constructor(props) {
        super(props);

        const values = {};
        if (props.elements != null) {
            props.elements.forEach((e) => {
                if (e.type === 'bool') {
                    values[e.name] =
                        e.default === true ||
                        String(e.default).toLowerCase() === 'true';
                } else {
                    values[e.name] = e.default || null;
                }
            });
        }

        this.state = {
            show: true,
            values,
            error: null,
            errors: {},
            submitting: false,
        };
    }

    handleSubmit = async (e) => {
        e.preventDefault();

        const {elements} = this.props;
        const values = this.state.values;
        const errors = {};
        if (elements) {
            elements.forEach((elem) => {
                const error = checkDialogElementForError(
                    elem,
                    values[elem.name],
                );
                if (error) {
                    errors[elem.name] = (
                        <FormattedMessage
                            id={error.id}
                            defaultMessage={error.defaultMessage}
                            values={error.values}
                        />
                    );
                }
            });
        }

        this.setState({errors});

        if (Object.keys(errors).length !== 0) {
            return;
        }

        const {url, callbackId, state} = this.props;

        const dialog = {
            url,
            callback_id: callbackId,
            state,
            submission: values,
        };

        this.setState({submitting: true});

        const {data} = await this.props.actions.submitInteractiveDialog(
            dialog,
        );

        this.setState({submitting: false});

        let hasErrors = false;

        if (data) {
            if (data.error) {
                hasErrors = true;
                this.setState({error: data.error});
            }

            if (
                data.errors &&
                Object.keys(data.errors).length >= 0 &&
                checkIfErrorsMatchElements(data.errors, elements)
            ) {
                hasErrors = true;
                this.setState({errors: data.errors});
            }
        }

        if (!hasErrors) {
            this.handleHide(true);
        }
    };

    onHide = () => {
        this.handleHide(false);
    };

    handleHide = (submitted = false) => {
        const {url, callbackId, state, notifyOnCancel} = this.props;

        if (!submitted && notifyOnCancel) {
            const dialog = {
                url,
                callback_id: callbackId,
                state,
                cancelled: true,
            };

            this.props.actions.submitInteractiveDialog(dialog);
        }

        this.setState({show: false});
    };

    onChange = (name, value) => {
        const values = {...this.state.values, [name]: value};
        this.setState({values});
    };

    render() {
        const {
            title,
            introductionText,
            iconUrl,
            submitLabel,
            elements,
        } = this.props;

        let submitText = (
            <FormattedMessage
                id='interactive_dialog.submit'
                defaultMessage='Submit'
            />
        );
        if (submitLabel) {
            submitText = submitLabel;
        }

        let icon;
        if (iconUrl) {
            icon = (
                <img
                    id='interactiveDialogIconUrl'
                    alt={'modal title icon'}
                    className='more-modal__image'
                    width='36'
                    height='36'
                    src={iconUrl}
                />
            );
        }

        return (
            <Modal
                id='interactiveDialogModal'
                dialogClassName='a11y__modal about-modal'
                show={this.state.show}
                onHide={this.onHide}
                onExited={this.props.onExited}
                backdrop='static'
                role='dialog'
                aria-labelledby='interactiveDialogModalLabel'
            >
                <form
                    onSubmit={this.handleSubmit}
                    autoComplete={'off'}
                >
                    <Modal.Header
                        closeButton={true}
                        style={{borderBottom: elements == null && '0px'}}
                    >
                        <Modal.Title
                            componentClass='h1'
                            id='interactiveDialogModalLabel'
                        >
                            {icon}
                            {title}
                        </Modal.Title>
                    </Modal.Header>
                    {(elements || introductionText) && (
                        <Modal.Body>
                            {introductionText && (
                                <DialogIntroductionText
                                    id='interactiveDialogModalIntroductionText'
                                    value={introductionText}
                                    emojiMap={this.props.emojiMap}
                                />
                            )}
                            {elements &&
                            elements.map((e, index) => {
                                return (
                                    <DialogElement
                                        autoFocus={index === 0}
                                        key={'dialogelement' + e.name}
                                        displayName={e.display_name}
                                        name={e.name}
                                        type={e.type}
                                        subtype={e.subtype}
                                        helpText={e.help_text}
                                        errorText={this.state.errors[e.name]}
                                        placeholder={e.placeholder}
                                        minLength={e.min_length}
                                        maxLength={e.max_length}
                                        dataSource={e.data_source}
                                        optional={e.optional}
                                        options={e.options}
                                        value={this.state.values[e.name]}
                                        onChange={this.onChange}
                                    />
                                );
                            })}
                        </Modal.Body>
                    )}
                    <Modal.Footer>
                        {this.state.error && (
                            <div className='error-text'>{this.state.error}</div>
                        )}
                        <button
                            id='interactiveDialogCancel'
                            type='button'
                            className='btn btn-link cancel-button'
                            onClick={this.onHide}
                        >
                            <FormattedMessage
                                id='interactive_dialog.cancel'
                                defaultMessage='Cancel'
                            />
                        </button>
                        <SpinnerButton
                            id='interactiveDialogSubmit'
                            type='submit'
                            autoFocus={!elements || elements.length === 0}
                            className='btn btn-primary save-button'
                            spinning={this.state.submitting}
                            spinningText={localizeMessage(
                                'interactive_dialog.submitting',
                                'Submitting...',
                            )}
                        >
                            {submitText}
                        </SpinnerButton>
                    </Modal.Footer>
                </form>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';

import {submitInteractiveDialog} from 'mattermost-redux/actions/integrations';

import {getEmojiMap} from 'selectors/emojis';

import InteractiveDialog from './interactive_dialog';

function mapStateToProps(state) {
    const data = state.entities.integrations.dialog;
    if (!data || !data.dialog) {
        return {};
    }

    return {
        url: data.url,
        callbackId: data.dialog.callback_id,
        elements: data.dialog.elements,
        title: data.dialog.title,
        introductionText: data.dialog.introduction_text,
        iconUrl: data.dialog.icon_url,
        submitLabel: data.dialog.submit_label,
        notifyOnCancel: data.dialog.notify_on_cancel,
        state: data.dialog.state,
        emojiMap: getEmojiMap(state),
    };
}

function mapDispatchToProps(dispatch) {
    return {
        actions: bindActionCreators({
            submitInteractiveDialog,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(InteractiveDialog);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {RelationOneToOne} from '@mattermost/types/utilities';
import {UserProfile} from '@mattermost/types/users';
import {Channel, ChannelMembership} from '@mattermost/types/channels';
import {TeamMemberWithError, TeamInviteWithError} from '@mattermost/types/teams';

import {ActionFunc, DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';
import * as TeamActions from 'mattermost-redux/actions/teams';
import {joinChannel} from 'mattermost-redux/actions/channels';
import {getTeamMember} from 'mattermost-redux/selectors/entities/teams';
import {getChannelMembersInChannels} from 'mattermost-redux/selectors/entities/channels';
import {isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';
import {isGuest} from 'mattermost-redux/utils/user_utils';

import {addUsersToTeam} from 'actions/team_actions';
import {t} from 'utils/i18n';
import {localizeMessage} from 'utils/utils';
import {ConsolePages} from 'utils/constants';

export function sendMembersInvites(teamId: string, users: UserProfile[], emails: string[]): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        if (users.length > 0) {
            await dispatch(TeamActions.getTeamMembersByIds(teamId, users.map((u) => u.id)));
        }
        const state = getState();
        const sent = [];
        const notSent = [];
        const usersToAdd = [];
        for (const user of users) {
            const member = getTeamMember(state, teamId, user.id);
            if (isGuest(user.roles)) {
                notSent.push({user, reason: localizeMessage('invite.members.user-is-guest', 'Contact your admin to make this guest a full member.')});
            } else if (member) {
                notSent.push({user, reason: localizeMessage('invite.members.already-member', 'This person is already a team member.')});
            } else {
                usersToAdd.push(user);
            }
        }
        if (usersToAdd.length > 0) {
            const response = await dispatch(addUsersToTeam(teamId, usersToAdd.map((u) => u.id)));
            const members = response.data || [];
            for (const userToAdd of usersToAdd) {
                const memberWithError = members.find((m: TeamMemberWithError) => m.user_id === userToAdd.id && m.error);
                if (memberWithError) {
                    notSent.push({user: userToAdd, reason: memberWithError.error.message});
                } else {
                    sent.push({user: userToAdd, reason: localizeMessage('invite.members.added-to-team', 'This member has been added to the team.')});
                }
            }
        }
        if (emails.length > 0) {
            let response;
            try {
                response = await dispatch(TeamActions.sendEmailInvitesToTeamGracefully(teamId, emails));
            } catch (e) {
                response = {data: emails.map((email) => ({email, error: {error: localizeMessage('invite.members.unable-to-add-the-user-to-the-team', 'Unable to add the user to the team.')}}))};
            }
            const invitesWithErrors = response.data || [];
            if (response.error) {
                if (response.error.server_error_id === 'app.email.rate_limit_exceeded.app_error') {
                    response.error.message = localizeMessage('invite.rate-limit-exceeded', 'Invite emails rate limit exceeded.');
                }
                for (const email of emails) {
                    notSent.push({email, reason: response.error.message});
                }
            } else {
                for (const email of emails) {
                    const inviteWithError = invitesWithErrors.find((i: TeamInviteWithError) => email.toLowerCase() === i.email && i.error);
                    if (inviteWithError && inviteWithError.error.id === 'api.team.invite_members.unable_to_send_email_with_defaults.app_error' && isCurrentUserSystemAdmin(state)) {
                        notSent.push({
                            email,
                            reason: {
                                id: t('admin.environment.smtp.smtpFailure'),
                                message: 'SMTP is not configured in System Console. Can be configured <a>here</a>.',
                            },
                            path: ConsolePages.SMTP,
                        });
                    } else if (inviteWithError) {
                        notSent.push({email, reason: inviteWithError.error.message});
                    } else {
                        sent.push({email, reason: localizeMessage('invite.members.invite-sent', 'An invitation email has been sent.')});
                    }
                }
            }
        }
        return {
            data: {
                sent,
                notSent,
            },
        };
    };
}

export async function sendGuestInviteForUser(
    dispatch: DispatchFunc,
    user: UserProfile,
    teamId: string,
    channels: Channel[],
    members: RelationOneToOne<Channel, Record<string, ChannelMembership>>,
) {
    if (!isGuest(user.roles)) {
        return {notSent: {user, reason: localizeMessage('invite.members.user-is-not-guest', 'This person is already a member.')}};
    }
    let memberOfAll = true;
    let memberOfAny = false;

    for (const channel of channels) {
        const member = members && members[channel.id] && members[channel.id][user.id];
        if (member) {
            memberOfAny = true;
        } else {
            memberOfAll = false;
        }
    }

    if (memberOfAll) {
        return {notSent: {user, reason: localizeMessage('invite.guests.already-all-channels-member', 'This person is already a member of all the channels.')}};
    }

    try {
        await dispatch(addUsersToTeam(teamId, [user.id]));
        for (const channel of channels) {
            const member = members && members[channel.id] && members[channel.id][user.id];
            if (!member) {
                await dispatch(joinChannel(user.id, teamId, channel.id, channel.name)); // eslint-disable-line no-await-in-loop
            }
        }
    } catch (e) {
        return {notSent: {user, reason: localizeMessage('invite.guests.unable-to-add-the-user-to-the-channels', 'Unable to add the guest to the channels.')}};
    }

    if (memberOfAny) {
        return {notSent: {user, reason: localizeMessage('invite.guests.already-some-channels-member', 'This person is already a member of some of the channels.')}};
    }
    return {sent: {user, reason: {id: t('invite.guests.new-member'), message: 'This guest has been added to the team and {count, plural, one {channel} other {channels}}.', values: {count: channels.length}}}};
}

export function sendGuestsInvites(
    teamId: string,
    channels: Channel[],
    users: UserProfile[],
    emails: string[],
    message: string,
): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();
        const sent = [];
        const notSent = [];
        const members = getChannelMembersInChannels(state);
        const results = await Promise.all(users.map((user) => sendGuestInviteForUser(dispatch, user, teamId, channels, members)));

        for (const result of results) {
            if (result.sent) {
                sent.push(result.sent);
            }
            if (result.notSent) {
                notSent.push(result.notSent);
            }
        }

        if (emails.length > 0) {
            let response;
            try {
                response = await dispatch(TeamActions.sendEmailGuestInvitesToChannelsGracefully(teamId, channels.map((x) => x.id), emails, message));
            } catch (e) {
                response = {data: emails.map((email) => ({email, error: {error: localizeMessage('invite.guests.unable-to-add-the-user-to-the-channels', 'Unable to add the guest to the channels.')}}))};
            }

            if (response.error) {
                if (response.error.server_error_id === 'app.email.rate_limit_exceeded.app_error') {
                    response.error.message = localizeMessage('invite.rate-limit-exceeded', 'Invite emails rate limit exceeded.');
                }
                for (const email of emails) {
                    notSent.push({email, reason: response.error.message});
                }
            } else {
                for (const res of (response.data || [])) {
                    if (res.error) {
                        if (res.error.id === 'api.team.invite_members.unable_to_send_email_with_defaults.app_error' && isCurrentUserSystemAdmin(state)) {
                            notSent.push({
                                email: res.email,
                                reason: {
                                    id: t('admin.environment.smtp.smtpFailure'),
                                    message: 'SMTP is not configured in System Console. Can be configured <a>here</a>.',
                                },
                                path: ConsolePages.SMTP,
                            });
                        } else {
                            notSent.push({email: res.email, reason: res.error.message});
                        }
                    } else {
                        sent.push({email: res.email, reason: localizeMessage('invite.guests.added-to-channel', 'An invitation email has been sent.')});
                    }
                }
            }
        }
        return {data: {sent, notSent}};
    };
}

export function sendMembersInvitesToChannels(
    teamId: string,
    channels: Channel[],
    users: UserProfile[],
    emails: string[],
    message: string,
): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        if (users.length > 0) {
            // used to preload in the global store the teammembers info, used later to validate
            // if one of the invites is already part of the team by getTeamMembers > getMembersInTeam.
            await dispatch(TeamActions.getTeamMembersByIds(teamId, users.map((u) => u.id)));
        }
        const state = getState();
        const sent = [];
        const notSent = [];
        const usersToAdd = [];
        for (const user of users) {
            const member = getTeamMember(state, teamId, user.id);
            if (isGuest(user.roles)) {
                notSent.push({user, reason: localizeMessage('invite.members.user-is-guest', 'Contact your admin to make this guest a full member.')});
            } else if (member) {
                notSent.push({user, reason: localizeMessage('invite.members.already-member', 'This person is already a team member.')});
            } else {
                usersToAdd.push(user);
            }
        }
        if (usersToAdd.length > 0) {
            const response = await dispatch(addUsersToTeam(teamId, usersToAdd.map((u) => u.id)));
            const members = response.data || [];
            for (const userToAdd of usersToAdd) {
                const memberWithError = members.find((m: TeamMemberWithError) => m.user_id === userToAdd.id && m.error);
                if (memberWithError) {
                    notSent.push({user: userToAdd, reason: memberWithError.error.message});
                } else {
                    sent.push({user: userToAdd, reason: localizeMessage('invite.members.added-to-team', 'This member has been added to the team.')});
                }
            }
        }
        if (emails.length > 0) {
            let response;
            try {
                response = await dispatch(
                    TeamActions.sendEmailInvitesToTeamAndChannelsGracefully(
                        teamId,
                        channels.map((x) => x.id),
                        emails,
                        message,
                    ),
                );
            } catch (e) {
                response = {data: emails.map((email) => ({email, error: {error: localizeMessage('invite.members.unable-to-add-the-user-to-the-team', 'Unable to add the user to the team.')}}))};
            }
            const invitesWithErrors = response.data || [];
            if (response.error) {
                if (response.error.server_error_id === 'app.email.rate_limit_exceeded.app_error') {
                    response.error.message = localizeMessage('invite.rate-limit-exceeded', 'Invite emails rate limit exceeded.');
                }
                for (const email of emails) {
                    notSent.push({email, reason: response.error.message});
                }
            } else {
                for (const email of emails) {
                    const inviteWithError = invitesWithErrors.find((i: TeamInviteWithError) => email.toLowerCase() === i.email && i.error);
                    if (inviteWithError) {
                        if (inviteWithError.error.id === 'api.team.invite_members.unable_to_send_email_with_defaults.app_error' && isCurrentUserSystemAdmin(state)) {
                            notSent.push({
                                email,
                                reason: {
                                    id: t('admin.environment.smtp.smtpFailure'),
                                    message: 'SMTP is not configured in System Console. Can be configured <a>here</a>.',
                                },
                                path: ConsolePages.SMTP,
                            });
                        } else {
                            notSent.push({email, reason: inviteWithError.error.message});
                        }
                    } else {
                        sent.push({email, reason: localizeMessage('invite.members.invite-sent', 'An invitation email has been sent.')});
                    }
                }
            }
        }
        return {
            data: {
                sent,
                notSent,
            },
        };
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {getCurrentTeam, getCurrentTeamId, getTeam} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentChannel, getChannelsInCurrentTeam, getChannelsNameMapInCurrentTeam} from 'mattermost-redux/selectors/entities/channels';
import {haveIChannelPermission, haveICurrentTeamPermission} from 'mattermost-redux/selectors/entities/roles';
import {getConfig, getLicense} from 'mattermost-redux/selectors/entities/general';
import {getProfiles, searchProfiles as reduxSearchProfiles} from 'mattermost-redux/actions/users';
import {getCurrentUser} from 'mattermost-redux/selectors/entities/users';
import {searchChannels as reduxSearchChannels} from 'mattermost-redux/actions/channels';
import {regenerateTeamInviteId} from 'mattermost-redux/actions/teams';
import {Permissions} from 'mattermost-redux/constants';

import {CloseModalType} from 'actions/views/modals';
import {Constants} from 'utils/constants';
import {isAdmin} from 'mattermost-redux/utils/user_utils';
import {
    sendMembersInvites,
    sendGuestsInvites,
    sendMembersInvitesToChannels,
} from 'actions/invite_actions';
import {makeAsyncComponent} from 'components/async_load';

import {Channel} from '@mattermost/types/channels';
import {UserProfile} from '@mattermost/types/users';
import {ActionFunc, GenericAction} from 'mattermost-redux/types/actions';

import {GlobalState} from 'types/store';

import type {InviteResults} from './result_view';
const InvitationModal = makeAsyncComponent('InvitationModal', React.lazy(() => import('./invitation_modal')));

const searchProfiles = (term: string, options = {}) => {
    if (!term) {
        return getProfiles(0, 20, options);
    }
    return reduxSearchProfiles(term, options);
};

const searchChannels = (teamId: string, term: string) => {
    return reduxSearchChannels(teamId, term);
};

type OwnProps = {
    channelToInvite?: Channel;
}

export function mapStateToProps(state: GlobalState, props: OwnProps) {
    const config = getConfig(state);
    const license = getLicense(state);
    const channels = getChannelsInCurrentTeam(state);
    const channelsByName = getChannelsNameMapInCurrentTeam(state);
    const townSquareDisplayName = channelsByName[Constants.DEFAULT_CHANNEL]?.display_name || Constants.DEFAULT_CHANNEL_UI_NAME;

    const currentTeamId = getCurrentTeamId(state);
    const currentTeam = currentTeamId === '' && props.channelToInvite ? getTeam(state, props.channelToInvite.team_id) : getCurrentTeam(state);
    const currentChannel = getCurrentChannel(state);
    const invitableChannels = channels.filter((channel) => {
        if (channel.type === Constants.DM_CHANNEL || channel.type === Constants.GM_CHANNEL) {
            return false;
        }
        if (channel.type === Constants.PRIVATE_CHANNEL) {
            return haveIChannelPermission(state, currentTeam.id, channel.id, Permissions.MANAGE_PRIVATE_CHANNEL_MEMBERS);
        }
        return haveIChannelPermission(state, currentTeam.id, channel.id, Permissions.MANAGE_PUBLIC_CHANNEL_MEMBERS);
    });
    const guestAccountsEnabled = config.EnableGuestAccounts === 'true';
    const emailInvitationsEnabled = config.EnableEmailInvitations === 'true';
    const isEnterpriseReady = config.BuildEnterpriseReady === 'true';
    const isGroupConstrained = Boolean(currentTeam.group_constrained);
    const canInviteGuests = !isGroupConstrained && isEnterpriseReady && guestAccountsEnabled && haveICurrentTeamPermission(state, Permissions.INVITE_GUEST);
    const isCloud = license.Cloud === 'true';

    const canAddUsers = haveICurrentTeamPermission(state, Permissions.ADD_USER_TO_TEAM);

    return {
        invitableChannels,
        currentTeam,
        canInviteGuests,
        canAddUsers,
        emailInvitationsEnabled,
        isCloud,
        isAdmin: isAdmin(getCurrentUser(state).roles),
        currentChannel,
        townSquareDisplayName,
    };
}

type Actions = {
    sendGuestsInvites: (teamId: string, channels: Channel[], users: UserProfile[], emails: string[], message: string) => Promise<{data: InviteResults}>;
    sendMembersInvites: (teamId: string, users: UserProfile[], emails: string[]) => Promise<{data: InviteResults}>;
    sendMembersInvitesToChannels: (teamId: string, channels: Channel[], users: UserProfile[], emails: string[], message: string) => Promise<{data: InviteResults}>;
    regenerateTeamInviteId: (teamId: string) => void;
    searchProfiles: (term: string, options?: Record<string, string>) => Promise<{data: UserProfile[]}>;
    searchChannels: (teamId: string, term: string) => ActionFunc;
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc | CloseModalType>, Actions>({
            sendGuestsInvites,
            sendMembersInvites,
            sendMembersInvitesToChannels,
            regenerateTeamInviteId,
            searchProfiles,
            searchChannels,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(InvitationModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/* eslint-disable max-lines */

import {PreferenceType} from '@mattermost/types/preferences';
import FormData from 'form-data';

import {SystemSetting} from '@mattermost/types/general';
import {ClusterInfo, AnalyticsRow, SchemaMigration} from '@mattermost/types/admin';
import type {AppBinding, AppCallRequest, AppCallResponse} from '@mattermost/types/apps';
import {Audit} from '@mattermost/types/audits';
import {UserAutocomplete, AutocompleteSuggestion} from '@mattermost/types/autocomplete';
import {Bot, BotPatch} from '@mattermost/types/bots';
import {
    Product,
    CloudCustomer,
    Address,
    CloudCustomerPatch,
    Invoice,
    Limits,
    NotifyAdminRequest,
    Subscription,
    ValidBusinessEmail,
    SelfHostedSignupProgress,
} from '@mattermost/types/cloud';
import {ChannelCategory, OrderedChannelCategories} from '@mattermost/types/channel_categories';
import {
    Channel,
    ChannelMemberCountsByGroup,
    ChannelMembership,
    ChannelModeration,
    ChannelModerationPatch,
    ChannelStats,
    ChannelsWithTotalCount,
    ChannelUnread,
    ChannelViewResponse,
    ChannelWithTeamData,
    ChannelSearchOpts,
    ServerChannel,
} from '@mattermost/types/channels';
import {Options, StatusOK, ClientResponse, LogLevel, FetchPaginatedThreadOptions} from '@mattermost/types/client4';
import {Compliance} from '@mattermost/types/compliance';
import {
    ClientConfig,
    ClientLicense,
    DataRetentionPolicy,
    License,
    AdminConfig,
    EnvironmentConfig,
    RequestLicenseBody,
} from '@mattermost/types/config';
import {CustomEmoji} from '@mattermost/types/emojis';
import {ServerError} from '@mattermost/types/errors';
import {FileInfo, FileUploadResponse, FileSearchResults} from '@mattermost/types/files';
import {
    Group,
    GroupPatch,
    GroupSyncable,
    MixedUnlinkedGroup,
    SyncablePatch,
    UsersWithGroupsAndCount,
    GroupsWithCount,
    GroupCreateWithUserIds,
    GroupSearachParams,
    CustomGroupPatch,
} from '@mattermost/types/groups';
import {PostActionResponse} from '@mattermost/types/integration_actions';
import {
    Command,
    CommandArgs,
    CommandResponse,
    DialogSubmission,
    IncomingWebhook,
    OAuthApp,
    OutgoingWebhook,
    SubmitDialogResponse,
} from '@mattermost/types/integrations';
import {Job} from '@mattermost/types/jobs';
import {MfaSecret} from '@mattermost/types/mfa';
import {
    ClientPluginManifest,
    PluginManifest,
    PluginsResponse,
    PluginStatus,
} from '@mattermost/types/plugins';
import type {
    MarketplaceApp,
    MarketplacePlugin,
} from '@mattermost/types/marketplace';
import {Post, PostList, PostSearchResults, OpenGraphMetadata, PostsUsageResponse, TeamsUsageResponse, PaginatedPostList, FilesUsageResponse, PostAcknowledgement} from '@mattermost/types/posts';
import {Draft} from '@mattermost/types/drafts';
import {BoardPatch, BoardsUsageResponse, BoardTemplate, Board, CreateBoardResponse} from '@mattermost/types/boards';
import {Reaction} from '@mattermost/types/reactions';
import {Role} from '@mattermost/types/roles';
import {SamlCertificateStatus, SamlMetadataResponse} from '@mattermost/types/saml';
import {Scheme} from '@mattermost/types/schemes';
import {Session} from '@mattermost/types/sessions';
import {
    GetTeamMembersOpts,
    Team,
    TeamInviteWithError,
    TeamMembership,
    TeamMemberWithError,
    TeamStats,
    TeamsWithCount,
    TeamUnread,
    TeamSearchOpts,
} from '@mattermost/types/teams';
import {TermsOfService} from '@mattermost/types/terms_of_service';
import {
    AuthChangeResponse,
    UserAccessToken,
    UserProfile,
    UsersStats,
    UserStatus,
    GetFilteredUsersStatsOpts,
    UserCustomStatus,
} from '@mattermost/types/users';
import {DeepPartial, RelationOneToOne, ValueOf} from '@mattermost/types/utilities';
import {ProductNotices} from '@mattermost/types/product_notices';
import {
    DataRetentionCustomPolicies,
    CreateDataRetentionCustomPolicy,
    PatchDataRetentionCustomPolicy,
    GetDataRetentionCustomPoliciesRequest,
} from '@mattermost/types/data_retention';
import {CompleteOnboardingRequest} from '@mattermost/types/setup';

import {UserThreadList, UserThread, UserThreadWithPost} from '@mattermost/types/threads';
import {LeastActiveChannelsResponse, TopChannelResponse, TopReactionResponse, TopThreadResponse, TopDMsResponse} from '@mattermost/types/insights';

import {cleanUrlForLogging} from './errors';
import {buildQueryString} from './helpers';
import {TelemetryHandler} from './telemetry';

const HEADER_AUTH = 'Authorization';
const HEADER_BEARER = 'BEARER';
const HEADER_CONTENT_TYPE = 'Content-Type';
const HEADER_REQUESTED_WITH = 'X-Requested-With';
const HEADER_USER_AGENT = 'User-Agent';
export const HEADER_X_CLUSTER_ID = 'X-Cluster-Id';
const HEADER_X_CSRF_TOKEN = 'X-CSRF-Token';
export const HEADER_X_VERSION_ID = 'X-Version-Id';

const AUTOCOMPLETE_LIMIT_DEFAULT = 25;
const PER_PAGE_DEFAULT = 60;
const LOGS_PER_PAGE_DEFAULT = 10000;
export const DEFAULT_LIMIT_BEFORE = 30;
export const DEFAULT_LIMIT_AFTER = 30;

const GRAPHQL_ENDPOINT = '/api/v5/graphql';

// placed here because currently not supported
// to import from outside the package from main bundle
export const suitePluginIds = {
    playbooks: 'playbooks',
    focalboard: 'focalboard',
    apps: 'com.mattermost.apps',
    calls: 'com.mattermost.calls',
    nps: 'com.mattermost.nps',
    channelExport: 'com.mattermost.plugin-channel-export',
};

export default class Client4 {
    logToConsole = false;
    serverVersion = '';
    clusterId = '';
    token = '';
    csrf = '';
    url = '';
    urlVersion = '/api/v4';
    userAgent: string|null = null;
    enableLogging = false;
    defaultHeaders: {[x: string]: string} = {};
    userId = '';
    diagnosticId = '';
    includeCookies = true;
    setAuthHeader = true;
    translations = {
        connectionError: 'There appears to be a problem with your internet connection.',
        unknownError: 'We received an unexpected status code from the server.',
    };
    userRoles = '';
    telemetryHandler?: TelemetryHandler;

    getUrl() {
        return this.url;
    }

    getAbsoluteUrl(baseUrl: string) {
        if (typeof baseUrl !== 'string' || !baseUrl.startsWith('/')) {
            return baseUrl;
        }
        return this.getUrl() + baseUrl;
    }

    getGraphQLUrl() {
        return `${this.url}${GRAPHQL_ENDPOINT}`;
    }

    setUrl(url: string) {
        this.url = url;
    }

    setUserAgent(userAgent: string) {
        this.userAgent = userAgent;
    }

    getToken() {
        return this.token;
    }

    setToken(token: string) {
        this.token = token;
    }

    setCSRF(csrfToken: string) {
        this.csrf = csrfToken;
    }

    setAcceptLanguage(locale: string) {
        this.defaultHeaders['Accept-Language'] = locale;
    }

    setEnableLogging(enable: boolean) {
        this.enableLogging = enable;
    }

    setIncludeCookies(include: boolean) {
        this.includeCookies = include;
    }

    setUserId(userId: string) {
        this.userId = userId;
    }

    setUserRoles(roles: string) {
        this.userRoles = roles;
    }

    setDiagnosticId(diagnosticId: string) {
        this.diagnosticId = diagnosticId;
    }

    setTelemetryHandler(telemetryHandler?: TelemetryHandler) {
        this.telemetryHandler = telemetryHandler;
    }

    getServerVersion() {
        return this.serverVersion;
    }

    getUrlVersion() {
        return this.urlVersion;
    }

    getBaseRoute() {
        return `${this.url}${this.urlVersion}`;
    }

    // This function belongs to the Apps Framework feature.
    // Apps Framework feature is experimental, and this function is susceptible
    // to breaking changes without pushing the major version of this package.
    getAppsProxyRoute() {
        return `${this.url}/plugins/com.mattermost.apps`;
    }

    getUsersRoute() {
        return `${this.getBaseRoute()}/users`;
    }

    getUserRoute(userId: string) {
        return `${this.getUsersRoute()}/${userId}`;
    }

    getTeamsRoute() {
        return `${this.getBaseRoute()}/teams`;
    }

    getTeamRoute(teamId: string) {
        return `${this.getTeamsRoute()}/${teamId}`;
    }

    getTeamSchemeRoute(teamId: string) {
        return `${this.getTeamRoute(teamId)}/scheme`;
    }

    getTeamNameRoute(teamName: string) {
        return `${this.getTeamsRoute()}/name/${teamName}`;
    }

    getTeamMembersRoute(teamId: string) {
        return `${this.getTeamRoute(teamId)}/members`;
    }

    getTeamMemberRoute(teamId: string, userId: string) {
        return `${this.getTeamMembersRoute(teamId)}/${userId}`;
    }

    getChannelsRoute() {
        return `${this.getBaseRoute()}/channels`;
    }

    getChannelRoute(channelId: string) {
        return `${this.getChannelsRoute()}/${channelId}`;
    }

    getChannelMembersRoute(channelId: string) {
        return `${this.getChannelRoute(channelId)}/members`;
    }

    getChannelMemberRoute(channelId: string, userId: string) {
        return `${this.getChannelMembersRoute(channelId)}/${userId}`;
    }

    getChannelSchemeRoute(channelId: string) {
        return `${this.getChannelRoute(channelId)}/scheme`;
    }

    getChannelCategoriesRoute(userId: string, teamId: string) {
        return `${this.getBaseRoute()}/users/${userId}/teams/${teamId}/channels/categories`;
    }

    getPostsRoute() {
        return `${this.getBaseRoute()}/posts`;
    }

    getPostRoute(postId: string) {
        return `${this.getPostsRoute()}/${postId}`;
    }

    getReactionsRoute() {
        return `${this.getBaseRoute()}/reactions`;
    }

    getCommandsRoute() {
        return `${this.getBaseRoute()}/commands`;
    }

    getFilesRoute() {
        return `${this.getBaseRoute()}/files`;
    }

    getFileRoute(fileId: string) {
        return `${this.getFilesRoute()}/${fileId}`;
    }

    getPreferencesRoute(userId: string) {
        return `${this.getUserRoute(userId)}/preferences`;
    }

    getIncomingHooksRoute() {
        return `${this.getBaseRoute()}/hooks/incoming`;
    }

    getIncomingHookRoute(hookId: string) {
        return `${this.getBaseRoute()}/hooks/incoming/${hookId}`;
    }

    getOutgoingHooksRoute() {
        return `${this.getBaseRoute()}/hooks/outgoing`;
    }

    getOutgoingHookRoute(hookId: string) {
        return `${this.getBaseRoute()}/hooks/outgoing/${hookId}`;
    }

    getOAuthRoute() {
        return `${this.url}/oauth`;
    }

    getOAuthAppsRoute() {
        return `${this.getBaseRoute()}/oauth/apps`;
    }

    getOAuthAppRoute(appId: string) {
        return `${this.getOAuthAppsRoute()}/${appId}`;
    }

    getEmojisRoute() {
        return `${this.getBaseRoute()}/emoji`;
    }

    getEmojiRoute(emojiId: string) {
        return `${this.getEmojisRoute()}/${emojiId}`;
    }

    getBrandRoute() {
        return `${this.getBaseRoute()}/brand`;
    }

    getBrandImageUrl(timestamp: string) {
        return `${this.getBrandRoute()}/image?t=${timestamp}`;
    }

    getDataRetentionRoute() {
        return `${this.getBaseRoute()}/data_retention`;
    }

    getJobsRoute() {
        return `${this.getBaseRoute()}/jobs`;
    }

    getPluginsRoute() {
        return `${this.getBaseRoute()}/plugins`;
    }

    getPluginRoute(pluginId: string) {
        return `${this.getPluginsRoute()}/${pluginId}`;
    }

    getPluginsMarketplaceRoute() {
        return `${this.getPluginsRoute()}/marketplace`;
    }

    getRolesRoute() {
        return `${this.getBaseRoute()}/roles`;
    }

    getSchemesRoute() {
        return `${this.getBaseRoute()}/schemes`;
    }

    getRedirectLocationRoute() {
        return `${this.getBaseRoute()}/redirect_location`;
    }

    getBotsRoute() {
        return `${this.getBaseRoute()}/bots`;
    }

    getBotRoute(botUserId: string) {
        return `${this.getBotsRoute()}/${botUserId}`;
    }

    getGroupsRoute() {
        return `${this.getBaseRoute()}/groups`;
    }

    getGroupRoute(groupID: string) {
        return `${this.getGroupsRoute()}/${groupID}`;
    }

    getNoticesRoute() {
        return `${this.getBaseRoute()}/system/notices`;
    }

    getCloudRoute() {
        return `${this.getBaseRoute()}/cloud`;
    }

    getHostedCustomerRoute() {
        return `${this.getBaseRoute()}/hosted_customer`;
    }

    getUsageRoute() {
        return `${this.getBaseRoute()}/usage`;
    }

    getPermissionsRoute() {
        return `${this.getBaseRoute()}/permissions`;
    }

    getUserThreadsRoute(userID: string, teamID: string): string {
        return `${this.getUserRoute(userID)}/teams/${teamID}/threads`;
    }

    getUserThreadRoute(userId: string, teamId: string, threadId: string): string {
        return `${this.getUserThreadsRoute(userId, teamId)}/${threadId}`;
    }

    getSystemRoute(): string {
        return `${this.getBaseRoute()}/system`;
    }

    getDraftsRoute() {
        return `${this.getBaseRoute()}/drafts`;
    }

    getCSRFFromCookie() {
        if (typeof document !== 'undefined' && typeof document.cookie !== 'undefined') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.startsWith('MMCSRF=')) {
                    return cookie.replace('MMCSRF=', '');
                }
            }
        }
        return '';
    }

    getOptions(options: Options) {
        const newOptions: Options = {...options};

        const headers: {[x: string]: string} = {
            [HEADER_REQUESTED_WITH]: 'XMLHttpRequest',
            ...this.defaultHeaders,
        };

        if (this.setAuthHeader && this.token) {
            headers[HEADER_AUTH] = `${HEADER_BEARER} ${this.token}`;
        }

        const csrfToken = this.csrf || this.getCSRFFromCookie();
        if (options.method && options.method.toLowerCase() !== 'get' && csrfToken) {
            headers[HEADER_X_CSRF_TOKEN] = csrfToken;
        }

        if (this.includeCookies) {
            newOptions.credentials = 'include';
        }

        if (this.userAgent) {
            headers[HEADER_USER_AGENT] = this.userAgent;
        }

        if (options.body) {
            // when the body is an instance of FormData we let fetch to set the Content-Type header so it defines a correct boundary
            if (!(options.body instanceof FormData)) {
                headers[HEADER_CONTENT_TYPE] = 'application/json';
            }
        }

        if (newOptions.headers) {
            Object.assign(headers, newOptions.headers);
        }

        return {
            ...newOptions,
            headers,
        };
    }

    // User Routes

    createUser = (user: UserProfile, token: string, inviteId: string, redirect?: string) => {
        this.trackEvent('api', 'api_users_create');

        const queryParams: any = {};

        if (token) {
            queryParams.t = token;
        }

        if (inviteId) {
            queryParams.iid = inviteId;
        }

        if (redirect) {
            queryParams.r = redirect;
        }

        return this.doFetch<UserProfile>(
            `${this.getUsersRoute()}${buildQueryString(queryParams)}`,
            {method: 'post', body: JSON.stringify(user)},
        );
    }

    patchMe = (userPatch: Partial<UserProfile>) => {
        return this.doFetch<UserProfile>(
            `${this.getUserRoute('me')}/patch`,
            {method: 'put', body: JSON.stringify(userPatch)},
        );
    }

    patchUser = (userPatch: Partial<UserProfile> & {id: string}) => {
        this.trackEvent('api', 'api_users_patch');

        return this.doFetch<UserProfile>(
            `${this.getUserRoute(userPatch.id)}/patch`,
            {method: 'put', body: JSON.stringify(userPatch)},
        );
    }

    updateUser = (user: UserProfile) => {
        this.trackEvent('api', 'api_users_update');

        return this.doFetch<UserProfile>(
            `${this.getUserRoute(user.id)}`,
            {method: 'put', body: JSON.stringify(user)},
        );
    }

    promoteGuestToUser = (userId: string) => {
        this.trackEvent('api', 'api_users_promote_guest_to_user');

        return this.doFetch<StatusOK>(
            `${this.getUserRoute(userId)}/promote`,
            {method: 'post'},
        );
    }

    demoteUserToGuest = (userId: string) => {
        this.trackEvent('api', 'api_users_demote_user_to_guest');

        return this.doFetch<StatusOK>(
            `${this.getUserRoute(userId)}/demote`,
            {method: 'post'},
        );
    }

    updateUserRoles = (userId: string, roles: string) => {
        this.trackEvent('api', 'api_users_update_roles');

        return this.doFetch<StatusOK>(
            `${this.getUserRoute(userId)}/roles`,
            {method: 'put', body: JSON.stringify({roles})},
        );
    };

    updateUserMfa = (userId: string, activate: boolean, code: string) => {
        const body: any = {
            activate,
        };

        if (activate) {
            body.code = code;
        }

        return this.doFetch<StatusOK>(
            `${this.getUserRoute(userId)}/mfa`,
            {method: 'put', body: JSON.stringify(body)},
        );
    }

    updateUserPassword = (userId: string, currentPassword: string, newPassword: string) => {
        this.trackEvent('api', 'api_users_newpassword');

        return this.doFetch<StatusOK>(
            `${this.getUserRoute(userId)}/password`,
            {method: 'put', body: JSON.stringify({current_password: currentPassword, new_password: newPassword})},
        );
    }

    resetUserPassword = (token: string, newPassword: string) => {
        this.trackEvent('api', 'api_users_reset_password');

        return this.doFetch<StatusOK>(
            `${this.getUsersRoute()}/password/reset`,
            {method: 'post', body: JSON.stringify({token, new_password: newPassword})},
        );
    }

    getKnownUsers = () => {
        return this.doFetch<Array<UserProfile['id']>>(
            `${this.getUsersRoute()}/known`,
            {method: 'get'},
        );
    }

    sendPasswordResetEmail = (email: string) => {
        this.trackEvent('api', 'api_users_send_password_reset');

        return this.doFetch<StatusOK>(
            `${this.getUsersRoute()}/password/reset/send`,
            {method: 'post', body: JSON.stringify({email})},
        );
    }

    updateUserActive = (userId: string, active: boolean) => {
        this.trackEvent('api', 'api_users_update_active');

        return this.doFetch<StatusOK>(
            `${this.getUserRoute(userId)}/active`,
            {method: 'put', body: JSON.stringify({active})},
        );
    }

    uploadProfileImage = (userId: string, imageData: File) => {
        this.trackEvent('api', 'api_users_update_profile_picture');

        const formData = new FormData();
        formData.append('image', imageData);
        const request: any = {
            method: 'post',
            body: formData,
        };

        if (formData.getBoundary) {
            request.headers = {
                'Content-Type': `multipart/form-data; boundary=${formData.getBoundary()}`,
            };
        }

        return this.doFetch<StatusOK>(
            `${this.getUserRoute(userId)}/image`,
            request,
        );
    };

    setDefaultProfileImage = (userId: string) => {
        this.trackEvent('api', 'api_users_set_default_profile_picture');

        return this.doFetch<StatusOK>(
            `${this.getUserRoute(userId)}/image`,
            {method: 'delete'},
        );
    };

    verifyUserEmail = (token: string) => {
        return this.doFetch<StatusOK>(
            `${this.getUsersRoute()}/email/verify`,
            {method: 'post', body: JSON.stringify({token})},
        );
    }

    updateMyTermsOfServiceStatus = (termsOfServiceId: string, accepted: boolean) => {
        return this.doFetch<StatusOK>(
            `${this.getUserRoute('me')}/terms_of_service`,
            {method: 'post', body: JSON.stringify({termsOfServiceId, accepted})},
        );
    }

    getTermsOfService = () => {
        return this.doFetch<TermsOfService>(
            `${this.getBaseRoute()}/terms_of_service`,
            {method: 'get'},
        );
    }

    createTermsOfService = (text: string) => {
        return this.doFetch<TermsOfService>(
            `${this.getBaseRoute()}/terms_of_service`,
            {method: 'post', body: JSON.stringify({text})},
        );
    }

    sendVerificationEmail = (email: string) => {
        return this.doFetch<StatusOK>(
            `${this.getUsersRoute()}/email/verify/send`,
            {method: 'post', body: JSON.stringify({email})},
        );
    }

    login = async (loginId: string, password: string, token = '', ldapOnly = false) => {
        this.trackEvent('api', 'api_users_login');

        if (ldapOnly) {
            this.trackEvent('api', 'api_users_login_ldap');
        }

        const body: any = {
            login_id: loginId,
            password,
            token,
            deviceId: '',
        };

        if (ldapOnly) {
            body.ldap_only = 'true';
        }

        const {
            data: profile,
            headers,
        } = await this.doFetchWithResponse<UserProfile>(
            `${this.getUsersRoute()}/login`,
            {method: 'post', body: JSON.stringify(body)},
        );

        if (headers.has('Token')) {
            this.setToken(headers.get('Token')!);
        }

        return profile;
    };

    loginById = (id: string, password: string, token = '') => {
        this.trackEvent('api', 'api_users_login');
        const body: any = {
            id,
            password,
            token,
            device_id: '',
        };

        return this.doFetch<UserProfile>(
            `${this.getUsersRoute()}/login`,
            {method: 'post', body: JSON.stringify(body)},
        );
    };

    logout = async () => {
        this.trackEvent('api', 'api_users_logout');

        const {response} = await this.doFetchWithResponse(
            `${this.getUsersRoute()}/logout`,
            {method: 'post'},
        );

        if (response.ok) {
            this.token = '';
        }

        this.serverVersion = '';

        return response;
    };

    getProfiles = (page = 0, perPage = PER_PAGE_DEFAULT, options: Record<string, any> = {}) => {
        return this.doFetch<UserProfile[]>(
            `${this.getUsersRoute()}${buildQueryString({page, per_page: perPage, ...options})}`,
            {method: 'get'},
        );
    };

    getProfilesByIds = (userIds: string[], options = {}) => {
        return this.doFetch<UserProfile[]>(
            `${this.getUsersRoute()}/ids${buildQueryString(options)}`,
            {method: 'post', body: JSON.stringify(userIds)},
        );
    };

    getProfilesByUsernames = (usernames: string[]) => {
        return this.doFetch<UserProfile[]>(
            `${this.getUsersRoute()}/usernames`,
            {method: 'post', body: JSON.stringify(usernames)},
        );
    };

    getProfilesInTeam = (teamId: string, page = 0, perPage = PER_PAGE_DEFAULT, sort = '', options = {}) => {
        return this.doFetch<UserProfile[]>(
            `${this.getUsersRoute()}${buildQueryString({...options, in_team: teamId, page, per_page: perPage, sort})}`,
            {method: 'get'},
        );
    };

    getProfilesNotInTeam = (teamId: string, groupConstrained: boolean, page = 0, perPage = PER_PAGE_DEFAULT) => {
        const queryStringObj: any = {not_in_team: teamId, page, per_page: perPage};
        if (groupConstrained) {
            queryStringObj.group_constrained = true;
        }

        return this.doFetch<UserProfile[]>(
            `${this.getUsersRoute()}${buildQueryString(queryStringObj)}`,
            {method: 'get'},
        );
    };

    getProfilesWithoutTeam = (page = 0, perPage = PER_PAGE_DEFAULT, options = {}) => {
        return this.doFetch<UserProfile[]>(
            `${this.getUsersRoute()}${buildQueryString({...options, without_team: 1, page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    getProfilesInChannel = (channelId: string, page = 0, perPage = PER_PAGE_DEFAULT, sort = '', options: {active?: boolean} = {}) => {
        const queryStringObj = {in_channel: channelId, page, per_page: perPage, sort};

        return this.doFetch<UserProfile[]>(
            `${this.getUsersRoute()}${buildQueryString({...queryStringObj, ...options})}`,
            {method: 'get'},
        );
    };

    getProfilesInGroupChannels = (channelsIds: string[]) => {
        return this.doFetch<Record<string, UserProfile[]>>(
            `${this.getUsersRoute()}/group_channels`,
            {method: 'post', body: JSON.stringify(channelsIds)},
        );
    };

    getProfilesNotInChannel = (teamId: string, channelId: string, groupConstrained: boolean, page = 0, perPage = PER_PAGE_DEFAULT) => {
        const queryStringObj: any = {in_team: teamId, not_in_channel: channelId, page, per_page: perPage};
        if (groupConstrained) {
            queryStringObj.group_constrained = true;
        }

        return this.doFetch<UserProfile[]>(
            `${this.getUsersRoute()}${buildQueryString(queryStringObj)}`,
            {method: 'get'},
        );
    };

    getProfilesInGroup = (groupId: string, page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<UserProfile[]>(
            `${this.getUsersRoute()}${buildQueryString({in_group: groupId, page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    getProfilesNotInGroup = (groupId: string, page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<UserProfile[]>(
            `${this.getUsersRoute()}${buildQueryString({not_in_group: groupId, page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    getMe = () => {
        return this.doFetch<UserProfile>(
            `${this.getUserRoute('me')}`,
            {method: 'get'},
        );
    };

    getUser = (userId: string) => {
        return this.doFetch<UserProfile>(
            `${this.getUserRoute(userId)}`,
            {method: 'get'},
        );
    };

    getUserByUsername = (username: string) => {
        return this.doFetch<UserProfile>(
            `${this.getUsersRoute()}/username/${username}`,
            {method: 'get'},
        );
    };

    getUserByEmail = (email: string) => {
        return this.doFetch<UserProfile>(
            `${this.getUsersRoute()}/email/${email}`,
            {method: 'get'},
        );
    };

    getProfilePictureUrl = (userId: string, lastPictureUpdate: number) => {
        const params: any = {};

        if (lastPictureUpdate) {
            params._ = lastPictureUpdate;
        }

        return `${this.getUserRoute(userId)}/image${buildQueryString(params)}`;
    };

    getDefaultProfilePictureUrl = (userId: string) => {
        return `${this.getUserRoute(userId)}/image/default`;
    };

    autocompleteUsers = (name: string, teamId: string, channelId: string, options = {
        limit: AUTOCOMPLETE_LIMIT_DEFAULT,
    }) => {
        return this.doFetch<UserAutocomplete>(`${this.getUsersRoute()}/autocomplete${buildQueryString({
            in_team: teamId,
            in_channel: channelId,
            name,
            limit: options.limit,
        })}`, {
            method: 'get',
        });
    };

    getSessions = (userId: string) => {
        return this.doFetch<Session[]>(
            `${this.getUserRoute(userId)}/sessions`,
            {method: 'get'},
        );
    };

    revokeSession = (userId: string, sessionId: string) => {
        return this.doFetch<StatusOK>(
            `${this.getUserRoute(userId)}/sessions/revoke`,
            {method: 'post', body: JSON.stringify({session_id: sessionId})},
        );
    };

    revokeAllSessionsForUser = (userId: string) => {
        return this.doFetch<StatusOK>(
            `${this.getUserRoute(userId)}/sessions/revoke/all`,
            {method: 'post'},
        );
    };

    revokeSessionsForAllUsers = () => {
        return this.doFetch<StatusOK>(
            `${this.getUsersRoute()}/sessions/revoke/all`,
            {method: 'post'},
        );
    };

    getUserAudits = (userId: string, page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<Audit[]>(
            `${this.getUserRoute(userId)}/audits${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    /**
     * @deprecated
     */
    checkUserMfa = (loginId: string) => {
        return this.doFetch<{mfa_required: boolean}>(
            `${this.getUsersRoute()}/mfa`,
            {method: 'post', body: JSON.stringify({login_id: loginId})},
        );
    };

    generateMfaSecret = (userId: string) => {
        return this.doFetch<MfaSecret>(
            `${this.getUserRoute(userId)}/mfa/generate`,
            {method: 'post'},
        );
    };

    searchUsers = (term: string, options: any) => {
        this.trackEvent('api', 'api_search_users');

        return this.doFetch<UserProfile[]>(
            `${this.getUsersRoute()}/search`,
            {method: 'post', body: JSON.stringify({term, ...options})},
        );
    };

    getStatusesByIds = (userIds: string[]) => {
        return this.doFetch<UserStatus[]>(
            `${this.getUsersRoute()}/status/ids`,
            {method: 'post', body: JSON.stringify(userIds)},
        );
    };

    getStatus = (userId: string) => {
        return this.doFetch<UserStatus>(
            `${this.getUserRoute(userId)}/status`,
            {method: 'get'},
        );
    };

    updateStatus = (status: UserStatus) => {
        return this.doFetch<UserStatus>(
            `${this.getUserRoute(status.user_id)}/status`,
            {method: 'put', body: JSON.stringify(status)},
        );
    };

    updateCustomStatus = (customStatus: UserCustomStatus) => {
        return this.doFetch(
            `${this.getUserRoute('me')}/status/custom`,
            {method: 'put', body: JSON.stringify(customStatus)},
        );
    };

    unsetCustomStatus = () => {
        return this.doFetch(
            `${this.getUserRoute('me')}/status/custom`,
            {method: 'delete'},
        );
    }

    removeRecentCustomStatus = (customStatus: UserCustomStatus) => {
        return this.doFetch(
            `${this.getUserRoute('me')}/status/custom/recent/delete`,
            {method: 'post', body: JSON.stringify(customStatus)},
        );
    }

    switchEmailToOAuth = (service: string, email: string, password: string, mfaCode = '') => {
        this.trackEvent('api', 'api_users_email_to_oauth');

        return this.doFetch<AuthChangeResponse>(
            `${this.getUsersRoute()}/login/switch`,
            {method: 'post', body: JSON.stringify({current_service: 'email', new_service: service, email, password, mfa_code: mfaCode})},
        );
    };

    switchOAuthToEmail = (currentService: string, email: string, password: string) => {
        this.trackEvent('api', 'api_users_oauth_to_email');

        return this.doFetch<AuthChangeResponse>(
            `${this.getUsersRoute()}/login/switch`,
            {method: 'post', body: JSON.stringify({current_service: currentService, new_service: 'email', email, new_password: password})},
        );
    };

    switchEmailToLdap = (email: string, emailPassword: string, ldapId: string, ldapPassword: string, mfaCode = '') => {
        this.trackEvent('api', 'api_users_email_to_ldap');

        return this.doFetch<AuthChangeResponse>(
            `${this.getUsersRoute()}/login/switch`,
            {method: 'post', body: JSON.stringify({current_service: 'email', new_service: 'ldap', email, password: emailPassword, ldap_id: ldapId, new_password: ldapPassword, mfa_code: mfaCode})},
        );
    };

    switchLdapToEmail = (ldapPassword: string, email: string, emailPassword: string, mfaCode = '') => {
        this.trackEvent('api', 'api_users_ldap_to_email');

        return this.doFetch<AuthChangeResponse>(
            `${this.getUsersRoute()}/login/switch`,
            {method: 'post', body: JSON.stringify({current_service: 'ldap', new_service: 'email', email, password: ldapPassword, new_password: emailPassword, mfa_code: mfaCode})},
        );
    };

    getAuthorizedOAuthApps = (userId: string) => {
        return this.doFetch<OAuthApp[]>(
            `${this.getUserRoute(userId)}/oauth/apps/authorized`,
            {method: 'get'},
        );
    }

    authorizeOAuthApp = (responseType: string, clientId: string, redirectUri: string, state: string, scope: string) => {
        return this.doFetch<void>(
            `${this.url}/oauth/authorize`,
            {method: 'post', body: JSON.stringify({client_id: clientId, response_type: responseType, redirect_uri: redirectUri, state, scope})},
        );
    }

    deauthorizeOAuthApp = (clientId: string) => {
        return this.doFetch<StatusOK>(
            `${this.url}/oauth/deauthorize`,
            {method: 'post', body: JSON.stringify({client_id: clientId})},
        );
    }

    createUserAccessToken = (userId: string, description: string) => {
        this.trackEvent('api', 'api_users_create_access_token');

        return this.doFetch<UserAccessToken>(
            `${this.getUserRoute(userId)}/tokens`,
            {method: 'post', body: JSON.stringify({description})},
        );
    }

    getUserAccessToken = (tokenId: string) => {
        return this.doFetch<UserAccessToken>(
            `${this.getUsersRoute()}/tokens/${tokenId}`,
            {method: 'get'},
        );
    }

    getUserAccessTokensForUser = (userId: string, page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<UserAccessToken[]>(
            `${this.getUserRoute(userId)}/tokens${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    }

    getUserAccessTokens = (page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<UserAccessToken[]>(
            `${this.getUsersRoute()}/tokens${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    }

    revokeUserAccessToken = (tokenId: string) => {
        this.trackEvent('api', 'api_users_revoke_access_token');

        return this.doFetch<StatusOK>(
            `${this.getUsersRoute()}/tokens/revoke`,
            {method: 'post', body: JSON.stringify({token_id: tokenId})},
        );
    }

    disableUserAccessToken = (tokenId: string) => {
        return this.doFetch<StatusOK>(
            `${this.getUsersRoute()}/tokens/disable`,
            {method: 'post', body: JSON.stringify({token_id: tokenId})},
        );
    }

    enableUserAccessToken = (tokenId: string) => {
        return this.doFetch<StatusOK>(
            `${this.getUsersRoute()}/tokens/enable`,
            {method: 'post', body: JSON.stringify({token_id: tokenId})},
        );
    }

    // Team Routes

    createTeam = (team: Team) => {
        this.trackEvent('api', 'api_teams_create');

        return this.doFetch<Team>(
            `${this.getTeamsRoute()}`,
            {method: 'post', body: JSON.stringify(team)},
        );
    };

    deleteTeam = (teamId: string) => {
        this.trackEvent('api', 'api_teams_delete');

        return this.doFetch<StatusOK>(
            `${this.getTeamRoute(teamId)}`,
            {method: 'delete'},
        );
    };

    unarchiveTeam = (teamId: string) => {
        return this.doFetch<Team>(
            `${this.getTeamRoute(teamId)}/restore`,
            {method: 'post'},
        );
    }

    archiveAllTeamsExcept = (teamId: string) => {
        return this.doFetch<StatusOK>(
            `${this.getTeamRoute(teamId)}/except`,
            {method: 'delete'},
        );
    }

    updateTeam = (team: Team) => {
        this.trackEvent('api', 'api_teams_update_name', {team_id: team.id});

        return this.doFetch<Team>(
            `${this.getTeamRoute(team.id)}`,
            {method: 'put', body: JSON.stringify(team)},
        );
    };

    patchTeam = (team: Partial<Team> & {id: string}) => {
        this.trackEvent('api', 'api_teams_patch_name', {team_id: team.id});

        return this.doFetch<Team>(
            `${this.getTeamRoute(team.id)}/patch`,
            {method: 'put', body: JSON.stringify(team)},
        );
    };

    regenerateTeamInviteId = (teamId: string) => {
        this.trackEvent('api', 'api_teams_regenerate_invite_id', {team_id: teamId});

        return this.doFetch<Team>(
            `${this.getTeamRoute(teamId)}/regenerate_invite_id`,
            {method: 'post'},
        );
    };

    updateTeamScheme = (teamId: string, schemeId: string) => {
        const patch = {scheme_id: schemeId};

        this.trackEvent('api', 'api_teams_update_scheme', {team_id: teamId, ...patch});

        return this.doFetch<StatusOK>(
            `${this.getTeamSchemeRoute(teamId)}`,
            {method: 'put', body: JSON.stringify(patch)},
        );
    };

    checkIfTeamExists = (teamName: string) => {
        return this.doFetch<{exists: boolean}>(
            `${this.getTeamNameRoute(teamName)}/exists`,
            {method: 'get'},
        );
    };

    getTeams = (page = 0, perPage = PER_PAGE_DEFAULT, includeTotalCount = false, excludePolicyConstrained = false) => {
        return this.doFetch<Team[] | TeamsWithCount>(
            `${this.getTeamsRoute()}${buildQueryString({page, per_page: perPage, include_total_count: includeTotalCount, exclude_policy_constrained: excludePolicyConstrained})}`,
            {method: 'get'},
        );
    };

    searchTeams = (term: string, opts: TeamSearchOpts) => {
        this.trackEvent('api', 'api_search_teams');

        return this.doFetch<Team[] | TeamsWithCount>(
            `${this.getTeamsRoute()}/search`,
            {method: 'post', body: JSON.stringify({term, ...opts})},
        );
    };

    getTeam = (teamId: string) => {
        return this.doFetch<Team>(
            this.getTeamRoute(teamId),
            {method: 'get'},
        );
    };

    getTeamByName = (teamName: string) => {
        this.trackEvent('api', 'api_teams_get_team_by_name');

        return this.doFetch<Team>(
            this.getTeamNameRoute(teamName),
            {method: 'get'},
        );
    };

    getMyTeams = () => {
        return this.doFetch<Team[]>(
            `${this.getUserRoute('me')}/teams`,
            {method: 'get'},
        );
    };

    getTeamsForUser = (userId: string) => {
        return this.doFetch<Team[]>(
            `${this.getUserRoute(userId)}/teams`,
            {method: 'get'},
        );
    };

    getMyTeamMembers = () => {
        return this.doFetch<TeamMembership[]>(
            `${this.getUserRoute('me')}/teams/members`,
            {method: 'get'},
        );
    };

    getMyTeamUnreads = (includeCollapsedThreads = false) => {
        return this.doFetch<TeamUnread[]>(
            `${this.getUserRoute('me')}/teams/unread${buildQueryString({include_collapsed_threads: includeCollapsedThreads})}`,
            {method: 'get'},
        );
    };

    getTeamMembers = (teamId: string, page = 0, perPage = PER_PAGE_DEFAULT, options: GetTeamMembersOpts) => {
        return this.doFetch<TeamMembership[]>(
            `${this.getTeamMembersRoute(teamId)}${buildQueryString({page, per_page: perPage, ...options})}`,
            {method: 'get'},
        );
    };

    getTeamMembersForUser = (userId: string) => {
        return this.doFetch<TeamMembership[]>(
            `${this.getUserRoute(userId)}/teams/members`,
            {method: 'get'},
        );
    };

    getTeamMember = (teamId: string, userId: string) => {
        return this.doFetch<TeamMembership>(
            `${this.getTeamMemberRoute(teamId, userId)}`,
            {method: 'get'},
        );
    };

    getTeamMembersByIds = (teamId: string, userIds: string[]) => {
        return this.doFetch<TeamMembership[]>(
            `${this.getTeamMembersRoute(teamId)}/ids`,
            {method: 'post', body: JSON.stringify(userIds)},
        );
    };

    addToTeam = (teamId: string, userId: string) => {
        this.trackEvent('api', 'api_teams_invite_members', {team_id: teamId});

        const member = {user_id: userId, team_id: teamId};
        return this.doFetch<TeamMembership>(
            `${this.getTeamMembersRoute(teamId)}`,
            {method: 'post', body: JSON.stringify(member)},
        );
    };

    addToTeamFromInvite = (token = '', inviteId = '') => {
        this.trackEvent('api', 'api_teams_invite_members');

        const query = buildQueryString({token, invite_id: inviteId});
        return this.doFetch<TeamMembership>(
            `${this.getTeamsRoute()}/members/invite${query}`,
            {method: 'post'},
        );
    };

    addUsersToTeam = (teamId: string, userIds: string[]) => {
        this.trackEvent('api', 'api_teams_batch_add_members', {team_id: teamId, count: userIds.length});

        const members: any = [];
        userIds.forEach((id) => members.push({team_id: teamId, user_id: id}));
        return this.doFetch<TeamMembership[]>(
            `${this.getTeamMembersRoute(teamId)}/batch`,
            {method: 'post', body: JSON.stringify(members)},
        );
    };

    addUsersToTeamGracefully = (teamId: string, userIds: string[]) => {
        this.trackEvent('api', 'api_teams_batch_add_members', {team_id: teamId, count: userIds.length});

        const members: any = [];
        userIds.forEach((id) => members.push({team_id: teamId, user_id: id}));
        return this.doFetch<TeamMemberWithError[]>(
            `${this.getTeamMembersRoute(teamId)}/batch?graceful=true`,
            {method: 'post', body: JSON.stringify(members)},
        );
    };

    joinTeam = (inviteId: string) => {
        const query = buildQueryString({invite_id: inviteId});
        return this.doFetch<TeamMembership>(
            `${this.getTeamsRoute()}/members/invite${query}`,
            {method: 'post'},
        );
    };

    removeFromTeam = (teamId: string, userId: string) => {
        this.trackEvent('api', 'api_teams_remove_members', {team_id: teamId});

        return this.doFetch<StatusOK>(
            `${this.getTeamMemberRoute(teamId, userId)}`,
            {method: 'delete'},
        );
    };

    getTeamStats = (teamId: string) => {
        return this.doFetch<TeamStats>(
            `${this.getTeamRoute(teamId)}/stats`,
            {method: 'get'},
        );
    };

    getTotalUsersStats = () => {
        return this.doFetch<UsersStats>(
            `${this.getUsersRoute()}/stats`,
            {method: 'get'},
        );
    };

    getFilteredUsersStats = (options: GetFilteredUsersStatsOpts) => {
        return this.doFetch<UsersStats>(
            `${this.getUsersRoute()}/stats/filtered${buildQueryString(options)}`,
            {method: 'get'},
        );
    };

    invalidateAllEmailInvites = () => {
        return this.doFetch<StatusOK>(
            `${this.getTeamsRoute()}/invites/email`,
            {method: 'delete'},
        );
    };

    getTeamInviteInfo = (inviteId: string) => {
        return this.doFetch<{
            display_name: string;
            description: string;
            name: string;
            id: string;
        }>(
            `${this.getTeamsRoute()}/invite/${inviteId}`,
            {method: 'get'},
        );
    };

    updateTeamMemberRoles = (teamId: string, userId: string, roles: string[]) => {
        this.trackEvent('api', 'api_teams_update_member_roles', {team_id: teamId});

        return this.doFetch<StatusOK>(
            `${this.getTeamMemberRoute(teamId, userId)}/roles`,
            {method: 'put', body: JSON.stringify({roles})},
        );
    };

    sendEmailInvitesToTeam = (teamId: string, emails: string[]) => {
        this.trackEvent('api', 'api_teams_invite_members', {team_id: teamId});

        return this.doFetch<StatusOK>(
            `${this.getTeamRoute(teamId)}/invite/email`,
            {method: 'post', body: JSON.stringify(emails)},
        );
    };

    sendEmailGuestInvitesToChannels = (teamId: string, channelIds: string[], emails: string[], message: string) => {
        this.trackEvent('api', 'api_teams_invite_guests', {team_id: teamId, channel_ids: channelIds});

        return this.doFetch<StatusOK>(
            `${this.getTeamRoute(teamId)}/invite-guests/email`,
            {method: 'post', body: JSON.stringify({emails, channels: channelIds, message})},
        );
    };

    sendEmailInvitesToTeamGracefully = (teamId: string, emails: string[]) => {
        this.trackEvent('api', 'api_teams_invite_members', {team_id: teamId});

        return this.doFetch<TeamInviteWithError>(
            `${this.getTeamRoute(teamId)}/invite/email?graceful=true`,
            {method: 'post', body: JSON.stringify(emails)},
        );
    };

    sendEmailInvitesToTeamAndChannelsGracefully = (
        teamId: string,
        channelIds: string[],
        emails: string[],
        message: string,
    ) => {
        this.trackEvent('api', 'api_teams_invite_members_to_channels', {team_id: teamId, channel_len: channelIds.length});

        return this.doFetch<TeamInviteWithError>(
            `${this.getTeamRoute(teamId)}/invite/email?graceful=true`,
            {method: 'post', body: JSON.stringify({emails, channelIds, message})},
        );
    };

    sendEmailGuestInvitesToChannelsGracefully = async (teamId: string, channelIds: string[], emails: string[], message: string) => {
        this.trackEvent('api', 'api_teams_invite_guests', {team_id: teamId, channel_ids: channelIds});

        return this.doFetch<TeamInviteWithError>(
            `${this.getTeamRoute(teamId)}/invite-guests/email?graceful=true`,
            {method: 'post', body: JSON.stringify({emails, channels: channelIds, message})},
        );
    };

    getTeamIconUrl = (teamId: string, lastTeamIconUpdate: number) => {
        const params: any = {};
        if (lastTeamIconUpdate) {
            params._ = lastTeamIconUpdate;
        }

        return `${this.getTeamRoute(teamId)}/image${buildQueryString(params)}`;
    };

    setTeamIcon = (teamId: string, imageData: File) => {
        this.trackEvent('api', 'api_team_set_team_icon');

        const formData = new FormData();
        formData.append('image', imageData);

        const request: any = {
            method: 'post',
            body: formData,
        };

        if (formData.getBoundary) {
            request.headers = {
                'Content-Type': `multipart/form-data; boundary=${formData.getBoundary()}`,
            };
        }

        return this.doFetch<StatusOK>(
            `${this.getTeamRoute(teamId)}/image`,
            request,
        );
    };

    removeTeamIcon = (teamId: string) => {
        this.trackEvent('api', 'api_team_remove_team_icon');

        return this.doFetch<StatusOK>(
            `${this.getTeamRoute(teamId)}/image`,
            {method: 'delete'},
        );
    };

    updateTeamMemberSchemeRoles = (teamId: string, userId: string, isSchemeUser: boolean, isSchemeAdmin: boolean) => {
        const body = {scheme_user: isSchemeUser, scheme_admin: isSchemeAdmin};
        return this.doFetch<StatusOK>(
            `${this.getTeamRoute(teamId)}/members/${userId}/schemeRoles`,
            {method: 'put', body: JSON.stringify(body)},
        );
    };

    // Channel Routes

    getAllChannels = (page = 0, perPage = PER_PAGE_DEFAULT, notAssociatedToGroup = '', excludeDefaultChannels = false, includeTotalCount = false, includeDeleted = false, excludePolicyConstrained = false) => {
        const queryData = {
            page,
            per_page: perPage,
            not_associated_to_group: notAssociatedToGroup,
            exclude_default_channels: excludeDefaultChannels,
            include_total_count: includeTotalCount,
            include_deleted: includeDeleted,
            exclude_policy_constrained: excludePolicyConstrained,
        };
        return this.doFetch<ChannelWithTeamData[] | ChannelsWithTotalCount>(
            `${this.getChannelsRoute()}${buildQueryString(queryData)}`,
            {method: 'get'},
        );
    };

    createChannel = (channel: Channel) => {
        this.trackEvent('api', 'api_channels_create', {team_id: channel.team_id});

        return this.doFetch<ServerChannel>(
            `${this.getChannelsRoute()}`,
            {method: 'post', body: JSON.stringify(channel)},
        );
    };

    createDirectChannel = (userIds: string[]) => {
        this.trackEvent('api', 'api_channels_create_direct');

        return this.doFetch<ServerChannel>(
            `${this.getChannelsRoute()}/direct`,
            {method: 'post', body: JSON.stringify(userIds)},
        );
    };

    createGroupChannel = (userIds: string[]) => {
        this.trackEvent('api', 'api_channels_create_group');

        return this.doFetch<ServerChannel>(
            `${this.getChannelsRoute()}/group`,
            {method: 'post', body: JSON.stringify(userIds)},
        );
    };

    deleteChannel = (channelId: string) => {
        this.trackEvent('api', 'api_channels_delete', {channel_id: channelId});

        return this.doFetch<StatusOK>(
            `${this.getChannelRoute(channelId)}`,
            {method: 'delete'},
        );
    };

    unarchiveChannel = (channelId: string) => {
        this.trackEvent('api', 'api_channels_unarchive', {channel_id: channelId});

        return this.doFetch<ServerChannel>(
            `${this.getChannelRoute(channelId)}/restore`,
            {method: 'post'},
        );
    };

    updateChannel = (channel: Channel) => {
        this.trackEvent('api', 'api_channels_update', {channel_id: channel.id});

        return this.doFetch<ServerChannel>(
            `${this.getChannelRoute(channel.id)}`,
            {method: 'put', body: JSON.stringify(channel)},
        );
    };

    updateChannelPrivacy = (channelId: string, privacy: any) => {
        this.trackEvent('api', 'api_channels_update_privacy', {channel_id: channelId, privacy});

        return this.doFetch<ServerChannel>(
            `${this.getChannelRoute(channelId)}/privacy`,
            {method: 'put', body: JSON.stringify({privacy})},
        );
    };

    patchChannel = (channelId: string, channelPatch: Partial<Channel>) => {
        this.trackEvent('api', 'api_channels_patch', {channel_id: channelId});

        return this.doFetch<ServerChannel>(
            `${this.getChannelRoute(channelId)}/patch`,
            {method: 'put', body: JSON.stringify(channelPatch)},
        );
    };

    updateChannelNotifyProps = (props: any) => {
        this.trackEvent('api', 'api_users_update_channel_notifications', {channel_id: props.channel_id});

        return this.doFetch<StatusOK>(
            `${this.getChannelMemberRoute(props.channel_id, props.user_id)}/notify_props`,
            {method: 'put', body: JSON.stringify(props)},
        );
    };

    updateChannelScheme = (channelId: string, schemeId: string) => {
        const patch = {scheme_id: schemeId};

        this.trackEvent('api', 'api_channels_update_scheme', {channel_id: channelId, ...patch});

        return this.doFetch<StatusOK>(
            `${this.getChannelSchemeRoute(channelId)}`,
            {method: 'put', body: JSON.stringify(patch)},
        );
    };

    getChannel = (channelId: string) => {
        return this.doFetch<ServerChannel>(
            `${this.getChannelRoute(channelId)}`,
            {method: 'get'},
        );
    };

    getChannelByName = (teamId: string, channelName: string, includeDeleted = false) => {
        return this.doFetch<ServerChannel>(
            `${this.getTeamRoute(teamId)}/channels/name/${channelName}?include_deleted=${includeDeleted}`,
            {method: 'get'},
        );
    };

    getChannelByNameAndTeamName = (teamName: string, channelName: string, includeDeleted = false) => {
        return this.doFetch<ServerChannel>(
            `${this.getTeamNameRoute(teamName)}/channels/name/${channelName}?include_deleted=${includeDeleted}`,
            {method: 'get'},
        );
    };

    getChannels = (teamId: string, page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<ServerChannel[]>(
            `${this.getTeamRoute(teamId)}/channels${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    }

    getAllTeamsChannels = () => {
        return this.doFetch<ServerChannel[]>(
            `${this.getUsersRoute()}/me/channels`,
            {method: 'get'},
        );
    };

    getArchivedChannels = (teamId: string, page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<ServerChannel[]>(
            `${this.getTeamRoute(teamId)}/channels/deleted${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    getMyChannels = (teamId: string, includeDeleted = false) => {
        return this.doFetch<ServerChannel[]>(
            `${this.getUserRoute('me')}/teams/${teamId}/channels${buildQueryString({include_deleted: includeDeleted})}`,
            {method: 'get'},
        );
    };

    getAllChannelsMembers = (userId: string, page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<ChannelMembership[]>(
            `${this.getUserRoute(userId)}/channel_members${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    getMyChannelMember = (channelId: string) => {
        return this.doFetch<ChannelMembership>(
            `${this.getChannelMemberRoute(channelId, 'me')}`,
            {method: 'get'},
        );
    };

    getMyChannelMembers = (teamId: string) => {
        return this.doFetch<ChannelMembership[]>(
            `${this.getUserRoute('me')}/teams/${teamId}/channels/members`,
            {method: 'get'},
        );
    };

    getChannelMembers = (channelId: string, page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<ChannelMembership[]>(
            `${this.getChannelMembersRoute(channelId)}${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    getChannelTimezones = (channelId: string) => {
        return this.doFetch<string[]>(
            `${this.getChannelRoute(channelId)}/timezones`,
            {method: 'get'},
        );
    };

    getChannelMember = (channelId: string, userId: string) => {
        return this.doFetch<ChannelMembership>(
            `${this.getChannelMemberRoute(channelId, userId)}`,
            {method: 'get'},
        );
    };

    getChannelMembersByIds = (channelId: string, userIds: string[]) => {
        return this.doFetch<ChannelMembership[]>(
            `${this.getChannelMembersRoute(channelId)}/ids`,
            {method: 'post', body: JSON.stringify(userIds)},
        );
    };

    addToChannel = (userId: string, channelId: string, postRootId = '') => {
        this.trackEvent('api', 'api_channels_add_member', {channel_id: channelId});

        const member = {user_id: userId, channel_id: channelId, post_root_id: postRootId};
        return this.doFetch<ChannelMembership>(
            `${this.getChannelMembersRoute(channelId)}`,
            {method: 'post', body: JSON.stringify(member)},
        );
    };

    removeFromChannel = (userId: string, channelId: string) => {
        this.trackEvent('api', 'api_channels_remove_member', {channel_id: channelId});

        return this.doFetch<StatusOK>(
            `${this.getChannelMemberRoute(channelId, userId)}`,
            {method: 'delete'},
        );
    };

    updateChannelMemberRoles = (channelId: string, userId: string, roles: string) => {
        return this.doFetch<StatusOK>(
            `${this.getChannelMemberRoute(channelId, userId)}/roles`,
            {method: 'put', body: JSON.stringify({roles})},
        );
    };

    getChannelStats = (channelId: string) => {
        return this.doFetch<ChannelStats>(
            `${this.getChannelRoute(channelId)}/stats`,
            {method: 'get'},
        );
    };

    getChannelModerations = (channelId: string) => {
        return this.doFetch<ChannelModeration[]>(
            `${this.getChannelRoute(channelId)}/moderations`,
            {method: 'get'},
        );
    };

    patchChannelModerations = (channelId: string, channelModerationsPatch: ChannelModerationPatch[]) => {
        return this.doFetch<ChannelModeration[]>(
            `${this.getChannelRoute(channelId)}/moderations/patch`,
            {method: 'put', body: JSON.stringify(channelModerationsPatch)},
        );
    };

    getChannelMemberCountsByGroup = (channelId: string, includeTimezones: boolean) => {
        return this.doFetch<ChannelMemberCountsByGroup>(
            `${this.getChannelRoute(channelId)}/member_counts_by_group?include_timezones=${includeTimezones}`,
            {method: 'get'},
        );
    };

    viewMyChannel = (channelId: string, prevChannelId?: string) => {
        const data = {channel_id: channelId, prev_channel_id: prevChannelId, collapsed_threads_supported: true};
        return this.doFetch<ChannelViewResponse>(
            `${this.getChannelsRoute()}/members/me/view`,
            {method: 'post', body: JSON.stringify(data)},
        );
    };

    autocompleteChannels = (teamId: string, name: string) => {
        return this.doFetch<Channel[]>(
            `${this.getTeamRoute(teamId)}/channels/autocomplete${buildQueryString({name})}`,
            {method: 'get'},
        );
    };

    autocompleteChannelsForSearch = (teamId: string, name: string) => {
        return this.doFetch<Channel[]>(
            `${this.getTeamRoute(teamId)}/channels/search_autocomplete${buildQueryString({name})}`,
            {method: 'get'},
        );
    };

    searchChannels = (teamId: string, term: string) => {
        return this.doFetch<Channel[]>(
            `${this.getTeamRoute(teamId)}/channels/search`,
            {method: 'post', body: JSON.stringify({term})},
        );
    };

    searchArchivedChannels = (teamId: string, term: string) => {
        return this.doFetch<Channel[]>(
            `${this.getTeamRoute(teamId)}/channels/search_archived`,
            {method: 'post', body: JSON.stringify({term})},
        );
    };

    searchAllChannels = (term: string, opts: ChannelSearchOpts = {}) => {
        const body = {
            term,
            ...opts,
        };
        const includeDeleted = Boolean(opts.include_deleted);
        const nonAdminSearch = Boolean(opts.nonAdminSearch);
        let queryParams: {include_deleted?: boolean; system_console?: boolean} = {include_deleted: includeDeleted};
        if (nonAdminSearch) {
            queryParams = {system_console: false};
            delete body.nonAdminSearch;
        }
        return this.doFetch<Channel[] | ChannelsWithTotalCount>(
            `${this.getChannelsRoute()}/search${buildQueryString(queryParams)}`,
            {method: 'post', body: JSON.stringify(body)},
        );
    };

    searchGroupChannels = (term: string) => {
        return this.doFetch<Channel[]>(
            `${this.getChannelsRoute()}/group/search`,
            {method: 'post', body: JSON.stringify({term})},
        );
    };

    updateChannelMemberSchemeRoles = (channelId: string, userId: string, isSchemeUser: boolean, isSchemeAdmin: boolean) => {
        const body = {scheme_user: isSchemeUser, scheme_admin: isSchemeAdmin};
        return this.doFetch<StatusOK>(
            `${this.getChannelRoute(channelId)}/members/${userId}/schemeRoles`,
            {method: 'put', body: JSON.stringify(body)},
        );
    };

    // Channel Category Routes

    getChannelCategories = (userId: string, teamId: string) => {
        return this.doFetch<OrderedChannelCategories>(
            `${this.getChannelCategoriesRoute(userId, teamId)}`,
            {method: 'get'},
        );
    };

    createChannelCategory = (userId: string, teamId: string, category: Partial<ChannelCategory>) => {
        return this.doFetch<ChannelCategory>(
            `${this.getChannelCategoriesRoute(userId, teamId)}`,
            {method: 'post', body: JSON.stringify(category)},
        );
    };

    updateChannelCategories = (userId: string, teamId: string, categories: ChannelCategory[]) => {
        return this.doFetch<ChannelCategory[]>(
            `${this.getChannelCategoriesRoute(userId, teamId)}`,
            {method: 'put', body: JSON.stringify(categories)},
        );
    };

    getChannelCategoryOrder = (userId: string, teamId: string) => {
        return this.doFetch<string[]>(
            `${this.getChannelCategoriesRoute(userId, teamId)}/order`,
            {method: 'get'},
        );
    };

    updateChannelCategoryOrder = (userId: string, teamId: string, categoryOrder: string[]) => {
        return this.doFetch<string[]>(
            `${this.getChannelCategoriesRoute(userId, teamId)}/order`,
            {method: 'put', body: JSON.stringify(categoryOrder)},
        );
    };

    getChannelCategory = (userId: string, teamId: string, categoryId: string) => {
        return this.doFetch<ChannelCategory>(
            `${this.getChannelCategoriesRoute(userId, teamId)}/${categoryId}`,
            {method: 'get'},
        );
    };

    updateChannelCategory = (userId: string, teamId: string, category: ChannelCategory) => {
        return this.doFetch<ChannelCategory>(
            `${this.getChannelCategoriesRoute(userId, teamId)}/${category.id}`,
            {method: 'put', body: JSON.stringify(category)},
        );
    };

    deleteChannelCategory = (userId: string, teamId: string, categoryId: string) => {
        return this.doFetch<ChannelCategory>(
            `${this.getChannelCategoriesRoute(userId, teamId)}/${categoryId}`,
            {method: 'delete'},
        );
    }

    // Post Routes

    createPost = async (post: Post) => {
        const result = await this.doFetch<Post>(
            `${this.getPostsRoute()}`,
            {method: 'post', body: JSON.stringify(post)},
        );
        const analyticsData = {channel_id: result.channel_id, post_id: result.id, user_actual_id: result.user_id, root_id: result.root_id};
        this.trackEvent('api', 'api_posts_create', analyticsData);

        if (result.root_id != null && result.root_id !== '') {
            this.trackEvent('api', 'api_posts_replied', analyticsData);
        }
        return result;
    };

    updatePost = (post: Post) => {
        this.trackEvent('api', 'api_posts_update', {channel_id: post.channel_id, post_id: post.id});

        return this.doFetch<Post>(
            `${this.getPostRoute(post.id)}`,
            {method: 'put', body: JSON.stringify(post)},
        );
    };

    getPost = (postId: string) => {
        return this.doFetch<Post>(
            `${this.getPostRoute(postId)}`,
            {method: 'get'},
        );
    };

    patchPost = (postPatch: Partial<Post> & {id: string}) => {
        this.trackEvent('api', 'api_posts_patch', {channel_id: postPatch.channel_id, post_id: postPatch.id});

        return this.doFetch<Post>(
            `${this.getPostRoute(postPatch.id)}/patch`,
            {method: 'put', body: JSON.stringify(postPatch)},
        );
    };

    deletePost = (postId: string) => {
        this.trackEvent('api', 'api_posts_delete');

        return this.doFetch<StatusOK>(
            `${this.getPostRoute(postId)}`,
            {method: 'delete'},
        );
    };

    getPostThread = (postId: string, fetchThreads = true, collapsedThreads = false, collapsedThreadsExtended = false) => {
        // this is to ensure we have backwards compatibility for `getPostThread`
        return this.getPaginatedPostThread(postId, {fetchThreads, collapsedThreads, collapsedThreadsExtended});
    };

    getPaginatedPostThread = async (postId: string, options: FetchPaginatedThreadOptions): Promise<PaginatedPostList> => {
        // getting all option parameters with defaults from the options object and spread the rest
        const {
            fetchThreads = true,
            collapsedThreads = false,
            collapsedThreadsExtended = false,
            direction = 'down',
            fetchAll = false,
            perPage = fetchAll ? undefined : PER_PAGE_DEFAULT,
            ...rest
        } = options;

        return this.doFetch<PaginatedPostList>(
            `${this.getPostRoute(postId)}/thread${buildQueryString({skipFetchThreads: !fetchThreads, collapsedThreads, collapsedThreadsExtended, direction, perPage, ...rest})}`,
            {method: 'get'},
        );
    };

    getPosts = (channelId: string, page = 0, perPage = PER_PAGE_DEFAULT, fetchThreads = true, collapsedThreads = false, collapsedThreadsExtended = false) => {
        return this.doFetch<PostList>(
            `${this.getChannelRoute(channelId)}/posts${buildQueryString({page, per_page: perPage, skipFetchThreads: !fetchThreads, collapsedThreads, collapsedThreadsExtended})}`,
            {method: 'get'},
        );
    };

    getPostsUnread = (channelId: string, userId: string, limitAfter = DEFAULT_LIMIT_AFTER, limitBefore = DEFAULT_LIMIT_BEFORE, fetchThreads = true, collapsedThreads = false, collapsedThreadsExtended = false) => {
        return this.doFetch<PostList>(
            `${this.getUserRoute(userId)}/channels/${channelId}/posts/unread${buildQueryString({limit_after: limitAfter, limit_before: limitBefore, skipFetchThreads: !fetchThreads, collapsedThreads, collapsedThreadsExtended})}`,
            {method: 'get'},
        );
    };

    getPostsSince = (channelId: string, since: number, fetchThreads = true, collapsedThreads = false, collapsedThreadsExtended = false) => {
        return this.doFetch<PostList>(
            `${this.getChannelRoute(channelId)}/posts${buildQueryString({since, skipFetchThreads: !fetchThreads, collapsedThreads, collapsedThreadsExtended})}`,
            {method: 'get'},
        );
    };

    getPostsBefore = (channelId: string, postId: string, page = 0, perPage = PER_PAGE_DEFAULT, fetchThreads = true, collapsedThreads = false, collapsedThreadsExtended = false) => {
        return this.doFetch<PostList>(
            `${this.getChannelRoute(channelId)}/posts${buildQueryString({before: postId, page, per_page: perPage, skipFetchThreads: !fetchThreads, collapsedThreads, collapsedThreadsExtended})}`,
            {method: 'get'},
        );
    };

    getPostsAfter = (channelId: string, postId: string, page = 0, perPage = PER_PAGE_DEFAULT, fetchThreads = true, collapsedThreads = false, collapsedThreadsExtended = false) => {
        return this.doFetch<PostList>(
            `${this.getChannelRoute(channelId)}/posts${buildQueryString({after: postId, page, per_page: perPage, skipFetchThreads: !fetchThreads, collapsedThreads, collapsedThreadsExtended})}`,
            {method: 'get'},
        );
    };

    getUserThreads = (
        userId: UserProfile['id'] = 'me',
        teamId: Team['id'],
        {
            before = '',
            after = '',
            perPage = PER_PAGE_DEFAULT,
            extended = false,
            deleted = false,
            unread = false,
            since = 0,
            totalsOnly = false,
            threadsOnly = false,
        },
    ) => {
        return this.doFetch<UserThreadList>(
            `${this.getUserThreadsRoute(userId, teamId)}${buildQueryString({before, after, per_page: perPage, extended, deleted, unread, since, totalsOnly, threadsOnly})}`,
            {method: 'get'},
        );
    };

    getUserThread = (userId: string, teamId: string, threadId: string, extended = false) => {
        const url = `${this.getUserThreadRoute(userId, teamId, threadId)}`;
        return this.doFetch<UserThreadWithPost>(
            `${url}${buildQueryString({extended})}`,
            {method: 'get'},
        );
    };

    updateThreadsReadForUser = (userId: string, teamId: string) => {
        const url = `${this.getUserThreadsRoute(userId, teamId)}/read`;
        return this.doFetch<StatusOK>(
            url,
            {method: 'put'},
        );
    };

    updateThreadReadForUser = (userId: string, teamId: string, threadId: string, timestamp: number) => {
        const url = `${this.getUserThreadRoute(userId, teamId, threadId)}/read/${timestamp}`;
        return this.doFetch<UserThread>(
            url,
            {method: 'put'},
        );
    };

    markThreadAsUnreadForUser = (userId: string, teamId: string, threadId: string, postId: string) => {
        const url = `${this.getUserThreadRoute(userId, teamId, threadId)}/set_unread/${postId}`;
        return this.doFetch<UserThread>(
            url,
            {method: 'post'},
        );
    };

    updateThreadFollowForUser = (userId: string, teamId: string, threadId: string, state: boolean) => {
        const url = this.getUserThreadRoute(userId, teamId, threadId) + '/following';
        return this.doFetch<StatusOK>(
            url,
            {method: state ? 'put' : 'delete'},
        );
    };

    getFileInfosForPost = (postId: string) => {
        return this.doFetch<FileInfo[]>(
            `${this.getPostRoute(postId)}/files/info`,
            {method: 'get'},
        );
    };

    getFlaggedPosts = (userId: string, channelId = '', teamId = '', page = 0, perPage = PER_PAGE_DEFAULT) => {
        this.trackEvent('api', 'api_posts_get_flagged', {team_id: teamId});

        return this.doFetch<PostList>(
            `${this.getUserRoute(userId)}/posts/flagged${buildQueryString({channel_id: channelId, team_id: teamId, page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    getPinnedPosts = (channelId: string) => {
        this.trackEvent('api', 'api_posts_get_pinned', {channel_id: channelId});
        return this.doFetch<PostList>(
            `${this.getChannelRoute(channelId)}/pinned`,
            {method: 'get'},
        );
    };

    markPostAsUnread = (userId: string, postId: string) => {
        this.trackEvent('api', 'api_post_set_unread_post');

        return this.doFetch<ChannelUnread>(
            `${this.getUserRoute(userId)}/posts/${postId}/set_unread`,
            {method: 'post', body: JSON.stringify({collapsed_threads_supported: true})},
        );
    }

    pinPost = (postId: string) => {
        this.trackEvent('api', 'api_posts_pin');

        return this.doFetch<StatusOK>(
            `${this.getPostRoute(postId)}/pin`,
            {method: 'post'},
        );
    };

    unpinPost = (postId: string) => {
        this.trackEvent('api', 'api_posts_unpin');

        return this.doFetch<StatusOK>(
            `${this.getPostRoute(postId)}/unpin`,
            {method: 'post'},
        );
    };

    getPostsByIds = (postIds: string[]) => {
        return this.doFetch<Post[]>(
            `${this.getPostsRoute()}/ids`,
            {method: 'post', body: JSON.stringify(postIds)},
        );
    };

    addReaction = (userId: string, postId: string, emojiName: string) => {
        this.trackEvent('api', 'api_reactions_save', {post_id: postId});

        return this.doFetch<Reaction>(
            `${this.getReactionsRoute()}`,
            {method: 'post', body: JSON.stringify({user_id: userId, post_id: postId, emoji_name: emojiName})},
        );
    };

    removeReaction = (userId: string, postId: string, emojiName: string) => {
        this.trackEvent('api', 'api_reactions_delete', {post_id: postId});

        return this.doFetch<StatusOK>(
            `${this.getUserRoute(userId)}/posts/${postId}/reactions/${emojiName}`,
            {method: 'delete'},
        );
    };

    getReactionsForPost = (postId: string) => {
        return this.doFetch<Reaction[]>(
            `${this.getPostRoute(postId)}/reactions`,
            {method: 'get'},
        );
    };

    getTopReactionsForTeam = (teamId: string, page: number, perPage: number, timeRange: string) => {
        return this.doFetch<TopReactionResponse>(
            `${this.getTeamRoute(teamId)}/top/reactions${buildQueryString({page, per_page: perPage, time_range: timeRange})}`,
            {method: 'get'},
        );
    }

    getMyTopReactions = (teamId: string, page: number, perPage: number, timeRange: string) => {
        return this.doFetch<TopReactionResponse>(
            `${this.getUsersRoute()}/me/top/reactions${buildQueryString({page, per_page: perPage, time_range: timeRange, team_id: teamId})}`,
            {method: 'get'},
        );
    }

    getTopChannelsForTeam = (teamId: string, page: number, perPage: number, timeRange: string) => {
        return this.doFetch<TopChannelResponse>(
            `${this.getTeamRoute(teamId)}/top/channels${buildQueryString({page, per_page: perPage, time_range: timeRange})}`,
            {method: 'get'},
        );
    }

    getMyTopChannels = (teamId: string, page: number, perPage: number, timeRange: string) => {
        return this.doFetch<TopChannelResponse>(
            `${this.getUsersRoute()}/me/top/channels${buildQueryString({page, per_page: perPage, time_range: timeRange, team_id: teamId})}`,
            {method: 'get'},
        );
    }

    getTopThreadsForTeam = (teamId: string, page: number, perPage: number, timeRange: string) => {
        return this.doFetch<TopThreadResponse>(
            `${this.getTeamRoute(teamId)}/top/threads${buildQueryString({page, per_page: perPage, time_range: timeRange})}`,
            {method: 'get'},
        );
    }

    getMyTopThreads = (teamId: string, page: number, perPage: number, timeRange: string) => {
        return this.doFetch<TopThreadResponse>(
            `${this.getUsersRoute()}/me/top/threads${buildQueryString({page, per_page: perPage, time_range: timeRange, team_id: teamId})}`,
            {method: 'get'},
        );
    }

    getLeastActiveChannelsForTeam = (teamId: string, page: number, perPage: number, timeRange: string) => {
        return this.doFetch<LeastActiveChannelsResponse>(
            `${this.getTeamRoute(teamId)}/top/inactive_channels${buildQueryString({page, per_page: perPage, time_range: timeRange})}`,
            {method: 'get'},
        );
    }
    getMyTopDMs = (teamId: string, page: number, perPage: number, timeRange: string) => {
        return this.doFetch<TopDMsResponse>(
            `${this.getUsersRoute()}/me/top/dms${buildQueryString({page, per_page: perPage, time_range: timeRange, team_id: teamId})}`,
            {method: 'get'},
        );
    }

    getMyLeastActiveChannels = (teamId: string, page: number, perPage: number, timeRange: string) => {
        return this.doFetch<LeastActiveChannelsResponse>(
            `${this.getUsersRoute()}/me/top/inactive_channels${buildQueryString({page, per_page: perPage, time_range: timeRange, team_id: teamId})}`,
            {method: 'get'},
        );
    }
    getNewTeamMembers = (teamId: string, page: number, perPage: number, timeRange: string) => {
        return this.doFetch<TopDMsResponse>(
            `${this.getTeamRoute(teamId)}/top/team_members${buildQueryString({page, per_page: perPage, time_range: timeRange})}`,
            {method: 'get'},
        );
    }

    searchPostsWithParams = (teamId: string, params: any) => {
        this.trackEvent('api', 'api_posts_search', {team_id: teamId});

        let route = `${this.getPostsRoute()}/search`;
        if (teamId) {
            route = `${this.getTeamRoute(teamId)}/posts/search`;
        }

        return this.doFetch<PostSearchResults>(
            route,
            {method: 'post', body: JSON.stringify(params)},
        );
    };

    searchPosts = (teamId: string, terms: string, isOrSearch: boolean) => {
        return this.searchPostsWithParams(teamId, {terms, is_or_search: isOrSearch});
    };

    searchFilesWithParams = (teamId: string, params: any) => {
        this.trackEvent('api', 'api_files_search', {team_id: teamId});

        return this.doFetch<FileSearchResults>(
            `${this.getTeamRoute(teamId)}/files/search`,
            {method: 'post', body: JSON.stringify(params)},
        );
    };

    searchFiles = (teamId: string, terms: string, isOrSearch: boolean) => {
        return this.searchFilesWithParams(teamId, {terms, is_or_search: isOrSearch});
    };

    getOpenGraphMetadata = (url: string) => {
        return this.doFetch<OpenGraphMetadata>(
            `${this.getBaseRoute()}/opengraph`,
            {method: 'post', body: JSON.stringify({url})},
        );
    };

    doPostAction = (postId: string, actionId: string, selectedOption = '') => {
        return this.doPostActionWithCookie(postId, actionId, '', selectedOption);
    };

    doPostActionWithCookie = (postId: string, actionId: string, actionCookie: string, selectedOption = '') => {
        if (selectedOption) {
            this.trackEvent('api', 'api_interactive_messages_menu_selected');
        } else {
            this.trackEvent('api', 'api_interactive_messages_button_clicked');
        }

        const msg: any = {
            selected_option: selectedOption,
        };
        if (actionCookie !== '') {
            msg.cookie = actionCookie;
        }
        return this.doFetch<PostActionResponse>(
            `${this.getPostRoute(postId)}/actions/${encodeURIComponent(actionId)}`,
            {method: 'post', body: JSON.stringify(msg)},
        );
    };

    // Files Routes

    getFileUrl(fileId: string, timestamp: number) {
        let url = `${this.getFileRoute(fileId)}`;
        if (timestamp) {
            url += `?${timestamp}`;
        }

        return url;
    }

    getFileThumbnailUrl(fileId: string, timestamp: number) {
        let url = `${this.getFileRoute(fileId)}/thumbnail`;
        if (timestamp) {
            url += `?${timestamp}`;
        }

        return url;
    }

    getFilePreviewUrl(fileId: string, timestamp: number) {
        let url = `${this.getFileRoute(fileId)}/preview`;
        if (timestamp) {
            url += `?${timestamp}`;
        }

        return url;
    }

    uploadFile = (fileFormData: any, formBoundary: string) => {
        this.trackEvent('api', 'api_files_upload');
        const request: any = {
            method: 'post',
            body: fileFormData,
        };

        if (formBoundary) {
            request.headers = {
                'Content-Type': `multipart/form-data; boundary=${formBoundary}`,
            };
        }

        return this.doFetch<FileUploadResponse>(
            `${this.getFilesRoute()}`,
            request,
        );
    };

    getFilePublicLink = (fileId: string) => {
        return this.doFetch<{
            link: string;
        }>(
            `${this.getFileRoute(fileId)}/link`,
            {method: 'get'},
        );
    }

    acknowledgePost = (postId: string, userId: string) => {
        this.trackEvent('api', 'api_posts_ack');

        return this.doFetch<PostAcknowledgement>(
            `${this.getUserRoute(userId)}/posts/${postId}/ack`,
            {method: 'post'},
        );
    };

    unacknowledgePost = (postId: string, userId: string) => {
        this.trackEvent('api', 'api_posts_unack');

        return this.doFetch<null>(
            `${this.getUserRoute(userId)}/posts/${postId}/ack`,
            {method: 'delete'},
        );
    };

    // Preference Routes

    savePreferences = (userId: string, preferences: PreferenceType[]) => {
        return this.doFetch<StatusOK>(
            `${this.getPreferencesRoute(userId)}`,
            {method: 'put', body: JSON.stringify(preferences)},
        );
    };

    getMyPreferences = () => {
        return this.doFetch<PreferenceType>(
            `${this.getPreferencesRoute('me')}`,
            {method: 'get'},
        );
    };

    deletePreferences = (userId: string, preferences: PreferenceType[]) => {
        return this.doFetch<StatusOK>(
            `${this.getPreferencesRoute(userId)}/delete`,
            {method: 'post', body: JSON.stringify(preferences)},
        );
    };

    // General Routes

    ping = () => {
        return this.doFetch<{
            status: string;
        }>(
            `${this.getBaseRoute()}/system/ping?time=${Date.now()}`,
            {method: 'get'},
        );
    };

    upgradeToEnterprise = async () => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/upgrade_to_enterprise`,
            {method: 'post'},
        );
    }

    upgradeToEnterpriseStatus = async () => {
        return this.doFetch<{
            percentage: number;
            error: string | null;
        }>(
            `${this.getBaseRoute()}/upgrade_to_enterprise/status`,
            {method: 'get'},
        );
    }

    restartServer = async () => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/restart`,
            {method: 'post'},
        );
    }

    logClientError = (message: string, level = LogLevel.Error) => {
        const url = `${this.getBaseRoute()}/logs`;

        if (!this.enableLogging) {
            throw new ClientError(this.getUrl(), {
                message: 'Logging disabled.',
                url,
            });
        }

        return this.doFetch<{
            message: string;
        }>(
            url,
            {method: 'post', body: JSON.stringify({message, level})},
        );
    };

    getClientConfigOld = () => {
        return this.doFetch<ClientConfig>(
            `${this.getBaseRoute()}/config/client?format=old`,
            {method: 'get'},
        );
    };

    getClientLicenseOld = () => {
        return this.doFetch<ClientLicense>(
            `${this.getBaseRoute()}/license/client?format=old`,
            {method: 'get'},
        );
    };

    getWarnMetricsStatus = async () => {
        return this.doFetch(
            `${this.getBaseRoute()}/warn_metrics/status`,
            {method: 'get'},
        );
    };

    sendWarnMetricAck = async (warnMetricId: string, forceAckVal: boolean) => {
        return this.doFetch(
            `${this.getBaseRoute()}/warn_metrics/ack/${encodeURI(warnMetricId)}`,
            {method: 'post', body: JSON.stringify({forceAck: forceAckVal})},
        );
    }

    setFirstAdminVisitMarketplaceStatus = async () => {
        return this.doFetch<StatusOK>(
            `${this.getPluginsRoute()}/marketplace/first_admin_visit`,
            {method: 'post', body: JSON.stringify({first_admin_visit_marketplace_status: true})},
        );
    }

    getFirstAdminVisitMarketplaceStatus = async () => {
        return this.doFetch<SystemSetting>(
            `${this.getPluginsRoute()}/marketplace/first_admin_visit`,
            {method: 'get'},
        );
    };

    getFirstAdminSetupComplete = async () => {
        return this.doFetch<SystemSetting>(
            `${this.getSystemRoute()}/onboarding/complete`,
            {method: 'get'},
        );
    };

    getTranslations = (url: string) => {
        return this.doFetch<Record<string, string>>(
            url,
            {method: 'get'},
        );
    };

    getWebSocketUrl = () => {
        return `${this.getBaseRoute()}/websocket`;
    }

    // Integration Routes

    createIncomingWebhook = (hook: IncomingWebhook) => {
        this.trackEvent('api', 'api_integrations_created', {team_id: hook.team_id});

        return this.doFetch<IncomingWebhook>(
            `${this.getIncomingHooksRoute()}`,
            {method: 'post', body: JSON.stringify(hook)},
        );
    };

    getIncomingWebhook = (hookId: string) => {
        return this.doFetch<IncomingWebhook>(
            `${this.getIncomingHookRoute(hookId)}`,
            {method: 'get'},
        );
    };

    getIncomingWebhooks = (teamId = '', page = 0, perPage = PER_PAGE_DEFAULT) => {
        const queryParams: any = {
            page,
            per_page: perPage,
        };

        if (teamId) {
            queryParams.team_id = teamId;
        }

        return this.doFetch<IncomingWebhook[]>(
            `${this.getIncomingHooksRoute()}${buildQueryString(queryParams)}`,
            {method: 'get'},
        );
    };

    removeIncomingWebhook = (hookId: string) => {
        this.trackEvent('api', 'api_integrations_deleted');

        return this.doFetch<StatusOK>(
            `${this.getIncomingHookRoute(hookId)}`,
            {method: 'delete'},
        );
    };

    updateIncomingWebhook = (hook: IncomingWebhook) => {
        this.trackEvent('api', 'api_integrations_updated', {team_id: hook.team_id});

        return this.doFetch<IncomingWebhook>(
            `${this.getIncomingHookRoute(hook.id)}`,
            {method: 'put', body: JSON.stringify(hook)},
        );
    };

    createOutgoingWebhook = (hook: OutgoingWebhook) => {
        this.trackEvent('api', 'api_integrations_created', {team_id: hook.team_id});

        return this.doFetch<OutgoingWebhook>(
            `${this.getOutgoingHooksRoute()}`,
            {method: 'post', body: JSON.stringify(hook)},
        );
    };

    getOutgoingWebhook = (hookId: string) => {
        return this.doFetch<OutgoingWebhook>(
            `${this.getOutgoingHookRoute(hookId)}`,
            {method: 'get'},
        );
    };

    getOutgoingWebhooks = (channelId = '', teamId = '', page = 0, perPage = PER_PAGE_DEFAULT) => {
        const queryParams: any = {
            page,
            per_page: perPage,
        };

        if (channelId) {
            queryParams.channel_id = channelId;
        }

        if (teamId) {
            queryParams.team_id = teamId;
        }

        return this.doFetch<OutgoingWebhook[]>(
            `${this.getOutgoingHooksRoute()}${buildQueryString(queryParams)}`,
            {method: 'get'},
        );
    };

    removeOutgoingWebhook = (hookId: string) => {
        this.trackEvent('api', 'api_integrations_deleted');

        return this.doFetch<StatusOK>(
            `${this.getOutgoingHookRoute(hookId)}`,
            {method: 'delete'},
        );
    };

    updateOutgoingWebhook = (hook: OutgoingWebhook) => {
        this.trackEvent('api', 'api_integrations_updated', {team_id: hook.team_id});

        return this.doFetch<OutgoingWebhook>(
            `${this.getOutgoingHookRoute(hook.id)}`,
            {method: 'put', body: JSON.stringify(hook)},
        );
    };

    regenOutgoingHookToken = (id: string) => {
        return this.doFetch<OutgoingWebhook>(
            `${this.getOutgoingHookRoute(id)}/regen_token`,
            {method: 'post'},
        );
    };

    getCommandsList = (teamId: string) => {
        return this.doFetch<Command[]>(
            `${this.getCommandsRoute()}?team_id=${teamId}`,
            {method: 'get'},
        );
    };

    getCommandAutocompleteSuggestionsList = (userInput: string, teamId: string, commandArgs: CommandArgs) => {
        return this.doFetch<AutocompleteSuggestion[]>(
            `${this.getTeamRoute(teamId)}/commands/autocomplete_suggestions${buildQueryString({...commandArgs, user_input: userInput})}`,
            {method: 'get'},
        );
    };

    getAutocompleteCommandsList = (teamId: string, page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<Command[]>(
            `${this.getTeamRoute(teamId)}/commands/autocomplete${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    getCustomTeamCommands = (teamId: string) => {
        return this.doFetch<Command[]>(
            `${this.getCommandsRoute()}?team_id=${teamId}&custom_only=true`,
            {method: 'get'},
        );
    };

    executeCommand = (command: string, commandArgs: CommandArgs) => {
        this.trackEvent('api', 'api_integrations_used');

        return this.doFetch<CommandResponse>(
            `${this.getCommandsRoute()}/execute`,
            {method: 'post', body: JSON.stringify({command, ...commandArgs})},
        );
    };

    addCommand = (command: Command) => {
        this.trackEvent('api', 'api_integrations_created');

        return this.doFetch<Command>(
            `${this.getCommandsRoute()}`,
            {method: 'post', body: JSON.stringify(command)},
        );
    };

    editCommand = (command: Command) => {
        this.trackEvent('api', 'api_integrations_created');

        return this.doFetch<Command>(
            `${this.getCommandsRoute()}/${command.id}`,
            {method: 'put', body: JSON.stringify(command)},
        );
    };

    regenCommandToken = (id: string) => {
        return this.doFetch<{
            token: string;
        }>(
            `${this.getCommandsRoute()}/${id}/regen_token`,
            {method: 'put'},
        );
    };

    deleteCommand = (id: string) => {
        this.trackEvent('api', 'api_integrations_deleted');

        return this.doFetch<StatusOK>(
            `${this.getCommandsRoute()}/${id}`,
            {method: 'delete'},
        );
    };

    createOAuthApp = (app: OAuthApp) => {
        this.trackEvent('api', 'api_apps_register');

        return this.doFetch<OAuthApp>(
            `${this.getOAuthAppsRoute()}`,
            {method: 'post', body: JSON.stringify(app)},
        );
    };

    editOAuthApp = (app: OAuthApp) => {
        return this.doFetch<OAuthApp>(
            `${this.getOAuthAppsRoute()}/${app.id}`,
            {method: 'put', body: JSON.stringify(app)},
        );
    };

    getOAuthApps = (page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<OAuthApp[]>(
            `${this.getOAuthAppsRoute()}${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    getAppsOAuthAppIDs = () => {
        return this.doFetch<string[]>(
            `${this.getAppsProxyRoute()}/api/v1/oauth-app-ids`,
            {method: 'get'},
        );
    }

    getAppsBotIDs = () => {
        return this.doFetch<string[]>(
            `${this.getAppsProxyRoute()}/api/v1/bot-ids`,
            {method: 'get'},
        );
    }

    getOAuthApp = (appId: string) => {
        return this.doFetch<OAuthApp>(
            `${this.getOAuthAppRoute(appId)}`,
            {method: 'get'},
        );
    };

    getOAuthAppInfo = (appId: string) => {
        return this.doFetch<OAuthApp>(
            `${this.getOAuthAppRoute(appId)}/info`,
            {method: 'get'},
        );
    };

    deleteOAuthApp = (appId: string) => {
        this.trackEvent('api', 'api_apps_delete');

        return this.doFetch<StatusOK>(
            `${this.getOAuthAppRoute(appId)}`,
            {method: 'delete'},
        );
    };

    regenOAuthAppSecret = (appId: string) => {
        return this.doFetch<OAuthApp>(
            `${this.getOAuthAppRoute(appId)}/regen_secret`,
            {method: 'post'},
        );
    };

    submitInteractiveDialog = (data: DialogSubmission) => {
        this.trackEvent('api', 'api_interactive_messages_dialog_submitted');
        return this.doFetch<SubmitDialogResponse>(
            `${this.getBaseRoute()}/actions/dialogs/submit`,
            {method: 'post', body: JSON.stringify(data)},
        );
    };

    // Emoji Routes

    createCustomEmoji = (emoji: CustomEmoji, imageData: File) => {
        this.trackEvent('api', 'api_emoji_custom_add');

        const formData = new FormData();
        formData.append('image', imageData);
        formData.append('emoji', JSON.stringify(emoji));
        const request: any = {
            method: 'post',
            body: formData,
        };

        if (formData.getBoundary) {
            request.headers = {
                'Content-Type': `multipart/form-data; boundary=${formData.getBoundary()}`,
            };
        }

        return this.doFetch<CustomEmoji>(
            `${this.getEmojisRoute()}`,
            request,
        );
    };

    getCustomEmoji = (id: string) => {
        return this.doFetch<CustomEmoji>(
            `${this.getEmojisRoute()}/${id}`,
            {method: 'get'},
        );
    };

    getCustomEmojiByName = (name: string) => {
        return this.doFetch<CustomEmoji>(
            `${this.getEmojisRoute()}/name/${name}`,
            {method: 'get'},
        );
    };

    getCustomEmojis = (page = 0, perPage = PER_PAGE_DEFAULT, sort = '') => {
        return this.doFetch<CustomEmoji[]>(
            `${this.getEmojisRoute()}${buildQueryString({page, per_page: perPage, sort})}`,
            {method: 'get'},
        );
    };

    deleteCustomEmoji = (emojiId: string) => {
        this.trackEvent('api', 'api_emoji_custom_delete');

        return this.doFetch<StatusOK>(
            `${this.getEmojiRoute(emojiId)}`,
            {method: 'delete'},
        );
    };

    getSystemEmojiImageUrl = (filename: string) => {
        const extension = filename.endsWith('.png') ? '' : '.png';
        return `${this.url}/static/emoji/${filename}${extension}`;
    };

    getCustomEmojiImageUrl = (id: string) => {
        return `${this.getEmojiRoute(id)}/image`;
    };

    searchCustomEmoji = (term: string, options = {}) => {
        return this.doFetch<CustomEmoji[]>(
            `${this.getEmojisRoute()}/search`,
            {method: 'post', body: JSON.stringify({term, ...options})},
        );
    };

    autocompleteCustomEmoji = (name: string) => {
        return this.doFetch<CustomEmoji[]>(
            `${this.getEmojisRoute()}/autocomplete${buildQueryString({name})}`,
            {method: 'get'},
        );
    };

    // Data Retention

    getDataRetentionPolicy = () => {
        return this.doFetch<DataRetentionPolicy>(
            `${this.getDataRetentionRoute()}/policy`,
            {method: 'get'},
        );
    };

    getDataRetentionCustomPolicies = (page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<GetDataRetentionCustomPoliciesRequest>(
            `${this.getDataRetentionRoute()}/policies${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    getDataRetentionCustomPolicy = (id: string) => {
        return this.doFetch<DataRetentionCustomPolicies>(
            `${this.getDataRetentionRoute()}/policies/${id}`,
            {method: 'get'},
        );
    };

    deleteDataRetentionCustomPolicy = (id: string) => {
        return this.doFetch<DataRetentionCustomPolicies>(
            `${this.getDataRetentionRoute()}/policies/${id}`,
            {method: 'delete'},
        );
    };

    searchDataRetentionCustomPolicyChannels = (policyId: string, term: string, opts: ChannelSearchOpts) => {
        return this.doFetch<DataRetentionCustomPolicies>(
            `${this.getDataRetentionRoute()}/policies/${policyId}/channels/search`,
            {method: 'post', body: JSON.stringify({term, ...opts})},
        );
    }

    searchDataRetentionCustomPolicyTeams = (policyId: string, term: string, opts: TeamSearchOpts) => {
        return this.doFetch<DataRetentionCustomPolicies>(
            `${this.getDataRetentionRoute()}/policies/${policyId}/teams/search`,
            {method: 'post', body: JSON.stringify({term, ...opts})},
        );
    }

    getDataRetentionCustomPolicyTeams = (id: string, page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<Team[]>(
            `${this.getDataRetentionRoute()}/policies/${id}/teams${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    getDataRetentionCustomPolicyChannels = (id: string, page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<{channels: Channel[]; total_count: number}>(
            `${this.getDataRetentionRoute()}/policies/${id}/channels${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    createDataRetentionPolicy = (policy: CreateDataRetentionCustomPolicy) => {
        return this.doFetch<DataRetentionCustomPolicies>(
            `${this.getDataRetentionRoute()}/policies`,
            {method: 'post', body: JSON.stringify(policy)},
        );
    };

    updateDataRetentionPolicy = (id: string, policy: PatchDataRetentionCustomPolicy) => {
        return this.doFetch<DataRetentionCustomPolicies>(
            `${this.getDataRetentionRoute()}/policies/${id}`,
            {method: 'PATCH', body: JSON.stringify(policy)},
        );
    };
    addDataRetentionPolicyTeams = (id: string, teams: string[]) => {
        return this.doFetch<DataRetentionCustomPolicies>(
            `${this.getDataRetentionRoute()}/policies/${id}/teams`,
            {method: 'post', body: JSON.stringify(teams)},
        );
    };
    removeDataRetentionPolicyTeams = (id: string, teams: string[]) => {
        return this.doFetch<DataRetentionCustomPolicies>(
            `${this.getDataRetentionRoute()}/policies/${id}/teams`,
            {method: 'delete', body: JSON.stringify(teams)},
        );
    };
    addDataRetentionPolicyChannels = (id: string, channels: string[]) => {
        return this.doFetch<DataRetentionCustomPolicies>(
            `${this.getDataRetentionRoute()}/policies/${id}/channels`,
            {method: 'post', body: JSON.stringify(channels)},
        );
    };
    removeDataRetentionPolicyChannels = (id: string, channels: string[]) => {
        return this.doFetch<DataRetentionCustomPolicies>(
            `${this.getDataRetentionRoute()}/policies/${id}/channels`,
            {method: 'delete', body: JSON.stringify(channels)},
        );
    };

    // Jobs Routes
    getJob = (id: string) => {
        return this.doFetch<Job>(
            `${this.getJobsRoute()}/${id}`,
            {method: 'get'},
        );
    };

    getJobs = (page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<Job[]>(
            `${this.getJobsRoute()}${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    getJobsByType = (type: string, page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<Job[]>(
            `${this.getJobsRoute()}/type/${type}${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    createJob = (job: Job) => {
        return this.doFetch<Job>(
            `${this.getJobsRoute()}`,
            {method: 'post', body: JSON.stringify(job)},
        );
    };

    cancelJob = (id: string) => {
        return this.doFetch<StatusOK>(
            `${this.getJobsRoute()}/${id}/cancel`,
            {method: 'post'},
        );
    };

    // Admin Routes

    getLogs = (page = 0, perPage = LOGS_PER_PAGE_DEFAULT) => {
        return this.doFetch<string[]>(
            `${this.getBaseRoute()}/logs${buildQueryString({page, logs_per_page: perPage})}`,
            {method: 'get'},
        );
    };

    getAudits = (page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<Audit[]>(
            `${this.getBaseRoute()}/audits${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    getConfig = () => {
        return this.doFetch<AdminConfig>(
            `${this.getBaseRoute()}/config`,
            {method: 'get'},
        );
    };

    updateConfig = (config: AdminConfig) => {
        return this.doFetch<AdminConfig>(
            `${this.getBaseRoute()}/config`,
            {method: 'put', body: JSON.stringify(config)},
        );
    };

    patchConfig = (patch: DeepPartial<AdminConfig>) => {
        return this.doFetch<AdminConfig>(
            `${this.getBaseRoute()}/config/patch`,
            {method: 'put', body: JSON.stringify(patch)},
        );
    };

    reloadConfig = () => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/config/reload`,
            {method: 'post'},
        );
    };

    getEnvironmentConfig = () => {
        return this.doFetch<EnvironmentConfig>(
            `${this.getBaseRoute()}/config/environment`,
            {method: 'get'},
        );
    };

    testEmail = (config: AdminConfig) => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/email/test`,
            {method: 'post', body: JSON.stringify(config)},
        );
    };

    testSiteURL = (siteURL: string) => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/site_url/test`,
            {method: 'post', body: JSON.stringify({site_url: siteURL})},
        );
    };

    testS3Connection = (config: ClientConfig) => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/file/s3_test`,
            {method: 'post', body: JSON.stringify(config)},
        );
    };

    invalidateCaches = () => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/caches/invalidate`,
            {method: 'post'},
        );
    };

    recycleDatabase = () => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/database/recycle`,
            {method: 'post'},
        );
    };

    createComplianceReport = (job: Partial<Compliance>) => {
        return this.doFetch<Compliance>(
            `${this.getBaseRoute()}/compliance/reports`,
            {method: 'post', body: JSON.stringify(job)},
        );
    };

    getComplianceReport = (reportId: string) => {
        return this.doFetch<Compliance>(
            `${this.getBaseRoute()}/compliance/reports/${reportId}`,
            {method: 'get'},
        );
    };

    getComplianceReports = (page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<Compliance[]>(
            `${this.getBaseRoute()}/compliance/reports${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    uploadBrandImage = (imageData: File) => {
        const formData = new FormData();
        formData.append('image', imageData);
        const request: any = {
            method: 'post',
            body: formData,
        };

        if (formData.getBoundary) {
            request.headers = {
                'Content-Type': `multipart/form-data; boundary=${formData.getBoundary()}`,
            };
        }

        return this.doFetch<StatusOK>(
            `${this.getBrandRoute()}/image`,
            request,
        );
    };

    deleteBrandImage = () => {
        return this.doFetch<StatusOK>(
            `${this.getBrandRoute()}/image`,
            {method: 'delete'},
        );
    };

    getClusterStatus = () => {
        return this.doFetch<ClusterInfo[]>(
            `${this.getBaseRoute()}/cluster/status`,
            {method: 'get'},
        );
    };

    testLdap = () => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/ldap/test`,
            {method: 'post'},
        );
    };

    syncLdap = () => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/ldap/sync`,
            {method: 'post'},
        );
    };

    getLdapGroups = (page = 0, perPage = PER_PAGE_DEFAULT, opts = {}) => {
        const query = {page, per_page: perPage, ...opts};
        return this.doFetch<{
            count: number;
            groups: MixedUnlinkedGroup[];
        }>(
            `${this.getBaseRoute()}/ldap/groups${buildQueryString(query)}`,
            {method: 'get'},
        );
    };

    linkLdapGroup = (key: string) => {
        return this.doFetch<Group>(
            `${this.getBaseRoute()}/ldap/groups/${encodeURI(key)}/link`,
            {method: 'post'},
        );
    };

    unlinkLdapGroup = (key: string) => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/ldap/groups/${encodeURI(key)}/link`,
            {method: 'delete'},
        );
    };

    getSamlCertificateStatus = () => {
        return this.doFetch<SamlCertificateStatus>(
            `${this.getBaseRoute()}/saml/certificate/status`,
            {method: 'get'},
        );
    };

    uploadPublicSamlCertificate = (fileData: File) => {
        const formData = new FormData();
        formData.append('certificate', fileData);

        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/saml/certificate/public`,
            {
                method: 'post',
                body: formData,
            },
        );
    };

    uploadPrivateSamlCertificate = (fileData: File) => {
        const formData = new FormData();
        formData.append('certificate', fileData);

        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/saml/certificate/private`,
            {
                method: 'post',
                body: formData,
            },
        );
    };

    uploadPublicLdapCertificate = (fileData: File) => {
        const formData = new FormData();
        formData.append('certificate', fileData);

        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/ldap/certificate/public`,
            {
                method: 'post',
                body: formData,
            },
        );
    };

    uploadPrivateLdapCertificate = (fileData: File) => {
        const formData = new FormData();
        formData.append('certificate', fileData);

        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/ldap/certificate/private`,
            {
                method: 'post',
                body: formData,
            },
        );
    };

    uploadIdpSamlCertificate = (fileData: File) => {
        const formData = new FormData();
        formData.append('certificate', fileData);

        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/saml/certificate/idp`,
            {
                method: 'post',
                body: formData,
            },
        );
    };

    deletePublicSamlCertificate = () => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/saml/certificate/public`,
            {method: 'delete'},
        );
    };

    deletePrivateSamlCertificate = () => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/saml/certificate/private`,
            {method: 'delete'},
        );
    };

    deletePublicLdapCertificate = () => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/ldap/certificate/public`,
            {method: 'delete'},
        );
    };

    deletePrivateLdapCertificate = () => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/ldap/certificate/private`,
            {method: 'delete'},
        );
    };

    deleteIdpSamlCertificate = () => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/saml/certificate/idp`,
            {method: 'delete'},
        );
    };

    testElasticsearch = (config: ClientConfig) => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/elasticsearch/test`,
            {method: 'post', body: JSON.stringify(config)},
        );
    };

    purgeElasticsearchIndexes = () => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/elasticsearch/purge_indexes`,
            {method: 'post'},
        );
    };

    purgeBleveIndexes = () => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/bleve/purge_indexes`,
            {method: 'post'},
        );
    };

    uploadLicense = (fileData: File) => {
        this.trackEvent('api', 'api_license_upload');

        const formData = new FormData();
        formData.append('license', fileData);

        const request: any = {
            method: 'post',
            body: formData,
        };

        if (formData.getBoundary) {
            request.headers = {
                'Content-Type': `multipart/form-data; boundary=${formData.getBoundary()}`,
            };
        }

        return this.doFetch<License>(
            `${this.getBaseRoute()}/license`,
            request,
        );
    };

    requestTrialLicense = (body: RequestLicenseBody) => {
        return this.doFetchWithResponse<ClientLicense>(
            `${this.getBaseRoute()}/trial-license`,
            {method: 'POST', body: JSON.stringify(body)},
        );
    }

    removeLicense = () => {
        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/license`,
            {method: 'delete'},
        );
    };

    getPrevTrialLicense = () => {
        return this.doFetch<ClientLicense>(
            `${this.getBaseRoute()}/trial-license/prev`,
            {method: 'get'},
        );
    }

    getAnalytics = (name = 'standard', teamId = '') => {
        return this.doFetch<AnalyticsRow[]>(
            `${this.getBaseRoute()}/analytics/old${buildQueryString({name, team_id: teamId})}`,
            {method: 'get'},
        );
    };

    // Role Routes

    getRole = (roleId: string) => {
        return this.doFetch<Role>(
            `${this.getRolesRoute()}/${roleId}`,
            {method: 'get'},
        );
    };

    getRoleByName = (roleName: string) => {
        return this.doFetch<Role>(
            `${this.getRolesRoute()}/name/${roleName}`,
            {method: 'get'},
        );
    };

    getRolesByNames = (rolesNames: string[]) => {
        return this.doFetch<Role[]>(
            `${this.getRolesRoute()}/names`,
            {method: 'post', body: JSON.stringify(rolesNames)},
        );
    };

    patchRole = (roleId: string, rolePatch: Partial<Role>) => {
        return this.doFetch<Role>(
            `${this.getRolesRoute()}/${roleId}/patch`,
            {method: 'put', body: JSON.stringify(rolePatch)},
        );
    };

    // Scheme Routes

    getSchemes = (scope = '', page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<Scheme[]>(
            `${this.getSchemesRoute()}${buildQueryString({scope, page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    createScheme = (scheme: Scheme) => {
        this.trackEvent('api', 'api_schemes_create');

        return this.doFetch<Scheme>(
            `${this.getSchemesRoute()}`,
            {method: 'post', body: JSON.stringify(scheme)},
        );
    };

    getScheme = (schemeId: string) => {
        return this.doFetch<Scheme>(
            `${this.getSchemesRoute()}/${schemeId}`,
            {method: 'get'},
        );
    };

    deleteScheme = (schemeId: string) => {
        this.trackEvent('api', 'api_schemes_delete');

        return this.doFetch<StatusOK>(
            `${this.getSchemesRoute()}/${schemeId}`,
            {method: 'delete'},
        );
    };

    patchScheme = (schemeId: string, schemePatch: Partial<Scheme>) => {
        this.trackEvent('api', 'api_schemes_patch', {scheme_id: schemeId});

        return this.doFetch<Scheme>(
            `${this.getSchemesRoute()}/${schemeId}/patch`,
            {method: 'put', body: JSON.stringify(schemePatch)},
        );
    };

    getSchemeTeams = (schemeId: string, page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<Team[]>(
            `${this.getSchemesRoute()}/${schemeId}/teams${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    getSchemeChannels = (schemeId: string, page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<Channel[]>(
            `${this.getSchemesRoute()}/${schemeId}/channels${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    };

    // Plugin Routes - EXPERIMENTAL - SUBJECT TO CHANGE

    uploadPlugin = async (fileData: File, force = false) => {
        this.trackEvent('api', 'api_plugin_upload');

        const formData = new FormData();
        if (force) {
            formData.append('force', 'true');
        }
        formData.append('plugin', fileData);

        const request: any = {
            method: 'post',
            body: formData,
        };

        if (formData.getBoundary) {
            request.headers = {
                'Content-Type': `multipart/form-data; boundary=${formData.getBoundary()}`,
            };
        }

        return this.doFetch<PluginManifest>(
            this.getPluginsRoute(),
            request,
        );
    };

    installPluginFromUrl = (pluginDownloadUrl: string, force = false) => {
        this.trackEvent('api', 'api_install_plugin');

        const queryParams = {plugin_download_url: pluginDownloadUrl, force};

        return this.doFetch<PluginManifest>(
            `${this.getPluginsRoute()}/install_from_url${buildQueryString(queryParams)}`,
            {method: 'post'},
        );
    };

    getPlugins = () => {
        return this.doFetch<PluginsResponse>(
            this.getPluginsRoute(),
            {method: 'get'},
        );
    };

    getMarketplacePlugins = (filter: string, localOnly = false) => {
        return this.doFetch<MarketplacePlugin[]>(
            `${this.getPluginsMarketplaceRoute()}${buildQueryString({filter: filter || '', local_only: localOnly})}`,
            {method: 'get'},
        );
    }

    installMarketplacePlugin = (id: string) => {
        this.trackEvent('api', 'api_install_marketplace_plugin');

        return this.doFetch<MarketplacePlugin>(
            `${this.getPluginsMarketplaceRoute()}`,
            {method: 'post', body: JSON.stringify({id})},
        );
    }

    // This function belongs to the Apps Framework feature.
    // Apps Framework feature is experimental, and this function is susceptible
    // to breaking changes without pushing the major version of this package.
    getMarketplaceApps = (filter: string) => {
        return this.doFetch<MarketplaceApp[]>(
            `${this.getAppsProxyRoute()}/api/v1/marketplace${buildQueryString({filter: filter || ''})}`,
            {method: 'get'},
        );
    }

    getPluginStatuses = () => {
        return this.doFetch<PluginStatus[]>(
            `${this.getPluginsRoute()}/statuses`,
            {method: 'get'},
        );
    };

    removePlugin = (pluginId: string) => {
        return this.doFetch<StatusOK>(
            this.getPluginRoute(pluginId),
            {method: 'delete'},
        );
    };

    getWebappPlugins = () => {
        return this.doFetch<ClientPluginManifest[]>(
            `${this.getPluginsRoute()}/webapp`,
            {method: 'get'},
        );
    };

    enablePlugin = (pluginId: string) => {
        return this.doFetch<StatusOK>(
            `${this.getPluginRoute(pluginId)}/enable`,
            {method: 'post'},
        );
    };

    disablePlugin = (pluginId: string) => {
        return this.doFetch<StatusOK>(
            `${this.getPluginRoute(pluginId)}/disable`,
            {method: 'post'},
        );
    };

    getBoardsUsage = () => {
        return this.doFetch<BoardsUsageResponse>(
            `/plugins/${suitePluginIds.focalboard}/api/v2/limits`,
            {method: 'get'},
        );
    }

    getBoardsTemplates = (teamId = '0') => {
        return this.doFetch<BoardTemplate[]>(
            `/plugins/${suitePluginIds.focalboard}/api/v2/teams/${teamId}/templates`,
            {method: 'get'},
        );
    }

    createBoard = (board: Board) => {
        return this.doFetch<CreateBoardResponse>(
            `/plugins/${suitePluginIds.focalboard}/api/v2/boards`,
            {method: 'POST', body: JSON.stringify({...board})},
        );
    }

    createBoardFromTemplate = (boardTemplateId: string, teamId: string) => {
        return this.doFetch<CreateBoardResponse>(
            `/plugins/${suitePluginIds.focalboard}/api/v2/boards/${boardTemplateId}/duplicate?asTemplate=false&toTeam=${teamId}`,
            {method: 'POST'},
        );
    }

    patchBoard = (newBoardId: string, boardPatch: BoardPatch) => {
        return this.doFetch<Board>(
            `/plugins/${suitePluginIds.focalboard}/api/v2/boards/${newBoardId}`,
            {method: 'PATCH', body: JSON.stringify({...boardPatch})},
        );
    }

    // Groups

    linkGroupSyncable = (groupID: string, syncableID: string, syncableType: string, patch: SyncablePatch) => {
        return this.doFetch<GroupSyncable>(
            `${this.getGroupRoute(groupID)}/${syncableType}s/${syncableID}/link`,
            {method: 'post', body: JSON.stringify(patch)},
        );
    };

    unlinkGroupSyncable = (groupID: string, syncableID: string, syncableType: string) => {
        return this.doFetch<StatusOK>(
            `${this.getGroupRoute(groupID)}/${syncableType}s/${syncableID}/link`,
            {method: 'delete'},
        );
    };

    getGroupSyncables = (groupID: string, syncableType: string) => {
        return this.doFetch<GroupSyncable[]>(
            `${this.getGroupRoute(groupID)}/${syncableType}s`,
            {method: 'get'},
        );
    };

    getGroup = (groupID: string, includeMemberCount = false) => {
        return this.doFetch<Group>(
            `${this.getGroupRoute(groupID)}${buildQueryString({include_member_count: includeMemberCount})}`,
            {method: 'get'},
        );
    };

    getGroupStats = (groupID: string) => {
        return this.doFetch<Group>(
            `${this.getGroupRoute(groupID)}/stats`,
            {method: 'get'},
        );
    };

    getGroups = (filterAllowReference = false, page = 0, perPage = 10, includeMemberCount = false, hasFilterMember = false) => {
        const qs: any = {
            filter_allow_reference: filterAllowReference,
            page,
            per_page: perPage,
            include_member_count: includeMemberCount,
        };

        if (hasFilterMember) {
            qs.filter_has_member = hasFilterMember;
        }
        return this.doFetch<Group[]>(
            `${this.getGroupsRoute()}${buildQueryString(qs)}`,
            {method: 'get'},
        );
    };

    getGroupsByUserId = (userID: string) => {
        return this.doFetch<Group[]>(
            `${this.getUsersRoute()}/${userID}/groups`,
            {method: 'get'},
        );
    };

    getGroupsNotAssociatedToTeam = (teamID: string, q = '', page = 0, perPage = PER_PAGE_DEFAULT, source = 'ldap') => {
        this.trackEvent('api', 'api_groups_get_not_associated_to_team', {team_id: teamID});
        return this.doFetch<Group[]>(
            `${this.getGroupsRoute()}${buildQueryString({not_associated_to_team: teamID, page, per_page: perPage, q, include_member_count: true, group_source: source})}`,
            {method: 'get'},
        );
    };

    getGroupsNotAssociatedToChannel = (channelID: string, q = '', page = 0, perPage = PER_PAGE_DEFAULT, filterParentTeamPermitted = false, source = 'ldap') => {
        this.trackEvent('api', 'api_groups_get_not_associated_to_channel', {channel_id: channelID});
        const query = {
            not_associated_to_channel: channelID,
            page,
            per_page: perPage,
            q,
            include_member_count: true,
            filter_parent_team_permitted: filterParentTeamPermitted,
            group_source: source,
        };
        return this.doFetch<Group[]>(
            `${this.getGroupsRoute()}${buildQueryString(query)}`,
            {method: 'get'},
        );
    };

    createGroupWithUserIds = (group: GroupCreateWithUserIds) => {
        return this.doFetch<Group>(
            this.getGroupsRoute(),
            {method: 'post', body: JSON.stringify(group)},
        );
    }

    addUsersToGroup = (groupId: string, userIds: string[]) => {
        return this.doFetch<UserProfile[]>(
            `${this.getGroupRoute(groupId)}/members`,
            {method: 'post', body: JSON.stringify({user_ids: userIds})},
        );
    }

    removeUsersFromGroup = (groupId: string, userIds: string[]) => {
        return this.doFetch<UserProfile[]>(
            `${this.getGroupRoute(groupId)}/members`,
            {method: 'delete', body: JSON.stringify({user_ids: userIds})},
        );
    }

    searchGroups = (params: GroupSearachParams) => {
        return this.doFetch<Group[]>(
            `${this.getGroupsRoute()}${buildQueryString(params)}`,
            {method: 'get'},
        );
    }

    // This function belongs to the Apps Framework feature.
    // Apps Framework feature is experimental, and this function is susceptible
    // to breaking changes without pushing the major version of this package.
    executeAppCall = async (call: AppCallRequest, trackAsSubmit: boolean) => {
        const callCopy: AppCallRequest = {
            ...call,
            context: {
                ...call.context,
                track_as_submit: trackAsSubmit,
                user_agent: 'webapp',
            },
        };
        return this.doFetch<AppCallResponse>(
            `${this.getAppsProxyRoute()}/api/v1/call`,
            {method: 'post', body: JSON.stringify(callCopy)},
        );
    }

    // This function belongs to the Apps Framework feature.
    // Apps Framework feature is experimental, and this function is susceptible
    // to breaking changes without pushing the major version of this package.
    getAppsBindings = async (userID: string, channelID: string, teamID: string) => {
        const params = {
            user_id: userID,
            channel_id: channelID,
            team_id: teamID,
            user_agent: 'webapp',
        };

        return this.doFetch<AppBinding[]>(
            `${this.getAppsProxyRoute()}/api/v1/bindings${buildQueryString(params)}`,
            {method: 'get'},
        );
    }

    getGroupsAssociatedToTeam = (teamID: string, q = '', page = 0, perPage = PER_PAGE_DEFAULT, filterAllowReference = false) => {
        this.trackEvent('api', 'api_groups_get_associated_to_team', {team_id: teamID});

        return this.doFetch<{
            groups: Group[];
            total_group_count: number;
        }>(
            `${this.getBaseRoute()}/teams/${teamID}/groups${buildQueryString({page, per_page: perPage, q, include_member_count: true, filter_allow_reference: filterAllowReference})}`,
            {method: 'get'},
        );
    };

    getGroupsAssociatedToChannel = (channelID: string, q = '', page = 0, perPage = PER_PAGE_DEFAULT, filterAllowReference = false) => {
        this.trackEvent('api', 'api_groups_get_associated_to_channel', {channel_id: channelID});

        return this.doFetch<{
            groups: Group[];
            total_group_count: number;
        }>(
            `${this.getBaseRoute()}/channels/${channelID}/groups${buildQueryString({page, per_page: perPage, q, include_member_count: true, filter_allow_reference: filterAllowReference})}`,
            {method: 'get'},
        );
    };

    getAllGroupsAssociatedToTeam = (teamID: string, filterAllowReference = false, includeMemberCount = false) => {
        return this.doFetch<GroupsWithCount>(
            `${this.getBaseRoute()}/teams/${teamID}/groups${buildQueryString({paginate: false, filter_allow_reference: filterAllowReference, include_member_count: includeMemberCount})}`,
            {method: 'get'},
        );
    };

    getAllGroupsAssociatedToChannelsInTeam = (teamID: string, filterAllowReference = false) => {
        return this.doFetch<{
            groups: RelationOneToOne<Channel, Group>;
        }>(
            `${this.getBaseRoute()}/teams/${teamID}/groups_by_channels${buildQueryString({paginate: false, filter_allow_reference: filterAllowReference})}`,
            {method: 'get'},
        );
    };

    getAllGroupsAssociatedToChannel = (channelID: string, filterAllowReference = false, includeMemberCount = false) => {
        return this.doFetch<GroupsWithCount>(
            `${this.getBaseRoute()}/channels/${channelID}/groups${buildQueryString({paginate: false, filter_allow_reference: filterAllowReference, include_member_count: includeMemberCount})}`,
            {method: 'get'},
        );
    };

    patchGroupSyncable = (groupID: string, syncableID: string, syncableType: string, patch: SyncablePatch) => {
        return this.doFetch<GroupSyncable>(
            `${this.getGroupRoute(groupID)}/${syncableType}s/${syncableID}/patch`,
            {method: 'put', body: JSON.stringify(patch)},
        );
    };

    patchGroup = (groupID: string, patch: GroupPatch | CustomGroupPatch) => {
        return this.doFetch<Group>(
            `${this.getGroupRoute(groupID)}/patch`,
            {method: 'put', body: JSON.stringify(patch)},
        );
    };

    archiveGroup = (groupId: string) => {
        return this.doFetch<Group>(
            `${this.getGroupRoute(groupId)}`,
            {method: 'delete'},
        );
    }

    createGroupTeamsAndChannels = (userID: string) => {
        return this.doFetch<Group>(
            `${this.getBaseRoute()}/ldap/users/${userID}/group_sync_memberships`,
            {method: 'post'},
        );
    }

    // Redirect Location
    getRedirectLocation = (urlParam: string) => {
        if (!urlParam.length) {
            return Promise.resolve();
        }
        const url = `${this.getRedirectLocationRoute()}${buildQueryString({url: urlParam})}`;
        return this.doFetch<{
            location: string;
        }>(url, {method: 'get'});
    };

    // Bot Routes

    createBot = (bot: Bot) => {
        return this.doFetch<Bot>(
            `${this.getBotsRoute()}`,
            {method: 'post', body: JSON.stringify(bot)},
        );
    }

    patchBot = (botUserId: string, botPatch: BotPatch) => {
        return this.doFetch<Bot>(
            `${this.getBotRoute(botUserId)}`,
            {method: 'put', body: JSON.stringify(botPatch)},
        );
    }

    getBot = (botUserId: string) => {
        return this.doFetch<Bot>(
            `${this.getBotRoute(botUserId)}`,
            {method: 'get'},
        );
    }

    getBots = (page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<Bot[]>(
            `${this.getBotsRoute()}${buildQueryString({page, per_page: perPage})}`,
            {method: 'get'},
        );
    }

    getBotsIncludeDeleted = (page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<Bot[]>(
            `${this.getBotsRoute()}${buildQueryString({include_deleted: true, page, per_page: perPage})}`,
            {method: 'get'},
        );
    }

    getBotsOrphaned = (page = 0, perPage = PER_PAGE_DEFAULT) => {
        return this.doFetch<Bot[]>(
            `${this.getBotsRoute()}${buildQueryString({only_orphaned: true, page, per_page: perPage})}`,
            {method: 'get'},
        );
    }

    disableBot = (botUserId: string) => {
        return this.doFetch<Bot>(
            `${this.getBotRoute(botUserId)}/disable`,
            {method: 'post'},
        );
    }

    enableBot = (botUserId: string) => {
        return this.doFetch<Bot>(
            `${this.getBotRoute(botUserId)}/enable`,
            {method: 'post'},
        );
    }

    assignBot = (botUserId: string, newOwnerId: string) => {
        return this.doFetch<Bot>(
            `${this.getBotRoute(botUserId)}/assign/${newOwnerId}`,
            {method: 'post'},
        );
    }

    // Cloud routes
    getCloudProducts = (includeLegacyProducts?: boolean) => {
        let query = '';
        if (includeLegacyProducts) {
            query = '?include_legacy=true';
        }
        return this.doFetch<Product[]>(
            `${this.getCloudRoute()}/products${query}`, {method: 'get'},
        );
    };

    bootstrapSelfHostedSignup = () => {
        return this.doFetch<{progress: ValueOf<typeof SelfHostedSignupProgress>}>(
            `${this.getHostedCustomerRoute()}/bootstrap`,
            {method: 'post'},
        );
    };

    createPaymentMethod = async () => {
        return this.doFetch(
            `${this.getCloudRoute()}/payment`,
            {method: 'post'},
        );
    }

    getCloudCustomer = () => {
        return this.doFetch<CloudCustomer>(
            `${this.getCloudRoute()}/customer`, {method: 'get'},
        );
    }

    updateCloudCustomer = (customerPatch: CloudCustomerPatch) => {
        return this.doFetch<CloudCustomer>(
            `${this.getCloudRoute()}/customer`,
            {method: 'put', body: JSON.stringify(customerPatch)},
        );
    }

    updateCloudCustomerAddress = (address: Address) => {
        return this.doFetch<CloudCustomer>(
            `${this.getCloudRoute()}/customer/address`,
            {method: 'put', body: JSON.stringify(address)},
        );
    }

    notifyAdmin = (req: NotifyAdminRequest) => {
        return this.doFetchWithResponse<StatusOK>(
            `${this.getUsersRoute()}/notify-admin`,
            {method: 'post', body: JSON.stringify(req)},
        );
    }

    confirmPaymentMethod = async (stripeSetupIntentID: string) => {
        return this.doFetch(
            `${this.getCloudRoute()}/payment/confirm`,
            {method: 'post', body: JSON.stringify({stripe_setup_intent_id: stripeSetupIntentID})},
        );
    }

    subscribeCloudProduct = (productId: string, seats = 0) => {
        return this.doFetch<CloudCustomer>(
            `${this.getCloudRoute()}/subscription`,
            {method: 'put', body: JSON.stringify({product_id: productId, seats})},
        );
    }

    requestCloudTrial = (subscriptionId: string, email = '') => {
        return this.doFetchWithResponse<Subscription>(
            `${this.getCloudRoute()}/request-trial`,
            {method: 'put', body: JSON.stringify({email, subscription_id: subscriptionId})},
        );
    }

    validateBusinessEmail = (email = '') => {
        return this.doFetchWithResponse<ValidBusinessEmail>(
            `${this.getCloudRoute()}/validate-business-email`,
            {method: 'post', body: JSON.stringify({email})},
        );
    }

    validateWorkspaceBusinessEmail = () => {
        return this.doFetchWithResponse<ValidBusinessEmail>(
            `${this.getCloudRoute()}/validate-workspace-business-email`,
            {method: 'post'},
        );
    }

    getSubscription = () => {
        return this.doFetch<Subscription>(
            `${this.getCloudRoute()}/subscription`,
            {method: 'get'},
        );
    }

    getRenewalLink = () => {
        return this.doFetch<{renewal_link: string}>(
            `${this.getBaseRoute()}/license/renewal`,
            {method: 'get'},
        );
    }

    getInvoices = () => {
        return this.doFetch<Invoice[]>(
            `${this.getCloudRoute()}/subscription/invoices`,
            {method: 'get'},
        );
    }

    getInvoicePdfUrl = (invoiceId: string) => {
        return `${this.getCloudRoute()}/subscription/invoices/${invoiceId}/pdf`;
    }

    getCloudLimits = () => {
        return this.doFetch<Limits>(
            `${this.getCloudRoute()}/limits`,
            {method: 'get'},
        );
    }

    getPostsUsage = () => {
        return this.doFetch<PostsUsageResponse>(
            `${this.getUsageRoute()}/posts`,
            {method: 'get'},
        );
    }

    getFilesUsage = () => {
        return this.doFetch<FilesUsageResponse>(
            `${this.getUsageRoute()}/storage`,
            {method: 'get'},
        );
    }

    getTeamsUsage = () => {
        return this.doFetch<TeamsUsageResponse>(
            `${this.getUsageRoute()}/teams`,
            {method: 'get'},
        );
    }

    teamMembersMinusGroupMembers = (teamID: string, groupIDs: string[], page: number, perPage: number) => {
        const query = `group_ids=${groupIDs.join(',')}&page=${page}&per_page=${perPage}`;
        return this.doFetch<UsersWithGroupsAndCount>(
            `${this.getTeamRoute(teamID)}/members_minus_group_members?${query}`,
            {method: 'get'},
        );
    }

    channelMembersMinusGroupMembers = (channelID: string, groupIDs: string[], page: number, perPage: number) => {
        const query = `group_ids=${groupIDs.join(',')}&page=${page}&per_page=${perPage}`;
        return this.doFetch<UsersWithGroupsAndCount>(
            `${this.getChannelRoute(channelID)}/members_minus_group_members?${query}`,
            {method: 'get'},
        );
    }

    getSamlMetadataFromIdp = (samlMetadataURL: string) => {
        return this.doFetch<SamlMetadataResponse>(
            `${this.getBaseRoute()}/saml/metadatafromidp`, {method: 'post', body: JSON.stringify({saml_metadata_url: samlMetadataURL})},
        );
    };

    setSamlIdpCertificateFromMetadata = (certData: string) => {
        const request: any = {
            method: 'post',
            body: certData,
        };

        request.headers = {
            'Content-Type': 'application/x-pem-file',
        };

        return this.doFetch<StatusOK>(
            `${this.getBaseRoute()}/saml/certificate/idp`,
            request,
        );
    };

    getInProductNotices = (teamId: string, client: string, clientVersion: string) => {
        return this.doFetch<ProductNotices>(
            `${this.getNoticesRoute()}/${teamId}?client=${client}&clientVersion=${clientVersion}`,
            {method: 'get'},
        );
    };

    updateNoticesAsViewed = (noticeIds: string[]) => {
        // Only one notice is marked as viewed at a time so using 0 index
        this.trackEvent('ui', `notice_seen_${noticeIds[0]}`);
        return this.doFetch<StatusOK>(
            `${this.getNoticesRoute()}/view`,
            {method: 'put', body: JSON.stringify(noticeIds)},
        );
    }

    getAncillaryPermissions = (subsectionPermissions: string[]) => {
        return this.doFetch<string[]>(
            `${this.getPermissionsRoute()}/ancillary?subsection_permissions=${subsectionPermissions.join(',')}`,
            {method: 'get'},
        );
    }

    completeSetup = (completeOnboardingRequest: CompleteOnboardingRequest) => {
        return this.doFetch<StatusOK>(
            `${this.getSystemRoute()}/onboarding/complete`,
            {method: 'post', body: JSON.stringify(completeOnboardingRequest)},
        );
    }

    getAppliedSchemaMigrations = () => {
        return this.doFetch<SchemaMigration[]>(
            `${this.getSystemRoute()}/schema/version`,
            {method: 'get'},
        );
    }

    /**
     * @param query string query of graphQL, pass the json stringified version of the query
     * eg.  const query = JSON.stringify({query: `{license, config}`, operationName: 'queryForLicenseAndConfig'});
     *      client4.fetchWithGraphQL(query);
     */
    fetchWithGraphQL = async <DataResponse>(query: string) => {
        return this.doFetch<DataResponse>(this.getGraphQLUrl(), {method: 'post', body: query});
    }

    // Client Helpers

    protected doFetch = async <ClientDataResponse>(url: string, options: Options): Promise<ClientDataResponse> => {
        const {data} = await this.doFetchWithResponse<ClientDataResponse>(url, options);

        return data;
    };

    private doFetchWithResponse = async <ClientDataResponse>(url: string, options: Options): Promise<ClientResponse<ClientDataResponse>> => {
        const response = await fetch(url, this.getOptions(options));
        const headers = parseAndMergeNestedHeaders(response.headers);

        let data;
        try {
            data = await response.json();
        } catch (err) {
            throw new ClientError(this.getUrl(), {
                message: 'Received invalid response from the server.',
                url,
            });
        }

        if (headers.has(HEADER_X_VERSION_ID) && !headers.get('Cache-Control')) {
            const serverVersion = headers.get(HEADER_X_VERSION_ID);
            if (serverVersion && this.serverVersion !== serverVersion) {
                this.serverVersion = serverVersion;
            }
        }

        if (headers.has(HEADER_X_CLUSTER_ID)) {
            const clusterId = headers.get(HEADER_X_CLUSTER_ID);
            if (clusterId && this.clusterId !== clusterId) {
                this.clusterId = clusterId;
            }
        }

        if (response.ok) {
            return {
                response,
                headers,
                data,
            };
        }

        const msg = data.message || '';

        if (this.logToConsole) {
            console.error(msg); // eslint-disable-line no-console
        }

        throw new ClientError(this.getUrl(), {
            message: msg,
            server_error_id: data.id,
            status_code: data.status_code,
            url,
        });
    };

    trackEvent(category: string, event: string, props?: any) {
        if (this.telemetryHandler) {
            this.telemetryHandler.trackEvent(this.userId, this.userRoles, category, event, props);
        }
    }

    pageVisited(category: string, name: string) {
        if (this.telemetryHandler) {
            this.telemetryHandler.pageVisited(this.userId, this.userRoles, category, name);
        }
    }

    upsertDraft = async (draft: Draft, connectionId: string) => {
        const result = await this.doFetch<Draft>(
            `${this.getDraftsRoute()}`,
            {
                method: 'post',
                body: JSON.stringify(draft),
                headers: {
                    'Connection-Id': `${connectionId}`,
                },
            },
        );

        return result;
    };

    getUserDrafts = (teamId: Team['id']) => {
        return this.doFetch<Draft[]>(
            `${this.getUserRoute('me')}/teams/${teamId}/drafts`,
            {method: 'get'},
        );
    };

    deleteDraft = (channelId: Channel['id'], rootId = '', connectionId: string) => {
        let endpoint = `${this.getUserRoute('me')}/channels/${channelId}/drafts`;
        if (rootId !== '') {
            endpoint += `/${rootId}`;
        }

        return this.doFetch<null>(
            endpoint,
            {
                method: 'delete',
                headers: {
                    'Connection-Id': `${connectionId}`,
                },
            },
        );
    };
}

export function parseAndMergeNestedHeaders(originalHeaders: any) {
    const headers = new Map();
    let nestedHeaders = new Map();
    originalHeaders.forEach((val: string, key: string) => {
        const capitalizedKey = key.replace(/\b[a-z]/g, (l) => l.toUpperCase());
        let realVal = val;
        if (val && val.match(/\n\S+:\s\S+/)) {
            const nestedHeaderStrings = val.split('\n');
            realVal = nestedHeaderStrings.shift() as string;
            const moreNestedHeaders = new Map(
                nestedHeaderStrings.map((h: any) => h.split(/:\s/)),
            );
            nestedHeaders = new Map([...nestedHeaders, ...moreNestedHeaders]);
        }
        headers.set(capitalizedKey, realVal);
    });
    return new Map([...headers, ...nestedHeaders]);
}

export class ClientError extends Error implements ServerError {
    url?: string;
    server_error_id?: string;
    status_code?: number;

    constructor(baseUrl: string, data: ServerError) {
        super(data.message + ': ' + cleanUrlForLogging(baseUrl, data.url || ''));

        this.message = data.message;
        this.url = data.url;
        this.server_error_id = data.server_error_id;
        this.status_code = data.status_code;

        // Ensure message is treated as a property of this class when object spreading. Without this,
        // copying the object by using `{...error}` would not include the message.
        Object.defineProperty(this, 'message', {enumerable: true});
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useState} from 'react';
import {Modal} from 'react-bootstrap';
import {defineMessages, useIntl} from 'react-intl';
import {useSelector} from 'react-redux';

import {GlobalState} from 'types/store';

import {suitePluginIds} from 'packages/client/src/client4';

import {t} from 'utils/i18n';
import * as Utils from 'utils/utils';

import KeyboardShortcutSequence, {
    KEYBOARD_SHORTCUTS,
    KeyboardShortcutDescriptor,
} from 'components/keyboard_shortcuts/keyboard_shortcuts_sequence';

import './keyboard_shortcuts_modal.scss';

const modalMessages = defineMessages({
    msgHeader: {
        id: t('shortcuts.msgs.header'),
        defaultMessage: 'Messages',
    },
    msgInputHeader: {
        id: t('shortcuts.msgs.input.header'),
        defaultMessage: 'Works inside an empty input field',
    },
    filesHeader: {
        id: t('shortcuts.files.header'),
        defaultMessage: 'Files',
    },
    browserHeader: {
        id: t('shortcuts.browser.header'),
        defaultMessage: 'Built-in Browser Commands',
    },
    msgCompHeader: {
        id: t('shortcuts.msgs.comp.header'),
        defaultMessage: 'Autocomplete',
    },
    browserInputHeader: {
        id: t('shortcuts.browser.input.header'),
        defaultMessage: 'Works inside an input field',
    },
    msgMarkdownHeader: {
        id: t('shortcuts.msgs.markdown.header'),
        defaultMessage: 'Formatting',
    },
    info: {
        id: t('shortcuts.info'),
        defaultMessage:
            'Begin a message with / for a list of all the available slash commands.',
    },
    navHeader: {
        id: t('shortcuts.nav.header'),
        defaultMessage: 'Navigation',
    },
    msgSearchHeader: {
        id: t('shortcuts.msgs.search.header'),
        defaultMessage: 'Searching',
    },
    callsHeader: {
        id: t('shortcuts.calls.header'),
        defaultMessage: 'Calls',
    },
    callsGlobalHeader: {
        id: t('shortcuts.calls.global.header'),
        defaultMessage: 'Global',
    },
    callsWidgetHeader: {
        id: t('shortcuts.calls.widget.header'),
        defaultMessage: 'Call widget',
    },
    callsExpandedHeader: {
        id: t('shortcuts.calls.expanded.header'),
        defaultMessage: 'Expanded view (pop-out window)',
    },
});

interface Props {
    onExited: () => void;
}

const KeyboardShortcutsModal = ({onExited}: Props): JSX.Element => {
    const [show, setShow] = useState(true);

    const {formatMessage} = useIntl();

    const handleHide = useCallback(() => setShow(false), []);

    const isLinux = Utils.isLinux();

    const isCallsEnabled = useSelector((state: GlobalState) => {
        return Boolean(state.plugins.plugins[suitePluginIds.calls]);
    });

    const renderShortcutSequences = (shortcuts: {[key: string]: KeyboardShortcutDescriptor}) => {
        return Object.entries(shortcuts).map(([key, shortcut]) => {
            return (
                <KeyboardShortcutSequence
                    key={key}
                    shortcut={shortcut}
                />
            );
        });
    };

    return (
        <Modal
            dialogClassName='a11y__modal shortcuts-modal'
            show={show}
            onHide={handleHide}
            onExited={onExited}
            role='dialog'
            aria-labelledby='shortcutsModalLabel'
        >
            <div className='shortcuts-content'>
                <Modal.Header closeButton={true}>
                    <Modal.Title
                        componentClass='h1'
                        id='shortcutsModalLabel'
                    >
                        <strong><KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.mainHeader}/></strong>
                    </Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    <div className='row'>
                        <div className='col-sm-4'>
                            <div className='section'>
                                <div>
                                    <h3 className='section-title'><strong>{formatMessage(modalMessages.navHeader)}</strong></h3>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.navPrev}/>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.navNext}/>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.navUnreadPrev}/>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.navUnreadNext}/>
                                    {!isLinux && <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.teamNavPrev}/>}
                                    {!isLinux && <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.teamNavNext}/>}
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.teamNavSwitcher}/>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.navSwitcher}/>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.navDMMenu}/>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.navSettings}/>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.navMentions}/>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.navFocusCenter}/>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.navOpenCloseSidebar}/>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.navExpandSidebar}/>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.navOpenChannelInfo}/>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.navToggleUnreads}/>
                                </div>
                            </div>
                        </div>
                        <div className='col-sm-4'>
                            <div className='section'>
                                <div>
                                    <h3 className='section-title'><strong>{formatMessage(modalMessages.msgHeader)}</strong></h3>
                                    <span><strong>{formatMessage(modalMessages.msgInputHeader)}</strong></span>
                                    <div className='subsection'>
                                        <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.msgEdit}/>
                                        <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.msgReply}/>
                                        <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.msgLastReaction}/>
                                        <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.msgReprintPrev}/>
                                        <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.msgReprintNext}/>
                                    </div>
                                    <span><strong>{formatMessage(modalMessages.msgCompHeader)}</strong></span>
                                    <div className='subsection'>
                                        <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.msgCompUsername}/>
                                        <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.msgCompChannel}/>
                                        <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.msgCompEmoji}/>
                                    </div>
                                    <span><strong>{formatMessage(modalMessages.msgMarkdownHeader)}</strong></span>
                                    <div className='subsection'>
                                        <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.msgMarkdownBold}/>
                                        <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.msgMarkdownItalic}/>
                                        <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.msgMarkdownLink}/>
                                    </div>
                                    <span><strong>{formatMessage(modalMessages.msgSearchHeader)}</strong></span>
                                    <div className='subsection'>
                                        <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.msgSearchChannel}/>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div className='col-sm-4'>
                            <div className='section'>
                                <div>
                                    <h3 className='section-title'><strong>{formatMessage(modalMessages.filesHeader)}</strong></h3>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.filesUpload}/>
                                </div>
                                <div className='section--lower'>
                                    <h3 className='section-title'><strong>{formatMessage(modalMessages.browserHeader)}</strong></h3>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.browserChannelPrev}/>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.browserChannelNext}/>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.browserFontIncrease}/>
                                    <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.browserFontDecrease}/>
                                    <span><strong>{formatMessage(modalMessages.browserInputHeader)}</strong></span>
                                    <div className='subsection'>
                                        <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.browserHighlightPrev}/>
                                        <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.browserHighlightNext}/>
                                        <KeyboardShortcutSequence shortcut={KEYBOARD_SHORTCUTS.browserNewline}/>
                                    </div>
                                </div>
                            </div>
                        </div>

                    </div>
                    { isCallsEnabled &&
                    <div className='row'>
                        <div className='col-sm-4'>
                            <div className='section'>
                                <div>
                                    <h3 className='section-title'><strong>{formatMessage(modalMessages.callsHeader)}</strong></h3>

                                    <span><strong>{formatMessage(modalMessages.callsGlobalHeader)}</strong></span>
                                    <div className='subsection'>
                                        {renderShortcutSequences(KEYBOARD_SHORTCUTS.calls.global)}
                                    </div>

                                    <span><strong>{formatMessage(modalMessages.callsWidgetHeader)}</strong></span>
                                    <div className='subsection'>
                                        {renderShortcutSequences(KEYBOARD_SHORTCUTS.calls.widget)}
                                    </div>

                                    <span><strong>{formatMessage(modalMessages.callsExpandedHeader)}</strong></span>
                                    <div className='subsection'>
                                        {renderShortcutSequences(KEYBOARD_SHORTCUTS.calls.popout)}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    }
                    <div className='info__label'>{formatMessage(modalMessages.info)}</div>
                </Modal.Body>
            </div>
        </Modal>
    );
};

export default KeyboardShortcutsModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {MessageDescriptor} from 'react-intl';

import {t} from 'utils/i18n';

export type KeyboardShortcutDescriptor =
	| MessageDescriptor
	| {default: MessageDescriptor; mac?: MessageDescriptor};

export function isMessageDescriptor(
    descriptor: KeyboardShortcutDescriptor,
): descriptor is MessageDescriptor {
    return Boolean((descriptor as MessageDescriptor).id);
}

const callsKBShortcuts = {
    global: {
        callsJoinCall: {
            default: {
                id: t('shortcuts.calls.join_call'),
                defaultMessage: 'Join call in current channel:\tCtrl|Shift|S',
            },
            mac: {
                id: t('shortcuts.calls.join_call.mac'),
                defaultMessage: 'Join call in current channel:\t|Shift|S',
            },
        },
    },
    widget: {
        callsMuteToggle: {
            default: {
                id: t('shortcuts.calls.mute_toggle'),
                defaultMessage: 'Mute or unmute:\tCtrl|Shift|Space',
            },
            mac: {
                id: t('shortcuts.calls.mute_toggle.mac'),
                defaultMessage: 'Mute or unmute:\t|Shift|Space',
            },
        },
        callsRaiseHandToggle: {
            default: {
                id: t('shortcuts.calls.raise_hand_toggle'),
                defaultMessage: 'Raise or lower hand:\tCtrl|Shift|Y',
            },
            mac: {
                id: t('shortcuts.calls.raise_hand_toggle.mac'),
                defaultMessage: 'Raise or lower hand:\t|Shift|Y',
            },
        },
        callsShareScreenToggle: {
            default: {
                id: t('shortcuts.calls.share_screen_toggle'),
                defaultMessage: 'Share or unshare the screen:\tCtrl|Shift|E',
            },
            mac: {
                id: t('shortcuts.calls.share_screen_toggle.mac'),
                defaultMessage: 'Share or unshare the screen:\t|Shift|E',
            },
        },
        callsParticipantsListToggle: {
            default: {
                id: t('shortcuts.calls.participants_list_toggle'),
                defaultMessage: 'Show or hide participants list:\tAlt|P\tCtrl|Shift|P',
            },
            mac: {
                id: t('shortcuts.calls.participants_list_toggle.mac'),
                defaultMessage: 'Show or hide participants list:\t|P\t|Shift|P',
            },
        },
        callsLeaveCall: {
            default: {
                id: t('shortcuts.calls.leave_call'),
                defaultMessage: 'Leave current call:\tCtrl|Shift|L',
            },
            mac: {
                id: t('shortcuts.calls.leave_call.mac'),
                defaultMessage: 'Leave current call:\t|Shift|L',
            },
        },
    },
    popout: {
        callsPushToTalk: {
            default: {
                id: t('shortcuts.calls.push_to_talk'),
                defaultMessage: 'Hold to unmute (push to talk):\tSpace',
            },
        },
    },
};

export const KEYBOARD_SHORTCUTS = {
    mainHeader: {
        default: {
            id: t('shortcuts.header'),
            defaultMessage: 'Keyboard shortcuts\tCtrl|/',
        },
        mac: {
            id: t('shortcuts.header.mac'),
            defaultMessage: 'Keyboard shortcuts\t|/',
        },
    },
    navPrev: {
        default: {
            id: t('shortcuts.nav.prev'),
            defaultMessage: 'Previous channel:\tAlt|Up',
        },
        mac: {
            id: t('shortcuts.nav.prev.mac'),
            defaultMessage: 'Previous channel:\t|Up',
        },
    },
    navNext: {
        default: {
            id: t('shortcuts.nav.next'),
            defaultMessage: 'Next channel:\tAlt|Down',
        },
        mac: {
            id: t('shortcuts.nav.next.mac'),
            defaultMessage: 'Next channel:\t|Down',
        },
    },
    navUnreadPrev: {
        default: {
            id: t('shortcuts.nav.unread_prev'),
            defaultMessage: 'Previous unread channel:\tAlt|Shift|Up',
        },
        mac: {
            id: t('shortcuts.nav.unread_prev.mac'),
            defaultMessage: 'Previous unread channel:\t|Shift|Up',
        },
    },
    navUnreadNext: {
        default: {
            id: t('shortcuts.nav.unread_next'),
            defaultMessage: 'Next unread channel:\tAlt|Shift|Down',
        },
        mac: {
            id: t('shortcuts.nav.unread_next.mac'),
            defaultMessage: 'Next unread channel:\t|Shift|Down',
        },
    },
    teamNavPrev: {
        default: {
            id: t('shortcuts.team_nav.prev'),
            defaultMessage: 'Previous team:\tCtrl|Alt|Up',
        },
        mac: {
            id: t('shortcuts.team_nav.prev.mac'),
            defaultMessage: 'Previous team:\t||Up',
        },
    },
    teamNavNext: {
        default: {
            id: t('shortcuts.team_nav.next'),
            defaultMessage: 'Next team:\tCtrl|Alt|Down',
        },
        mac: {
            id: t('shortcuts.team_nav.next.mac'),
            defaultMessage: 'Next team:\t||Down',
        },
    },
    teamNavSwitcher: {
        default: {
            id: t('shortcuts.team_nav.switcher'),
            defaultMessage: 'Navigate to a specific team:\tCtrl|Alt|[1-9]',
        },
        mac: {
            id: t('shortcuts.team_nav.switcher.mac'),
            defaultMessage: 'Navigate to a specific team:\t||[1-9]',
        },
    },
    teamNavigation: {
        default: {
            id: t('team.button.tooltip'),
            defaultMessage: 'Ctrl|Alt|{order}',
        },
        mac: {
            id: t('team.button.tooltip.mac'),
            defaultMessage: '||{order}',
        },
    },
    navSwitcher: {
        default: {
            id: t('shortcuts.nav.switcher'),
            defaultMessage: 'Quick channel navigation:\tCtrl|K',
        },
        mac: {
            id: t('shortcuts.nav.switcher.mac'),
            defaultMessage: 'Quick channel navigation:\t|K',
        },
    },
    navDMMenu: {
        default: {
            id: t('shortcuts.nav.direct_messages_menu'),
            defaultMessage: 'Direct messages menu:\tCtrl|Shift|K',
        },
        mac: {
            id: t('shortcuts.nav.direct_messages_menu.mac'),
            defaultMessage: 'Direct messages menu:\t|Shift|K',
        },
    },
    navSettings: {
        default: {
            id: t('shortcuts.nav.settings'),
            defaultMessage: 'Settings:\tCtrl|Shift|A',
        },
        mac: {
            id: t('shortcuts.nav.settings.mac'),
            defaultMessage: 'Settings:\t|Shift|A',
        },
    },
    navMentions: {
        default: {
            id: t('shortcuts.nav.recent_mentions'),
            defaultMessage: 'Recent mentions:\tCtrl|Shift|M',
        },
        mac: {
            id: t('shortcuts.nav.recent_mentions.mac'),
            defaultMessage: 'Recent mentions:\t|Shift|M',
        },
    },
    navFocusCenter: {
        default: {
            id: t('shortcuts.nav.focus_center'),
            defaultMessage: 'Set focus to input field:\tCtrl|Shift|L',
        },
        mac: {
            id: t('shortcuts.nav.focus_center.mac'),
            defaultMessage: 'Set focus to input field:\t|Shift|L',
        },
    },
    navOpenCloseSidebar: {
        default: {
            id: t('shortcuts.nav.open_close_sidebar'),
            defaultMessage: 'Open or close the right sidebar:\tCtrl|.',
        },
        mac: {
            id: t('shortcuts.nav.open_close_sidebar.mac'),
            defaultMessage: 'Open or close the right sidebar:\t|.',
        },
    },
    navExpandSidebar: {
        default: {
            id: t('shortcuts.nav.expand_sidebar'),
            defaultMessage: 'Expand the right sidebar:\tCtrl|Shift|.',
        },
        mac: {
            id: t('shortcuts.nav.expand_sidebar.mac'),
            defaultMessage: 'Expand the right sidebar:\t|Shift|.',
        },
    },
    navOpenChannelInfo: {
        default: {
            id: t('shortcuts.nav.open_channel_info'),
            defaultMessage: 'View channel info:\tCtrl|Alt|I',
        },
        mac: {
            id: t('shortcuts.nav.open_channel_info.mac'),
            defaultMessage: 'View channel info:\t|Shift|I',
        },
    },
    navToggleUnreads: {
        default: {
            id: t('shortcuts.nav.toggle_unreads'),
            defaultMessage: 'Toggle unread/all channels:\tCtrl|Shift|U',
        },
        mac: {
            id: t('shortcuts.nav.toggle_unreads.mac'),
            defaultMessage: 'Toggle unread/all channels:\t|Shift|U',
        },
    },
    msgEdit: {
        id: t('shortcuts.msgs.edit'),
        defaultMessage: 'Edit last message in channel:\tUp',
    },
    msgReply: {
        id: t('shortcuts.msgs.reply'),
        defaultMessage: 'Reply to last message in channel:\tShift|Up',
    },
    msgReprintPrev: {
        default: {
            id: t('shortcuts.msgs.reprint_prev'),
            defaultMessage: 'Reprint previous message:\tCtrl|Up',
        },
        mac: {
            id: t('shortcuts.msgs.reprint_prev.mac'),
            defaultMessage: 'Reprint previous message:\t|Up',
        },
    },
    msgReprintNext: {
        default: {
            id: t('shortcuts.msgs.reprint_next'),
            defaultMessage: 'Reprint next message:\tCtrl|Down',
        },
        mac: {
            id: t('shortcuts.msgs.reprint_next.mac'),
            defaultMessage: 'Reprint next message:\t|Down',
        },
    },
    msgCompUsername: {
        id: t('shortcuts.msgs.comp.username'),
        defaultMessage: 'Username:\t@|[a-z]|Tab',
    },
    msgCompChannel: {
        id: t('shortcuts.msgs.comp.channel'),
        defaultMessage: 'Channel:\t~|[a-z]|Tab',
    },
    msgCompEmoji: {
        id: t('shortcuts.msgs.comp.emoji'),
        defaultMessage: 'Emoji:\t:|[a-z]|Tab',
    },
    msgLastReaction: {
        default: {
            id: t('shortcuts.msgs.comp.last_reaction'),
            defaultMessage: 'React to last message:\tCtrl|Shift|\u29F5',
        },
        mac: {
            id: t('shortcuts.msgs.comp.last_reaction.mac'),
            defaultMessage: 'React to last message:\t|Shift|\u29F5',
        },
    },
    msgMarkdownBold: {
        default: {
            id: t('shortcuts.msgs.markdown.bold'),
            defaultMessage: 'Bold:\tCtrl|B',
        },
        mac: {
            id: t('shortcuts.msgs.markdown.bold.mac'),
            defaultMessage: 'Bold:\t|B',
        },
    },
    msgMarkdownCode: {
        default: {
            id: t('shortcuts.msgs.markdown.code'),
            defaultMessage: 'Code',
        },
        mac: {
            id: t('shortcuts.msgs.markdown.code.mac'),
            defaultMessage: 'Code',
        },
    },
    msgMarkdownStrike: {
        default: {
            id: t('shortcuts.msgs.markdown.strike'),
            defaultMessage: 'Strikethrough:\tCtrl|Shift|X',
        },
        mac: {
            id: t('shortcuts.msgs.markdown.strike.mac'),
            defaultMessage: 'Strikethrough:\t|Shift|X',
        },
    },
    msgMarkdownH3: {
        default: {
            id: t('shortcuts.msgs.markdown.h3'),
            defaultMessage: 'Heading',
        },
        mac: {
            id: t('shortcuts.msgs.markdown.h3.mac'),
            defaultMessage: 'Heading',
        },
    },
    msgMarkdownQuote: {
        default: {
            id: t('shortcuts.msgs.markdown.quote'),
            defaultMessage: 'Quote',
        },
        mac: {
            id: t('shortcuts.msgs.markdown.quote.mac'),
            defaultMessage: 'Quote',
        },
    },
    msgMarkdownOl: {
        default: {
            id: t('shortcuts.msgs.markdown.ordered'),
            defaultMessage: 'Numbered List',
        },
        mac: {
            id: t('shortcuts.msgs.markdown.ordered.mac'),
            defaultMessage: 'Numbered List',
        },
    },
    msgMarkdownUl: {
        default: {
            id: t('shortcuts.msgs.markdown.unordered'),
            defaultMessage: 'Bulleted List',
        },
        mac: {
            id: t('shortcuts.msgs.markdown.unordered.mac'),
            defaultMessage: 'Bulleted List',
        },
    },
    msgShowFormatting: {
        default: {
            id: t('shortcuts.msgs.markdown.formatting'),
            defaultMessage: 'Show/Hide Formatting:\tCtrl|Alt|T',
        },
        mac: {
            id: t('shortcuts.msgs.markdown.formatting.mac'),
            defaultMessage: 'Show/Hide Formatting:\t||T',
        },
    },
    msgShowEmojiPicker: {
        default: {
            id: t('shortcuts.msgs.markdown.emoji'),
            defaultMessage: 'Emoji / Gif picker:\tCtrl|Shift|E',
        },
        mac: {
            id: t('shortcuts.msgs.markdown.emoji.mac'),
            defaultMessage: 'Emoji / Gif picker:\t|Shift|E',
        },
    },
    msgMarkdownPreview: {
        default: {
            id: t('shortcuts.msgs.markdown.preview'),
            defaultMessage: 'Show/Hide Preview:\tCtrl|Alt|P',
        },
        mac: {
            id: t('shortcuts.msgs.markdown.preview.mac'),
            defaultMessage: 'Show/Hide Preview:\t|Shift|P',
        },
    },
    msgMarkdownItalic: {
        default: {
            id: t('shortcuts.msgs.markdown.italic'),
            defaultMessage: 'Italic:\tCtrl|I',
        },
        mac: {
            id: t('shortcuts.msgs.markdown.italic.mac'),
            defaultMessage: 'Italic:\t|I',
        },
    },
    msgMarkdownLink: {
        default: {
            id: t('shortcuts.msgs.markdown.link'),
            defaultMessage: 'Link:\tCtrl|Alt|K',
        },
        mac: {
            id: t('shortcuts.msgs.markdown.link.mac'),
            defaultMessage: 'Link:\t||K',
        },
    },
    filesUpload: {
        default: {
            id: t('shortcuts.files.upload'),
            defaultMessage: 'Upload files:\tCtrl|U',
        },
        mac: {
            id: t('shortcuts.files.upload.mac'),
            defaultMessage: 'Upload files:\t|U',
        },
    },
    browserChannelPrev: {
        default: {
            id: t('shortcuts.browser.channel_prev'),
            defaultMessage: 'Back in history:\tAlt|Left',
        },
        mac: {
            id: t('shortcuts.browser.channel_prev.mac'),
            defaultMessage: 'Back in history:\t|[',
        },
    },
    browserChannelNext: {
        default: {
            id: t('shortcuts.browser.channel_next'),
            defaultMessage: 'Forward in history:\tAlt|Right',
        },
        mac: {
            id: t('shortcuts.browser.channel_next.mac'),
            defaultMessage: 'Forward in history:\t|]',
        },
    },
    browserFontIncrease: {
        default: {
            id: t('shortcuts.browser.font_increase'),
            defaultMessage: 'Zoom in:\tCtrl|+',
        },
        mac: {
            id: t('shortcuts.browser.font_increase.mac'),
            defaultMessage: 'Zoom in:\t|+',
        },
    },
    browserFontDecrease: {
        default: {
            id: t('shortcuts.browser.font_decrease'),
            defaultMessage: 'Zoom out:\tCtrl|-',
        },
        mac: {
            id: t('shortcuts.browser.font_decrease.mac'),
            defaultMessage: 'Zoom out:\t|-',
        },
    },
    browserHighlightPrev: {
        id: t('shortcuts.browser.highlight_prev'),
        defaultMessage: 'Highlight text to the previous line:\tShift|Up',
    },
    browserHighlightNext: {
        id: t('shortcuts.browser.highlight_next'),
        defaultMessage: 'Highlight text to the next line:\tShift|Down',
    },
    browserNewline: {
        id: t('shortcuts.browser.newline'),
        defaultMessage: 'Create a new line:\tShift|Enter',
    },
    msgSearchChannel: {
        default: {
            id: t('shortcuts.msgs.search_channel'),
            defaultMessage: 'In channel:\tCtrl|F',
        },
        mac: {
            id: t('shortcuts.msgs.search_channel.mac'),
            defaultMessage: 'In channel:\t|F',
        },
    },
    msgPostPriority: {
        default: {
            id: t('shortcuts.msgs.formatting_bar.post_priority'),
            defaultMessage: 'Message priority',
        },
        mac: {
            id: t('shortcuts.msgs.formatting_bar.post_priority'),
            defaultMessage: 'Message priority',
        },
    },
    calls: callsKBShortcuts,
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {FormatXMLElementFn, PrimitiveType} from 'intl-messageformat';
import React, {memo} from 'react';
import {useIntl} from 'react-intl';

import {ShortcutKeyVariant, ShortcutKey} from 'components/shortcut_key';
import {isMac} from 'utils/utils';

import {isMessageDescriptor, KeyboardShortcutDescriptor} from './keyboard_shortcuts';

import './keyboard_shortcuts_sequence.scss';

type Props = {
    shortcut: KeyboardShortcutDescriptor;
    values?: Record<string, PrimitiveType | FormatXMLElementFn<string, string>>;
    hideDescription?: boolean;
    hoistDescription?: boolean;
    isInsideTooltip?: boolean;
};

function normalizeShortcutDescriptor(shortcut: KeyboardShortcutDescriptor) {
    if (isMessageDescriptor(shortcut)) {
        return shortcut;
    }
    const {default: standard, mac} = shortcut;
    return isMac() && mac ? mac : standard;
}

const KEY_SEPARATOR = '|';

function KeyboardShortcutSequence({shortcut, values, hideDescription, hoistDescription, isInsideTooltip}: Props) {
    const {formatMessage} = useIntl();
    const shortcutText = formatMessage(normalizeShortcutDescriptor(shortcut), values);
    const splitShortcut = shortcutText.split('\t');

    let description = '';
    let keys = '';
    let altKeys = '';

    if (splitShortcut.length > 1) {
        description = splitShortcut[0];
        keys = splitShortcut[1];
        altKeys = splitShortcut[2];
    } else if (splitShortcut[0].includes(KEY_SEPARATOR)) {
        keys = splitShortcut[0];
    } else {
        description = splitShortcut[0];
    }

    const renderAltKeys = () => {
        const shortcutKeys = altKeys.split(KEY_SEPARATOR).map((key) => (
            <ShortcutKey
                key={key}
                variant={isInsideTooltip ? ShortcutKeyVariant.Tooltip : ShortcutKeyVariant.ShortcutModal}
            >
                {key}
            </ShortcutKey>
        ));

        return (
            <React.Fragment>
                <span>{'\t|\t'}</span>
                {shortcutKeys}
            </React.Fragment>
        );
    };

    return (
        <>
            {hoistDescription && !hideDescription && description?.replace(/:{1,2}$/, '')}
            <div className='shortcut-line'>
                {!hoistDescription && !hideDescription && description && <span>{description}</span>}
                {keys && keys.split(KEY_SEPARATOR).map((key) => (
                    <ShortcutKey
                        key={key}
                        variant={isInsideTooltip ? ShortcutKeyVariant.Tooltip : ShortcutKeyVariant.ShortcutModal}
                    >
                        {key}
                    </ShortcutKey>
                ))}

                {altKeys && renderAltKeys()}
            </div>
        </>
    );
}

export default memo(KeyboardShortcutSequence);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import KeyboardShortcutSequence from './keyboard_shortcuts_sequence';

export * from './keyboard_shortcuts';
export default KeyboardShortcutSequence;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {FormattedMessage} from 'react-intl';

import TrialBenefitsModalStepMore from 'components/trial_benefits_modal/trial_benefits_modal_step_more';

import './learn_more_trial_modal_step.scss';

export type LearnMoreTrialModalStepProps = {
    id: string;
    title: string;
    description: string;
    svgWrapperClassName: string;
    svgElement: React.ReactNode;
    bottomLeftMessage?: string;
    pageURL?: string;
    buttonLabel?: string;
    handleOnClose?: () => void;
}

const LearnMoreTrialModalStep = (
    {
        id,
        title,
        description,
        svgWrapperClassName,
        svgElement,
        bottomLeftMessage,
        pageURL,
        buttonLabel,
        handleOnClose,
    }: LearnMoreTrialModalStepProps) => {
    return (
        <div
            id={`learnMoreTrialModalStep-${id}`}
            className='LearnMoreTrialModalStep slide-container'
        >
            <div className={`${svgWrapperClassName} svg-wrapper`}>
                {svgElement}
            </div>
            <div className='title'>
                {title}
            </div>
            <div className='description'>
                {description}
            </div>
            {(pageURL && buttonLabel) && (
                <TrialBenefitsModalStepMore
                    id={id}
                    route={pageURL}
                    message={buttonLabel}
                    onClick={handleOnClose}
                    styleLink={true}
                    telemetryId={'learn_more_trial_modal'}
                />
            )}
            <div className='disclaimer'>
                <span>
                    <FormattedMessage
                        id='start_trial.modal.disclaimer'
                        defaultMessage='By clicking Start trial, I agree to the <linkEvaluation>Mattermost Software Evaluation Agreement</linkEvaluation>, <linkPrivacy>privacy policy</linkPrivacy> and receiving product emails.'
                        values={{
                            linkEvaluation: (msg: React.ReactNode) => (
                                <a
                                    href='https://mattermost.com/software-evaluation-agreement'
                                    target='_blank'
                                    rel='noreferrer'
                                >
                                    {msg}
                                </a>
                            ),
                            linkPrivacy: (msg: React.ReactNode) => (
                                <a
                                    href='https://mattermost.com/privacy-policy/'
                                    target='_blank'
                                    rel='noreferrer'
                                >
                                    {msg}
                                </a>
                            ),
                        }}
                    />
                </span>
            </div>
            {bottomLeftMessage && (
                <div className='bottom-text-left-message'>
                    {bottomLeftMessage}
                </div>
            )}
        </div>
    );
};

export default LearnMoreTrialModalStep;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useEffect, useMemo, useState} from 'react';
import {useIntl} from 'react-intl';
import {useSelector, useDispatch} from 'react-redux';

import {trackEvent} from 'actions/telemetry_actions';

import {ConsolePages, ModalIdentifiers, TELEMETRY_CATEGORIES} from 'utils/constants';

import Carousel from 'components/common/carousel/carousel';
import GenericModal from 'components/generic_modal';
import GuestAccessSvg from 'components/common/svg_images_components/guest_access_svg';
import MonitorImacLikeSVG from 'components/common/svg_images_components/monitor_imaclike_svg';
import SystemRolesSVG from 'components/admin_console/feature_discovery/features/images/system_roles_svg';
import CloudStartTrialButton from 'components/cloud_start_trial/cloud_start_trial_btn';
import {BtnStyle} from 'components/common/carousel/carousel_button';

import {closeModal} from 'actions/views/modals';
import {DispatchFunc} from 'mattermost-redux/types/actions';
import {getLicense} from 'mattermost-redux/selectors/entities/general';

import StartTrialBtn from './start_trial_btn';

import LearnMoreTrialModalStep, {LearnMoreTrialModalStepProps} from './learn_more_trial_modal_step';

import './learn_more_trial_modal.scss';

type Props = {
    onClose?: () => void;
    onExited: () => void;
}

const LearnMoreTrialModal = (
    {
        onClose,
        onExited,
    }: Props): JSX.Element | null => {
    const {formatMessage} = useIntl();
    const [embargoed, setEmbargoed] = useState(false);
    const dispatch = useDispatch<DispatchFunc>();

    // Cloud conditions
    const license = useSelector(getLicense);
    const isCloud = license?.Cloud === 'true';

    const handleEmbargoError = useCallback(() => {
        setEmbargoed(true);
    }, []);

    let startTrialBtnMsg = formatMessage({id: 'start_trial.modal_btn.start_free_trial', defaultMessage: 'Start free 30-day trial'});

    // close this modal once start trial btn is clicked and trial has started successfully
    const dismissAction = useCallback(() => {
        dispatch(closeModal(ModalIdentifiers.LEARN_MORE_TRIAL_MODAL));
    }, []);

    let startTrialBtn = (
        <StartTrialBtn
            message={startTrialBtnMsg}
            handleEmbargoError={handleEmbargoError}
            telemetryId='start_trial_from_learn_more_about_trial_modal'
            onClick={dismissAction}
        />
    );

    // no need to check if is cloud trial or if it have had prev cloud trial because the button that show this modal takes care of that
    if (isCloud) {
        startTrialBtnMsg = formatMessage({id: 'trial_btn.free.tryFreeFor30Days', defaultMessage: 'Try free for 30 days'});
        startTrialBtn = (
            <CloudStartTrialButton
                message={startTrialBtnMsg}
                telemetryId={'start_cloud_trial_from_learn_more_about_trial_modal'}
                onClick={dismissAction}
                extraClass={'btn btn-primary start-cloud-trial-btn'}
            />
        );
    }

    const handleOnClose = useCallback(() => {
        if (onClose) {
            onClose();
        }

        onExited();
    }, [onClose, onExited]);

    useEffect(() => {
        trackEvent(
            TELEMETRY_CATEGORIES.SELF_HOSTED_START_TRIAL_MODAL,
            'learn_more_trial_modal_view',
        );
    }, []);

    const buttonLabel = formatMessage({id: 'learn_more_trial_modal_step.learnMoreAboutFeature', defaultMessage: 'Learn more about this feature.'});

    const steps: LearnMoreTrialModalStepProps[] = useMemo(() => [
        {
            id: 'useSso',
            title: formatMessage({id: 'learn_more_about_trial.modal.useSsoTitle', defaultMessage: 'Use SSO (with OpenID, SAML, Google, O365)'}),
            description: formatMessage({id: 'learn_more_about_trial.modal.useSsoDescription', defaultMessage: 'Sign on quickly and easily with our SSO feature that works with OpenID, SAML, Google, and O365.'}),
            svgWrapperClassName: 'guestAccessSvg',
            svgElement: (
                <GuestAccessSvg
                    width={400}
                    height={180}
                />
            ),
            pageURL: 'https://docs.mattermost.com/onboard/sso-saml.html',
            buttonLabel,
        },
        {
            id: 'ldap',
            title: formatMessage({id: 'learn_more_about_trial.modal.ldapTitle', defaultMessage: 'Synchronize your Active Directory/LDAP groups'}),
            description: formatMessage({id: 'learn_more_about_trial.modal.ldapDescription', defaultMessage: 'Use AD/LDAP groups to organize and apply actions to multiple users at once. Manage team and channel memberships, permissions and more.'}),
            svgWrapperClassName: 'personMacSvg',
            svgElement: (
                <MonitorImacLikeSVG
                    width={400}
                    height={180}
                />
            ),
            pageURL: 'https://docs.mattermost.com/onboard/ad-ldap.html',
            buttonLabel,
        },
        {
            id: 'systemConsole',
            title: formatMessage({id: 'learn_more_about_trial.modal.systemConsoleTitle', defaultMessage: 'Provide controlled access to the System Console'}),
            description: formatMessage({id: 'learn_more_about_trial.modal.systemConsoleDescription', defaultMessage: 'Use System Roles to give designated users read and/or write access to select sections of System Console.'}),
            svgWrapperClassName: 'personBoxSvg',
            svgElement: (
                <SystemRolesSVG
                    width={400}
                    height={180}
                />
            ),
            pageURL: ConsolePages.LICENSE,
            buttonLabel,
        },
    ], []);

    const handleOnPrevNextSlideClick = useCallback((slideIndex: number) => {
        const slideId = steps[slideIndex - 1]?.id;

        if (slideId) {
            trackEvent(
                TELEMETRY_CATEGORIES.SELF_HOSTED_START_TRIAL_MODAL,
                'learn_more_trial_modal_slide_shown_' + slideId,
            );
        }
    }, [steps]);

    const getSlides = useMemo(
        () =>
            steps.map(({id, ...rest}) => (
                <LearnMoreTrialModalStep
                    {...rest}
                    id={id}
                    key={id}
                />
            )),
        [],
    );

    const headerText = formatMessage({id: 'learn_more_trial_modal.pretitle', defaultMessage: 'With Enterprise, you can...'});

    return (
        <GenericModal
            className='LearnMoreTrialModal'
            id='learnMoreTrialModal'
            onExited={handleOnClose}
            modalHeaderText={headerText}
        >
            <Carousel
                dataSlides={getSlides}
                id={'learnMoreTrialModalCarousel'}
                infiniteSlide={false}
                onNextSlideClick={handleOnPrevNextSlideClick}
                onPrevSlideClick={handleOnPrevNextSlideClick}
                disableNextButton={embargoed}
                btnsStyle={BtnStyle.CHEVRON}
                actionButton={startTrialBtn}
            />
        </GenericModal>
    );
};

export default LearnMoreTrialModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState} from 'react';

import {useIntl} from 'react-intl';

import {useDispatch, useSelector} from 'react-redux';

import {EmbargoedEntityTrialError} from 'components/admin_console/license_settings/trial_banner/trial_banner';

import {DispatchFunc} from 'mattermost-redux/types/actions';
import {getLicenseConfig} from 'mattermost-redux/actions/general';

import {GlobalState} from 'types/store';

import {requestTrialLicense} from 'actions/admin_actions';
import {trackEvent} from 'actions/telemetry_actions';

import {openModal} from 'actions/views/modals';

import TrialBenefitsModal from 'components/trial_benefits_modal/trial_benefits_modal';

import {ModalIdentifiers, TELEMETRY_CATEGORIES} from 'utils/constants';

import './start_trial_btn.scss';

export type StartTrialBtnProps = {
    message: string;
    telemetryId: string;
    onClick?: () => void;
    handleEmbargoError?: () => void;
    btnClass?: string;
    renderAsButton?: boolean;
    disabled?: boolean;
    trackingPage?: string;
};

enum TrialLoadStatus {
    NotStarted = 'NOT_STARTED',
    Started = 'STARTED',
    Success = 'SUCCESS',
    Failed = 'FAILED',
    Embargoed = 'EMBARGOED',
}

const StartTrialBtn = ({
    message,
    btnClass,
    telemetryId,
    onClick,
    handleEmbargoError,
    disabled = false,
    renderAsButton = false,
    trackingPage = 'licensing',
}: StartTrialBtnProps) => {
    const {formatMessage} = useIntl();
    const dispatch = useDispatch<DispatchFunc>();
    const stats = useSelector((state: GlobalState) => state.entities.admin.analytics);

    const [status, setLoadStatus] = useState(TrialLoadStatus.NotStarted);

    const requestLicense = async (): Promise<TrialLoadStatus> => {
        setLoadStatus(TrialLoadStatus.Started);
        let users = 0;
        if (stats && (typeof stats.TOTAL_USERS === 'number')) {
            users = stats.TOTAL_USERS;
        }
        const requestedUsers = Math.max(users, 30);
        const {error, data} = await dispatch(requestTrialLicense(requestedUsers, true, true, trackingPage));
        if (error) {
            if (typeof data?.status !== 'undefined' && data.status === 451) {
                setLoadStatus(TrialLoadStatus.Embargoed);
                if (typeof handleEmbargoError === 'function') {
                    handleEmbargoError();
                }
                return TrialLoadStatus.Embargoed;
            }
            setLoadStatus(TrialLoadStatus.Failed);
            return TrialLoadStatus.Failed;
        }

        await dispatch(getLicenseConfig());
        setLoadStatus(TrialLoadStatus.Success);
        return TrialLoadStatus.Success;
    };

    const openTrialBenefitsModal = async (status: TrialLoadStatus) => {
        // Only open the benefits modal if the trial request succeeded
        if (status !== TrialLoadStatus.Success) {
            return;
        }
        await dispatch(openModal({
            modalId: ModalIdentifiers.TRIAL_BENEFITS_MODAL,
            dialogType: TrialBenefitsModal,
            dialogProps: {trialJustStarted: true},
        }));
    };

    const btnText = (status: TrialLoadStatus): string => {
        switch (status) {
        case TrialLoadStatus.Started:
            return formatMessage({id: 'start_trial.modal.gettingTrial', defaultMessage: 'Getting Trial...'});
        case TrialLoadStatus.Success:
            return formatMessage({id: 'start_trial.modal.loaded', defaultMessage: 'Loaded!'});
        case TrialLoadStatus.Failed:
            return formatMessage({id: 'start_trial.modal.failed', defaultMessage: 'Failed'});
        case TrialLoadStatus.Embargoed:
            return formatMessage({id: 'admin.license.trial-request.embargoed'});
        default:
            return message;
        }
    };
    const startTrial = async () => {
        // reading status from here instead of normal flow because
        // by the time the function needs the updated value from requestLicense,
        // it will be too late to wait for the render cycle to happen again
        // to close over the updated value
        const updatedStatus = await requestLicense();
        if (onClick && updatedStatus === TrialLoadStatus.Success) {
            onClick();
        } else {
            await openTrialBenefitsModal(updatedStatus);
        }
        trackEvent(
            TELEMETRY_CATEGORIES.SELF_HOSTED_START_TRIAL_MODAL,
            telemetryId,
        );
    };

    if (status === TrialLoadStatus.Embargoed) {
        return (
            <div className='StartTrialBtn embargoed'>
                <EmbargoedEntityTrialError/>
            </div>
        );
    }

    const id = 'start_trial_btn';

    return renderAsButton ? (
        <button
            id={id}
            className={btnClass}
            onClick={startTrial}
            disabled={disabled}
        >
            {btnText(status)}
        </button>
    ) : (
        <a
            id={id}
            className='StartTrialBtn start-trial-btn'
            onClick={startTrial}
        >
            {btnText(status)}
        </a>
    );
};

export default StartTrialBtn;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState} from 'react';
import {FormattedMessage} from 'react-intl';

import {Channel} from '@mattermost/types/channels';
import {LeastActiveChannel} from '@mattermost/types/insights';

import Constants from 'utils/constants';

import ConfirmModal from 'components/confirm_modal';

type Props = {
    channel: Channel | LeastActiveChannel;
    onExited: () => void;
    callback?: () => any;
    actions: {
        leaveChannel: (channelId: string) => any;
    };
}

const LeaveChannelModal = ({actions, channel, callback, onExited}: Props) => {
    const [show, setShow] = useState(true);

    const handleSubmit = () => {
        if (channel) {
            const channelId = channel.id;
            actions.leaveChannel(channelId).then((result: {data: boolean}) => {
                if (result.data) {
                    callback?.();
                    handleHide();
                }
            });
        }
    };

    const handleHide = () => setShow(false);

    let title;
    let message;
    if (channel && channel.display_name) {
        if (channel.type === Constants.PRIVATE_CHANNEL) {
            title = (
                <FormattedMessage
                    id='leave_private_channel_modal.title'
                    defaultMessage='Leave Private Channel {channel}'
                    values={{
                        channel: <b>{channel.display_name}</b>,
                    }}
                />
            );
        } else {
            title = (
                <FormattedMessage
                    id='leave_public_channel_modal.title'
                    defaultMessage='Leave Channel {channel}'
                    values={{
                        channel: <b>{channel.display_name}</b>,
                    }}
                />
            );
        }

        if (channel.type === Constants.PRIVATE_CHANNEL) {
            message = (
                <FormattedMessage
                    id='leave_private_channel_modal.message'
                    defaultMessage='Are you sure you wish to leave the private channel {channel}? You must be re-invited in order to re-join this channel in the future.'
                    values={{
                        channel: <b>{channel.display_name}</b>,
                    }}
                />
            );
        } else {
            message = (
                <FormattedMessage
                    id='leave_public_channel_modal.message'
                    defaultMessage='Are you sure you wish to leave the channel {channel}? You can re-join this channel in the future if you change your mind.'
                    values={{
                        channel: <b>{channel.display_name}</b>,
                    }}
                />
            );
        }
    }

    const buttonClass = 'btn btn-danger';
    const button = (
        <FormattedMessage
            id='leave_private_channel_modal.leave'
            defaultMessage='Yes, leave channel'
        />
    );

    return (
        <ConfirmModal
            show={show}
            title={title}
            message={message}
            confirmButtonClass={buttonClass}
            confirmButtonText={button}
            onConfirm={handleSubmit}
            onCancel={handleHide}
            onExited={onExited}
        />
    );
};

export default LeaveChannelModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {GenericAction} from 'mattermost-redux/types/actions';

import {leaveChannel} from 'actions/views/channel';

import LeaveChannelModal from './leave_channel_modal';

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            leaveChannel,
        }, dispatch),
    };
}

export default connect(null, mapDispatchToProps)(LeaveChannelModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

import LoadingScreen from 'components/loading_screen';
import {Group} from '@mattermost/types/groups';

export const DEFAULT_NUM_PER_PAGE = 50;

type Props = {

    /**
     * titleText (optional) a string to show at the top bar of the modal.
     */
    titleText?: string;

    /**
     * searchPlaceholderText (optional) a string to show as a placeholder in the search input.
     */
    searchPlaceholderText?: string;

    /**
     * titleBarButtonText (optional) a string representing a title bar button text.
     */
    titleBarButtonText?: string;

    /**
     * numPerPage (optional) a number setting how many items per page should be displayed. Defaults to
     * DEFAULT_NUM_PER_PAGE.
     */
    numPerPage?: number;

    /**
     * show (optional) a boolean setting to hide the modal via props rather then unmounting it.
     */
    show?: boolean;

    /**
     * titleBarButtonOnClick (optional) a func to handle title button bar clicks.
     */
    titleBarButtonOnClick?: () => void;

    /**
     * loadItems is a function that receives the params (pageNumber, searchTerm) and should return an object
     * with the shape {items: [], totalCount: 0}.
     * items: an array of objects that are passed to each renderRow function.
     * totalCount: an integer representing the total number of items as displayed in the pagination text.
     *
     * Example:
     *     const loadItems = async (pageNumber, searchTerm) => {
     *         const {data} = await loadFromServer(searchTerm, pageNumber, PER_PAGE);
     *         return {
     *             items: data.users,
     *             totalCount: data.total,
     *         };
     *     };
     */
    loadItems: (page: number, searchTerm: string) => Promise<{
        items: Group[];
        totalCount: number;
    }>;

    /**
     * onHide (optional) a function to be invoked when the modal is closed.
     */
    onHide?: () => void;

    /**
     * renderRow is a function that receives the params (item, listModal) and should return JSX.
     * item: an object as returned by each entry in the loadItems function's 'items' array.
     * listModal: the instance of the ListModal component class.
     *
     * Example:
     *     const renderRow = (item, listModal) => <div>{item.id}</div>;
     */
    renderRow: (item: Group, listModal: ListModal) => JSX.Element;
}

type State = {
    show: boolean;
    page: number;
    items: Group[];
    totalCount: number;
    loading: boolean;
    searchTerm: string;
}

export default class ListModal extends React.PureComponent<Props, State> {
    static defaultProps = {
        show: true,
    };
    numPerPage: number;

    constructor(props: Props) {
        super(props);

        this.numPerPage = props.numPerPage || DEFAULT_NUM_PER_PAGE;

        this.state = {
            show: true,
            page: 0,
            items: [],
            totalCount: 0,
            loading: true,
            searchTerm: '',
        };
    }

    async componentDidMount() {
        const {totalCount, items} = await this.props.loadItems(0, '');
        this.setState({totalCount, items, loading: false}); // eslint-disable-line react/no-did-mount-set-state
    }

    handleHide = () => {
        this.setState({show: false});
    }

    handleExit = () => {
        if (this.props.onHide) {
            this.props.onHide();
        }
    }

    renderRows() {
        if (this.state.loading) {
            return (
                <div>
                    <LoadingScreen
                        position='absolute'
                        key='loading'
                    />
                </div>
            );
        }
        return this.state.items.map((item) => (
            this.props.renderRow(item, this)
        ));
    }

    onNext = () => {
        const nextPage = this.state.page + 1;
        this.onPageChange(nextPage);
    }

    onPrev = () => {
        const prevPage = this.state.page - 1;
        this.onPageChange(prevPage);
    }

    onPageChange = async (page: number) => {
        this.setState({loading: true});
        const result = await this.props.loadItems(page, this.state.searchTerm);
        this.setState({page, items: result.items, loading: false});
    }

    onSearchInput = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const {target} = event;
        const searchTerm = target.value;
        this.setState({loading: true, searchTerm});
        const result = await this.props.loadItems(0, searchTerm);
        const {items, totalCount} = result;
        this.setState({loading: false, items, totalCount});
    }

    paginationRange() {
        let startCount = (this.state.page * this.numPerPage) + 1;
        const endCount = (startCount + this.state.items.length) - 1;
        if (endCount === 0) {
            startCount = 0;
        }
        return {startCount, endCount};
    }

    render() {
        if (!this.props.show) {
            return null;
        }
        const {endCount, startCount} = this.paginationRange();
        return (
            <div>
                <Modal
                    dialogClassName='a11y__modal more-modal more-modal--action'
                    show={this.state.show}
                    onHide={this.handleHide}
                    onExited={this.handleExit}
                >
                    <Modal.Header closeButton={true}>
                        <Modal.Title componentClass='h1'>
                            <span className='name'>{this.props.titleText}</span>
                        </Modal.Title>
                        {this.props.titleBarButtonText && this.props.titleBarButtonOnClick &&
                            <a
                                className='btn btn-md btn-primary'
                                href='#'
                                onClick={this.props.titleBarButtonOnClick}
                            >
                                {this.props.titleBarButtonText}
                            </a>}
                    </Modal.Header>
                    <Modal.Body>
                        <div className='filtered-user-list'>
                            <div className='filter-row'>
                                <div className='col-xs-12'>
                                    <label
                                        className='hidden-label'
                                        htmlFor='searchUsersInput'
                                    >
                                        {this.props.searchPlaceholderText}
                                    </label>
                                    <input
                                        id='searchUsersInput'
                                        className='form-control filter-textbox'
                                        placeholder={this.props.searchPlaceholderText}
                                        onChange={this.onSearchInput}
                                    />
                                </div>
                                <div className='col-sm-12'>
                                    <span className='member-count pull-left'>
                                        <FormattedMessage
                                            id='list_modal.paginatorCount'
                                            defaultMessage='{startCount, number} - {endCount, number} of {total, number} total'
                                            values={{
                                                startCount,
                                                endCount,
                                                total: this.state.totalCount,
                                            }}
                                        />
                                    </span>
                                </div>
                            </div>
                            <div className='more-modal__list'>
                                <div>
                                    {this.renderRows()}
                                </div>
                            </div>
                            <div className='filter-controls'>
                                {this.state.page > 0 &&
                                <button
                                    onClick={this.onPrev}
                                    className='btn btn-link filter-control filter-control__prev'
                                >
                                    <FormattedMessage
                                        id='filtered_user_list.prev'
                                        defaultMessage='Previous'
                                    />
                                </button>}
                                {this.props.numPerPage && (this.state.items.length >= this.props.numPerPage) && endCount !== this.state.totalCount &&
                                <button
                                    onClick={this.onNext}
                                    className='btn btn-link filter-control filter-control__next'
                                >
                                    <FormattedMessage
                                        id='filtered_user_list.next'
                                        defaultMessage='Next'
                                    />
                                </button>}
                            </div>
                        </div>
                    </Modal.Body>
                </Modal>
            </div >
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import LoadingSpinner from 'components/widgets/loading/loading_spinner';

type Props = {
    loading?: string;
    progress?: number;
    containerClass?: string;
}

const LoadingImagePreview: React.FC<Props> = ({loading, progress, containerClass}: Props) => {
    let progressView: JSX.Element = (
        <span className='loader-percent'/>
    );

    if (progress) {
        progressView = (
            <span className='loader-percent'>
                {`${loading} ${progress}%`}
            </span>
        );
    }

    return (
        <div className={containerClass}>
            <LoadingSpinner/>
            {progressView}
        </div>
    );
};

LoadingImagePreview.defaultProps = {
    containerClass: 'view-image__loading',
};

export default LoadingImagePreview;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode, CSSProperties} from 'react';
import {useIntl} from 'react-intl';
import classNames from 'classnames';

type Props = {
    position?: 'absolute' | 'fixed' | 'relative' | 'static' | 'inherit';
    style?: CSSProperties;
    message?: ReactNode;
    className?: string;
    centered?: boolean;
}

function LoadingScreen({message, position = 'relative', style, className = '', centered = false}: Props) {
    const {formatMessage} = useIntl();

    return (
        <div
            className={classNames('loading-screen', className, {
                'loading-screen--in-middle': centered,
            })}
            style={{position, ...style}}
        >
            <div className='loading__content'>
                <p>
                    {message || formatMessage({id: 'loading_screen.loading', defaultMessage: 'Loading'})}
                </p>
                <div className='round round-1'/>
                <div className='round round-2'/>
                <div className='round round-3'/>
            </div>
        </div>
    );
}

export default LoadingScreen;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {HTMLAttributes} from 'react';
import {useIntl, MessageDescriptor} from 'react-intl';
import {PrimitiveType, FormatXMLElementFn} from 'intl-messageformat';

type Props = Omit<HTMLAttributes<HTMLSpanElement | HTMLElement>, 'title' | 'component'> & {
    component?: 'i' | 'span';
    ariaLabel?: MessageDescriptor & {
        values?: Record<string, PrimitiveType | FormatXMLElementFn<string, string>>;
    };
    title?: MessageDescriptor & {
        values?: Record<string, PrimitiveType | FormatXMLElementFn<string, string>>;
    };
}

const LocalizedIcon = React.forwardRef((props: Props, ref?: React.Ref<HTMLSpanElement | HTMLElement>) => {
    const {
        component = 'i',
        ariaLabel,
        title,
        ...otherProps
    } = props;

    const {formatMessage} = useIntl();

    if (component !== 'i' && component !== 'span') {
        return null;
    }

    // Use an uppercase name since JSX thinks anything lowercase is an HTML tag
    const Component = component;

    const iconProps: HTMLAttributes<HTMLElement> = {
        ...otherProps,
    };
    if (ariaLabel) {
        iconProps['aria-label'] = formatMessage({id: ariaLabel.id, defaultMessage: ariaLabel.defaultMessage}, ariaLabel.values);
    }
    if (title) {
        iconProps.title = formatMessage({id: title.id, defaultMessage: title.defaultMessage}, title.values);
    }

    return (
        <Component
            ref={ref}
            {...iconProps}
        />
    );
});
LocalizedIcon.displayName = 'LocalizedIcon';

export default LocalizedIcon;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {InputHTMLAttributes} from 'react';
import {useIntl, MessageDescriptor} from 'react-intl';
import {PrimitiveType, FormatXMLElementFn} from 'intl-messageformat';

export type Props = Omit<InputHTMLAttributes<HTMLInputElement>, 'placeholder'> & {
    placeholder: MessageDescriptor & {
        values?: Record<string, PrimitiveType | FormatXMLElementFn<string, string>>;
    };
};

const LocalizedInput = React.forwardRef((props: Props, ref?: React.Ref<HTMLInputElement>) => {
    const {
        placeholder: {
            id,
            defaultMessage,
            values,
        },
        ...otherProps
    } = props;

    const {formatMessage} = useIntl();

    return (
        <input
            {...otherProps}
            ref={ref}
            placeholder={formatMessage({id, defaultMessage}, values)}
        />
    );
});
LocalizedInput.displayName = 'LocalizedInput';

export default LocalizedInput;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {CSSProperties} from 'react';
import {useIntl} from 'react-intl';

export default function LeaveTeamIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='100%'
                height='100%'
                viewBox='0 0 164 164'
                style={style}
                role='img'
                aria-label={formatMessage({id: 'navbar_dropdown.leave.icon', defaultMessage: 'Leave Team Icon'})}
            >
                <path d='M26.023,164L26.023,7.035L26.022,0.32L137.658,0.32L137.658,164L124.228,164L124.228, 13.749L39.452,13.749L39.452,164L26.023, 164ZM118.876,164L118.876,18.619L58.137,32.918L58.137,149.701L118.876,164Z'/>
            </svg>
        </span>
    );
}

const style: CSSProperties = {
    fillRule: 'evenodd',
    clipRule: 'evenodd',
    strokeLinejoin: 'round',
    strokeMiterlimit: 1.41421,
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

import {ActionFunc} from 'mattermost-redux/types/actions';
import {UserProfile} from '@mattermost/types/users';

import * as UserUtils from 'mattermost-redux/utils/user_utils';
import FormattedMarkdownMessage from 'components/formatted_markdown_message';

import Constants from 'utils/constants';

import {isKeyPressed} from 'utils/utils';

type Props = {
    currentUser: UserProfile;
    currentUserId: string;
    currentTeamId: string;
    numOfPublicChannels: number;
    numOfPrivateChannels: number;
    onExited: () => void;
    actions: {
        leaveTeam: (teamId: string, userId: string) => ActionFunc;
        toggleSideBarRightMenu: () => void;
    };
};

type State = {
    show: boolean;
};

export default class LeaveTeamModal extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            show: true,
        };
    }

    componentDidMount() {
        document.addEventListener('keypress', this.handleKeyPress);
    }

    componentWillUnmount() {
        document.removeEventListener('keypress', this.handleKeyPress);
    }

    handleHide = () => {
        this.setState({
            show: false,
        });
    }

    handleKeyPress = (e: KeyboardEvent) => {
        if (isKeyPressed(e, Constants.KeyCodes.ENTER)) {
            this.handleSubmit();
        }
    };

    handleSubmit = () => {
        this.handleHide();

        this.props.actions.leaveTeam(
            this.props.currentTeamId,
            this.props.currentUserId,
        );
        this.props.actions.toggleSideBarRightMenu();
    };

    render() {
        const {
            currentUser,
            numOfPrivateChannels,
            numOfPublicChannels,
        } = this.props;

        const isGuest = UserUtils.isGuest(currentUser.roles);

        let modalMessage;
        if (isGuest) {
            if (numOfPublicChannels !== 0 && numOfPrivateChannels !== 0) {
                modalMessage = (
                    <FormattedMarkdownMessage
                        id='leave_team_modal_guest.desc'
                        defaultMessage="** You will be removed from {num_of_public_channels} public { num_of_public_channels,plural,one {channel} other {channels}} and {num_of_private_channels} private { num_of_private_channels,plural,one {channel} other {channels}} on this team.** You won't be able to rejoin it without an invitation from another team member. Are you sure?"
                        values={{
                            num_of_public_channels: numOfPublicChannels,
                            num_of_private_channels: numOfPrivateChannels,
                        }}
                    />
                );
            } else if (numOfPublicChannels === 0) {
                modalMessage = (
                    <FormattedMarkdownMessage
                        id='leave_team_modal_guest_only_private.desc'
                        defaultMessage="** You will be removed from {num_of_private_channels} private { num_of_private_channels,plural,one {channel} other {channels}} on this team.** You won't be able to rejoin it without an invitation from another team member. Are you sure?"
                        values={{
                            num_of_public_channels: numOfPublicChannels,
                            num_of_private_channels: numOfPrivateChannels,
                        }}
                    />
                );
            } else {
                modalMessage = (
                    <FormattedMarkdownMessage
                        id='leave_team_modal_guest_only_public.desc'
                        defaultMessage="** You will be removed from {num_of_public_channels} public { num_of_public_channels,plural,one {channel} other {channels}} on this team.** You won't be able to rejoin it without an invitation from another team member. Are you sure?"
                        values={{
                            num_of_public_channels: numOfPublicChannels,
                            num_of_private_channels: numOfPrivateChannels,
                        }}
                    />);
            }
        } else if (numOfPublicChannels !== 0 && numOfPrivateChannels !== 0) {
            modalMessage = (
                <FormattedMarkdownMessage
                    id='leave_team_modal.desc'
                    defaultMessage="**You will be removed from {num_of_public_channels} public { num_of_public_channels,plural,one {channel} other {channels} } and {num_of_private_channels} private {num_of_private_channels,one {channel} other {channels}} on this team.** If the team is private you won't be able to rejoin it without an invitation from another team member. Are you sure?"

                    values={{
                        num_of_public_channels: numOfPublicChannels,
                        num_of_private_channels: numOfPrivateChannels,
                    }}
                />);
        } else if (numOfPublicChannels === 0) {
            modalMessage = (
                <FormattedMarkdownMessage
                    id='leave_team_modal_private.desc'
                    defaultMessage="**You will be removed from {num_of_private_channels} private {num_of_private_channels,one {channel} other {channels}} on this team.** If the team is private you won't be able to rejoin it without an invitation from another team member. Are you sure?"
                    values={{
                        num_of_public_channels: numOfPublicChannels,
                        num_of_private_channels: numOfPrivateChannels,
                    }}
                />);
        } else {
            modalMessage = (
                <FormattedMarkdownMessage
                    id='leave_team_modal_public.desc'
                    defaultMessage='**You will be removed from {num_of_public_channels} public { num_of_public_channels,plural,one {channel} other {channels} } on this team.** Are you sure?'
                    values={{
                        num_of_public_channels: numOfPublicChannels,
                        num_of_private_channels: numOfPrivateChannels,
                    }}
                />
            );
        }

        return (
            <Modal
                dialogClassName='a11y__modal'
                className='modal-confirm'
                show={this.state.show}
                onExited={this.props.onExited}
                onHide={this.handleHide}
                id='leaveTeamModal'
                role='dialog'
                aria-labelledby='leaveTeamModalLabel'
            >
                <Modal.Header closeButton={false}>
                    <Modal.Title
                        componentClass='h1'
                        id='leaveTeamModalLabel'
                    >
                        <FormattedMessage
                            id='leave_team_modal.title'
                            defaultMessage='Leave the team?'
                        />
                    </Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    {modalMessage}
                </Modal.Body>
                <Modal.Footer>
                    <button
                        type='button'
                        className='btn btn-link'
                        onClick={this.handleHide}
                        id='leaveTeamNo'
                    >
                        <FormattedMessage
                            id='leave_team_modal.no'
                            defaultMessage='No'
                        />
                    </button>
                    <button
                        type='button'
                        className='btn btn-danger'
                        onClick={this.handleSubmit}
                        id='leaveTeamYes'
                    >
                        <FormattedMessage
                            id='leave_team_modal.yes'
                            defaultMessage='Yes'
                        />
                    </button>
                </Modal.Footer>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {removeUserFromTeam as leaveTeam} from 'mattermost-redux/actions/teams';

import {getMyChannels} from 'mattermost-redux/selectors/entities/channels';
import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentUserId, getCurrentUser} from 'mattermost-redux/selectors/entities/users';

import {GenericAction} from 'mattermost-redux/types/actions';

import {toggleSideBarRightMenuAction} from 'actions/global_actions';

import {GlobalState} from 'types/store';

import {Constants} from 'utils/constants';

import LeaveTeamModal from './leave_team_modal';

function getNumOfPrivateChannels(state: GlobalState) {
    const channels = getMyChannels(state);

    return channels.filter((channel) => channel.type === Constants.PRIVATE_CHANNEL).length;
}

function getNumOfPublicChannels(state: GlobalState) {
    const channels = getMyChannels(state);

    return channels.filter((channel) => channel.type === Constants.OPEN_CHANNEL).length;
}

function mapStateToProps(state: GlobalState) {
    const currentUserId = getCurrentUserId(state);
    const currentTeamId = getCurrentTeamId(state);
    const currentUser = getCurrentUser(state);

    return {
        currentUserId,
        currentTeamId,
        currentUser,
        numOfPrivateChannels: getNumOfPrivateChannels(state),
        numOfPublicChannels: getNumOfPublicChannels(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            leaveTeam,
            toggleSideBarRightMenu: toggleSideBarRightMenuAction,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(LeaveTeamModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {Team, TeamMembership} from '@mattermost/types/teams';
import {UserProfile} from '@mattermost/types/users';
import {ActionFunc} from 'mattermost-redux/types/actions';
import type {isCollapsedThreadsEnabled} from 'mattermost-redux/selectors/entities/preferences';

import {getHistory} from 'utils/browser_history';
import * as Utils from 'utils/utils';
import {isGuest, isAdmin, isSystemAdmin} from 'mattermost-redux/utils/user_utils';
import ConfirmModal from 'components/confirm_modal';
import DropdownIcon from 'components/widgets/icons/fa_dropdown_icon';

import Menu from 'components/widgets/menu/menu';
import MenuWrapper from 'components/widgets/menu/menu_wrapper';

const ROWS_FROM_BOTTOM_TO_OPEN_UP = 3;

type Props = {
    user: UserProfile;
    currentUser: UserProfile;
    teamMember: TeamMembership;
    teamUrl: string;
    currentTeam: Team;
    index: number;
    totalUsers: number;
    collapsedThreads: ReturnType<typeof isCollapsedThreadsEnabled>;
    actions: {
        getMyTeamMembers: () => void;
        getMyTeamUnreads: (collapsedThreads: boolean) => void;
        getUser: (id: string) => void;
        getTeamMember: (teamId: string, userId: string) => void;
        getTeamStats: (teamId: string) => ActionFunc;
        getChannelStats: (channelId: string) => void;
        updateTeamMemberSchemeRoles: (teamId: string, userId: string, b1: boolean, b2: boolean) => ActionFunc & Partial<{error: Error}>;
        updateUserActive: (userId: string, active: boolean) => ActionFunc;
        removeUserFromTeamAndGetStats: (teamId: string, userId: string) => ActionFunc & Partial<{error: Error}>;
    };
};

type State = {
    serverError: string|null;
    showDemoteModal: boolean;
    user: UserProfile|null;
    role: string|null;
}

export default class TeamMembersDropdown extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            serverError: null,
            showDemoteModal: false,
            user: null,
            role: null,
        };
    }

    private handleMakeMember = async () => {
        const me = this.props.currentUser;
        if (this.props.user.id === me.id && me.roles.includes('system_admin')) {
            this.handleDemote(this.props.user, 'team_user');
        } else {
            const {error} = await this.props.actions.updateTeamMemberSchemeRoles(this.props.teamMember.team_id, this.props.user.id, true, false);
            if (error) {
                this.setState({serverError: error.message});
            } else {
                this.props.actions.getUser(this.props.user.id);
                this.props.actions.getTeamMember(this.props.teamMember.team_id, this.props.user.id);
                if (this.props.user.id === me.id) {
                    await this.props.actions.getMyTeamMembers();
                    this.props.actions.getMyTeamUnreads(this.props.collapsedThreads);
                }
            }
        }
    }

    private handleRemoveFromTeam = async () => {
        const {error} = await this.props.actions.removeUserFromTeamAndGetStats(this.props.teamMember.team_id, this.props.user.id);
        if (error) {
            this.setState({serverError: error.message});
        }
    }

    private handleMakeAdmin = async () => {
        const me = this.props.currentUser;
        if (this.props.user.id === me.id && me.roles.includes('system_admin')) {
            this.handleDemote(this.props.user, 'team_user team_admin');
        } else {
            const {error} = await this.props.actions.updateTeamMemberSchemeRoles(this.props.teamMember.team_id, this.props.user.id, true, true);
            if (error) {
                this.setState({serverError: error.message});
            } else {
                this.props.actions.getUser(this.props.user.id);
                this.props.actions.getTeamMember(this.props.teamMember.team_id, this.props.user.id);
            }
        }
    }

    private handleDemote = (user: UserProfile, role: string): void => {
        this.setState({
            serverError: this.state.serverError,
            showDemoteModal: true,
            user,
            role,
        });
    }

    private handleDemoteCancel = (): void => {
        this.setState({
            serverError: null,
            showDemoteModal: false,
            user: null,
            role: null,
        });
    }

    private handleDemoteSubmit = async () => {
        const {error} = await this.props.actions.updateTeamMemberSchemeRoles(this.props.teamMember.team_id, this.props.user.id, true, false);
        if (error) {
            this.setState({serverError: error.message});
        } else {
            this.props.actions.getUser(this.props.user.id);
            getHistory().push(this.props.teamUrl);
        }
    }

    render() {
        let serverError = null;
        if (this.state.serverError) {
            serverError = (
                <div className='has-error'>
                    <label className='has-error control-label'>{this.state.serverError}</label>
                </div>
            );
        }

        const {currentTeam, teamMember, user} = this.props;

        let currentRoles = null;

        if (isGuest(user.roles)) {
            currentRoles = (
                <FormattedMessage
                    id='team_members_dropdown.guest'
                    defaultMessage='Guest'
                />
            );
        } else if (user.roles.length > 0 && isSystemAdmin(user.roles)) {
            currentRoles = (
                <FormattedMessage
                    id='team_members_dropdown.systemAdmin'
                    defaultMessage='System Admin'
                />
            );
        } else if ((teamMember.roles.length > 0 && isAdmin(teamMember.roles)) || teamMember.scheme_admin) {
            currentRoles = (
                <FormattedMessage
                    id='team_members_dropdown.teamAdmin'
                    defaultMessage='Team Admin'
                />
            );
        } else {
            currentRoles = (
                <FormattedMessage
                    id='team_members_dropdown.member'
                    defaultMessage='Member'
                />
            );
        }

        const me = this.props.currentUser;
        let showMakeMember = !isGuest(user.roles) && (isAdmin(teamMember.roles) || teamMember.scheme_admin) && !isSystemAdmin(user.roles);
        let showMakeAdmin = !isGuest(user.roles) && !isAdmin(teamMember.roles) && !isSystemAdmin(user.roles) && !teamMember.scheme_admin;

        if (user.delete_at > 0) {
            currentRoles = (
                <FormattedMessage
                    id='team_members_dropdown.inactive'
                    defaultMessage='Inactive'
                />
            );
            showMakeMember = false;
            showMakeAdmin = false;
        }

        const canRemoveFromTeam = user.id !== me.id && (!currentTeam.group_constrained || user.is_bot);

        let makeDemoteModal = null;
        if (user.id === me.id) {
            const title = (
                <FormattedMessage
                    id='team_members_dropdown.confirmDemoteRoleTitle'
                    defaultMessage='Confirm Demotion from System Admin Role'
                />
            );

            const message = (
                <div>
                    <FormattedMessage
                        id='team_members_dropdown.confirmDemoteDescription'
                        defaultMessage="If you demote yourself from the System Admin role and there is not another user with System Admin privileges, you'll need to re-assign a System Admin by accessing the Mattermost server through a terminal and running the following command."
                    />
                    <br/>
                    <br/>
                    <FormattedMessage
                        id='team_members_dropdown.confirmDemotionCmd'
                        defaultMessage='platform roles system_admin {username}'
                        values={{
                            username: me.username,
                        }}
                    />
                    {serverError}
                </div>
            );

            const confirmButton = (
                <FormattedMessage
                    id='team_members_dropdown.confirmDemotion'
                    defaultMessage='Confirm Demotion'
                />
            );

            makeDemoteModal = (
                <ConfirmModal
                    show={this.state.showDemoteModal}
                    title={title}
                    message={message}
                    confirmButtonText={confirmButton}
                    onConfirm={this.handleDemoteSubmit}
                    onCancel={this.handleDemoteCancel}
                />
            );
        }

        if (!canRemoveFromTeam && !showMakeAdmin && !showMakeMember) {
            return <div>{currentRoles}</div>;
        }

        const {index, totalUsers} = this.props;
        let openUp = false;
        if (totalUsers > ROWS_FROM_BOTTOM_TO_OPEN_UP && totalUsers - index <= ROWS_FROM_BOTTOM_TO_OPEN_UP) {
            openUp = true;
        }

        const menuRemove = (
            <Menu.ItemAction
                id='removeFromTeam'
                onClick={this.handleRemoveFromTeam}
                text={Utils.localizeMessage('team_members_dropdown.leave_team', 'Remove From Team')}
            />
        );
        const menuMakeAdmin = (
            <Menu.ItemAction
                onClick={this.handleMakeAdmin}
                text={Utils.localizeMessage('team_members_dropdown.makeAdmin', 'Make Team Admin')}
            />
        );
        const menuMakeMember = (
            <Menu.ItemAction
                onClick={this.handleMakeMember}
                text={Utils.localizeMessage('team_members_dropdown.makeMember', 'Make Member')}
            />
        );
        return (
            <MenuWrapper>
                <button
                    id={`teamMembersDropdown_${user.username}`}
                    className='dropdown-toggle theme color--link style--none'
                    type='button'
                    aria-expanded='true'
                >
                    <span>{currentRoles} </span>
                    <DropdownIcon/>
                </button>
                <div>
                    <Menu
                        openLeft={true}
                        openUp={openUp}
                        ariaLabel={Utils.localizeMessage('team_members_dropdown.menuAriaLabel', 'Change the role of a team member')}
                    >
                        {canRemoveFromTeam ? menuRemove : null}
                        {showMakeAdmin ? menuMakeAdmin : null}
                        {showMakeMember ? menuMakeMember : null}
                    </Menu>
                    {makeDemoteModal}
                    {serverError}
                </div>
            </MenuWrapper>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {getChannelStats} from 'mattermost-redux/actions/channels';
import {
    getMyTeamMembers,
    getMyTeamUnreads,
    getTeamStats,
    getTeamMember,
    updateTeamMemberSchemeRoles,
} from 'mattermost-redux/actions/teams';
import {getUser, updateUserActive} from 'mattermost-redux/actions/users';
import {getCurrentUser} from 'mattermost-redux/selectors/entities/users';
import {getCurrentRelativeTeamUrl, getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';
import {isCollapsedThreadsEnabled} from 'mattermost-redux/selectors/entities/preferences';

import {GlobalState} from '@mattermost/types/store';

import {GenericAction} from 'mattermost-redux/types/actions';

import {removeUserFromTeamAndGetStats} from 'actions/team_actions';

import TeamMembersDropdown from './team_members_dropdown';

function mapStateToProps(state: GlobalState) {
    return {
        currentUser: getCurrentUser(state),
        teamUrl: getCurrentRelativeTeamUrl(state),
        currentTeam: getCurrentTeam(state),
        collapsedThreads: isCollapsedThreadsEnabled(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            getMyTeamMembers,
            getMyTeamUnreads,
            getUser,
            getTeamMember,
            getTeamStats,
            getChannelStats,
            updateUserActive,
            updateTeamMemberSchemeRoles,
            removeUserFromTeamAndGetStats,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(TeamMembersDropdown);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {ActionResult} from 'mattermost-redux/types/actions';
import {UserProfile} from '@mattermost/types/users';
import {TeamMembership, TeamStats, GetTeamMembersOpts} from '@mattermost/types/teams';
import {Teams} from 'mattermost-redux/constants';

import Constants from 'utils/constants';
import * as UserAgent from 'utils/user_agent';

import SearchableUserList from 'components/searchable_user_list/searchable_user_list_container';
import TeamMembersDropdown from 'components/team_members_dropdown';

const USERS_PER_PAGE = 50;

type Props = {
    searchTerm: string;
    users: UserProfile[];
    teamMembers: {
        [userId: string]: TeamMembership;
    };
    currentTeamId: string;
    totalTeamMembers: number;
    canManageTeamMembers?: boolean;
    actions: {
        getTeamMembers: (teamId: string, page?: number, perPage?: number, options?: GetTeamMembersOpts) => Promise<{data: TeamMembership}>;
        searchProfiles: (term: string, options?: {[key: string]: any}) => Promise<{data: UserProfile[]}>;
        getTeamStats: (teamId: string) => Promise<{data: TeamStats}>;
        loadProfilesAndTeamMembers: (page: number, perPage: number, teamId?: string, options?: {[key: string]: any}) => Promise<{
            data: boolean;
        }>;
        loadStatusesForProfilesList: (users: UserProfile[]) => Promise<{
            data: boolean;
        }>;
        loadTeamMembersForProfilesList: (profiles: any, teamId: string, reloadAllMembers: boolean) => Promise<{
            data: boolean;
        }>;
        setModalSearchTerm: (term: string) => ActionResult;
    };
}

type State = {
    loading: boolean;
}

export default class MemberListTeam extends React.PureComponent<Props, State> {
    private searchTimeoutId: number;

    constructor(props: Props) {
        super(props);

        this.searchTimeoutId = 0;

        this.state = {
            loading: true,
        };
    }

    async componentDidMount() {
        await Promise.all([
            this.props.actions.loadProfilesAndTeamMembers(0, Constants.PROFILE_CHUNK_SIZE, this.props.currentTeamId, {active: true}),
            this.props.actions.getTeamMembers(this.props.currentTeamId, 0, Constants.DEFAULT_MAX_USERS_PER_TEAM,
                {
                    sort: Teams.SORT_USERNAME_OPTION,
                    exclude_deleted_users: true,
                } as GetTeamMembersOpts,
            ),
            this.props.actions.getTeamStats(this.props.currentTeamId),
        ]);
        this.loadComplete();
    }

    componentWillUnmount() {
        this.props.actions.setModalSearchTerm('');
    }

    componentDidUpdate(prevProps: Props) {
        if (prevProps.searchTerm !== this.props.searchTerm) {
            clearTimeout(this.searchTimeoutId);

            const searchTerm = this.props.searchTerm;
            if (searchTerm === '') {
                this.loadComplete();
                this.searchTimeoutId = 0;
                return;
            }

            const searchTimeoutId = window.setTimeout(
                async () => {
                    const {
                        loadStatusesForProfilesList,
                        loadTeamMembersForProfilesList,
                        searchProfiles,
                    } = this.props.actions;
                    const {data} = await searchProfiles(searchTerm, {team_id: this.props.currentTeamId});

                    if (searchTimeoutId !== this.searchTimeoutId) {
                        return;
                    }

                    this.setState({loading: true});

                    loadStatusesForProfilesList(data);
                    loadTeamMembersForProfilesList(data, this.props.currentTeamId, true).then(({data: membersLoaded}) => {
                        if (membersLoaded) {
                            this.loadComplete();
                        }
                    });
                },
                Constants.SEARCH_TIMEOUT_MILLISECONDS,
            );

            this.searchTimeoutId = searchTimeoutId;
        }
    }

    loadComplete = () => {
        this.setState({loading: false});
    }

    nextPage = async (page: number) => {
        this.setState({loading: true});
        await Promise.all([
            this.props.actions.loadProfilesAndTeamMembers(page, USERS_PER_PAGE, this.props.currentTeamId, {active: true}),
            this.props.actions.getTeamMembers(this.props.currentTeamId, page, Constants.DEFAULT_MAX_USERS_PER_TEAM,
                {
                    sort: Teams.SORT_USERNAME_OPTION,
                    exclude_deleted_users: true,
                } as GetTeamMembersOpts,
            ),
        ]);
        this.loadComplete();
    }

    search = (term: string) => {
        this.props.actions.setModalSearchTerm(term);
    }

    render() {
        let teamMembersDropdown;
        if (this.props.canManageTeamMembers) {
            teamMembersDropdown = [TeamMembersDropdown];
        }

        const teamMembers = this.props.teamMembers;
        const users = this.props.users;
        const actionUserProps: {
            [userId: string]: {
                teamMember: TeamMembership;
            };
        } = {};

        let usersToDisplay;
        if (this.state.loading) {
            usersToDisplay = null;
        } else {
            usersToDisplay = [];

            for (let i = 0; i < users.length; i++) {
                const user = users[i];

                if (teamMembers[user.id] && user.delete_at === 0) {
                    usersToDisplay.push(user);
                    actionUserProps[user.id] = {
                        teamMember: teamMembers[user.id],
                    };
                }
            }
        }

        return (
            <SearchableUserList
                users={usersToDisplay}
                usersPerPage={USERS_PER_PAGE}
                total={this.props.totalTeamMembers}
                nextPage={this.nextPage}
                search={this.search}
                actions={teamMembersDropdown}
                actionUserProps={actionUserProps}
                focusOnMount={!UserAgent.isMobile()}
            />
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';

import {getTeamStats, getTeamMembers} from 'mattermost-redux/actions/teams';
import {GetTeamMembersOpts, TeamStats, TeamMembership} from '@mattermost/types/teams';
import {haveITeamPermission} from 'mattermost-redux/selectors/entities/roles';
import {getMembersInCurrentTeam, getCurrentTeamStats} from 'mattermost-redux/selectors/entities/teams';
import {getProfilesInCurrentTeam, searchProfilesInCurrentTeam} from 'mattermost-redux/selectors/entities/users';
import {Permissions} from 'mattermost-redux/constants';
import {searchProfiles} from 'mattermost-redux/actions/users';
import {ActionFunc, GenericAction, ActionResult} from 'mattermost-redux/types/actions';
import {UserProfile} from '@mattermost/types/users';

import {loadStatusesForProfilesList} from 'actions/status_actions';
import {loadProfilesAndTeamMembers, loadTeamMembersForProfilesList} from 'actions/user_actions';
import {setModalSearchTerm} from 'actions/views/search';

import {GlobalState} from 'types/store';

import MemberListTeam from './member_list_team';

type Props = {
    teamId: string;
}

type Actions = {
    getTeamMembers: (teamId: string, page?: number, perPage?: number, options?: GetTeamMembersOpts) => Promise<{data: TeamMembership}>;
    searchProfiles: (term: string, options?: {[key: string]: any}) => Promise<{data: UserProfile[]}>;
    getTeamStats: (teamId: string) => Promise<{data: TeamStats}>;
    loadProfilesAndTeamMembers: (page: number, perPage: number, teamId?: string, options?: {[key: string]: any}) => Promise<{
        data: boolean;
    }>;
    loadStatusesForProfilesList: (users: UserProfile[]) => Promise<{
        data: boolean;
    }>;
    loadTeamMembersForProfilesList: (profiles: any, teamId: string, reloadAllMembers: boolean) => Promise<{
        data: boolean;
    }>;
    setModalSearchTerm: (term: string) => ActionResult;
}

function mapStateToProps(state: GlobalState, ownProps: Props) {
    const canManageTeamMembers = haveITeamPermission(state, ownProps.teamId, Permissions.MANAGE_TEAM_ROLES);

    const searchTerm = state.views.search.modalSearch;

    let users;
    if (searchTerm) {
        users = searchProfilesInCurrentTeam(state, searchTerm);
    } else {
        users = getProfilesInCurrentTeam(state);
    }

    const stats = getCurrentTeamStats(state) || {active_member_count: 0};

    return {
        searchTerm,
        users,
        teamMembers: getMembersInCurrentTeam(state) || {},
        currentTeamId: state.entities.teams.currentTeamId,
        totalTeamMembers: stats.active_member_count,
        canManageTeamMembers,
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc | GenericAction>, Actions>({
            searchProfiles,
            getTeamStats,
            getTeamMembers,
            loadProfilesAndTeamMembers,
            loadStatusesForProfilesList,
            loadTeamMembersForProfilesList,
            setModalSearchTerm,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(MemberListTeam);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

import Permissions from 'mattermost-redux/constants/permissions';

import {Team} from '@mattermost/types/teams';

import TeamPermissionGate from 'components/permissions_gates/team_permission_gate';
import MemberListTeam from 'components/member_list_team';
import InvitationModal from 'components/invitation_modal';

import {ModalData} from 'types/actions';

import {ModalIdentifiers} from 'utils/constants';

type Props = {
    currentTeam: Team;
    onExited: () => void;
    onLoad?: () => void;
    actions: {
        openModal: <P>(modalData: ModalData<P>) => void;
    };
}

type State = {
    show: boolean;
}

export default class TeamMembersModal extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            show: true,
        };
    }

    componentDidMount() {
        if (this.props.onLoad) {
            this.props.onLoad();
        }
    }

    handleHide = () => {
        this.setState({show: false});
    }

    handleInvitePeople = () => {
        const {actions} = this.props;

        actions.openModal({
            modalId: ModalIdentifiers.INVITATION,
            dialogType: InvitationModal,
        });

        this.handleHide();
    }

    render() {
        let teamDisplayName = '';
        if (this.props.currentTeam) {
            teamDisplayName = this.props.currentTeam.display_name;
        }

        return (
            <Modal
                dialogClassName='a11y__modal more-modal'
                show={this.state.show}
                onHide={this.handleHide}
                onExited={this.props.onExited}
                role='dialog'
                aria-labelledby='teamMemberModalLabel'
                id='teamMembersModal'
            >
                <Modal.Header closeButton={true}>
                    <Modal.Title
                        componentClass='h1'
                        id='teamMemberModalLabel'
                    >
                        <FormattedMessage
                            id='team_member_modal.members'
                            defaultMessage='{team} Members'
                            values={{
                                team: teamDisplayName,
                            }}
                        />
                    </Modal.Title>
                    <TeamPermissionGate
                        teamId={this.props.currentTeam.id}
                        permissions={[Permissions.ADD_USER_TO_TEAM, Permissions.INVITE_GUEST]}
                    >
                        <button
                            id='invitePeople'
                            type='button'
                            className='btn btn-primary invite-people-btn'
                            onClick={this.handleInvitePeople}
                        >
                            <FormattedMessage
                                id='team_member_modal.invitePeople'
                                defaultMessage='Invite People'
                            />
                        </button>
                    </TeamPermissionGate>
                </Modal.Header>
                <Modal.Body>
                    <MemberListTeam
                        teamId={this.props.currentTeam.id}
                    />
                </Modal.Body>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';

import {getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';
import {Action} from 'mattermost-redux/types/actions';

import {ModalIdentifiers} from 'utils/constants';
import {isModalOpen} from 'selectors/views/modals';
import {openModal} from 'actions/views/modals';

import {ModalData} from 'types/actions';
import {GlobalState} from 'types/store';

import TeamMembersModal from './team_members_modal';

type Actions = {
    openModal: <P>(modalData: ModalData<P>) => void;
}

function mapStateToProps(state: GlobalState) {
    const modalId = ModalIdentifiers.TEAM_MEMBERS;
    return {
        currentTeam: getCurrentTeam(state),
        show: isModalOpen(state, modalId),
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, Actions>({
            openModal,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(TeamMembersModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useState} from 'react';
import {FormattedMessage, useIntl} from 'react-intl';

import type {ActionResult} from 'mattermost-redux/types/actions';

import SettingItemMax from 'components/setting_item_max';

import SettingItemMin from 'components/setting_item_min';

import type {Team} from '@mattermost/types/teams';

type Props = {
    teamId?: string;
    isActive: boolean;
    isGroupConstrained?: boolean;
    allowOpenInvite?: boolean;
    onToggle: (active: boolean) => void;
    patchTeam: (patch: Partial<Team>) => Promise<ActionResult>;
};

const OpenInvite = (props: Props) => {
    const {teamId, isActive, isGroupConstrained, onToggle, patchTeam} = props;
    const intl = useIntl();
    const [serverError, setServerError] = useState('');
    const [allowOpenInvite, setAllowOpenInvite] = useState(props.allowOpenInvite);

    const submit = useCallback(() => {
        setServerError('');
        const data = {
            id: teamId,
            allow_open_invite: allowOpenInvite,
        };

        patchTeam(data).then(({error}) => {
            if (error) {
                setServerError(error.message);
            } else {
                onToggle(false);
            }
        });
    }, [onToggle, patchTeam, teamId, allowOpenInvite]);

    const handleToggle = useCallback(() => {
        if (isActive) {
            onToggle(false);
        } else {
            onToggle(true);
            setAllowOpenInvite(props.allowOpenInvite);
        }
    }, [isActive, onToggle]);

    if (!isActive) {
        let describe = '';
        if (props.allowOpenInvite) {
            describe = intl.formatMessage({id: 'general_tab.yes', defaultMessage: 'Yes'});
        } else if (isGroupConstrained) {
            describe = intl.formatMessage({id: 'team_settings.openInviteSetting.groupConstrained', defaultMessage: 'No, members of this team are added and removed by linked groups.'});
        } else {
            describe = intl.formatMessage({id: 'general_tab.no', defaultMessage: 'No'});
        }

        return (
            <SettingItemMin
                title={intl.formatMessage({id: 'general_tab.openInviteTitle', defaultMessage: 'Allow any user with an account on this server to join this team'})}
                describe={describe}
                updateSection={handleToggle}
                section={'open_invite'}
            />
        );
    }

    let inputs;

    if (isGroupConstrained) {
        inputs = [
            <div key='userOpenInviteOptions'>
                <div>
                    <FormattedMessage
                        id='team_settings.openInviteDescription.groupConstrained'
                        defaultMessage='No, members of this team are added and removed by linked groups. <link>Learn More</link>'
                        values={{
                            link: (msg: React.ReactNode) => (
                                <a
                                    href='https://mattermost.com/pl/default-ldap-group-constrained-team-channel.html'
                                    target='_blank'
                                    rel='noreferrer'
                                >
                                    {msg}
                                </a>
                            ),
                        }}
                    />
                </div>
            </div>,
        ];
    } else {
        inputs = [
            <fieldset key='userOpenInviteOptions'>
                <legend className='form-legend hidden-label'>
                    <FormattedMessage
                        id='team_settings.openInviteDescription.ariaLabel'
                        defaultMessage='Invite Code'
                    />
                </legend>
                <div className='radio'>
                    <label>
                        <input
                            id='teamOpenInvite'
                            name='userOpenInviteOptions'
                            type='radio'
                            defaultChecked={allowOpenInvite}
                            onChange={() => setAllowOpenInvite(true)}
                        />
                        <FormattedMessage
                            id='general_tab.yes'
                            defaultMessage='Yes'
                        />
                    </label>
                    <br/>
                </div>
                <div className='radio'>
                    <label>
                        <input
                            id='teamOpenInviteNo'
                            name='userOpenInviteOptions'
                            type='radio'
                            defaultChecked={!allowOpenInvite}
                            onChange={() => setAllowOpenInvite(false)}
                        />
                        <FormattedMessage
                            id='general_tab.no'
                            defaultMessage='No'
                        />
                    </label>
                    <br/>
                </div>
                <div className='mt-5'>
                    <FormattedMessage
                        id='general_tab.openInviteDesc'
                        defaultMessage='When allowed, a link to this team will be included on the landing page allowing anyone with an account to join this team. Changing from "Yes" to "No" will regenerate the  invitation code, create a new invitation link and invalidate the previous link.'
                    />
                </div>
            </fieldset>,
        ];
    }

    return (
        <SettingItemMax
            title={intl.formatMessage({id: 'general_tab.openInviteTitle', defaultMessage: 'Allow any user with an account on this server to join this team'})}
            inputs={inputs}
            submit={submit}
            serverError={serverError}
            updateSection={handleToggle}
        />
    );
};

export default OpenInvite;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/* eslint-disable react/no-string-refs */

import React, {ChangeEvent, MouseEvent, ReactNode} from 'react';
import {FormattedMessage, FormattedDate} from 'react-intl';

import Constants from 'utils/constants';
import {imageURLForTeam, isMobile, localizeMessage, moveCursorToEnd} from 'utils/utils';
import {t} from 'utils/i18n';

import SettingItemMax from 'components/setting_item_max';
import SettingItemMin from 'components/setting_item_min';
import SettingPicture from 'components/setting_picture';
import BackIcon from 'components/widgets/icons/fa_back_icon';
import LocalizedInput from 'components/localized_input/localized_input';

import {Team} from '@mattermost/types/teams';

import OpenInvite from './open_invite';

import {PropsFromRedux, OwnProps} from '.';

const ACCEPTED_TEAM_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/bmp'];

type Props = PropsFromRedux & OwnProps;

type State = {
    name?: Team['display_name'];
    invite_id?: Team['invite_id'];
    description?: Team['description'];
    allowed_domains?: Team['allowed_domains'];
    serverError: ReactNode;
    clientError: ReactNode;
    teamIconFile: File | null;
    loadingIcon: boolean;
    submitActive: boolean;
    isInitialState: boolean;
    shouldFetchTeam?: boolean;
}

export default class GeneralTab extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);
        this.state = this.setupInitialState(props);
    }

    updateSection = (section: string) => {
        this.setState(this.setupInitialState(this.props));
        this.props.updateSection(section);
    }

    setupInitialState(props: Props) {
        const team = props.team;

        return {
            name: team?.display_name,
            invite_id: team?.invite_id,
            description: team?.description,
            allowed_domains: team?.allowed_domains,
            serverError: '',
            clientError: '',
            teamIconFile: null,
            loadingIcon: false,
            submitActive: false,
            isInitialState: true,
        };
    }

    static getDerivedStateFromProps(nextProps: Props, prevState: State) {
        const {team} = nextProps;
        if (!prevState.isInitialState) {
            return {
                name: team?.display_name,
                description: team?.description,
                allowed_domains: team?.allowed_domains,
                invite_id: team?.invite_id,
                isInitialState: false,
            };
        }
        return null;
    }

    componentDidUpdate(prevProps: Props, prevState: State) {
        if (!prevState.shouldFetchTeam && this.state.shouldFetchTeam) {
            this.fetchTeam();
        }
    }

    fetchTeam() {
        if (this.state.serverError) {
            return;
        }
        if (this.props.team) {
            this.props.actions.getTeam(this.props.team.id).then(({error}) => {
                const state = {
                    shouldFetchTeam: false,
                    serverError: '',
                };
                if (error) {
                    state.serverError = error.message;
                }
                this.setState(state);
            });
        }
    }

    handleAllowedDomainsSubmit = async () => {
        const state = {serverError: '', clientError: ''};

        const data = {...this.props.team};
        data.allowed_domains = this.state.allowed_domains;

        const {error} = await this.props.actions.patchTeam(data);

        if (error) {
            state.serverError = error.message;
            this.setState(state);
        } else {
            this.updateSection('');
        }
    }

    handleNameSubmit = async () => {
        const state: Pick<State, 'serverError' | 'clientError'> = {serverError: '', clientError: ''};
        let valid = true;

        const name = this.state.name?.trim();

        if (!name) {
            state.clientError = localizeMessage('general_tab.required', 'This field is required');
            valid = false;
        } else if (name.length < Constants.MIN_TEAMNAME_LENGTH) {
            state.clientError = (
                <FormattedMessage
                    id='general_tab.teamNameRestrictions'
                    defaultMessage='Team Name must be {min} or more characters up to a maximum of {max}. You can add a longer team description.'
                    values={{
                        min: Constants.MIN_TEAMNAME_LENGTH,
                        max: Constants.MAX_TEAMNAME_LENGTH,
                    }}
                />
            );

            valid = false;
        } else {
            state.clientError = '';
        }

        this.setState(state);

        if (!valid) {
            return;
        }

        const data = {...this.props.team};
        data.display_name = this.state.name;

        const {error} = await this.props.actions.patchTeam(data);

        if (error) {
            state.serverError = error.message;
            this.setState(state);
        } else {
            this.updateSection('');
        }
    }

    handleInviteIdSubmit = async () => {
        const state = {serverError: '', clientError: ''};
        this.setState(state);

        const {error} = await this.props.actions.regenerateTeamInviteId(this.props.team?.id || '');

        if (error) {
            state.serverError = error.message;
            this.setState(state);
        } else {
            this.updateSection('');
        }
    }

    handleClose = () => this.updateSection('');

    handleDescriptionSubmit = async () => {
        const state = {serverError: '', clientError: ''};
        let valid = true;

        const description = this.state.description?.trim();
        if (description === this.props.team?.description) {
            state.clientError = localizeMessage('general_tab.chooseDescription', 'Please choose a new description for your team');
            valid = false;
        } else {
            state.clientError = '';
        }

        this.setState(state);

        if (!valid) {
            return;
        }

        const data = {...this.props.team};
        data.description = this.state.description;

        const {error} = await this.props.actions.patchTeam(data);

        if (error) {
            state.serverError = error.message;
            this.setState(state);
        } else {
            this.updateSection('');
        }
    }

    handleTeamIconSubmit = async () => {
        if (!this.state.teamIconFile || !this.state.submitActive) {
            return;
        }

        this.setState({
            loadingIcon: true,
            clientError: '',
            serverError: '',
        });

        const {error} = await this.props.actions.setTeamIcon(this.props.team?.id || '', this.state.teamIconFile);

        if (error) {
            this.setState({
                loadingIcon: false,
                serverError: error.message,
            });
        } else {
            this.setState({
                loadingIcon: false,
                submitActive: false,
            });
            this.updateSection('');
        }
    }

    handleTeamIconRemove = async () => {
        this.setState({
            loadingIcon: true,
            clientError: '',
            serverError: '',
        });

        const {error} = await this.props.actions.removeTeamIcon(this.props.team?.id || '');

        if (error) {
            this.setState({
                loadingIcon: false,
                serverError: error.message,
            });
        } else {
            this.setState({
                loadingIcon: false,
                submitActive: false,
            });
            this.updateSection('');
        }
    }

    componentDidMount() {
        document.getElementById('team_settings')?.addEventListener('hidden.bs.modal', this.handleClose);
    }

    componentWillUnmount() {
        document.getElementById('team_settings')?.removeEventListener('hidden.bs.modal', this.handleClose);
    }

    onOpenInviteToggle = (active: boolean) => this.handleUpdateSection(active ? 'open_invite' : '');

    handleUpdateSection = (section: string) => {
        if (section === 'invite_id' && this.props.activeSection !== section && !this.props.team?.invite_id) {
            this.setState({shouldFetchTeam: true}, () => {
                this.updateSection(section);
            });
            return;
        }

        this.updateSection(section);
    }

    updateName = (e: ChangeEvent<HTMLInputElement>) => this.setState({name: e.target.value});

    updateDescription = (e: ChangeEvent<HTMLInputElement>) => this.setState({description: e.target.value});

    updateTeamIcon = (e: ChangeEvent<HTMLInputElement>) => {
        if (e && e.target && e.target.files && e.target.files[0]) {
            const file = e.target.files[0];

            if (!ACCEPTED_TEAM_IMAGE_TYPES.includes(file.type)) {
                this.setState({
                    clientError: localizeMessage('general_tab.teamIconInvalidFileType', 'Only BMP, JPG or PNG images may be used for team icons'),
                });
            } else if (file.size > this.props.maxFileSize) {
                this.setState({
                    clientError: localizeMessage('general_tab.teamIconTooLarge', 'Unable to upload team icon. File is too large.'),
                });
            } else {
                this.setState({
                    teamIconFile: e.target.files[0],
                    clientError: '',
                    submitActive: true,
                });
            }
        } else {
            this.setState({
                teamIconFile: null,
                clientError: localizeMessage('general_tab.teamIconError', 'An error occurred while selecting the image.'),
            });
        }
    }

    updateAllowedDomains = (e: ChangeEvent<HTMLInputElement>) => this.setState({allowed_domains: e.target.value});

    render() {
        const team = this.props.team;

        const clientError = this.state.clientError;
        const serverError = this.state.serverError ?? null;

        let inviteSection;

        if (this.props.activeSection === 'invite_id' && this.props.canInviteTeamMembers) {
            const inputs = [];

            inputs.push(
                <div key='teamInviteSetting'>
                    <div className='row'>
                        <label className='col-sm-5 control-label visible-xs-block'/>
                        <div className='col-sm-12'>
                            <input
                                id='teamInviteId'
                                autoFocus={true}
                                className='form-control'
                                type='text'
                                value={this.state.invite_id}
                                maxLength={32}
                                onFocus={moveCursorToEnd}
                                readOnly={true}
                            />
                        </div>
                    </div>
                    <div className='setting-list__hint'>
                        <FormattedMessage
                            id='general_tab.codeLongDesc'
                            defaultMessage='The Invite Code is part of the unique team invitation link which is sent to members youre inviting to this team. Regenerating the code creates a new invitation link and invalidates the previous link.'
                            values={{
                                getTeamInviteLink: (
                                    <strong>
                                        <FormattedMessage
                                            id='general_tab.getTeamInviteLink'
                                            defaultMessage='Get Team Invite Link'
                                        />
                                    </strong>
                                ),
                            }}
                        />
                    </div>
                </div>,
            );

            inviteSection = (
                <SettingItemMax
                    title={localizeMessage('general_tab.codeTitle', 'Invite Code')}
                    inputs={inputs}
                    submit={this.handleInviteIdSubmit}
                    serverError={serverError}
                    clientError={clientError}
                    updateSection={this.handleUpdateSection}
                    saveButtonText={localizeMessage('general_tab.regenerate', 'Regenerate')}
                />
            );
        } else if (this.props.canInviteTeamMembers) {
            inviteSection = (
                <SettingItemMin
                    title={localizeMessage('general_tab.codeTitle', 'Invite Code')}
                    describe={localizeMessage('general_tab.codeDesc', "Click 'Edit' to regenerate Invite Code.")}
                    updateSection={this.handleUpdateSection}
                    section={'invite_id'}
                />
            );
        }

        let nameSection;

        if (this.props.activeSection === 'name') {
            const inputs = [];

            const teamNameLabel = isMobile() ? '' : (
                <FormattedMessage
                    id='general_tab.teamName'
                    defaultMessage='Team Name'
                />
            );

            inputs.push(
                <div
                    key='teamNameSetting'
                    className='form-group'
                >
                    <label className='col-sm-5 control-label'>{teamNameLabel}</label>
                    <div className='col-sm-7'>
                        <input
                            id='teamName'
                            autoFocus={true}
                            className='form-control'
                            type='text'
                            maxLength={Constants.MAX_TEAMNAME_LENGTH}
                            onChange={this.updateName}
                            value={this.state.name}
                            onFocus={moveCursorToEnd}
                        />
                    </div>
                </div>,
            );

            const nameExtraInfo = <span>{localizeMessage('general_tab.teamNameInfo', 'Set the name of the team as it appears on your sign-in screen and at the top of the left-hand sidebar.')}</span>;

            nameSection = (
                <SettingItemMax
                    title={localizeMessage('general_tab.teamName', 'Team Name')}
                    inputs={inputs}
                    submit={this.handleNameSubmit}
                    serverError={serverError}
                    clientError={clientError}
                    updateSection={this.handleUpdateSection}
                    extraInfo={nameExtraInfo}
                />
            );
        } else {
            const describe = this.state.name;

            nameSection = (
                <SettingItemMin
                    title={localizeMessage('general_tab.teamName', 'Team Name')}
                    describe={describe}
                    updateSection={this.handleUpdateSection}
                    section={'name'}
                />
            );
        }

        let descriptionSection;

        if (this.props.activeSection === 'description') {
            const inputs = [];

            const teamDescriptionLabel = isMobile() ? '' : (
                <FormattedMessage
                    id='general_tab.teamDescription'
                    defaultMessage='Team Description'
                />
            );

            inputs.push(
                <div
                    key='teamDescriptionSetting'
                    className='form-group'
                >
                    <label className='col-sm-5 control-label'>{teamDescriptionLabel}</label>
                    <div className='col-sm-7'>
                        <input
                            id='teamDescription'
                            autoFocus={true}
                            className='form-control'
                            type='text'
                            maxLength={Constants.MAX_TEAMDESCRIPTION_LENGTH}
                            onChange={this.updateDescription}
                            value={this.state.description}
                            onFocus={moveCursorToEnd}
                        />
                    </div>
                </div>,
            );

            const descriptionExtraInfo = <span>{localizeMessage('general_tab.teamDescriptionInfo', 'Team description provides additional information to help users select the right team. Maximum of 50 characters.')}</span>;

            descriptionSection = (
                <SettingItemMax
                    title={localizeMessage('general_tab.teamDescription', 'Team Description')}
                    inputs={inputs}
                    submit={this.handleDescriptionSubmit}
                    serverError={serverError}
                    clientError={clientError}
                    updateSection={this.handleUpdateSection}
                    extraInfo={descriptionExtraInfo}
                />
            );
        } else {
            const describeMsg = this.state.description ?? (
                <FormattedMessage
                    id='general_tab.emptyDescription'
                    defaultMessage="Click 'Edit' to add a team description."
                />
            );

            descriptionSection = (
                <SettingItemMin
                    title={localizeMessage('general_tab.teamDescription', 'Team Description')}
                    describe={describeMsg}
                    updateSection={this.handleUpdateSection}
                    section={'description'}
                />
            );
        }

        let teamIconSection;
        if (this.props.activeSection === 'team_icon') {
            const helpText = (
                <FormattedMessage
                    id='setting_picture.help.team'
                    defaultMessage='Upload a team icon in BMP, JPG or PNG format.\nSquare images with a solid background color are recommended.'
                />
            );
            teamIconSection = (
                <SettingPicture
                    imageContext='team'
                    title={localizeMessage('general_tab.teamIcon', 'Team Icon')}
                    src={imageURLForTeam(team || {} as Team)}
                    file={this.state.teamIconFile}
                    serverError={this.state.serverError}
                    clientError={this.state.clientError}
                    loadingPicture={this.state.loadingIcon}
                    submitActive={this.state.submitActive}
                    updateSection={(e: MouseEvent<HTMLButtonElement>) => {
                        this.updateSection('');
                        e.preventDefault();
                    }}
                    onFileChange={this.updateTeamIcon}
                    onSubmit={this.handleTeamIconSubmit}
                    onRemove={this.handleTeamIconRemove}
                    helpText={helpText}
                />
            );
        } else {
            let minMessage;

            if (team?.last_team_icon_update) {
                minMessage = (
                    <FormattedMessage
                        id='general_tab.teamIconLastUpdated'
                        defaultMessage='Image last updated {date}'
                        values={{
                            date: (
                                <FormattedDate
                                    value={new Date(team.last_team_icon_update)}
                                    day='2-digit'
                                    month='short'
                                    year='numeric'
                                />
                            ),
                        }}
                    />
                );
            } else {
                minMessage = isMobile() ? localizeMessage('general_tab.teamIconEditHintMobile', 'Click to upload an image') : localizeMessage('general_tab.teamIconEditHint', 'Click \'Edit\' to upload an image.');
            }

            teamIconSection = (
                <SettingItemMin
                    title={localizeMessage('general_tab.teamIcon', 'Team Icon')}
                    describe={minMessage}
                    section={'team_icon'}
                    updateSection={this.handleUpdateSection}
                />
            );
        }

        let allowedDomainsSection;

        if (this.props.activeSection === 'allowed_domains') {
            const inputs = [];

            inputs.push(
                <div
                    key='allowedDomainsSetting'
                    className='form-group'
                >
                    <div className='col-sm-12'>
                        <LocalizedInput
                            id='allowedDomains'
                            autoFocus={true}
                            className='form-control'
                            type='text'
                            onChange={this.updateAllowedDomains}
                            value={this.state.allowed_domains}
                            onFocus={moveCursorToEnd}
                            placeholder={{id: t('general_tab.AllowedDomainsExample'), defaultMessage: 'corp.mattermost.com, mattermost.com'}}
                            aria-label={localizeMessage('general_tab.allowedDomains.ariaLabel', 'Allowed Domains')}
                        />
                    </div>
                </div>,
            );

            const allowedDomainsInfo = <span>{localizeMessage('general_tab.AllowedDomainsInfo', 'Users can only join the team if their email matches a specific domain (e.g. "mattermost.com") or list of comma-separated domains (e.g. "corp.mattermost.com, mattermost.com").')}</span>;

            allowedDomainsSection = (
                <SettingItemMax
                    title={localizeMessage('general_tab.allowedDomains', 'Allow only users with a specific email domain to join this team')}
                    inputs={inputs}
                    submit={this.handleAllowedDomainsSubmit}
                    serverError={serverError}
                    clientError={clientError}
                    updateSection={this.handleUpdateSection}
                    extraInfo={allowedDomainsInfo}
                />
            );
        } else {
            const describeMsg = this.state.allowed_domains ?? (
                <FormattedMessage
                    id='general_tab.allowedDomainsEdit'
                    defaultMessage="Click 'Edit' to add an email domain whitelist."
                />
            );
            allowedDomainsSection = (
                <SettingItemMin
                    title={localizeMessage('general_tab.allowedDomains', 'allowedDomains')}
                    describe={describeMsg}
                    updateSection={this.handleUpdateSection}
                    section={'allowed_domains'}
                />
            );
        }

        return (
            <div>
                <div className='modal-header'>
                    <button
                        id='closeButton'
                        type='button'
                        className='close'
                        data-dismiss='modal'
                        aria-label='Close'
                        onClick={this.props.closeModal}
                    >
                        <span aria-hidden='true'>{''}</span>
                    </button>
                    <h4 className='modal-title'>
                        <div className='modal-back'>
                            <span onClick={this.props.collapseModal}>
                                <BackIcon/>
                            </span>
                        </div>
                        <FormattedMessage
                            id='general_tab.title'
                            defaultMessage='General Settings'
                        />
                    </h4>
                </div>
                <div className='user-settings'>
                    <h3 className='tab-header'>
                        <FormattedMessage
                            id='general_tab.title'
                            defaultMessage='General Settings'
                        />
                    </h3>
                    <div className='divider-dark first'/>
                    {nameSection}
                    <div className='divider-light'/>
                    {descriptionSection}
                    <div className='divider-light'/>
                    {teamIconSection}
                    {!team?.group_constrained &&
                        <>
                            <div className='divider-light'/>
                            {allowedDomainsSection}
                        </>
                    }
                    <div className='divider-light'/>
                    <OpenInvite
                        teamId={this.props.team?.id}
                        isActive={this.props.activeSection === 'open_invite'}
                        isGroupConstrained={this.props.team?.group_constrained}
                        allowOpenInvite={this.props.team?.allow_open_invite}
                        onToggle={this.onOpenInviteToggle}
                        patchTeam={this.props.actions.patchTeam}
                    />
                    {!team?.group_constrained &&
                        <>
                            <div className='divider-light'/>
                            {inviteSection}
                        </>
                    }
                    <div className='divider-dark'/>
                </div>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';
import {connect, ConnectedProps} from 'react-redux';

import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getTeam, patchTeam, removeTeamIcon, setTeamIcon, regenerateTeamInviteId} from 'mattermost-redux/actions/teams';
import {Permissions} from 'mattermost-redux/constants';
import {haveITeamPermission} from 'mattermost-redux/selectors/entities/roles';
import {ActionResult, GenericAction} from 'mattermost-redux/types/actions';

import {GlobalState} from 'types/store/index';

import {Team} from '@mattermost/types/teams';

import TeamGeneralTab from './team_general_tab';

export type OwnProps = {
    updateSection: (section: string) => void;
    team?: Team & { last_team_icon_update?: number };
    activeSection: string;
    closeModal: () => void;
    collapseModal: () => void;
};

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const config = getConfig(state);
    const maxFileSize = parseInt(config.MaxFileSize ?? '', 10);

    const canInviteTeamMembers = haveITeamPermission(state, ownProps.team?.id || '', Permissions.INVITE_USER);

    return {
        maxFileSize,
        canInviteTeamMembers,
    };
}

type Actions = {
    getTeam: (teamId: string) => Promise<ActionResult>;
    patchTeam: (team: Partial<Team>) => Promise<ActionResult>;
    regenerateTeamInviteId: (teamId: string) => Promise<ActionResult>;
    removeTeamIcon: (teamId: string) => Promise<ActionResult>;
    setTeamIcon: (teamId: string, teamIconFile: File) => Promise<ActionResult>;
};

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject, Actions>({
            getTeam,
            patchTeam,
            regenerateTeamInviteId,
            removeTeamIcon,
            setTeamIcon,
        }, dispatch),
    };
}

const connector = connect(mapStateToProps, mapDispatchToProps);

export type PropsFromRedux = ConnectedProps<typeof connector>;

export default connector(TeamGeneralTab);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import GeneralTab from 'components/team_general_tab';

import {Team} from '@mattermost/types/teams';

type Props = {
    activeTab: string;
    activeSection: string;
    updateSection: (section: string) => void;
    closeModal: () => void;
    collapseModal: () => void;
    team?: Team;
};

const TeamSettings = ({
    activeTab = '',
    activeSection = '',
    updateSection,
    closeModal,
    collapseModal,
    team,
}: Props): JSX.Element | null => {
    if (!team) {
        return null;
    }

    let result;
    switch (activeTab) {
    case 'general':
        result = (
            <div>
                <GeneralTab
                    team={team}
                    activeSection={activeSection}
                    updateSection={updateSection}
                    closeModal={closeModal}
                    collapseModal={collapseModal}
                />
            </div>
        );
        break;
    default:
        result = (
            <div/>
        );
        break;
    }

    return result;
};

export default TeamSettings;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';

import {GlobalState} from '@mattermost/types/store';

import TeamSettings from './team_settings';

function mapStateToProps(state: GlobalState) {
    return {
        team: getCurrentTeam(state),
    };
}

export default connect(mapStateToProps)(TeamSettings);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import ReactDOM from 'react-dom';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

import * as Utils from 'utils/utils';
const SettingsSidebar = React.lazy(() => import('components/settings_sidebar'));

import TeamSettings from 'components/team_settings';

type Props = {
    onExited: () => void;
    isCloud?: boolean;
}

export type State = {
    activeTab: string;
    activeSection: string;
    show: boolean;
}

export default class TeamSettingsModal extends React.PureComponent<Props, State> {
    modalBodyRef: React.RefObject<Modal>;

    constructor(props: Props) {
        super(props);

        this.state = {
            activeTab: 'general',
            activeSection: '',
            show: true,
        };

        this.modalBodyRef = React.createRef();
    }

    updateTab = (tab: string) => {
        this.setState({
            activeTab: tab,
            activeSection: '',
        });
    }

    updateSection = (section: string) => {
        this.setState({activeSection: section});
    }

    collapseModal = () => {
        const el = ReactDOM.findDOMNode(this.modalBodyRef.current) as HTMLDivElement;
        const modalDialog = el.closest('.modal-dialog');
        modalDialog?.classList.remove('display--content');

        this.setState({
            activeTab: '',
            activeSection: '',
        });
    }

    handleHide = () => {
        this.setState({show: false});
    }

    // called after the dialog is fully hidden and faded out
    handleHidden = () => {
        this.setState({
            activeTab: 'general',
            activeSection: '',
        });
        this.props.onExited();
    }

    render() {
        const tabs = [];
        tabs.push({name: 'general', uiName: Utils.localizeMessage('team_settings_modal.generalTab', 'General'), icon: 'icon fa fa-cog', iconTitle: Utils.localizeMessage('generic_icons.settings', 'Settings Icon')});

        return (
            <Modal
                dialogClassName='a11y__modal settings-modal settings-modal--action'
                show={this.state.show}
                onHide={this.handleHide}
                onExited={this.handleHidden}
                role='dialog'
                aria-labelledby='teamSettingsModalLabel'
                id='teamSettingsModal'
            >
                <Modal.Header
                    id='teamSettingsModalLabel'
                    closeButton={true}
                >
                    <Modal.Title componentClass='h1'>
                        <FormattedMessage
                            id='team_settings_modal.title'
                            defaultMessage='Team Settings'
                        />
                    </Modal.Title>
                </Modal.Header>
                <Modal.Body ref={this.modalBodyRef}>
                    <div className='settings-table'>
                        <div className='settings-links'>
                            <React.Suspense fallback={null}>
                                <SettingsSidebar
                                    tabs={tabs}
                                    activeTab={this.state.activeTab}
                                    updateTab={this.updateTab}
                                />
                            </React.Suspense>
                        </div>
                        <div className='settings-content minimize-settings'>
                            <TeamSettings
                                activeTab={this.state.activeTab}
                                activeSection={this.state.activeSection}
                                updateSection={this.updateSection}
                                closeModal={this.handleHide}
                                collapseModal={this.collapseModal}
                            />
                        </div>
                    </div>
                </Modal.Body>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getLicense} from 'mattermost-redux/selectors/entities/general';

import {ModalIdentifiers} from 'utils/constants';
import {isModalOpen} from 'selectors/views/modals';

import {GlobalState} from 'types/store';

import TeamSettingsModal from './team_settings_modal';

function mapStateToProps(state: GlobalState) {
    const modalId = ModalIdentifiers.TEAM_SETTINGS;
    return {
        show: isModalOpen(state, modalId),
        isCloud: getLicense(state).Cloud === 'true',
    };
}

export default connect(mapStateToProps)(TeamSettingsModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage, injectIntl, IntlShape} from 'react-intl';

import ConfirmModal from 'components/confirm_modal';

import AddGroupsToTeamModal from 'components/add_groups_to_team_modal';

import {ModalIdentifiers} from 'utils/constants';

import ListModal, {DEFAULT_NUM_PER_PAGE} from 'components/list_modal';

import DropdownIcon from 'components/widgets/icons/fa_dropdown_icon';

import groupsAvatar from 'images/groups-avatar.png';
import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import Menu from 'components/widgets/menu/menu';

import {ModalData} from 'types/actions';

import * as Utils from 'utils/utils';
import {Team, TeamMembership} from '@mattermost/types/teams';
import {Group, SyncablePatch, SyncableType} from '@mattermost/types/groups';

type Props = {
    intl: IntlShape;
    team: Team;
    actions: {
        getGroupsAssociatedToTeam: (teamID: string, q: string, page: number, perPage: number, filterAllowReference: boolean) => Promise<{
            data: {
                groups: Group[];
                totalGroupCount: number;
                teamID: string;
            };
        }>;
        closeModal: (modalId: string) => void;
        openModal: <P>(modalData: ModalData<P>) => void;
        unlinkGroupSyncable: (groupID: string, syncableID: string, syncableType: SyncableType) => Promise<{
            data: boolean;
        }>;
        patchGroupSyncable: (groupID: string, syncableID: string, syncableType: SyncableType, patch: Partial<SyncablePatch>) => Promise<{
            data: boolean;
        }>;
        getMyTeamMembers: () => Promise<{
            data: TeamMembership[];
        }>;
    };
};

type State = {
    showConfirmModal: boolean;
    item: Group;
    listModal?: ListModal;
}

class TeamGroupsManageModal extends React.PureComponent<Props, State> {
    state = {
        showConfirmModal: false,
        item: {
            member_count: 0,
        },
    } as State;

    loadItems = async (pageNumber: number, searchTerm: string) => {
        const {data} = await this.props.actions.getGroupsAssociatedToTeam(this.props.team.id, searchTerm, pageNumber, DEFAULT_NUM_PER_PAGE, true);

        return {
            items: data.groups,
            totalCount: data.totalGroupCount,
        };
    };

    handleDeleteCanceled = () => {
        this.setState({showConfirmModal: false});
    };

    handleDeleteConfirmed = () => {
        this.setState({showConfirmModal: false});
        const {item, listModal} = this.state;
        this.props.actions.unlinkGroupSyncable(item.id, this.props.team.id, SyncableType.Team).then(async () => {
            if (listModal) {
                listModal.setState({loading: true});
                const {items, totalCount} = await listModal.props.loadItems(listModal.state.page, listModal.state.searchTerm);

                listModal.setState({loading: false, items, totalCount});
            }
        });
    };

    onClickRemoveGroup = (item: Group, listModal: ListModal) => {
        this.setState({showConfirmModal: true, item, listModal});
    };

    onClickConfirmRemoveGroup = (item: Group, listModal: ListModal) => this.props.actions.unlinkGroupSyncable(item.id, this.props.team.id, SyncableType.Team).then(async () => {
        listModal.setState({loading: true});
        const {items, totalCount} = await listModal.props.loadItems(listModal.state.page, listModal.state.searchTerm);
        listModal.setState({loading: false, items, totalCount});
    });

    onHide = () => {
        this.props.actions.closeModal(ModalIdentifiers.MANAGE_TEAM_GROUPS);
    };

    titleButtonOnClick = () => {
        this.onHide();
        this.props.actions.openModal({modalId: ModalIdentifiers.ADD_GROUPS_TO_TEAM, dialogType: AddGroupsToTeamModal});
    };

    setTeamMemberStatus = async (item: Group, listModal: ListModal, isTeamAdmin: boolean) => {
        this.props.actions.patchGroupSyncable(item.id, this.props.team.id, SyncableType.Team, {scheme_admin: isTeamAdmin}).then(async () => {
            listModal.setState({loading: true});
            const {items, totalCount} = await listModal.props.loadItems(listModal.state.page, listModal.state.searchTerm);

            this.props.actions.getMyTeamMembers();

            listModal.setState({loading: false, items, totalCount});
        });
    };

    renderRow = (item: Group, listModal: ListModal) => {
        let title;
        if (item.scheme_admin) {
            title = Utils.localizeMessage('team_members_dropdown.teamAdmins', 'Team Admins');
        } else {
            title = Utils.localizeMessage('team_members_dropdown.teamMembers', 'Team Members');
        }

        return (
            <div
                key={item.id}
                className='more-modal__row'
            >
                <img
                    className='more-modal__image'
                    src={groupsAvatar}
                    alt='group picture'
                    width='32'
                    height='32'
                />
                <div className='more-modal__details'>
                    <div className='more-modal__name'>{item.display_name} {'-'} {'&nbsp;'}
                        <span className='more-modal__name_count'>
                            <FormattedMessage
                                id='numMembers'
                                defaultMessage='{num, number} {num, plural, one {member} other {members}}'
                                values={{
                                    num: item.member_count,
                                }}
                            />
                        </span>
                    </div>
                </div>
                <div className='more-modal__actions'>
                    <MenuWrapper>
                        <button
                            id={`teamGroupsDropdown_${item.display_name}`}
                            className='dropdown-toggle theme color--link style--none'
                            type='button'
                            aria-expanded='true'
                        >
                            <span>{title} </span>
                            <DropdownIcon/>
                        </button>
                        <Menu
                            openLeft={true}
                            ariaLabel={Utils.localizeMessage('team_members_dropdown.menuAriaLabel', 'Change the role of a team member')}
                        >
                            <Menu.ItemAction
                                show={!item.scheme_admin}
                                onClick={() => this.setTeamMemberStatus(item, listModal, true)}
                                text={Utils.localizeMessage('team_members_dropdown.makeTeamAdmins', 'Make Team Admins')}
                            />
                            <Menu.ItemAction
                                show={Boolean(item.scheme_admin)}
                                onClick={() => this.setTeamMemberStatus(item, listModal, false)}
                                text={Utils.localizeMessage('team_members_dropdown.makeTeamMembers', 'Make Team Members')}
                            />
                            <Menu.ItemAction
                                onClick={() => this.onClickRemoveGroup(item, listModal)}
                                text={Utils.localizeMessage('group_list_modal.removeGroupButton', 'Remove Group')}
                            />
                        </Menu>
                    </MenuWrapper>
                </div>
            </div>
        );
    };

    render() {
        const {formatMessage} = this.props.intl;
        const memberCount = this.state.item.member_count;
        return (
            <>
                <ListModal
                    show={!this.state.showConfirmModal}
                    titleText={formatMessage({id: 'groups', defaultMessage: '{team} Groups'}, {team: this.props.team.display_name})}
                    searchPlaceholderText={formatMessage({id: 'manage_team_groups_modal.search_placeholder', defaultMessage: 'Search groups'})}
                    renderRow={this.renderRow}
                    loadItems={this.loadItems}
                    onHide={this.onHide}
                    titleBarButtonText={formatMessage({id: 'group_list_modal.addGroupButton', defaultMessage: 'Add Groups'})}
                    titleBarButtonOnClick={this.titleButtonOnClick}
                />
                <ConfirmModal
                    show={this.state.showConfirmModal}
                    title={formatMessage({id: 'remove_group_confirm_title', defaultMessage: 'Remove Group and {memberCount, number} {memberCount, plural, one {Member} other {Members}}'}, {memberCount})}
                    message={formatMessage({id: 'remove_group_confirm_message', defaultMessage: '{memberCount, number} {memberCount, plural, one {member} other {members}} associated to this group will be removed from the team. Are you sure you wish to remove this group and {memberCount} {memberCount, plural, one {member} other {members}}?'}, {memberCount})}
                    confirmButtonText={formatMessage({id: 'remove_group_confirm_button', defaultMessage: 'Yes, Remove Group and {memberCount, plural, one {Member} other {Members}}'}, {memberCount})}
                    onConfirm={this.handleDeleteConfirmed}
                    onCancel={this.handleDeleteCanceled}
                />
            </>
        );
    }
}

export default injectIntl(TeamGroupsManageModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';
import {connect} from 'react-redux';

import {getGroupsAssociatedToTeam, unlinkGroupSyncable, patchGroupSyncable} from 'mattermost-redux/actions/groups';
import {getMyTeamMembers} from 'mattermost-redux/actions/teams';

import {closeModal, openModal} from 'actions/views/modals';

import {GlobalState} from '@mattermost/types/store';
import {Action} from 'mattermost-redux/types/actions';
import {Group, SyncablePatch, SyncableType} from '@mattermost/types/groups';
import {TeamMembership} from '@mattermost/types/teams';

import {ModalData} from 'types/actions';

import TeamGroupsManageModal from './team_groups_manage_modal';

type OwnProps = {
    teamID: string;
};

const mapStateToProps = (state: GlobalState, ownProps: OwnProps) => {
    return {
        team: state.entities.teams.teams[ownProps.teamID],
    };
};

type Actions = {
    getGroupsAssociatedToTeam: (teamID: string, q: string, page: number, perPage: number, filterAllowReference: boolean) => Promise<{
        data: {
            groups: Group[];
            totalGroupCount: number;
            teamID: string;
        };
    }>;
    closeModal: (modalId: string) => void;
    openModal: <P>(modalData: ModalData<P>) => void;
    unlinkGroupSyncable: (groupID: string, syncableID: string, syncableType: SyncableType) => Promise<{
        data: boolean;
    }>;
    patchGroupSyncable: (groupID: string, syncableID: string, syncableType: SyncableType, patch: Partial<SyncablePatch>) => Promise<{
        data: boolean;
    }>;
    getMyTeamMembers: () => Promise<{
        data: TeamMembership[];
    }>;
}

const mapDispatchToProps = (dispatch: Dispatch) => ({
    actions: bindActionCreators<ActionCreatorsMapObject<Action>, Actions>({
        getGroupsAssociatedToTeam,
        closeModal,
        openModal,
        unlinkGroupSyncable,
        patchGroupSyncable,
        getMyTeamMembers,
    }, dispatch),
});

export default connect(mapStateToProps, mapDispatchToProps)(TeamGroupsManageModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {injectIntl, IntlShape} from 'react-intl';

import {Permissions} from 'mattermost-redux/constants';

import * as GlobalActions from 'actions/global_actions';
import {FREEMIUM_TO_ENTERPRISE_TRIAL_LENGTH_DAYS} from 'utils/cloud_utils';
import {Constants, LicenseSkus, ModalIdentifiers, PaidFeatures} from 'utils/constants';
import {cmdOrCtrlPressed, isKeyPressed} from 'utils/utils';
import {makeUrlSafe} from 'utils/url';
import * as UserAgent from 'utils/user_agent';
import InvitationModal from 'components/invitation_modal';

import TeamPermissionGate from 'components/permissions_gates/team_permission_gate';
import SystemPermissionGate from 'components/permissions_gates/system_permission_gate';

import LeaveTeamIcon from 'components/widgets/icons/leave_team_icon';

import LeaveTeamModal from 'components/leave_team_modal';
import UserSettingsModal from 'components/user_settings/modal';
import TeamMembersModal from 'components/team_members_modal';
import TeamSettingsModal from 'components/team_settings_modal';
import AboutBuildModal from 'components/about_build_modal';
import AddGroupsToTeamModal from 'components/add_groups_to_team_modal';

import Menu from 'components/widgets/menu/menu';
import RestrictedIndicator from 'components/widgets/menu/menu_items/restricted_indicator';
import TeamGroupsManageModal from 'components/team_groups_manage_modal';

import {ModalData} from 'types/actions';
import {PluginComponent} from 'types/store/plugins';
import {UserProfile} from '@mattermost/types/users';

export type Props = {
    mobile: boolean;
    id?: string;
    teamId?: string;
    teamName?: string;
    siteName?: string;
    currentUser?: UserProfile;
    appDownloadLink?: string;
    enableCommands: boolean;
    enableIncomingWebhooks: boolean;
    enableOAuthServiceProvider: boolean;
    enableOutgoingWebhooks: boolean;
    canManageSystemBots: boolean;
    canManageIntegrations: boolean;
    experimentalPrimaryTeam?: string;
    helpLink?: string;
    reportAProblemLink?: string;
    moreTeamsToJoin: boolean;
    pluginMenuItems?: PluginComponent[];
    isMentionSearch?: boolean;
    teamIsGroupConstrained: boolean;
    isLicensedForLDAPGroups?: boolean;
    intl: IntlShape;
    teamUrl: string;
    isFirstAdmin: boolean;
    isCloud: boolean;
    isStarterFree: boolean;
    isFreeTrial: boolean;
    usageDeltaTeams: number;
    location: {
        pathname: string;
    };
    guestAccessEnabled: boolean;
    canInviteTeamMember: boolean;
    actions: {
        openModal: <P>(modalData: ModalData<P>) => void;
        showMentions: () => void;
        showFlaggedPosts: () => void;
        closeRightHandSide: () => void;
        closeRhsMenu: () => void;
    };

};
export class MainMenu extends React.PureComponent<Props> {
    static defaultProps = {
        teamType: '',
        mobile: false,
        pluginMenuItems: [],
    };

    async componentDidMount(): Promise<void> {
        document.addEventListener('keydown', this.handleKeyDown);
    }

    componentWillUnmount(): void {
        document.removeEventListener('keydown', this.handleKeyDown);
    }

    handleKeyDown = (e: KeyboardEvent): void => {
        if (cmdOrCtrlPressed(e) && e.shiftKey && isKeyPressed(e, Constants.KeyCodes.A)) {
            e.preventDefault();
            this.props.actions.openModal({modalId: ModalIdentifiers.USER_SETTINGS, dialogType: UserSettingsModal, dialogProps: {isContentProductSettings: true}});
        }
    }

    handleEmitUserLoggedOutEvent = (): void => {
        GlobalActions.emitUserLoggedOutEvent();
    }

    getFlagged = (e: Event): void => {
        e.preventDefault();
        this.props.actions.showFlaggedPosts();
        this.props.actions.closeRhsMenu();
    }

    searchMentions = (e: Event): void => {
        e.preventDefault();

        if (this.props.isMentionSearch) {
            this.props.actions.closeRightHandSide();
        } else {
            this.props.actions.closeRhsMenu();
            this.props.actions.showMentions();
        }
    }

    render() {
        const {
            appDownloadLink,
            currentUser,
            teamIsGroupConstrained,
            isLicensedForLDAPGroups,
            teamId = '',
            guestAccessEnabled,
            canInviteTeamMember,
        } = this.props;

        const safeAppDownloadLink = makeUrlSafe(appDownloadLink || '');

        if (!currentUser) {
            return null;
        }

        const pluginItems = this.props.pluginMenuItems?.map((item) => (
            <Menu.ItemAction
                id={item.id + '_pluginmenuitem'}
                key={item.id + '_pluginmenuitem'}
                onClick={() => {
                    if (item.action) {
                        item.action();
                    }
                }}
                text={item.text}
                icon={this.props.mobile && item.mobileIcon}
            />
        ));

        const someIntegrationEnabled = this.props.enableIncomingWebhooks || this.props.enableOutgoingWebhooks || this.props.enableCommands || this.props.enableOAuthServiceProvider || this.props.canManageSystemBots;
        const showIntegrations = !this.props.mobile && someIntegrationEnabled && this.props.canManageIntegrations;
        const teamsLimitReached = this.props.isStarterFree && !this.props.isFreeTrial && this.props.usageDeltaTeams >= 0;
        const createTeamRestricted = this.props.isCloud && (this.props.isFreeTrial || teamsLimitReached);

        const {formatMessage} = this.props.intl;

        let invitePeopleModal = null;
        if (guestAccessEnabled || canInviteTeamMember) {
            invitePeopleModal = (
                <Menu.ItemToggleModalRedux
                    id='invitePeople'
                    modalId={ModalIdentifiers.INVITATION}
                    dialogType={InvitationModal}
                    text={formatMessage({
                        id: 'navbar_dropdown.invitePeople',
                        defaultMessage: 'Invite People',
                    })}
                    extraText={formatMessage({
                        id: 'navbar_dropdown.invitePeopleExtraText',
                        defaultMessage: 'Add people to the team',
                    })}
                    icon={this.props.mobile && <i className='fa fa-user-plus'/>}
                />
            );
        }

        return this.props.mobile ? (
            <Menu
                id={this.props.id}
                ariaLabel={formatMessage({id: 'navbar_dropdown.menuAriaLabel', defaultMessage: 'main menu'})}
            >
                <Menu.Group>
                    <SystemPermissionGate
                        permissions={[Permissions.SYSCONSOLE_WRITE_BILLING]}
                    >
                        <Menu.CloudTrial
                            id='menuCloudTrial'
                        />
                    </SystemPermissionGate>
                </Menu.Group>
                <Menu.Group>
                    <SystemPermissionGate
                        permissions={[Permissions.SYSCONSOLE_WRITE_ABOUT_EDITION_AND_LICENSE]}
                    >
                        <Menu.StartTrial
                            id='startTrial'
                        />
                    </SystemPermissionGate>
                </Menu.Group>
                <Menu.Group>
                    <Menu.ItemAction
                        id='recentMentions'
                        onClick={this.searchMentions}
                        icon={<i className='mentions'>{'@'}</i>}
                        text={formatMessage({id: 'sidebar_right_menu.recentMentions', defaultMessage: 'Recent Mentions'})}
                    />
                    <Menu.ItemAction
                        id='flaggedPosts'
                        onClick={this.getFlagged}
                        icon={<i className='fa fa-bookmark'/>}
                        text={formatMessage({id: 'sidebar_right_menu.flagged', defaultMessage: 'Saved Posts'})}
                    />
                </Menu.Group>
                <Menu.Group>
                    <Menu.ItemToggleModalRedux
                        id='profileSettings'
                        modalId={ModalIdentifiers.USER_SETTINGS}
                        dialogType={UserSettingsModal}
                        dialogProps={{isContentProductSettings: false}}
                        text={formatMessage({id: 'navbar_dropdown.profileSettings', defaultMessage: 'Profile'})}
                        icon={<i className='fa fa-user'/>}
                    />
                    <Menu.ItemToggleModalRedux
                        id='accountSettings'
                        modalId={ModalIdentifiers.USER_SETTINGS}
                        dialogType={UserSettingsModal}
                        dialogProps={{isContentProductSettings: true}}
                        text={formatMessage({id: 'navbar_dropdown.accountSettings', defaultMessage: 'Settings'})}
                        icon={<i className='fa fa-cog'/>}
                    />
                </Menu.Group>
                <Menu.Group>
                    <TeamPermissionGate
                        teamId={teamId}
                        permissions={[Permissions.MANAGE_TEAM]}
                    >
                        <Menu.ItemToggleModalRedux
                            id='addGroupsToTeam'
                            show={teamIsGroupConstrained && isLicensedForLDAPGroups}
                            modalId={ModalIdentifiers.ADD_GROUPS_TO_TEAM}
                            dialogType={AddGroupsToTeamModal}
                            text={formatMessage({id: 'navbar_dropdown.addGroupsToTeam', defaultMessage: 'Add Groups to Team'})}
                            icon={<i className='fa fa-user-plus'/>}
                        />
                    </TeamPermissionGate>
                    <TeamPermissionGate
                        teamId={teamId}
                        permissions={[Permissions.ADD_USER_TO_TEAM, Permissions.INVITE_GUEST]}
                    >
                        {invitePeopleModal}
                    </TeamPermissionGate>
                </Menu.Group>
                <Menu.Group>
                    <TeamPermissionGate
                        teamId={teamId}
                        permissions={[Permissions.MANAGE_TEAM]}
                    >
                        <Menu.ItemToggleModalRedux
                            id='teamSettings'
                            modalId={ModalIdentifiers.TEAM_SETTINGS}
                            dialogType={TeamSettingsModal}
                            text={formatMessage({id: 'navbar_dropdown.teamSettings', defaultMessage: 'Team Settings'})}
                            icon={<i className='fa fa-globe'/>}
                        />
                    </TeamPermissionGate>
                    <TeamPermissionGate
                        teamId={teamId}
                        permissions={[Permissions.MANAGE_TEAM]}
                    >
                        <Menu.ItemToggleModalRedux
                            id='manageGroups'
                            show={teamIsGroupConstrained && isLicensedForLDAPGroups}
                            modalId={ModalIdentifiers.MANAGE_TEAM_GROUPS}
                            dialogProps={{
                                teamID: teamId,
                            }}
                            dialogType={TeamGroupsManageModal}
                            text={formatMessage({id: 'navbar_dropdown.manageGroups', defaultMessage: 'Manage Groups'})}
                            icon={<i className='fa fa-user-plus'/>}
                        />
                    </TeamPermissionGate>
                    <TeamPermissionGate
                        teamId={teamId}
                        permissions={[Permissions.REMOVE_USER_FROM_TEAM, Permissions.MANAGE_TEAM_ROLES]}
                    >
                        <Menu.ItemToggleModalRedux
                            id='manageMembers'
                            modalId={ModalIdentifiers.TEAM_MEMBERS}
                            dialogType={TeamMembersModal}
                            text={formatMessage({id: 'navbar_dropdown.manageMembers', defaultMessage: 'Manage Members'})}
                            icon={<i className='fa fa-users'/>}
                        />
                    </TeamPermissionGate>
                    <TeamPermissionGate
                        teamId={teamId}
                        permissions={[Permissions.REMOVE_USER_FROM_TEAM, Permissions.MANAGE_TEAM_ROLES]}
                        invert={true}
                    >
                        <Menu.ItemToggleModalRedux
                            id='viewMembers'
                            modalId={ModalIdentifiers.TEAM_MEMBERS}
                            dialogType={TeamMembersModal}
                            text={formatMessage({id: 'navbar_dropdown.viewMembers', defaultMessage: 'View Members'})}
                            icon={<i className='fa fa-users'/>}
                        />
                    </TeamPermissionGate>
                </Menu.Group>
                <Menu.Group>
                    <SystemPermissionGate permissions={[Permissions.CREATE_TEAM]}>
                        <Menu.ItemLink
                            id='createTeam'
                            show={!teamsLimitReached}
                            to='/create_team'
                            text={formatMessage({id: 'navbar_dropdown.create', defaultMessage: 'Create a Team'})}
                            icon={<i className='fa fa-plus-square'/>}
                        />
                    </SystemPermissionGate>
                    <Menu.ItemLink
                        id='joinTeam'
                        show={!this.props.experimentalPrimaryTeam && this.props.moreTeamsToJoin}
                        to='/select_team'
                        text={formatMessage({id: 'navbar_dropdown.join', defaultMessage: 'Join Another Team'})}
                        icon={<i className='fa fa-plus-square'/>}
                    />
                    <Menu.ItemToggleModalRedux
                        id='leaveTeam'
                        show={!teamIsGroupConstrained && this.props.experimentalPrimaryTeam !== this.props.teamName}
                        modalId={ModalIdentifiers.LEAVE_TEAM}
                        dialogType={LeaveTeamModal}
                        text={formatMessage({id: 'navbar_dropdown.leave', defaultMessage: 'Leave Team'})}
                        icon={<LeaveTeamIcon/>}
                    />
                </Menu.Group>
                <Menu.Group>
                    {pluginItems}
                </Menu.Group>
                <Menu.Group>
                    <Menu.ItemLink
                        id='integrations'
                        show={showIntegrations}
                        to={'/' + this.props.teamName + '/integrations'}
                        text={formatMessage({id: 'navbar_dropdown.integrations', defaultMessage: 'Integrations'})}
                    />
                </Menu.Group>
                <Menu.Group>
                    <Menu.ItemExternalLink
                        id='helpLink'
                        show={Boolean(this.props.helpLink)}
                        url={this.props.helpLink}
                        text={formatMessage({id: 'navbar_dropdown.help', defaultMessage: 'Help'})}
                        icon={<i className='fa fa-question'/>}
                    />
                    <Menu.ItemExternalLink
                        id='reportLink'
                        show={Boolean(this.props.reportAProblemLink)}
                        url={this.props.reportAProblemLink}
                        text={formatMessage({id: 'navbar_dropdown.report', defaultMessage: 'Report a Problem'})}
                        icon={<i className='fa fa-phone'/>}
                    />
                    <Menu.ItemExternalLink
                        id='nativeAppLink'
                        show={this.props.appDownloadLink && !UserAgent.isMobileApp()}
                        url={safeAppDownloadLink}
                        text={formatMessage({id: 'navbar_dropdown.nativeApps', defaultMessage: 'Download Apps'})}
                        icon={<i className='fa fa-mobile'/>}
                    />
                    <Menu.ItemToggleModalRedux
                        id='about'
                        modalId={ModalIdentifiers.ABOUT}
                        dialogType={AboutBuildModal}
                        text={formatMessage({id: 'navbar_dropdown.about', defaultMessage: 'About {appTitle}'}, {appTitle: this.props.siteName || 'Mattermost'})}
                        icon={<i className='fa fa-info'/>}
                    />
                </Menu.Group>
                <Menu.Group>
                    <Menu.ItemAction
                        id='logout'
                        onClick={this.handleEmitUserLoggedOutEvent}
                        text={formatMessage({id: 'navbar_dropdown.logout', defaultMessage: 'Log Out'})}
                        icon={<i className='fa fa-sign-out'/>}
                    />
                </Menu.Group>
            </Menu>
        ) : (
            <Menu
                id={this.props.id}
                ariaLabel={formatMessage({id: 'sidebar.team_menu.menuAriaLabel', defaultMessage: 'team menu'})}
            >
                <Menu.Group>
                    <TeamPermissionGate
                        teamId={teamId}
                        permissions={[Permissions.MANAGE_TEAM]}
                    >
                        <Menu.ItemToggleModalRedux
                            id='addGroupsToTeam'
                            show={teamIsGroupConstrained && isLicensedForLDAPGroups}
                            modalId={ModalIdentifiers.ADD_GROUPS_TO_TEAM}
                            dialogType={AddGroupsToTeamModal}
                            text={formatMessage({id: 'navbar_dropdown.addGroupsToTeam', defaultMessage: 'Add Groups to Team'})}
                        />
                    </TeamPermissionGate>
                    <TeamPermissionGate
                        teamId={teamId}
                        permissions={[Permissions.ADD_USER_TO_TEAM, Permissions.INVITE_GUEST]}
                    >
                        {invitePeopleModal}
                    </TeamPermissionGate>
                    <TeamPermissionGate
                        teamId={teamId}
                        permissions={[Permissions.MANAGE_TEAM]}
                    >
                        <Menu.ItemToggleModalRedux
                            id='teamSettings'
                            modalId={ModalIdentifiers.TEAM_SETTINGS}
                            dialogType={TeamSettingsModal}
                            text={formatMessage({id: 'navbar_dropdown.teamSettings', defaultMessage: 'Team Settings'})}
                        />
                    </TeamPermissionGate>
                    <TeamPermissionGate
                        teamId={teamId}
                        permissions={[Permissions.MANAGE_TEAM]}
                    >
                        <Menu.ItemToggleModalRedux
                            id='manageGroups'
                            show={teamIsGroupConstrained && isLicensedForLDAPGroups}
                            modalId={ModalIdentifiers.MANAGE_TEAM_GROUPS}
                            dialogProps={{teamID: teamId}}
                            dialogType={TeamGroupsManageModal}
                            text={formatMessage({id: 'navbar_dropdown.manageGroups', defaultMessage: 'Manage Groups'})}
                        />
                    </TeamPermissionGate>
                    <TeamPermissionGate
                        teamId={teamId}
                        permissions={[Permissions.REMOVE_USER_FROM_TEAM, Permissions.MANAGE_TEAM_ROLES]}
                    >
                        <Menu.ItemToggleModalRedux
                            id='manageMembers'
                            modalId={ModalIdentifiers.TEAM_MEMBERS}
                            dialogType={TeamMembersModal}
                            text={formatMessage({id: 'navbar_dropdown.manageMembers', defaultMessage: 'Manage Members'})}
                        />
                    </TeamPermissionGate>
                    <TeamPermissionGate
                        teamId={teamId}
                        permissions={[Permissions.REMOVE_USER_FROM_TEAM, Permissions.MANAGE_TEAM_ROLES]}
                        invert={true}
                    >
                        <Menu.ItemToggleModalRedux
                            id='viewMembers'
                            modalId={ModalIdentifiers.TEAM_MEMBERS}
                            dialogType={TeamMembersModal}
                            text={formatMessage({id: 'navbar_dropdown.viewMembers', defaultMessage: 'View Members'})}
                        />
                    </TeamPermissionGate>
                    <Menu.ItemLink
                        id='joinTeam'
                        show={!this.props.experimentalPrimaryTeam && this.props.moreTeamsToJoin}
                        to='/select_team'
                        text={formatMessage({id: 'navbar_dropdown.join', defaultMessage: 'Join Another Team'})}
                    />
                    <Menu.ItemToggleModalRedux
                        id='leaveTeam'
                        className='destructive'
                        show={!teamIsGroupConstrained && this.props.experimentalPrimaryTeam !== this.props.teamName}
                        modalId={ModalIdentifiers.LEAVE_TEAM}
                        dialogType={LeaveTeamModal}
                        text={formatMessage({id: 'navbar_dropdown.leave', defaultMessage: 'Leave Team'})}
                    />
                </Menu.Group>
                <Menu.Group>
                    <SystemPermissionGate permissions={[Permissions.CREATE_TEAM]}>
                        <Menu.ItemLink
                            id='createTeam'
                            to='/create_team'
                            className={createTeamRestricted ? 'MenuItem__with-icon-tooltip' : ''}
                            disabled={teamsLimitReached}
                            text={formatMessage({id: 'navbar_dropdown.create', defaultMessage: 'Create a Team'})}
                            sibling={createTeamRestricted && (
                                <RestrictedIndicator
                                    feature={PaidFeatures.CREATE_MULTIPLE_TEAMS}
                                    minimumPlanRequiredForFeature={LicenseSkus.Professional}
                                    blocked={!this.props.isFreeTrial}
                                    tooltipMessage={formatMessage({
                                        id: 'navbar_dropdown.create.tooltip.cloudFreeTrial',
                                        defaultMessage: 'During your trial you are able to create multiple teams. These teams will be archived after your trial.',
                                    })}
                                    titleAdminPreTrial={formatMessage({
                                        id: 'navbar_dropdown.create.modal.titleAdminPreTrial',
                                        defaultMessage: 'Try unlimited teams with a free trial',
                                    })}
                                    messageAdminPreTrial={formatMessage({
                                        id: 'navbar_dropdown.create.modal.messageAdminPreTrial',
                                        defaultMessage: 'Create unlimited teams with one of our paid plans. Get the full experience of Enterprise when you start a free, {trialLength} day trial.',
                                    },
                                    {
                                        trialLength: FREEMIUM_TO_ENTERPRISE_TRIAL_LENGTH_DAYS,
                                    },
                                    )}
                                    titleAdminPostTrial={formatMessage({
                                        id: 'navbar_dropdown.create.modal.titleAdminPostTrial',
                                        defaultMessage: 'Upgrade to create unlimited teams',
                                    })}
                                    messageAdminPostTrial={formatMessage({
                                        id: 'navbar_dropdown.create.modal.messageAdminPostTrial',
                                        defaultMessage: 'Multiple teams allow for context-specific spaces that are more attuned to your and your teams needs. Upgrade to the Professional plan to create unlimited teams.',
                                    })}
                                    titleEndUser={formatMessage({
                                        id: 'navbar_dropdown.create.modal.titleEndUser',
                                        defaultMessage: 'Multiple teams available in paid plans',
                                    })}
                                    messageEndUser={formatMessage({
                                        id: 'navbar_dropdown.create.modal.messageEndUser',
                                        defaultMessage: 'Multiple teams allow for context-specific spaces that are more attuned to your teams needs.',
                                    })}
                                />
                            )}
                        />
                    </SystemPermissionGate>
                </Menu.Group>
                <Menu.Group>
                    {pluginItems}
                </Menu.Group>
            </Menu>
        );
    }
}

export default injectIntl(MainMenu);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';
import {withRouter} from 'react-router-dom';

import {GenericAction} from 'mattermost-redux/types/actions';

import {
    getConfig,
    getLicense,
} from 'mattermost-redux/selectors/entities/general';
import {
    getJoinableTeamIds,
    getCurrentTeam,
    getCurrentRelativeTeamUrl,
} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentUser, isFirstAdmin} from 'mattermost-redux/selectors/entities/users';
import {haveICurrentTeamPermission, haveISystemPermission} from 'mattermost-redux/selectors/entities/roles';
import {getCloudSubscription as selectCloudSubscription, getSubscriptionProduct} from 'mattermost-redux/selectors/entities/cloud';

import {Permissions} from 'mattermost-redux/constants';

import {RHSStates, CloudProducts} from 'utils/constants';

import {showMentions, showFlaggedPosts, closeRightHandSide, closeMenu as closeRhsMenu} from 'actions/views/rhs';
import {openModal} from 'actions/views/modals';
import {getRhsState} from 'selectors/rhs';
import {isCloudLicense} from 'utils/license_utils';

import {GlobalState} from 'types/store';

import MainMenu from './main_menu';

function mapStateToProps(state: GlobalState) {
    const config = getConfig(state);
    const currentTeam = getCurrentTeam(state);
    const currentUser = getCurrentUser(state);

    const appDownloadLink = config.AppDownloadLink;
    const enableCommands = config.EnableCommands === 'true';
    const siteName = config.SiteName;
    const enableIncomingWebhooks = config.EnableIncomingWebhooks === 'true';
    const enableOAuthServiceProvider = config.EnableOAuthServiceProvider === 'true';
    const enableOutgoingWebhooks = config.EnableOutgoingWebhooks === 'true';
    const experimentalPrimaryTeam = config.ExperimentalPrimaryTeam;
    const helpLink = config.HelpLink;
    const reportAProblemLink = config.ReportAProblemLink;

    const canManageTeamIntegrations = (haveICurrentTeamPermission(state, Permissions.MANAGE_SLASH_COMMANDS) || haveICurrentTeamPermission(state, Permissions.MANAGE_OAUTH) || haveICurrentTeamPermission(state, Permissions.MANAGE_INCOMING_WEBHOOKS) || haveICurrentTeamPermission(state, Permissions.MANAGE_OUTGOING_WEBHOOKS));
    const canManageSystemBots = (haveISystemPermission(state, {permission: Permissions.MANAGE_BOTS}) || haveISystemPermission(state, {permission: Permissions.MANAGE_OTHERS_BOTS}));
    const canManageIntegrations = canManageTeamIntegrations || canManageSystemBots;
    const canInviteTeamMember = haveICurrentTeamPermission(state, Permissions.ADD_USER_TO_TEAM);

    const joinableTeams = getJoinableTeamIds(state);
    const moreTeamsToJoin = joinableTeams && joinableTeams.length > 0;
    const rhsState = getRhsState(state);

    const subscription = selectCloudSubscription(state);
    const license = getLicense(state);
    const subscriptionProduct = getSubscriptionProduct(state);

    const isCloud = isCloudLicense(license);
    const isStarterFree = isCloud && subscriptionProduct?.sku === CloudProducts.STARTER;
    const isFreeTrial = isCloud && subscription?.is_free_trial === 'true';

    return {
        appDownloadLink,
        enableCommands,
        canManageIntegrations,
        enableIncomingWebhooks,
        enableOAuthServiceProvider,
        enableOutgoingWebhooks,
        canManageSystemBots,
        experimentalPrimaryTeam,
        helpLink,
        reportAProblemLink,
        pluginMenuItems: state.plugins.components.MainMenu,
        moreTeamsToJoin,
        siteName,
        teamId: currentTeam.id,
        teamName: currentTeam.name,
        currentUser,
        isMentionSearch: rhsState === RHSStates.MENTION,
        teamIsGroupConstrained: Boolean(currentTeam.group_constrained),
        isLicensedForLDAPGroups: state.entities.general.license.LDAPGroups === 'true',
        teamUrl: getCurrentRelativeTeamUrl(state),
        guestAccessEnabled: config.EnableGuestAccounts === 'true',
        canInviteTeamMember,
        isFirstAdmin: isFirstAdmin(state),
        isCloud,
        isStarterFree,
        isFreeTrial,
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            openModal,
            showMentions,
            showFlaggedPosts,
            closeRightHandSide,
            closeRhsMenu,
        }, dispatch),
    };
}

export default withRouter<any, any>(connect(mapStateToProps, mapDispatchToProps)(MainMenu));

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {Team} from '@mattermost/types/teams';
import {PostImage, PostType} from '@mattermost/types/posts';

import messageHtmlToComponent from 'utils/message_html_to_component';
import EmojiMap from 'utils/emoji_map';
import {ChannelNamesMap, TextFormattingOptions, formatText, MentionKey} from 'utils/text_formatting';
import PostEditedIndicator from '../post_view/post_edited_indicator';

type Props = {

    /*
     * An object mapping channel names to channels for the current team
     */
    channelNamesMap?: ChannelNamesMap;

    /*
     * An array of URL schemes that should be turned into links. Anything that looks
     * like a link will be turned into a link if this is not provided.
     */
    autolinkedUrlSchemes?: string[];

    /*
     * Whether or not to do Markdown rendering
     */
    enableFormatting?: boolean;

    /*
     * Whether or not this text is part of the RHS
     */
    isRHS?: boolean;

    /*
     * An array of paths on the server that are managed by another server
     */
    managedResourcePaths?: string[];

    /*
     * An array of words that can be used to mention a user
     */
    mentionKeys?: MentionKey[];

    /*
     * The text to be rendered
     */
    message: string;

    /*
     * Any additional text formatting options to be used
     */
    options: Partial<TextFormattingOptions>;

    /*
     * The root Site URL for the page
     */
    siteURL?: string;

    /*
     * The current team
     */
    team?: Team;

    /**
     * If an image proxy is enabled.
     */
    hasImageProxy?: boolean;

    /**
     * Minimum number of characters in a hashtag.
     */
    minimumHashtagLength?: number;

    /**
     * Whether or not to proxy image URLs
     */
    proxyImages?: boolean;

    /**
     * Any extra props that should be passed into the image component
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    imageProps?: object;

    /**
     * prop for passed down to image component for dimensions
     */
    imagesMetadata?: Record<string, PostImage>;

    /**
     * Whether or not to place the LinkTooltip component inside links
     */
    hasPluginTooltips?: boolean;

    /**
     * Post id prop passed down to markdown image
     */
    postId?: string;

    /**
     * When the post is edited this is the timestamp it happened at
     */
    editedAt?: number;

    channelId?: string;

    /**
     * Post id prop passed down to markdown image
     */
    postType?: PostType;
    emojiMap: EmojiMap;

    /**
     * Some components processed by messageHtmlToComponent e.g. AtSumOfMembersMention require to have a list of userIds
     */
    userIds?: string[];

    /**
     * Some additional data to pass down to rendered component to aid in rendering decisions
     */
    messageMetadata?: Record<string, string>;
}

export default class Markdown extends React.PureComponent<Props> {
    static defaultProps: Partial<Props> = {
        options: {},
        isRHS: false,
        proxyImages: true,
        imagesMetadata: {},
        postId: '', // Needed to avoid proptypes console errors for cases like channel header, which doesn't have a proper value
        editedAt: 0,
    }

    render() {
        const {postId, editedAt, message, enableFormatting} = this.props;
        if (message === '' || !enableFormatting) {
            return (
                <span>
                    {message}
                    <PostEditedIndicator
                        postId={postId}
                        editedAt={editedAt}
                    />
                </span>
            );
        }

        const options = Object.assign({
            autolinkedUrlSchemes: this.props.autolinkedUrlSchemes,
            siteURL: this.props.siteURL,
            mentionKeys: this.props.mentionKeys,
            atMentions: true,
            channelNamesMap: this.props.channelNamesMap,
            proxyImages: this.props.hasImageProxy && this.props.proxyImages,
            team: this.props.team,
            minimumHashtagLength: this.props.minimumHashtagLength,
            managedResourcePaths: this.props.managedResourcePaths,
            editedAt,
            postId,
        }, this.props.options);

        const htmlFormattedText = formatText(message, options, this.props.emojiMap);

        return messageHtmlToComponent(htmlFormattedText, this.props.isRHS, {
            imageProps: this.props.imageProps,
            imagesMetadata: this.props.imagesMetadata,
            hasPluginTooltips: this.props.hasPluginTooltips,
            postId: this.props.postId,
            userIds: this.props.userIds,
            messageMetadata: this.props.messageMetadata,
            channelId: this.props.channelId,
            postType: this.props.postType,
            mentionHighlight: this.props.options.mentionHighlight,
            disableGroupHighlight: this.props.options.disableGroupHighlight,
            editedAt,
            atSumOfMembersMentions: this.props.options.atSumOfMembersMentions,
            atPlanMentions: this.props.options.atPlanMentions,
        });
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {createSelector} from 'reselect';

import {Preferences} from 'mattermost-redux/constants';
import {getChannelNameToDisplayNameMap} from 'mattermost-redux/selectors/entities/channels';
import {getAutolinkedUrlSchemes, getConfig, getManagedResourcePaths} from 'mattermost-redux/selectors/entities/general';
import {getBool} from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';
import {getAllUserMentionKeys} from 'mattermost-redux/selectors/entities/search';

import {GlobalState} from '@mattermost/types/store';

import {getEmojiMap} from 'selectors/emojis';
import {getSiteURL} from 'utils/url';
import {ChannelNamesMap, MentionKey} from 'utils/text_formatting';

import {getPost} from 'mattermost-redux/selectors/entities/posts';

import Markdown from './markdown';

type Props = {
    channelNamesMap?: ChannelNamesMap;
    mentionKeys?: MentionKey[];
    postId?: string;
}

function makeGetChannelNamesMap() {
    return createSelector(
        'makeGetChannelNamesMap',
        getChannelNameToDisplayNameMap,
        (state: GlobalState, props: Props) => props && props.channelNamesMap,
        (channelNamesMap, channelMentions) => {
            if (channelMentions) {
                return Object.assign({}, channelMentions, channelNamesMap);
            }

            return channelNamesMap;
        },
    );
}

function makeMapStateToProps() {
    const getChannelNamesMap = makeGetChannelNamesMap();

    return function mapStateToProps(state: GlobalState, ownProps: Props) {
        const config = getConfig(state);

        let channelId;
        if (ownProps.postId) {
            channelId = getPost(state, ownProps.postId)?.channel_id;
        }

        return {
            autolinkedUrlSchemes: getAutolinkedUrlSchemes(state),
            channelNamesMap: getChannelNamesMap(state, ownProps),
            enableFormatting: getBool(state, Preferences.CATEGORY_ADVANCED_SETTINGS, 'formatting', true),
            managedResourcePaths: getManagedResourcePaths(state),
            mentionKeys: ownProps.mentionKeys || getAllUserMentionKeys(state),
            siteURL: getSiteURL(),
            team: getCurrentTeam(state),
            hasImageProxy: config.HasImageProxy === 'true',
            minimumHashtagLength: parseInt(config.MinimumHashtagLength || '', 10),
            emojiMap: getEmojiMap(state),
            channelId,
        };
    };
}

export default connect(makeMapStateToProps)(Markdown);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

type Modal = {
    open: boolean;
    dialogProps: Record<string, any>;
    dialogType: React.ComponentType;
}

type Props = {

    /*
     * Object that has map of modal's id and element
     */
    modals: {
        modalState: {
            [modalId: string]: Modal;
        };
    };

    /*
     * Object with action creators
     */
    actions: {

        /*
         * Action creator to close modal
         */
        closeModal: (modalId: string) => void;
    };
}

export default class ModalController extends React.PureComponent<Props> {
    public render(): React.ReactNode {
        const {modals, ...props} = this.props;
        const {modalState} = modals;

        if (!modals) {
            return null;
        }

        const modalOutput = [];

        for (const modalId in modalState) {
            if (modalState.hasOwnProperty(modalId)) {
                const modal = modalState[modalId];
                if (modal.open) {
                    const modalComponent = React.createElement(modal.dialogType, Object.assign({}, modal.dialogProps, {
                        onExited: () => {
                            props.actions.closeModal(modalId);

                            // Call any onExited prop provided by whoever opened the modal, if one was provided
                            modal.dialogProps?.onExited?.();
                        },
                        onHide: props.actions.closeModal.bind(this, modalId),
                        key: `${modalId}_modal`,
                    }));

                    modalOutput.push(modalComponent);
                }
            }
        }

        return (
            <>{modalOutput}</>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {GlobalState} from 'types/store/index.js';

import {Action, GenericAction} from 'mattermost-redux/types/actions.js';

import {closeModal} from 'actions/views/modals';

import ModalController from './modal_controller';

function mapStateToProps(state: GlobalState) {
    return {
        modals: state.views.modals,
    };
}

type Actions = {
    closeModal: (modalId: string) => void;
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, Actions>({
            closeModal,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(ModalController);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {Channel} from '@mattermost/types/channels';
import {UserProfile} from '@mattermost/types/users';

import {Value} from 'components/multiselect/multiselect';

// Not to be confused with the GroupChannel type used for LDAP groups
export type GroupChannel = Channel & {
    profiles: UserProfile[];
}

export function isGroupChannel(option: UserProfile | GroupChannel): option is GroupChannel {
    return (option as GroupChannel)?.type === 'G';
}

export type Option = (UserProfile & {last_post_at?: number}) | GroupChannel;

export type OptionValue = Option & Value;

export function optionValue(option: Option): OptionValue {
    return {
        value: option.id,
        label: isGroupChannel(option) ? option.display_name : option.username,
        ...option,
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {Client4} from 'mattermost-redux/client';

import {isGuest} from 'mattermost-redux/utils/user_utils';

import {UserProfile} from '@mattermost/types/users';

import CustomStatusEmoji from 'components/custom_status/custom_status_emoji';
import BotBadge from 'components/widgets/badges/bot_badge';
import GuestBadge from 'components/widgets/badges/guest_badge';
import ProfilePicture from 'components/profile_picture';

import {displayEntireNameForUser} from 'utils/utils';

type Props = {
    currentUserId: string;
    option: UserProfile;
    status: string;
};

export default function UserDetails(props: Props): JSX.Element {
    const {currentUserId, option, status} = props;
    const {
        id,
        delete_at: deleteAt,
        is_bot: isBot = false,
        last_picture_update: lastPictureUpdate,
    } = option;

    const displayName = displayEntireNameForUser(option);

    let modalName: React.ReactNode = displayName;
    if (option.id === currentUserId) {
        modalName = (
            <FormattedMessage
                id='more_direct_channels.directchannel.you'
                defaultMessage='{displayname} (you)'
                values={{
                    displayname: displayName,
                }}
            />
        );
    } else if (option.delete_at) {
        modalName = (
            <FormattedMessage
                id='more_direct_channels.directchannel.deactivated'
                defaultMessage='{displayname} - Deactivated'
                values={{
                    displayname: displayName,
                }}
            />
        );
    }

    return (
        <>
            <ProfilePicture
                src={Client4.getProfilePictureUrl(id, lastPictureUpdate)}
                status={!deleteAt && !isBot ? status : undefined}
                size='md'
            />
            <div className='more-modal__details'>
                <div className='more-modal__name'>
                    {modalName}
                    <BotBadge
                        show={isBot}
                        className='badge-popoverlist'
                    />
                    <GuestBadge
                        show={isGuest(option.roles)}
                        className='badge-popoverlist'
                    />
                    <CustomStatusEmoji
                        userID={option.id}
                        showTooltip={true}
                        emojiSize={15}
                    />
                </div>
                {!isBot && (
                    <div className='more-modal__description'>
                        {option.email}
                    </div>
                )}
            </div>
        </>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getCurrentUserId, getStatusForUserId} from 'mattermost-redux/selectors/entities/users';

import {UserProfile} from '@mattermost/types/users';

import {GlobalState} from 'types/store';

import UserDetails from './user_details';

type OwnProps = {
    option: UserProfile;
}

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    return {
        currentUserId: getCurrentUserId(state),
        status: getStatusForUserId(state, ownProps.option.id),
    };
}

export default connect(mapStateToProps)(UserDetails);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import classNames from 'classnames';
import React, {useCallback} from 'react';

import Timestamp from 'components/timestamp';
import AddIcon from 'components/widgets/icons/fa_add_icon';

import {
    GroupChannel,
    isGroupChannel,
    OptionValue,
} from '../types';

import UserDetails from './user_details';

const TIME_SPEC: React.ComponentProps<typeof Timestamp> = {
    useTime: false,
    style: 'long',
    ranges: [
        {within: ['minute', -1], display: ['second', 0]},
        {within: ['hour', -1], display: ['minute']},
        {within: ['hour', -24], display: ['hour']},
        {within: ['day', -30], display: ['day']},
        {within: ['month', -11], display: ['month']},
        {within: ['year', -1000], display: ['year']},
    ],
};

export type Props = {
    option: OptionValue;
    isMobileView: boolean;
    isSelected: boolean;
    add: (value: OptionValue) => void;
    select: (value: OptionValue) => void;
}

const ListItem = React.forwardRef((props: Props, ref?: React.Ref<HTMLDivElement>) => {
    const {
        option,
        isMobileView,
        isSelected,
        add,
        select,
    } = props;

    const {last_post_at: lastPostAt} = option;

    let details;
    if (isGroupChannel(option)) {
        details = <GMDetails option={option}/>;
    } else {
        details = <UserDetails option={option}/>;
    }

    const handleClick = useCallback(() => add(option), [option, add]);
    const handleMouseEnter = useCallback(() => select(option), [option, select]);

    return (
        <div
            ref={ref}
            className={classNames('more-modal__row clickable', {'more-modal__row--selected': isSelected})}
            onClick={handleClick}
            onMouseEnter={handleMouseEnter}
        >
            {details}

            {isMobileView && Boolean(lastPostAt) &&
                <div className='more-modal__lastPostAt'>
                    <Timestamp
                        {...TIME_SPEC}
                        value={lastPostAt}
                    />
                </div>
            }

            <div className='more-modal__actions'>
                <div className='more-modal__actions--round'>
                    <AddIcon/>
                </div>
            </div>
        </div>
    );
});
ListItem.displayName = 'ListItem';

export default ListItem;

function GMDetails(props: {option: GroupChannel}) {
    const {option} = props;

    return (
        <>
            <div className='more-modal__gm-icon bg-text-200'>
                {option.profiles.length}
            </div>
            <div className='more-modal__details'>
                <div className='more-modal__name'>
                    <span>
                        {option.profiles.map((profile) => `@${profile.username}`).join(', ')}
                    </span>
                </div>
            </div>
        </>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getIsMobileView} from 'selectors/views/browser';

import {GlobalState} from 'types/store';

import ListItem from './list_item';

function mapStateToProps(state: GlobalState) {
    return {
        isMobileView: getIsMobileView(state),
    };
}

export default connect(mapStateToProps)(ListItem);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useMemo} from 'react';
import {FormattedMessage, useIntl} from 'react-intl';

import MultiSelect from 'components/multiselect/multiselect';
import Constants from 'utils/constants';

import {UserProfile} from '@mattermost/types/users';

import ListItem from '../list_item';
import {Option, optionValue, OptionValue} from '../types';

const MAX_SELECTABLE_VALUES = Constants.MAX_USERS_IN_GM - 1;
export const USERS_PER_PAGE = 50;

type Props = {
    addValue: (value: OptionValue) => void;
    currentUserId: string;
    handleDelete: (values: OptionValue[]) => void;
    handlePageChange: (page: number, prevPage: number) => void;
    handleSubmit: (values?: OptionValue[]) => void;
    isExistingChannel: boolean;
    loading: boolean;
    options: Option[];
    saving: boolean;
    search: (term: string) => void;
    selectedItemRef: React.RefObject<HTMLDivElement>;
    totalCount: number;
    users: UserProfile[];

    /**
     * An array of values that have been selected by the user in the multiselect.
     */
    values: OptionValue[];
}

const List = React.forwardRef((props: Props, ref?: React.Ref<MultiSelect<OptionValue>>) => {
    const renderOptionValue = useCallback((
        option: OptionValue,
        isSelected: boolean,
        add: (value: OptionValue) => void,
        select: (value: OptionValue) => void,
    ) => {
        return (
            <ListItem
                ref={isSelected ? props.selectedItemRef : undefined}
                key={'more_direct_channels_list_' + option.value}
                option={option}
                isSelected={isSelected}
                add={add}
                select={select}
            />
        );
    }, [props.selectedItemRef]);

    const handleSubmitImmediatelyOn = useCallback((value: OptionValue) => {
        return value.id === props.currentUserId || Boolean(value.delete_at);
    }, [props.currentUserId]);

    const intl = useIntl();

    let note;
    if (props.isExistingChannel) {
        if (props.values.length >= MAX_SELECTABLE_VALUES) {
            note = (
                <FormattedMessage
                    id='more_direct_channels.new_convo_note.full'
                    defaultMessage={'You\'ve reached the maximum number of people for this conversation. Consider creating a private channel instead.'}
                />
            );
        } else {
            note = (
                <FormattedMessage
                    id='more_direct_channels.new_convo_note'
                    defaultMessage={'This will start a new conversation. If you\'re adding a lot of people, consider creating a private channel instead.'}
                />
            );
        }
    }

    const options = useMemo(() => {
        return props.options.map(optionValue);
    }, [props.options]);

    return (
        <MultiSelect<OptionValue>
            ref={ref}
            options={options}
            optionRenderer={renderOptionValue}
            selectedItemRef={props.selectedItemRef}
            values={props.values}
            valueRenderer={renderValue}
            ariaLabelRenderer={renderAriaLabel}
            perPage={USERS_PER_PAGE}
            handlePageChange={props.handlePageChange}
            handleInput={props.search}
            handleDelete={props.handleDelete}
            handleAdd={props.addValue}
            handleSubmit={props.handleSubmit}
            noteText={note}
            maxValues={MAX_SELECTABLE_VALUES}
            numRemainingText={
                <FormattedMessage
                    id='multiselect.numPeopleRemaining'
                    defaultMessage='Use  to browse,  to select. You can add {num, number} more {num, plural, one {person} other {people}}. '
                    values={{
                        num: MAX_SELECTABLE_VALUES - props.values.length,
                    }}
                />
            }
            buttonSubmitText={
                <FormattedMessage
                    id='multiselect.go'
                    defaultMessage='Go'
                />
            }
            buttonSubmitLoadingText={
                <FormattedMessage
                    id='multiselect.loading'
                    defaultMessage='Loading...'
                />
            }
            submitImmediatelyOn={handleSubmitImmediatelyOn}
            saving={props.saving}
            loading={props.loading}
            users={props.users}
            totalCount={props.totalCount}
            placeholderText={intl.formatMessage({id: 'multiselect.placeholder', defaultMessage: 'Search and add members'})}
        />
    );
});
export default List;

function renderValue(props: {data: OptionValue}) {
    return (props.data as UserProfile).username;
}

function renderAriaLabel(option: OptionValue) {
    return (option as UserProfile)?.username ?? '';
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {createSelector} from 'reselect';

import {getAllChannels, getChannelsWithUserProfiles} from 'mattermost-redux/selectors/entities/channels';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';

import {UserProfile} from '@mattermost/types/users';

import {getUserIdFromChannelName} from 'mattermost-redux/utils/channel_utils';
import {filterProfilesStartingWithTerm} from 'mattermost-redux/utils/user_utils';

import {GlobalState} from 'types/store';

import Constants from 'utils/constants';

import {Option, OptionValue} from '../types';

import List from './list';

type OwnProps = {
    users: UserProfile[];
    values: OptionValue[];
}

export function makeGetOptions(): (state: GlobalState, users: UserProfile[], values: OptionValue[]) => Option[] {
    // Gets all loaded DMs (as UserProfiles)
    const getUsersWithDMs = createSelector(
        'getUsersWithDMs',
        getCurrentUserId,
        getAllChannels,
        (state: GlobalState, users: UserProfile[]) => users,
        (currentUserId, allChannels, users) => {
            const directChannels = Object.values(allChannels).filter((channel) => channel.type === Constants.DM_CHANNEL);

            // Gets all loaded DMs (as UserProfiles)
            const usersWithDMs: Array<UserProfile & {last_post_at: number}> = [];
            for (const channel of directChannels) {
                const otherUserId = getUserIdFromChannelName(currentUserId, channel.name);
                const otherUser = users.find((user) => user.id === otherUserId);

                if (!otherUser) {
                    // The user doesn't match the search filter
                    continue;
                }

                if (channel.last_post_at === 0) {
                    // The DM channel exists but has no messages in it
                    continue;
                }

                usersWithDMs.push({
                    ...otherUser,
                    last_post_at: channel.last_post_at,
                });
            }

            return usersWithDMs;
        },
    );

    // Gets GM channels matching the search term and selected values
    const getFilteredGroupChannels = createSelector(
        'getFilteredGroupChannels',
        getChannelsWithUserProfiles,
        (state: GlobalState) => state.views.search.modalSearch,
        (state: GlobalState, values: OptionValue[]) => values,
        (channelsWithProfiles, searchTerm, values) => {
            return channelsWithProfiles.filter((channel) => {
                if (searchTerm) {
                    // Check that at least one of the users in the channel matches the search term
                    const matches = filterProfilesStartingWithTerm(channel.profiles, searchTerm);
                    if (matches.length === 0) {
                        return false;
                    }
                }

                if (values) {
                    // Check that all of the selected users are in the channel
                    const valuesInProfiles = values.every((value) => channel.profiles.find((user) => user.id === value.id));
                    if (!valuesInProfiles) {
                        return false;
                    }
                }

                // Only include GM channels with messages in them
                return channel.last_post_at > 0;
            });
        },
    );

    return createSelector(
        'makeGetOptions',
        getUsersWithDMs,
        (state: GlobalState, users: UserProfile[], values: OptionValue[]) => getFilteredGroupChannels(state, values),
        (state: GlobalState, users: UserProfile[]) => users,
        (state: GlobalState) => Boolean(state.views.search.modalSearch),
        (usersWithDMs, filteredGroupChannels, users, isSearch) => {
            // Recent DMs (as UserProfiles) and GMs sorted by recent activity
            const recents = [...usersWithDMs, ...filteredGroupChannels].
                sort((a, b) => b.last_post_at - a.last_post_at);

            // Only show the 20 most recent DMs and GMs when no search term has been entered. If a search term has been
            // entered, `users` is expected to have already been filtered by it
            if (!isSearch && recents.length > 0) {
                return recents.slice(0, 20);
            }

            // Other users sorted by whether or not they've been deactivated followed by alphabetically
            const usersWithoutDMs = users.
                filter((user) => user.delete_at === 0 && !usersWithDMs.some((other) => other.id === user.id)).
                map((user) => ({...user, last_post_at: 0}));
            usersWithoutDMs.sort((a, b) => {
                return a.username.localeCompare(b.username);
            });

            // Returns an array containing:
            //  1. All recent DMs (represented by UserProfiles) and GMs matching the filter
            //      - GMs are also filtered to only show ones containing each selected user
            //  2. Other non-deactivated users sorted by username
            return [
                ...recents,
                ...usersWithoutDMs,
            ];
        },
    );
}

function makeMapStateToProps() {
    const getOptions = makeGetOptions();

    return (state: GlobalState, ownProps: OwnProps) => {
        return {
            options: getOptions(state, ownProps.users, ownProps.values),
        };
    };
}

export default connect(makeMapStateToProps)(List);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';
import {debounce} from 'lodash';

import {UserProfile} from '@mattermost/types/users';
import {GenericAction} from 'mattermost-redux/types/actions';

import {getHistory} from 'utils/browser_history';
import Constants from 'utils/constants';
import MultiSelect from 'components/multiselect/multiselect';

import List from './list';
import {USERS_PER_PAGE} from './list/list';
import {
    isGroupChannel,
    optionValue,
    OptionValue,
} from './types';

export type Props = {
    currentUserId: string;
    currentTeamId: string;
    currentTeamName: string;
    searchTerm: string;
    users: UserProfile[];
    totalCount: number;

    /*
    * List of current channel members of existing channel
    */
    currentChannelMembers?: UserProfile[];

    /*
    * Whether the modal is for existing channel or not
    */
    isExistingChannel: boolean;

    /*
    * The mode by which direct messages are restricted, if at all.
    */
    restrictDirectMessage?: string;
    onModalDismissed?: () => void;
    onExited?: () => void;
    actions: {
        getProfiles: (page?: number | undefined, perPage?: number | undefined, options?: any) => Promise<any>;
        getProfilesInTeam: (teamId: string, page: number, perPage?: number | undefined, sort?: string | undefined, options?: any) => Promise<any>;
        loadProfilesMissingStatus: (users: UserProfile[]) => void;
        getTotalUsersStats: () => void;
        loadStatusesForProfilesList: (users: any) => {
            data: boolean;
        };
        loadProfilesForGroupChannels: (groupChannels: any) => void;
        openDirectChannelToUserId: (userId: any) => Promise<any>;
        openGroupChannelToUserIds: (userIds: any) => Promise<any>;
        searchProfiles: (term: string, options?: any) => Promise<any>;
        searchGroupChannels: (term: string) => Promise<any>;
        setModalSearchTerm: (term: any) => GenericAction;
    };
}

type State = {
    values: OptionValue[];
    show: boolean;
    search: boolean;
    saving: boolean;
    loadingUsers: boolean;
}

export default class MoreDirectChannels extends React.PureComponent<Props, State> {
    searchTimeoutId: any;
    exitToChannel?: string;
    multiselect: React.RefObject<MultiSelect<OptionValue>>;
    selectedItemRef: React.RefObject<HTMLDivElement>;
    constructor(props: Props) {
        super(props);

        this.searchTimeoutId = 0;
        this.multiselect = React.createRef();
        this.selectedItemRef = React.createRef();

        const values: OptionValue[] = [];

        if (props.currentChannelMembers) {
            for (let i = 0; i < props.currentChannelMembers.length; i++) {
                const user = Object.assign({}, props.currentChannelMembers[i]);

                if (user.id === props.currentUserId) {
                    continue;
                }

                values.push(optionValue(user));
            }
        }

        this.state = {
            values,
            show: true,
            search: false,
            saving: false,
            loadingUsers: true,
        };
    }

    loadModalData = () => {
        this.getUserProfiles();
        this.props.actions.getTotalUsersStats();
        this.props.actions.loadProfilesMissingStatus(this.props.users);
    }

    updateFromProps(prevProps: Props) {
        if (prevProps.searchTerm !== this.props.searchTerm) {
            clearTimeout(this.searchTimeoutId);

            const searchTerm = this.props.searchTerm;
            if (searchTerm === '') {
                this.resetPaging();
            } else {
                const teamId = this.props.restrictDirectMessage === 'any' ? '' : this.props.currentTeamId;

                this.searchTimeoutId = setTimeout(
                    async () => {
                        this.setUsersLoadingState(true);
                        const [{data: profilesData}, {data: groupChannelsData}] = await Promise.all([
                            this.props.actions.searchProfiles(searchTerm, {team_id: teamId}),
                            this.props.actions.searchGroupChannels(searchTerm),
                        ]);
                        if (profilesData) {
                            this.props.actions.loadStatusesForProfilesList(profilesData);
                        }
                        if (groupChannelsData) {
                            this.props.actions.loadProfilesForGroupChannels(groupChannelsData);
                        }
                        this.resetPaging();
                        this.setUsersLoadingState(false);
                    },
                    Constants.SEARCH_TIMEOUT_MILLISECONDS,
                );
            }
        }

        if (
            prevProps.users.length !== this.props.users.length
        ) {
            this.props.actions.loadProfilesMissingStatus(this.props.users);
        }
    }

    componentDidUpdate(prevProps: Props) {
        this.updateFromProps(prevProps);
    }

    handleHide = () => {
        this.props.actions.setModalSearchTerm('');
        this.setState({show: false});
    }

    setUsersLoadingState = (loadingState: boolean) => {
        this.setState({
            loadingUsers: loadingState,
        });
    }

    handleExit = () => {
        if (this.exitToChannel) {
            getHistory().push(this.exitToChannel);
        }

        this.props.onModalDismissed?.();
        this.props.onExited?.();
    }

    handleSubmit = (values = this.state.values) => {
        const {actions} = this.props;
        if (this.state.saving) {
            return;
        }

        const userIds = values.map((v) => v.id);
        if (userIds.length === 0) {
            return;
        }

        this.setState({saving: true});

        const done = (result: any) => {
            const {data, error} = result;
            this.setState({saving: false});

            if (!error) {
                this.exitToChannel = '/' + this.props.currentTeamName + '/channels/' + data.name;
                this.handleHide();
            }
        };

        if (userIds.length === 1) {
            actions.openDirectChannelToUserId(userIds[0]).then(done);
        } else {
            actions.openGroupChannelToUserIds(userIds).then(done);
        }
    };

    addValue = (value: OptionValue) => {
        if (isGroupChannel(value)) {
            this.addUsers(value.profiles);
        } else {
            const values = Object.assign([], this.state.values);

            if (values.indexOf(value) === -1) {
                values.push(value);
            }

            this.setState({values});
        }
    };

    addUsers = (users: UserProfile[]) => {
        const values: OptionValue[] = Object.assign([], this.state.values);
        const existingUserIds = values.map((user) => user.id);
        for (const user of users) {
            if (existingUserIds.indexOf(user.id) !== -1) {
                continue;
            }
            values.push(optionValue(user));
        }

        this.setState({values});
    };

    getUserProfiles = (page?: number) => {
        const pageNum = page ? page + 1 : 0;
        if (this.props.restrictDirectMessage === 'any') {
            this.props.actions.getProfiles(pageNum, USERS_PER_PAGE * 2).then(() => {
                this.setUsersLoadingState(false);
            });
        } else {
            this.props.actions.getProfilesInTeam(this.props.currentTeamId, pageNum, USERS_PER_PAGE * 2).then(() => {
                this.setUsersLoadingState(false);
            });
        }
    }

    handlePageChange = (page: number, prevPage: number) => {
        if (page > prevPage) {
            this.setUsersLoadingState(true);
            this.getUserProfiles(page);
        }
    }

    resetPaging = () => {
        this.multiselect.current?.resetPaging();
    }

    search = debounce((term: string) => {
        this.props.actions.setModalSearchTerm(term);
    }, 250);

    handleDelete = (values: OptionValue[]) => {
        this.setState({values});
    }

    render() {
        const body = (
            <List
                addValue={this.addValue}
                currentUserId={this.props.currentUserId}
                handleDelete={this.handleDelete}
                handlePageChange={this.handlePageChange}
                handleSubmit={this.handleSubmit}
                isExistingChannel={this.props.isExistingChannel}
                loading={this.state.loadingUsers}
                saving={this.state.saving}
                search={this.search}
                selectedItemRef={this.selectedItemRef}
                totalCount={this.props.totalCount}
                users={this.props.users}
                values={this.state.values}
            />
        );

        return (
            <Modal
                dialogClassName='a11y__modal more-modal more-direct-channels'
                show={this.state.show}
                onHide={this.handleHide}
                onExited={this.handleExit}
                onEntered={this.loadModalData}
                role='dialog'
                aria-labelledby='moreDmModalLabel'
                id='moreDmModal'
            >
                <Modal.Header closeButton={true}>
                    <Modal.Title
                        componentClass='h1'
                        id='moreDmModalLabel'
                    >
                        <FormattedMessage
                            id='more_direct_channels.title'
                            defaultMessage='Direct Messages'
                        />
                    </Modal.Title>
                </Modal.Header>
                <Modal.Body
                    role='application'
                >
                    {body}
                </Modal.Body>
                <Modal.Footer className='modal-footer--invisible'>
                    <button
                        id='closeModalButton'
                        type='button'
                        className='btn btn-link'
                    >
                        <FormattedMessage
                            id='general_button.close'
                            defaultMessage='Close'
                        />
                    </button>
                </Modal.Footer>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, ActionCreatorsMapObject, Dispatch} from 'redux';

import {
    getProfiles,
    getProfilesInTeam,
    getTotalUsersStats,
    searchProfiles,
} from 'mattermost-redux/actions/users';
import {searchGroupChannels} from 'mattermost-redux/actions/channels';
import {
    getCurrentUserId,
    getProfiles as selectProfiles,
    getProfilesInCurrentChannel,
    getProfilesInCurrentTeam,
    makeSearchProfilesStartingWithTerm,
    searchProfilesInCurrentTeam,
    getTotalUsersStats as getTotalUsersStatsSelector,
} from 'mattermost-redux/selectors/entities/users';

import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';
import {ActionFunc, GenericAction} from 'mattermost-redux/types/actions';
import {UserProfile} from '@mattermost/types/users';

import {openDirectChannelToUserId, openGroupChannelToUserIds} from 'actions/channel_actions';
import {loadStatusesForProfilesList, loadProfilesMissingStatus} from 'actions/status_actions';
import {loadProfilesForGroupChannels} from 'actions/user_actions';
import {setModalSearchTerm} from 'actions/views/search';

import {GlobalState} from 'types/store';

import MoreDirectChannels from './more_direct_channels';

type OwnProps = {
    isExistingChannel: boolean;
}

const makeMapStateToProps = () => {
    const searchProfilesStartingWithTerm = makeSearchProfilesStartingWithTerm();

    return (state: GlobalState, ownProps: OwnProps) => {
        const currentUserId = getCurrentUserId(state);
        let currentChannelMembers;
        if (ownProps.isExistingChannel) {
            currentChannelMembers = getProfilesInCurrentChannel(state);
        }

        const config = getConfig(state);
        const restrictDirectMessage = config.RestrictDirectMessage;

        const searchTerm = state.views.search.modalSearch;

        let users: UserProfile[];
        if (searchTerm) {
            if (restrictDirectMessage === 'any') {
                users = searchProfilesStartingWithTerm(state, searchTerm, false);
            } else {
                users = searchProfilesInCurrentTeam(state, searchTerm, false);
            }
        } else if (restrictDirectMessage === 'any') {
            users = selectProfiles(state);
        } else {
            users = getProfilesInCurrentTeam(state);
        }

        const team = getCurrentTeam(state);
        const stats = getTotalUsersStatsSelector(state) || {total_users_count: 0};

        return {
            currentTeamId: team.id,
            currentTeamName: team.name,
            searchTerm,
            users,
            currentChannelMembers,
            currentUserId,
            restrictDirectMessage,
            totalCount: stats.total_users_count,
        };
    };
};

type Actions = {
    getProfiles: (page?: number | undefined, perPage?: number | undefined, options?: any) => Promise<any>;
    getProfilesInTeam: (teamId: string, page: number, perPage?: number | undefined, sort?: string | undefined, options?: any) => Promise<any>;
    loadProfilesMissingStatus: (users: UserProfile[]) => ActionFunc;
    getTotalUsersStats: () => ActionFunc;
    loadStatusesForProfilesList: (users: any) => {
        data: boolean;
    };
    loadProfilesForGroupChannels: (groupChannels: any) => Promise<any>;
    openDirectChannelToUserId: (userId: any) => Promise<any>;
    openGroupChannelToUserIds: (userIds: any) => Promise<any>;
    searchProfiles: (term: string, options?: any) => Promise<any>;
    searchGroupChannels: (term: string) => Promise<any>;
    setModalSearchTerm: (term: any) => GenericAction;
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc | GenericAction>, Actions>({
            getProfiles,
            getProfilesInTeam,
            loadProfilesMissingStatus,
            getTotalUsersStats,
            loadStatusesForProfilesList,
            loadProfilesForGroupChannels,
            openDirectChannelToUserId,
            openGroupChannelToUserIds,
            searchProfiles,
            searchGroupChannels,
            setModalSearchTerm,
        }, dispatch),
    };
}

export default connect(makeMapStateToProps, mapDispatchToProps)(MoreDirectChannels);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/* eslint-disable react/no-string-refs */

import React from 'react';

import {getOptionValue} from 'react-select/src/builtins';

import {FormattedMessage} from 'react-intl';

import Constants from 'utils/constants';
import {cmdOrCtrlPressed} from 'utils/utils';

import LoadingScreen from 'components/loading_screen';

import {Value} from './multiselect';

export type Props<T extends Value> = {
    ariaLabelRenderer: getOptionValue<T>;
    loading?: boolean;
    onAdd: (value: T) => void;
    onPageChange?: (newPage: number, currentPage: number) => void;
    onSelect: (value: T | null) => void;
    optionRenderer: (
        option: T,
        isSelected: boolean,
        add: (value: T) => void,
        select: (value: T) => void
    ) => void;
    query?: string;
    selectedItemRef?: React.RefObject<HTMLDivElement>;
    options: T[];
    page: number;
    perPage: number;
    customNoOptionsMessage?: React.ReactNode;
}

type State = {
    selected: number;
}
const KeyCodes = Constants.KeyCodes;

export default class MultiSelectList<T extends Value> extends React.PureComponent<Props<T>, State> {
    public static defaultProps = {
        options: [],
        perPage: 50,
        onAction: () => null,
    };

    private toSelect = -1
    private listRef = React.createRef<HTMLDivElement>()
    private selectedItemRef = React.createRef<HTMLDivElement>()

    public constructor(props: Props<T>) {
        super(props);

        this.state = {
            selected: -1,
        };
    }

    public componentDidMount() {
        document.addEventListener('keydown', this.handleArrowPress);
    }

    public componentWillUnmount() {
        document.removeEventListener('keydown', this.handleArrowPress);
    }

    public componentDidUpdate(_: Props<T>, prevState: State) {
        const options = this.props.options;
        if (options && options.length > 0 && this.state.selected >= 0) {
            this.props.onSelect(options[this.state.selected]);
        }

        if (prevState.selected === this.state.selected) {
            return;
        }

        const selectRef = this.selectedItemRef.current || this.props.selectedItemRef?.current;
        if (this.listRef.current && selectRef) {
            const elemTop = selectRef.getBoundingClientRect().top;
            const elemBottom = selectRef.getBoundingClientRect().bottom;
            const listTop = this.listRef.current.getBoundingClientRect().top;
            const listBottom = this.listRef.current.getBoundingClientRect().bottom;
            if (elemBottom > listBottom) {
                selectRef.scrollIntoView(false);
            } else if (elemTop < listTop) {
                selectRef.scrollIntoView(true);
            }
        }
    }

    // setSelected updates the selected index and is referenced
    // externally by the MultiSelect component.
    public setSelected = (selected: number) => {
        this.setState({selected});
    }

    private handleArrowPress = (e: KeyboardEvent) => {
        if (cmdOrCtrlPressed(e) && e.shiftKey) {
            return;
        }

        const options = this.props.options;
        if (options.length === 0) {
            return;
        }

        let selected;
        switch (e.key) {
        case KeyCodes.DOWN[0]:
            if (this.state.selected === -1) {
                selected = 0;
                break;
            }
            selected = Math.min(this.state.selected + 1, options.length - 1);
            break;
        case KeyCodes.UP[0]:
            if (this.state.selected === -1) {
                selected = 0;
                break;
            }
            selected = Math.max(this.state.selected - 1, 0);
            break;
        default:
            return;
        }

        e.preventDefault();
        this.setState({selected});
        this.props.onSelect(options[selected]);
    }

    private defaultOptionRenderer = (
        option: T,
        isSelected: boolean,
        add: (value: T) => void,
        select: (value: T) => void,
    ) => {
        let rowSelected = '';
        if (isSelected) {
            rowSelected = 'more-modal__row--selected';
        }

        return (
            <div
                ref={isSelected ? this.selectedItemRef : option.value}
                className={rowSelected}
                key={'multiselectoption' + option.value}
                onClick={() => add(option)}
                onMouseEnter={() => select(option)}
            >
                {option.label}
            </div>
        );
    }

    private select = (option: T) => {
        const i = this.props.options.indexOf(option);
        if (i !== -1) {
            if (this.state.selected !== i) {
                this.setSelected(i);
            }
        }
    }

    public render() {
        const {options, customNoOptionsMessage} = this.props;
        let renderOutput;

        if (this.props.loading) {
            renderOutput = (
                <div aria-hidden={true}>
                    <LoadingScreen
                        position='absolute'
                        key='loading'
                    />
                </div>
            );
        } else if (options == null || options.length === 0) {
            if (customNoOptionsMessage) {
                renderOutput = customNoOptionsMessage;
            } else {
                renderOutput = (
                    <div
                        key='no-users-found'
                        className='no-channel-message'
                        tabIndex={0}
                    >
                        <p className='primary-message'>
                            <FormattedMessage
                                id='multiselect.list.notFound'
                                defaultMessage='No results found matching <b>{searchQuery}</b>'
                                values={{
                                    searchQuery: this.props.query,
                                    b: (value: string) => <b>{value}</b>,
                                }}
                            />
                        </p>
                    </div>
                );
            }
        } else {
            let renderer: Props<T>['optionRenderer'];
            if (this.props.optionRenderer) {
                renderer = this.props.optionRenderer;
            } else {
                renderer = this.defaultOptionRenderer;
            }

            const optionControls = options.map((o, i) => renderer(o, this.state.selected === i, this.props.onAdd, this.select));

            const selectedOption = options[this.state.selected];
            const ariaLabel = this.props.ariaLabelRenderer(selectedOption);

            renderOutput = (
                <div className='more-modal__list'>
                    <div
                        className='sr-only'
                        aria-live='polite'
                        aria-atomic='true'
                    >
                        {ariaLabel}
                    </div>
                    <div
                        ref={this.listRef}
                        id='multiSelectList'
                        className='more-modal__options'
                        role='presentation'
                        aria-hidden={true}
                    >
                        {optionControls}
                    </div>
                </div>
            );
        }

        return (
            <div
                className='multi-select__wrapper'
                aria-live='polite'
            >
                {renderOutput}
            </div>
        );
    }
}

/* eslint-enable react/no-string-refs */

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode} from 'react';
import {FormattedMessage} from 'react-intl';
import ReactSelect, {components} from 'react-select';

import {InputActionMeta} from 'react-select/src/types';
import {getOptionValue} from 'react-select/src/builtins';

import classNames from 'classnames';

import LocalizedIcon from 'components/localized_icon';
import CloseCircleSolidIcon from 'components/widgets/icons/close_circle_solid_icon';
import SaveButton from 'components/save_button';
import Avatar from 'components/widgets/users/avatar';

import {Constants, A11yCustomEventTypes} from 'utils/constants';
import {imageURLForUser, getDisplayName, localizeMessage} from 'utils/utils';

import MultiSelectList from './multiselect_list';

export type Value = {
    deleteAt?: number;
    display_name?: string;
    id: string;
    label: string;
    scheme_id?: string;
    value: string;
};

export type Props<T extends Value> = {
    ariaLabelRenderer: getOptionValue<T>;
    backButtonClick?: () => void;
    backButtonClass?: string;
    backButtonText?: string;
    buttonSubmitLoadingText?: ReactNode;
    buttonSubmitText?: ReactNode;
    handleAdd: (value: T) => void;
    handleDelete: (values: T[]) => void;
    handleInput: (input: string, multiselect: MultiSelect<T>) => void;
    handlePageChange?: (newPage: number, currentPage: number) => void;
    handleSubmit: (value?: T[]) => void;
    loading?: boolean;
    saveButtonPosition?: string;
    maxValues?: number;
    noteText?: ReactNode;
    numRemainingText?: ReactNode;
    optionRenderer: (
        option: T,
        isSelected: boolean,
        add: (value: T) => void,
        select: (value: T) => void
    ) => void;
    selectedItemRef?: React.RefObject<HTMLDivElement>;
    options: T[];
    perPage: number;
    placeholderText?: string;
    saving?: boolean;
    submitImmediatelyOn?: (value: T) => boolean;
    totalCount?: number;
    users?: unknown[];
    valueWithImage: boolean;
    valueRenderer?: (props: {data: T}) => any;
    values: T[];
    focusOnLoad?: boolean;
    savingEnabled?: boolean;
    handleCancel?: () => void;
    customNoOptionsMessage?: React.ReactNode;
}

export type State = {
    a11yActive: boolean;
    input: string;
    page: number;
}

const KeyCodes = Constants.KeyCodes;

export default class MultiSelect<T extends Value> extends React.PureComponent<Props<T>, State> {
    private listRef = React.createRef<MultiSelectList<T>>()
    private reactSelectRef = React.createRef<ReactSelect>()
    private selected: T | null = null

    public static defaultProps = {
        ariaLabelRenderer: defaultAriaLabelRenderer,
        saveButtonPosition: 'top',
        valueWithImage: false,
        focusOnLoad: true,
        savingEnabled: true,
    }

    public constructor(props: Props<T>) {
        super(props);

        this.state = {
            a11yActive: false,
            page: 0,
            input: '',
        };
    }

    public componentDidMount() {
        const inputRef: unknown = this.reactSelectRef.current && this.reactSelectRef.current.select.inputRef;

        document.addEventListener<'keydown'>('keydown', this.handleEnterPress);
        if (inputRef && typeof (inputRef as HTMLElement).addEventListener === 'function') {
            (inputRef as HTMLElement).addEventListener(A11yCustomEventTypes.ACTIVATE, this.handleA11yActivateEvent);
            (inputRef as HTMLElement).addEventListener(A11yCustomEventTypes.DEACTIVATE, this.handleA11yDeactivateEvent);

            if (this.props.focusOnLoad) {
                this.reactSelectRef.current!.focus(); // known from ternary definition of inputRef
            }
        }
    }

    public componentWillUnmount() {
        const inputRef: unknown = this.reactSelectRef.current && this.reactSelectRef.current.select.inputRef;

        if (inputRef && typeof (inputRef as HTMLElement).addEventListener === 'function') {
            (inputRef as HTMLElement).removeEventListener(A11yCustomEventTypes.ACTIVATE, this.handleA11yActivateEvent);
            (inputRef as HTMLElement).removeEventListener(A11yCustomEventTypes.DEACTIVATE, this.handleA11yDeactivateEvent);
        }

        document.removeEventListener('keydown', this.handleEnterPress);
    }

    private handleA11yActivateEvent = () => {
        this.setState({a11yActive: true});
    }

    private handleA11yDeactivateEvent = () => {
        this.setState({a11yActive: false});
    }

    private nextPage = () => {
        if (this.props.handlePageChange) {
            this.props.handlePageChange(this.state.page + 1, this.state.page);
        }
        if (this.listRef.current) {
            this.listRef.current.setSelected(0);
        }
        this.setState({page: this.state.page + 1});
    }

    private prevPage = () => {
        if (this.state.page === 0) {
            return;
        }

        if (this.props.handlePageChange) {
            this.props.handlePageChange(this.state.page - 1, this.state.page);
        }

        if (this.listRef.current) {
            this.listRef.current.setSelected(0);
        }
        this.setState({page: this.state.page - 1});
    }

    public resetPaging = () => {
        this.setState({page: 0});
    }

    private onSelect = (selected: T | null) => {
        this.selected = selected;
    }

    private onAdd = (value: T) => {
        if (this.props.maxValues && this.props.values.length >= this.props.maxValues) {
            return;
        }

        for (let i = 0; i < this.props.values.length; i++) {
            if (this.props.values[i].id === value.id) {
                return;
            }
        }

        this.props.handleAdd(value);
        this.selected = null;

        if (this.reactSelectRef.current) {
            this.reactSelectRef.current.select.handleInputChange(
                {currentTarget: {value: ''}} as React.KeyboardEvent<HTMLInputElement>,
            );
            this.reactSelectRef.current.focus();
        }

        const submitImmediatelyOn = this.props.submitImmediatelyOn;
        if (submitImmediatelyOn && submitImmediatelyOn(value)) {
            this.props.handleSubmit([value]);
        }
    }

    private onInput = (input: string, change: InputActionMeta) => {
        if (!change) {
            return;
        }

        if (change.action === 'input-blur' || change.action === 'menu-close') {
            return;
        }

        if (this.state.input === input) {
            return;
        }

        this.setState({input});

        if (this.listRef.current) {
            if (input === '') {
                this.listRef.current.setSelected(-1);
            } else {
                this.listRef.current.setSelected(0);
            }
        }
        this.selected = null;

        this.props.handleInput(input, this);
    }

    private onInputKeyDown = (e: React.KeyboardEvent) => {
        switch (e.key) {
        case KeyCodes.ENTER[0]:
            e.preventDefault();
            break;
        }
    }

    private handleEnterPress = (e: KeyboardEvent) => {
        switch (e.key) {
        case KeyCodes.ENTER[0]:
            if (this.selected == null) {
                this.props.handleSubmit();
                return;
            }
            this.onAdd(this.selected);
            break;
        }
    }

    private handleOnClick = (e: React.MouseEvent<HTMLButtonElement>) => {
        e.preventDefault();
        this.props.handleSubmit();
    }

    private onChange: ReactSelect['onChange'] = (_, change) => {
        if (change.action !== 'remove-value' && change.action !== 'pop-value') {
            return;
        }

        const values = [...this.props.values];
        for (let i = 0; i < values.length; i++) {
            // Types of ReactSelect do not match the behavior here,
            if (values[i].id === (change as any).removedValue.id) {
                values.splice(i, 1);
                break;
            }
        }

        this.props.handleDelete(values);
    }

    MultiValueRemove = ({children, innerProps}: any) => (
        <div {...innerProps}>
            {children || <CloseCircleSolidIcon/>}
        </div>
    );

    formatOptionLabel = (user: any) => {
        const profileImg = imageURLForUser(user.id, user.last_picture_update);

        return (
            <>
                <Avatar
                    size='sm'
                    username={user.username}
                    url={profileImg}
                />
                <div className='react-select__value__name'>
                    {getDisplayName(user)}
                </div>
            </>
        );
    }

    valueRenderer = (props: any) => {
        return this.props.valueWithImage ? <components.MultiValueLabel {...props}/> : this.props.valueRenderer;
    }

    public render() {
        const options = Object.assign([...this.props.options]);
        const {totalCount, users, values} = this.props;

        let numRemainingText;
        if (this.props.numRemainingText) {
            numRemainingText = this.props.numRemainingText;
        } else if (this.props.maxValues != null && this.props.maxValues !== undefined) {
            numRemainingText = (
                <FormattedMessage
                    id='multiselect.numRemaining'
                    defaultMessage='Up to {max, number} can be added at a time. You have {num, number} remaining.'
                    values={{
                        max: this.props.maxValues,
                        num: this.props.maxValues - this.props.values.length,
                    }}
                />
            );
        }

        let buttonSubmitText: ReactNode;
        if (this.props.buttonSubmitText) {
            buttonSubmitText = this.props.buttonSubmitText;
        } else if (this.props.maxValues != null) {
            buttonSubmitText = (
                <FormattedMessage
                    id='multiselect.go'
                    defaultMessage='Go'
                />
            );
        }

        let optionsToDisplay = [];
        let nextButton;
        let previousButton;
        let noteTextContainer;

        if (this.props.noteText) {
            noteTextContainer = (
                <div className='multi-select__note'>
                    <div className='note__icon'>
                        <LocalizedIcon
                            className='fa fa-info'
                            title={{id: 'generic_icons.info', defaultMessage: 'Info Icon'}}
                        />
                    </div>
                    <div>{this.props.noteText}</div>
                </div>
            );
        }

        const valueMap: Record<string, boolean> = {};
        for (let i = 0; i < values.length; i++) {
            valueMap[values[i].id] = true;
        }

        for (let i = options.length - 1; i >= 0; i--) {
            if (valueMap[options[i].id]) {
                options.splice(i, 1);
            }
        }

        if (options && options.length > this.props.perPage) {
            const pageStart = this.state.page * this.props.perPage;
            const pageEnd = pageStart + this.props.perPage;
            optionsToDisplay = options.slice(pageStart, pageEnd);
            if (!this.props.loading) {
                if (options.length > pageEnd) {
                    nextButton = (
                        <button
                            className='btn btn-link filter-control filter-control__next'
                            onClick={this.nextPage}
                        >
                            <FormattedMessage
                                id='filtered_user_list.next'
                                defaultMessage='Next'
                            />
                        </button>
                    );
                }

                if (this.state.page > 0) {
                    previousButton = (
                        <button
                            className='btn btn-link filter-control filter-control__prev'
                            onClick={this.prevPage}
                        >
                            <FormattedMessage
                                id='filtered_user_list.prev'
                                defaultMessage='Previous'
                            />
                        </button>
                    );
                }
            }
        } else {
            optionsToDisplay = options;
        }

        let multiSelectList;

        if (this.props.saveButtonPosition === 'bottom') {
            if (this.state.input) {
                multiSelectList = (
                    <MultiSelectList
                        ref={this.listRef}
                        options={optionsToDisplay}
                        optionRenderer={this.props.optionRenderer}
                        ariaLabelRenderer={this.props.ariaLabelRenderer}
                        page={this.state.page}
                        perPage={this.props.perPage}
                        onPageChange={this.props.handlePageChange}
                        onAdd={this.onAdd}
                        onSelect={this.onSelect}
                        loading={this.props.loading}
                        query={this.state.input}
                        selectedItemRef={this.props.selectedItemRef}
                        customNoOptionsMessage={this.props.customNoOptionsMessage || undefined}
                    />
                );
            }
        } else {
            multiSelectList = (
                <MultiSelectList
                    ref={this.listRef}
                    options={optionsToDisplay}
                    optionRenderer={this.props.optionRenderer}
                    ariaLabelRenderer={this.props.ariaLabelRenderer}
                    page={this.state.page}
                    perPage={this.props.perPage}
                    onPageChange={this.props.handlePageChange}
                    onAdd={this.onAdd}
                    onSelect={this.onSelect}
                    loading={this.props.loading}
                    query={this.state.input}
                    selectedItemRef={this.props.selectedItemRef}
                    customNoOptionsMessage={this.props.customNoOptionsMessage || undefined}
                />
            );
        }

        let memberCount;
        if (users && users.length && totalCount) {
            memberCount = (
                <FormattedMessage
                    id='multiselect.numMembers'
                    defaultMessage='{memberOptions, number} of {totalCount, number} members'
                    values={{
                        memberOptions: optionsToDisplay.length,
                        totalCount: this.props.totalCount,
                    }}
                />
            );
        }

        return (
            <>
                <div className='filtered-user-list'>
                    <div className='filter-row filter-row--full'>
                        <div className='multi-select__container react-select'>
                            <ReactSelect
                                id='selectItems'
                                ref={this.reactSelectRef as React.RefObject<any>} // type of ref on @types/react-select is outdated
                                isMulti={true}
                                options={this.props.options}
                                styles={styles}
                                components={{
                                    Menu: nullComponent,
                                    IndicatorsContainer: nullComponent,
                                    MultiValueLabel: this.props.valueWithImage ? components.MultiValueLabel : paddedComponent(this.props.valueRenderer),
                                    MultiValueRemove: this.props.valueWithImage ? this.MultiValueRemove : components.MultiValueRemove,
                                }}
                                isClearable={false}
                                openMenuOnFocus={false}
                                menuIsOpen={false}
                                onInputChange={this.onInput}
                                onKeyDown={this.onInputKeyDown as React.KeyboardEventHandler}
                                onChange={this.onChange}
                                value={this.props.values}
                                formatOptionLabel={this.props.valueWithImage ? this.formatOptionLabel : undefined}
                                placeholder={this.props.placeholderText}
                                inputValue={this.state.input}
                                getOptionValue={(option: Value) => option.id}
                                getOptionLabel={this.props.ariaLabelRenderer}
                                aria-label={this.props.placeholderText}
                                className={this.state.a11yActive ? 'multi-select__focused' : ''}
                                classNamePrefix='react-select-auto react-select'
                            />
                            {this.props.saveButtonPosition === 'top' &&
                                <SaveButton
                                    id='saveItems'
                                    saving={this.props.saving}
                                    disabled={this.props.saving}
                                    onClick={this.handleOnClick}
                                    defaultMessage={buttonSubmitText}
                                    savingMessage={this.props.buttonSubmitLoadingText}
                                />
                            }
                        </div>
                        <div
                            id='multiSelectHelpMemberInfo'
                            className='multi-select__help'
                        >
                            {numRemainingText}
                            {memberCount}
                        </div>
                    </div>
                    {multiSelectList}
                    <div
                        id='multiSelectMessageNote'
                        className='multi-select__help'
                    >
                        {noteTextContainer}
                    </div>
                    {this.props.saveButtonPosition === 'top' &&
                        <div className='filter-controls'>
                            {previousButton}
                            {nextButton}
                        </div>
                    }
                </div>
                {this.props.saveButtonPosition === 'bottom' &&
                    <div className='multi-select__footer'>
                        {
                            this.props.backButtonClick &&
                            <button
                                onClick={(e: React.MouseEvent<HTMLButtonElement>) => {
                                    e.preventDefault();
                                    if (this.props.backButtonClick) {
                                        this.props.backButtonClick();
                                    }
                                }}
                                className={classNames('btn', this.props.backButtonClass)}
                            >
                                {this.props.backButtonText || localizeMessage('multiselect.backButton', 'Back')}
                            </button>
                        }
                        <SaveButton
                            id='saveItems'
                            saving={this.props.saving}
                            disabled={this.props.saving || !this.props.savingEnabled}
                            onClick={this.handleOnClick}
                            defaultMessage={buttonSubmitText}
                            savingMessage={this.props.buttonSubmitLoadingText}
                        />
                    </div>
                }
            </>
        );
    }
}

function defaultAriaLabelRenderer(option: Value) {
    if (!option) {
        return null;
    }
    return option.label;
}

const nullComponent = () => null;

const paddedComponent = (WrappedComponent: any) => {
    return (props: {data: any}) => {
        return (
            <div className='react-select__padded-component'>
                <WrappedComponent {...props}/>
            </div>
        );
    };
};

const styles = {
    container: () => {
        return {
            display: 'flex',
            overflow: 'hidden',
            flex: 'auto',
        };
    },
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function PinIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='16px'
                height='16px'
                viewBox='0 0 18 18'
                version='1.1'
                role='img'
                aria-label={formatMessage({id: 'generic_icons.pin', defaultMessage: 'Pin Icon'})}
            >
                <path d='M17.73 7.01999L16.83 6.11999L10.98 0.251987C10.812 0.0839874 10.602 -1.26362e-05 10.35 -1.26362e-05C10.098 -1.26362e-05 9.888 0.0899873 9.72 0.269987C9.54 0.449987 9.45 0.665987 9.45 0.917987C9.45 1.15799 9.54 1.36799 9.72 1.54799L9.99 1.79999L5.994 5.75999C4.422 5.57999 2.922 5.77799 1.494 6.35399C1.35 6.40199 1.224 6.48599 1.116 6.60599C1.02 6.72599 0.954 6.86399 0.918 7.01999C0.894 7.16399 0.9 7.30799 0.936 7.45199C0.984 7.59599 1.062 7.72199 1.17 7.82999L5.004 11.664L1.35 15.3L0.45 17.55L2.7 16.65L6.354 13.014L10.17 16.83C10.278 16.938 10.404 17.01 10.548 17.046C10.704 17.094 10.854 17.1 10.998 17.064C11.154 17.04 11.286 16.974 11.394 16.866C11.514 16.77 11.598 16.644 11.646 16.488C12.246 15.024 12.444 13.524 12.24 11.988L16.2 8.02799L16.452 8.29799C16.632 8.47799 16.848 8.56799 17.1 8.56799C17.352 8.56799 17.562 8.47799 17.73 8.29799C17.91 8.11799 18 7.90799 18 7.66799C18 7.41599 17.91 7.19999 17.73 7.01999ZM10.584 11.052C10.464 11.172 10.386 11.316 10.35 11.484C10.314 11.64 10.32 11.796 10.368 11.952C10.584 12.792 10.584 13.638 10.368 14.49L3.51 7.63199C4.362 7.41599 5.208 7.41599 6.048 7.63199C6.204 7.67999 6.36 7.68599 6.516 7.64999C6.684 7.60199 6.828 7.51799 6.948 7.39799L11.25 3.07799L14.904 6.73199L10.584 11.052Z'/>
            </svg>
        </span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode, CSSProperties} from 'react';
import {FormattedMessage, MessageDescriptor} from 'react-intl';
import classNames from 'classnames';

import {t} from 'utils/i18n';

import FlagIcon from 'components/widgets/icons/flag_icon';
import MentionsIcon from 'components/widgets/icons/mentions_icon';
import PinIcon from 'components/widgets/icons/pin_icon';
import SearchIcon from 'components/widgets/icons/search_icon';

import {NoResultsVariant, NoResultsLayout} from './types';

interface Props {
    expanded?: boolean;
    iconGraphic?: ReactNode;
    title?: ReactNode;
    subtitle?: ReactNode;
    variant?: NoResultsVariant;
    titleValues?: Record<string, ReactNode>;
    subtitleValues?: Record<string, ReactNode>;
    style?: CSSProperties;
    layout?: NoResultsLayout;
    titleClassName?: string;
    subtitleClassName?: string;
}

const iconMap: {[key in NoResultsVariant]: React.ReactNode } = {
    [NoResultsVariant.ChannelSearch]: <SearchIcon className='no-results__icon'/>,
    [NoResultsVariant.Mentions]: <MentionsIcon className='no-results__icon'/>,
    [NoResultsVariant.FlaggedPosts]: <FlagIcon className='no-results__icon'/>,
    [NoResultsVariant.PinnedPosts]: <PinIcon className='no-results__icon'/>,
    [NoResultsVariant.ChannelFiles]: <i className='icon icon-file-text-outline no-results__icon'/>,
    [NoResultsVariant.ChannelFilesFiltered]: <i className='icon icon-file-text-outline no-results__icon'/>,
    [NoResultsVariant.UserGroups]: <i className='icon icon-account-multiple-outline no-results__icon'/>,
    [NoResultsVariant.UserGroupMembers]: <i className='icon icon-account-outline no-results__icon'/>,
};

const titleMap: {[key in NoResultsVariant]: MessageDescriptor} = {
    [NoResultsVariant.ChannelSearch]: {
        id: t('no_results.channel_search.title'),
    },
    [NoResultsVariant.Mentions]: {
        id: t('no_results.mentions.title'),
    },
    [NoResultsVariant.FlaggedPosts]: {
        id: t('no_results.flagged_posts.title'),
    },
    [NoResultsVariant.PinnedPosts]: {
        id: t('no_results.pinned_posts.title'),
    },
    [NoResultsVariant.ChannelFiles]: {
        id: t('no_results.channel_files.title'),
    },
    [NoResultsVariant.ChannelFilesFiltered]: {
        id: t('no_results.channel_files_filtered.title'),
    },
    [NoResultsVariant.UserGroups]: {
        id: t('no_results.user_groups.title'),
    },
    [NoResultsVariant.UserGroupMembers]: {
        id: t('no_results.user_group_members.title'),
    },
};

const subtitleMap: {[key in NoResultsVariant]: MessageDescriptor} = {
    [NoResultsVariant.ChannelSearch]: {
        id: t('no_results.channel_search.subtitle'),
    },
    [NoResultsVariant.Mentions]: {
        id: t('no_results.mentions.subtitle'),
    },
    [NoResultsVariant.FlaggedPosts]: {
        id: t('no_results.flagged_posts.subtitle'),
    },
    [NoResultsVariant.PinnedPosts]: {
        id: t('no_results.pinned_posts.subtitle'),
    },
    [NoResultsVariant.ChannelFiles]: {
        id: t('no_results.channel_files.subtitle'),
    },
    [NoResultsVariant.ChannelFilesFiltered]: {
        id: t('no_results.channel_files_filtered.subtitle'),
    },
    [NoResultsVariant.UserGroups]: {
        id: t('no_results.user_groups.subtitle'),
    },
    [NoResultsVariant.UserGroupMembers]: {
        id: t('no_results.user_group_members.subtitle'),
    },
};

import './no_results_indicator.scss';

const NoResultsIndicator = ({
    expanded,
    style,
    variant,
    iconGraphic = variant ? (
        <div className='no-results__variant-wrapper'>
            {iconMap[variant]}
        </div>
    ) : null,
    titleValues,
    title = variant ? (
        <FormattedMessage
            {...titleMap[variant]}
            values={titleValues}
        />
    ) : null,
    subtitleValues,
    subtitle = variant ? (
        <FormattedMessage
            {...subtitleMap[variant]}
            values={subtitleValues}
        />
    ) : null,
    layout = NoResultsLayout.Vertical,
    titleClassName,
    subtitleClassName,
}: Props) => {
    let content = (
        <div
            className={classNames('no-results__wrapper', {'horizontal-layout': layout === NoResultsLayout.Horizontal})}
            style={style}
        >
            {iconGraphic}

            <div
                className='no-results__text-container'
            >
                {title && (
                    <h3 className={classNames('no-results__title', {'only-title': !subtitle}, titleClassName)}>
                        {title}
                    </h3>
                )}

                {subtitle && (
                    <div className={classNames('no-results__subtitle', subtitleClassName)}>
                        {subtitle}
                    </div>
                )}
            </div>

        </div>
    );

    if (expanded) {
        content = (
            <div className='no-results__holder'>
                {content}
            </div>
        );
    }

    return content;
};

export default NoResultsIndicator;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

export enum NoResultsVariant {
    ChannelSearch = 'ChannelSearch',
    Mentions = 'Mentions',
    FlaggedPosts = 'FlaggedPosts',
    PinnedPosts = 'PinnedPosts',
    ChannelFiles = 'ChannelFiles',
    ChannelFilesFiltered = 'ChannelFilesFiltered',
    UserGroups = 'UserGroups',
    UserGroupMembers = 'UserGroupMembers',
}

export enum NoResultsLayout {
    Vertical,
    Horizontal,
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';
import styled from 'styled-components';

import {NotifyAdminRequest} from '@mattermost/types/cloud';
import {useGetNotifyAdmin, NotifyStatus, NotifyStatusValues} from 'components/common/hooks/useGetNotifyAdmin';

const Span = styled.span`
font-family: 'Open Sans';
font-size: 12px;
font-style: normal;
font-weight: 600;
line-height: 16px;
`;

const Button = styled.button`
border: none;
background: none;
color: var(--denim-button-bg);
text-decoration: none;
display: inline;
`;

export enum DafaultBtnText {
    NotifyAdmin = 'Notify your admin',
    Notifying = 'Notifying...',
    Notified = 'Notified!',
    AlreadyNotified = 'Already notified!',
    Failed = 'Try again later!',
}

type HookProps = {
    ctaText?: React.ReactNode;
    preTrial?: boolean;
}

type Props = HookProps & {
    callerInfo: string;
    notifyRequestData: NotifyAdminRequest;
}

type ValueOf<T> = T[keyof T]

export function useNotifyAdmin<T = HTMLAnchorElement | HTMLButtonElement>(props: HookProps, reqData: NotifyAdminRequest): [React.ReactNode, (e: React.MouseEvent<T, MouseEvent>, callerInfo: string) => void, ValueOf<typeof NotifyStatus>] {
    const {btnText: btnFormaText, notifyAdmin, notifyStatus} = useGetNotifyAdmin({});
    const {formatMessage} = useIntl();

    const btnText = (status: NotifyStatusValues): React.ReactNode => {
        switch (status) {
        case NotifyStatus.Started:
        case NotifyStatus.Success:
        case NotifyStatus.AlreadyComplete:
        case NotifyStatus.Failed:
            return formatMessage(btnFormaText(status));
        default:
            return props.ctaText || formatMessage(btnFormaText(NotifyStatus.NotStarted));
        }
    };

    const notifyFunc = async (e: React.MouseEvent<T, MouseEvent>, callerInfo: string) => {
        e.preventDefault();
        e.stopPropagation();
        notifyAdmin({
            trackingArgs: {
                category: 'pricing',
                event: 'click_notify_admin_cta',
                props: {
                    callerInfo,
                },
            },
            requestData: reqData,
        });
    };

    return [btnText(notifyStatus), notifyFunc, notifyStatus];
}

function NotifyAdminCTA(props: Props) {
    const [btnText, notify, status] = useNotifyAdmin(props, props.notifyRequestData);
    const {formatMessage} = useIntl();
    let title = formatMessage({id: 'pricing_modal.wantToUpgrade', defaultMessage: 'Want to upgrade? '});
    if (props.preTrial) {
        title = formatMessage({id: 'pricing_modal.wantToTry', defaultMessage: 'Want to try? '});
    }

    return (
        <>
            {props.ctaText ? (
                <span>
                    <Button
                        id='notify_admin_cta'
                        onClick={(e) => notify(e, props.callerInfo)}
                        disabled={status === NotifyStatus.AlreadyComplete}
                    >
                        {btnText}
                    </Button>
                </span>
            ) : (
                <Span id='notify_cta_container'>
                    {title}
                    <Button
                        id='notify_admin_cta'
                        onClick={(e) => notify(e, props.callerInfo)}
                        disabled={status === NotifyStatus.AlreadyComplete}
                    >
                        {btnText}
                    </Button>
                </Span>
            )}
        </>
    );
}

export default NotifyAdminCTA;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import ConfirmModalRedux from 'components/confirm_modal_redux';
import FormattedMarkdownMessage from 'components/formatted_markdown_message';

import {t} from 'utils/i18n';

type Props = {
    mentions: string[];
    memberNotifyCount: number;
    channelTimezoneCount: number;
    onConfirm: (checked: boolean) => void;
    onExited: () => void;
};

export default class NotifyConfirmModal extends React.PureComponent<Props> {
    render() {
        const {mentions, channelTimezoneCount, memberNotifyCount} = this.props;

        let notifyAllMessage: React.ReactNode = '';
        let notifyAllTitle: React.ReactNode = '';
        if (mentions.includes('@all') || mentions.includes('@channel') || mentions.includes('@here')) {
            notifyAllTitle = (
                <FormattedMessage
                    id='notify_all.title.confirm'
                    defaultMessage='Confirm sending notifications to entire channel'
                />
            );
            if (channelTimezoneCount > 0) {
                const atHereMsg = 'By using **@here** you are about to send notifications to up to **{totalMembers} people** in **{timezones, number} {timezones, plural, one {timezone} other {timezones}}**. Are you sure you want to do this?';
                const atAllChannelMsg = 'By using **@all** or **@channel** you are about to send notifications to **{totalMembers} people** in **{timezones, number} {timezones, plural, one {timezone} other {timezones}}**. Are you sure you want to do this?';
                const msg = mentions.length === 1 && mentions[0] === '@here' ? atHereMsg : atAllChannelMsg;
                const msgID = mentions.length === 1 && mentions[0] === '@here' ? t('notify_here.question_timezone') : t('notify_all.question_timezone');
                notifyAllMessage = (
                    <FormattedMarkdownMessage
                        id={msgID}
                        defaultMessage={msg}
                        values={{
                            totalMembers: memberNotifyCount,
                            timezones: channelTimezoneCount,
                        }}
                    />
                );
            } else {
                const atHereMsg = 'By using **@here** you are about to send notifications to up to **{totalMembers} people**. Are you sure you want to do this?';
                const atAllChannelMsg = 'By using **@all** or **@channel** you are about to send notifications to **{totalMembers} people**. Are you sure you want to do this?';
                const msg = mentions.length === 1 && mentions[0] === '@here' ? atHereMsg : atAllChannelMsg;
                const msgID = mentions.length === 1 && mentions[0] === '@here' ? t('notify_here.question') : t('notify_all.question');
                notifyAllMessage = (
                    <FormattedMarkdownMessage
                        id={msgID}
                        defaultMessage={msg}
                        values={{
                            totalMembers: memberNotifyCount,
                        }}
                    />
                );
            }
        } else if (mentions.length > 0) {
            notifyAllTitle = (
                <FormattedMessage
                    id='notify_all.title.confirm_groups'
                    defaultMessage='Confirm sending notifications to groups'
                />
            );

            if (mentions.length === 1) {
                if (channelTimezoneCount > 0) {
                    notifyAllMessage = (
                        <FormattedMarkdownMessage
                            id='notify_all.question_timezone_one_group'
                            defaultMessage='By using **{mention}** you are about to send notifications of up to **{totalMembers} people** in **{timezones, number} {timezones, plural, one {timezone} other {timezones}}**. Are you sure you want to do this?'
                            values={{
                                mention: mentions[0],
                                totalMembers: memberNotifyCount,
                                timezones: channelTimezoneCount,
                            }}
                        />
                    );
                } else {
                    notifyAllMessage = (
                        <FormattedMarkdownMessage
                            id='notify_all.question_one_group'
                            defaultMessage='By using **{mention}** you are about to send notifications of up to **{totalMembers} people**. Are you sure you want to do this?'
                            values={{
                                mention: mentions[0],
                                totalMembers: memberNotifyCount,
                            }}
                        />
                    );
                }
            } else if (channelTimezoneCount > 0) {
                notifyAllMessage = (
                    <FormattedMarkdownMessage
                        id='notify_all.question_timezone_groups'
                        defaultMessage='By using **{mentions}** and **{finalMention}** you are about to send notifications of up to **{totalMembers} people** in **{timezones, number} {timezones, plural, one {timezone} other {timezones}}**. Are you sure you want to do this?'
                        values={{
                            mentions: mentions.slice(0, -1).join(', '),
                            finalMention: mentions[mentions.length - 1],
                            totalMembers: memberNotifyCount,
                            timezones: channelTimezoneCount,
                        }}
                    />
                );
            } else {
                notifyAllMessage = (
                    <FormattedMarkdownMessage
                        id='notify_all.question_groups'
                        defaultMessage='By using **{mentions}** and **{finalMention}** you are about to send notifications of up to **{totalMembers} people**. Are you sure you want to do this?'
                        values={{
                            mentions: mentions.slice(0, -1).join(', '),
                            finalMention: mentions[mentions.length - 1],
                            totalMembers: memberNotifyCount,
                        }}
                    />
                );
            }
        }

        const notifyAllConfirm = (
            <FormattedMessage
                id='notify_all.confirm'
                defaultMessage='Confirm'
            />
        );

        return (
            <ConfirmModalRedux
                title={notifyAllTitle}
                message={notifyAllMessage}
                confirmButtonText={notifyAllConfirm}
                onConfirm={this.props.onConfirm}
                onExited={this.props.onExited}
            />
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

const FINISHED = 999;

export const OnboardingTaskCategory = 'onboarding_task_list';

// Whole task list is based on these
export const OnboardingTasksName = {
    CHANNELS_TOUR: 'channels_tour',
    BOARDS_TOUR: 'boards_tour',
    PLAYBOOKS_TOUR: 'playbooks_tour',
    INVITE_PEOPLE: 'invite_people',
    DOWNLOAD_APP: 'download_app',
    COMPLETE_YOUR_PROFILE: 'complete_your_profile',
    EXPLORE_OTHER_TOOLS: 'explore_other_tools',
    VISIT_SYSTEM_CONSOLE: 'visit_system_console',
    START_TRIAL: 'start_trial',
};

export const OnboardingTaskList = {
    ONBOARDING_TASK_LIST_OPEN: 'onboarding_task_list_open',
    ONBOARDING_TASK_LIST_SHOW: 'onboarding_task_list_show',
    ONBOARDING_TASK_LIST_CLOSE: 'onboarding_task_list_close',
    ONBOARDING_VIDEO_MODAL: 'onboarding_video_modal',
    DECLINED_ONBOARDING_TASK_LIST: 'declined_onboarding_task_list',
};

export const GenericTaskSteps = {
    START: 0,
    STARTED: 1,
    FINISHED,
};

export const TaskNameMapToSteps = {
    [OnboardingTasksName.CHANNELS_TOUR]: GenericTaskSteps,
    [OnboardingTasksName.BOARDS_TOUR]: GenericTaskSteps,
    [OnboardingTasksName.PLAYBOOKS_TOUR]: GenericTaskSteps,
    [OnboardingTasksName.COMPLETE_YOUR_PROFILE]: GenericTaskSteps,
    [OnboardingTasksName.EXPLORE_OTHER_TOOLS]: GenericTaskSteps,
    [OnboardingTasksName.DOWNLOAD_APP]: GenericTaskSteps,
    [OnboardingTasksName.VISIT_SYSTEM_CONSOLE]: GenericTaskSteps,
    [OnboardingTasksName.INVITE_PEOPLE]: GenericTaskSteps,
    [OnboardingTasksName.START_TRIAL]: GenericTaskSteps,
};


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {GlobalState} from 'types/store';

export function isShowOnboardingTaskCompletion(state: GlobalState) {
    return state.views.onboardingTasks.isShowOnboardingTaskCompletion;
}

export function isShowOnboardingCompleteProfileTour(state: GlobalState) {
    return state.views.onboardingTasks.isShowOnboardingCompleteProfileTour;
}

export function isShowOnboardingVisitConsoleTour(state: GlobalState) {
    return state.views.onboardingTasks.isShowOnboardingVisitConsoleTour;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect} from 'react';
import {FormattedMessage} from 'react-intl';
import {useDispatch, useSelector} from 'react-redux';

import {TourTip, useMeasurePunchouts} from '@mattermost/components';
import {setShowOnboardingVisitConsoleTour} from 'actions/views/onboarding_tasks';
import {isShowOnboardingVisitConsoleTour} from 'selectors/views/onboarding_tasks';

import {OnboardingTasksName, TaskNameMapToSteps} from './constants';
import {useHandleOnBoardingTaskData} from './onboarding_tasks_manager';

const translate = {x: 0, y: -2};

export const VisitSystemConsoleTour = () => {
    const dispatch = useDispatch();
    const handleTask = useHandleOnBoardingTaskData();
    const taskName = OnboardingTasksName.VISIT_SYSTEM_CONSOLE;
    const steps = TaskNameMapToSteps[taskName];
    const isOpen = useSelector(isShowOnboardingVisitConsoleTour);

    useEffect(() => {
        return () => {
            dispatch(setShowOnboardingVisitConsoleTour(false));
        };
    }, []);

    const title = (
        <FormattedMessage
            id='onboardingTask.visitSystemConsole.title'
            defaultMessage={'Visit the System Console'}
        />
    );
    const screen = (
        <p>
            <FormattedMessage
                id='onboardingTask.visitSystemConsole.Description'
                defaultMessage={'More detailed configuration settings for your workspace can be accessed here.'}
            />
        </p>
    );

    const overlayPunchOut = useMeasurePunchouts(['product-switcher-menu-dropdown'], []);

    const onDismiss = (e: React.MouseEvent) => {
        e.stopPropagation();
        e.preventDefault();
        handleTask(taskName, steps.START, true, 'dismiss');
    };

    return (
        <TourTip
            show={isOpen}
            title={title}
            screen={screen}
            overlayPunchOut={overlayPunchOut}
            step={steps.STARTED}
            placement='left-start'
            pulsatingDotPlacement='right'
            pulsatingDotTranslate={translate}
            handleDismiss={onDismiss}
            singleTip={true}
            showOptOut={false}
            interactivePunchOut={true}
        />
    );
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect} from 'react';
import {FormattedMessage} from 'react-intl';

import {useDispatch, useSelector} from 'react-redux';

import {TourTip, useMeasurePunchouts} from '@mattermost/components';
import {isShowOnboardingCompleteProfileTour} from 'selectors/views/onboarding_tasks';
import {setShowOnboardingCompleteProfileTour} from '../../actions/views/onboarding_tasks';

import {OnboardingTasksName, TaskNameMapToSteps} from './constants';
import {useHandleOnBoardingTaskData} from './onboarding_tasks_manager';

const translate = {x: 0, y: -2};

export const CompleteYourProfileTour = () => {
    const dispatch = useDispatch();
    const handleTask = useHandleOnBoardingTaskData();
    const taskName = OnboardingTasksName.COMPLETE_YOUR_PROFILE;
    const steps = TaskNameMapToSteps[taskName];
    const isOpen = useSelector(isShowOnboardingCompleteProfileTour);

    useEffect(() => {
        return () => {
            dispatch(setShowOnboardingCompleteProfileTour(false));
        };
    }, []);

    const title = (
        <FormattedMessage
            id='onboardingTask.completeYourProfileTour.title'
            defaultMessage={'Edit your profile'}
        />
    );
    const screen = (
        <p>
            <FormattedMessage
                id='onboardingTask.completeYourProfileTour.Description'
                defaultMessage={'Use this menu item to update your profile details and security settings.'}
            />
        </p>
    );

    const overlayPunchOut = useMeasurePunchouts(['status-drop-down-menu-list'], [], {y: -6, height: 6, x: 0, width: 0});
    const onDismiss = (e: React.MouseEvent) => {
        e.stopPropagation();
        e.preventDefault();
        handleTask(taskName, steps.START, true, 'dismiss');
    };

    return (
        <TourTip
            show={isOpen}
            title={title}
            screen={screen}
            overlayPunchOut={overlayPunchOut}
            step={steps.STARTED}
            placement='left-start'
            pulsatingDotPlacement='left'
            pulsatingDotTranslate={translate}
            handleDismiss={onDismiss}
            singleTip={true}
            showOptOut={false}
            interactivePunchOut={true}
        />
    );
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useMemo} from 'react';
import {FormattedMessage} from 'react-intl';
import {useDispatch, useSelector} from 'react-redux';
import {matchPath, useHistory, useLocation} from 'react-router-dom';

import {trackEvent as trackEventAction} from 'actions/telemetry_actions';
import {setProductMenuSwitcherOpen} from 'actions/views/product_menu';
import {setStatusDropdown} from 'actions/views/status_dropdown';
import {openModal} from 'actions/views/modals';
import {
    AutoTourStatus,
    FINISHED,
    OnboardingTourSteps,
    OnboardingTourStepsForGuestUsers,
    TTNameMapToATStatusKey,
    TutorialTourName,
} from 'components/tours';
import LearnMoreTrialModal from 'components/learn_more_trial_modal/learn_more_trial_modal';
import {savePreferences} from 'mattermost-redux/actions/preferences';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/common';

import {
    isReduceOnBoardingTaskList,
    makeGetCategory,
} from 'mattermost-redux/selectors/entities/preferences';
import {getLicense} from 'mattermost-redux/selectors/entities/general';
import {isCurrentUserGuestUser, isCurrentUserSystemAdmin, isFirstAdmin} from 'mattermost-redux/selectors/entities/users';

import {GlobalState} from 'types/store';
import {
    openInvitationsModal,
    setShowOnboardingCompleteProfileTour,
    setShowOnboardingVisitConsoleTour,
    switchToChannels,
} from 'actions/views/onboarding_tasks';

import {ModalIdentifiers, TELEMETRY_CATEGORIES, ExploreOtherToolsTourSteps} from 'utils/constants';

import {generateTelemetryTag} from './utils';
import {OnboardingTaskCategory, OnboardingTaskList, OnboardingTasksName, TaskNameMapToSteps} from './constants';

const getCategory = makeGetCategory();

const taskLabels = {
    [OnboardingTasksName.CHANNELS_TOUR]: (
        <FormattedMessage
            id='onboardingTask.checklist.task_learn_more_about_messaging'
            defaultMessage=' Learn about messaging'
        />
    ),
    [OnboardingTasksName.BOARDS_TOUR]: (
        <FormattedMessage
            id='onboardingTask.checklist.plan_sprint_with_kanban_style_boards'
            defaultMessage=' Plan a sprint with Kanban-style boards'
        />),
    [OnboardingTasksName.PLAYBOOKS_TOUR]: (
        <FormattedMessage
            id='onboardingTask.checklist.task_resolve_incidents_faster_with_playbooks'
            defaultMessage=' Resolve incidents faster with playbooks'
        />
    ),
    [OnboardingTasksName.INVITE_PEOPLE]: (
        <FormattedMessage
            id='onboardingTask.checklist.task_invite_team_members'
            defaultMessage=' Invite team members to the workspace'
        />
    ),
    [OnboardingTasksName.COMPLETE_YOUR_PROFILE]: (
        <FormattedMessage
            id='onboardingTask.checklist.task_complete_your_profile'
            defaultMessage=' Complete your profile'
        />
    ),
    [OnboardingTasksName.EXPLORE_OTHER_TOOLS]: (
        <FormattedMessage
            id='onboardingTask.checklist.explore_other_tools_in_platform'
            defaultMessage=' Explore other tools in the platform'
        />
    ),
    [OnboardingTasksName.DOWNLOAD_APP]: (
        <FormattedMessage
            id='onboardingTask.checklist.task_download_mm_apps'
            defaultMessage=' Download the Desktop and Mobile Apps'
        />
    ),
    [OnboardingTasksName.VISIT_SYSTEM_CONSOLE]: (
        <FormattedMessage
            id='onboardingTask.checklist.task_visit_system_console'
            defaultMessage=' Visit the System Console to configure your workspace'
        />
    ),
    [OnboardingTasksName.START_TRIAL]: (
        <FormattedMessage
            id='onboardingTask.checklist.task_start_enterprise_trial'
            defaultMessage=' Learn more about Enterprise-level high-security features'
        />
    ),
};

export const useTasksList = () => {
    const pluginsList = useSelector((state: GlobalState) => state.plugins.plugins);
    const prevTrialLicense = useSelector((state: GlobalState) => state.entities.admin.prevTrialLicense);
    const license = useSelector(getLicense);
    const isPrevLicensed = prevTrialLicense?.IsLicensed;
    const isCurrentLicensed = license?.IsLicensed;
    const isUserAdmin = useSelector((state: GlobalState) => isCurrentUserSystemAdmin(state));
    const isGuestUser = useSelector((state: GlobalState) => isCurrentUserGuestUser(state));
    const isUserFirstAdmin = useSelector(isFirstAdmin);
    const isThinOnBoardingTaskList = useSelector((state: GlobalState) => {
        return isReduceOnBoardingTaskList(state);
    });

    // Cloud conditions
    const subscription = useSelector((state: GlobalState) => state.entities.cloud.subscription);
    const isCloud = license?.Cloud === 'true';
    const isFreeTrial = subscription?.is_free_trial === 'true';
    const hadPrevCloudTrial = subscription?.is_free_trial === 'false' && subscription?.trial_end_at > 0;

    // Show this CTA if the instance is currently not licensed and has never had a trial license loaded before
    // if Cloud, show if not in trial and had never been on trial
    const selfHostedTrialCondition = isCurrentLicensed === 'false' && isPrevLicensed === 'false';
    const cloudTrialCondition = isCloud && !isFreeTrial && !hadPrevCloudTrial;

    const showStartTrialTask = selfHostedTrialCondition || cloudTrialCondition;

    const list: Record<string, string> = {...OnboardingTasksName};
    if (!pluginsList.focalboard || !isUserFirstAdmin) {
        delete list.BOARDS_TOUR;
    }
    if (!pluginsList.playbooks || !isUserFirstAdmin) {
        delete list.PLAYBOOKS_TOUR;
    }
    if (!showStartTrialTask) {
        delete list.START_TRIAL;
    }

    if (!isUserFirstAdmin && !isUserAdmin) {
        delete list.VISIT_SYSTEM_CONSOLE;
        delete list.START_TRIAL;
    }

    // explore other tools tour is only shown to subsequent admins and end users
    if (isUserFirstAdmin || (!pluginsList.playbooks && !pluginsList.focalboard)) {
        delete list.EXPLORE_OTHER_TOOLS;
    }

    // invite other users is hidden for guest users
    if (isGuestUser) {
        delete list.INVITE_PEOPLE;
    }

    if (isThinOnBoardingTaskList) {
        delete list.DOWNLOAD_APP;
        delete list.COMPLETE_YOUR_PROFILE;
        delete list.VISIT_SYSTEM_CONSOLE;
    }
    return Object.values(list);
};

export const useTasksListWithStatus = () => {
    const dataInDb = useSelector((state: GlobalState) => getCategory(state, OnboardingTaskCategory));
    const tasksList = useTasksList();
    return useMemo(() =>
        tasksList.map((task) => {
            const status = dataInDb.find((pref) => pref.name === task)?.value;
            return {
                name: task,
                status: status === FINISHED.toString(),
                label: taskLabels[task],
            };
        }), [dataInDb, tasksList]);
};

export const useHandleOnBoardingTaskData = () => {
    const dispatch = useDispatch();
    const currentUserId = useSelector(getCurrentUserId);
    const storeSavePreferences = useCallback(
        (taskCategory: string, taskName, step: number) => {
            const preferences = [
                {
                    user_id: currentUserId,
                    category: taskCategory,
                    name: taskName,
                    value: step.toString(),
                },
            ];
            dispatch(savePreferences(currentUserId, preferences));
        },
        [currentUserId],
    );

    return useCallback((
        taskName: string,
        step: number,
        trackEvent = true,
        trackEventSuffix?: string,
        taskCategory = OnboardingTaskCategory,
    ) => {
        storeSavePreferences(taskCategory, taskName, step);
        if (trackEvent) {
            const eventSuffix = trackEventSuffix ? `${step}--${trackEventSuffix}` : step.toString();
            const telemetryTag = generateTelemetryTag(OnboardingTaskCategory, taskName, eventSuffix);
            trackEventAction(OnboardingTaskCategory, telemetryTag);
        }
    }, [storeSavePreferences]);
};

export const useHandleOnBoardingTaskTrigger = () => {
    const dispatch = useDispatch();
    const history = useHistory();
    const {pathname} = useLocation();

    const handleSaveData = useHandleOnBoardingTaskData();
    const currentUserId = useSelector(getCurrentUserId);
    const isGuestUser = useSelector((state: GlobalState) => isCurrentUserGuestUser(state));
    const inAdminConsole = matchPath(pathname, {path: '/admin_console'}) != null;
    const inChannels = matchPath(pathname, {path: '/:team/channels/:chanelId'}) != null;
    const pluginsList = useSelector((state: GlobalState) => state.plugins.plugins);
    const boards = pluginsList.focalboard;

    return (taskName: string) => {
        switch (taskName) {
        case OnboardingTasksName.CHANNELS_TOUR: {
            handleSaveData(taskName, TaskNameMapToSteps[taskName].STARTED, true);
            const tourCategory = TutorialTourName.ONBOARDING_TUTORIAL_STEP;
            const preferences = [
                {
                    user_id: currentUserId,
                    category: tourCategory,
                    name: currentUserId,

                    // use SEND_MESSAGE when user is guest (channel creation and invitation are restricted), so only message box and the configure tips are shown
                    value: isGuestUser ? OnboardingTourStepsForGuestUsers.SEND_MESSAGE.toString() : OnboardingTourSteps.CHANNELS_AND_DIRECT_MESSAGES.toString(),
                },
                {
                    user_id: currentUserId,
                    category: tourCategory,
                    name: TTNameMapToATStatusKey[tourCategory],
                    value: AutoTourStatus.ENABLED.toString(),
                },
            ];
            dispatch(savePreferences(currentUserId, preferences));
            if (!inChannels) {
                dispatch(switchToChannels());
            }
            break;
        }
        case OnboardingTasksName.BOARDS_TOUR: {
            history.push('/boards');
            localStorage.setItem(OnboardingTaskCategory, 'true');
            handleSaveData(taskName, TaskNameMapToSteps[taskName].FINISHED, true);
            break;
        }
        case OnboardingTasksName.PLAYBOOKS_TOUR: {
            history.push('/playbooks/start');
            localStorage.setItem(OnboardingTaskCategory, 'true');
            handleSaveData(taskName, TaskNameMapToSteps[taskName].FINISHED, true);
            break;
        }
        case OnboardingTasksName.COMPLETE_YOUR_PROFILE: {
            dispatch(setStatusDropdown(true));
            dispatch(setShowOnboardingCompleteProfileTour(true));
            handleSaveData(taskName, TaskNameMapToSteps[taskName].STARTED, true);
            if (inAdminConsole) {
                dispatch(switchToChannels());
            }
            break;
        }
        case OnboardingTasksName.EXPLORE_OTHER_TOOLS: {
            dispatch(setProductMenuSwitcherOpen(true));
            handleSaveData(taskName, TaskNameMapToSteps[taskName].STARTED, true);
            const tourCategory = TutorialTourName.EXPLORE_OTHER_TOOLS;
            const preferences = [
                {
                    user_id: currentUserId,
                    category: tourCategory,
                    name: currentUserId,
                    value: boards ? ExploreOtherToolsTourSteps.BOARDS_TOUR.toString() : ExploreOtherToolsTourSteps.PLAYBOOKS_TOUR.toString(),
                },
                {
                    user_id: currentUserId,
                    category: tourCategory,
                    name: TTNameMapToATStatusKey[tourCategory],
                    value: AutoTourStatus.ENABLED.toString(),
                },
            ];
            dispatch(savePreferences(currentUserId, preferences));
            if (!inChannels) {
                dispatch(switchToChannels());
            }
            break;
        }
        case OnboardingTasksName.VISIT_SYSTEM_CONSOLE: {
            dispatch(setProductMenuSwitcherOpen(true));
            dispatch(setShowOnboardingVisitConsoleTour(true));
            handleSaveData(taskName, TaskNameMapToSteps[taskName].STARTED, true);
            break;
        }
        case OnboardingTasksName.INVITE_PEOPLE: {
            localStorage.setItem(OnboardingTaskCategory, 'true');

            if (inAdminConsole) {
                dispatch(openInvitationsModal(1000));
            } else {
                dispatch(openInvitationsModal());
            }
            handleSaveData(taskName, TaskNameMapToSteps[taskName].FINISHED, true);
            break;
        }
        case OnboardingTasksName.DOWNLOAD_APP: {
            handleSaveData(taskName, TaskNameMapToSteps[taskName].FINISHED, true);
            const preferences = [{
                user_id: currentUserId,
                category: OnboardingTaskCategory,
                name: OnboardingTaskList.ONBOARDING_TASK_LIST_OPEN,
                value: 'true',
            }];
            dispatch(savePreferences(currentUserId, preferences));
            window.open('https://mattermost.com/download/', '_blank', 'noopener,noreferrer');
            break;
        }
        case OnboardingTasksName.START_TRIAL: {
            trackEventAction(
                TELEMETRY_CATEGORIES.SELF_HOSTED_START_TRIAL_TASK_LIST,
                'open_start_trial_modal',
            );
            dispatch(openModal({
                modalId: ModalIdentifiers.LEARN_MORE_TRIAL_MODAL,
                dialogType: LearnMoreTrialModal,
            }));

            handleSaveData(taskName, TaskNameMapToSteps[taskName].FINISHED, true);
            break;
        }
        default:
        }
    };
};


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

export const generateTelemetryTag = (category: string, name: string, suffix: string) => {
    return `${category}--${name}--${suffix}`;
};

export function getAnalyticsCategory(isAdmin: boolean) {
    return isAdmin ? 'admin_onboarding' : 'end_user_onboarding';
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

// eslint-disable-next-line no-restricted-imports
import {OverlayTrigger as OriginalOverlayTrigger, OverlayTriggerProps} from 'react-bootstrap';
import {IntlContext, IntlShape} from 'react-intl';

import {Provider} from 'react-redux';

import store from 'stores/redux_store.jsx';

export type BaseOverlayTrigger = OriginalOverlayTrigger & {
    hide: () => void;
};

type Props = OverlayTriggerProps & {
    disabled?: boolean;
    className?: string;
};

const OverlayTrigger = React.forwardRef((props: Props, ref?: React.Ref<OriginalOverlayTrigger>) => {
    const {overlay, disabled, ...otherProps} = props;

    // The overlay is rendered outside of the regular React context, and our version react-bootstrap can't forward
    // that context itself, so we have to manually forward the react-intl context to this component's child.
    const OverlayWrapper = ({intl, ...overlayProps}: {intl: IntlShape}) => (
        <Provider store={store}>
            <IntlContext.Provider value={intl}>{React.cloneElement(overlay, overlayProps)}</IntlContext.Provider>
        </Provider>
    );

    return (
        <IntlContext.Consumer>
            {(intl): React.ReactNode => {
                const overlayProps = {...overlay.props};
                if (disabled) {
                    overlayProps.style = {visibility: 'hidden', ...overlayProps.style};
                }
                return (
                    <OriginalOverlayTrigger
                        {...otherProps}
                        ref={ref}
                        overlay={
                            <OverlayWrapper
                                {...overlayProps}
                                intl={intl}
                            />
                        }
                    />
                );
            }}
        </IntlContext.Consumer>
    );
});

OverlayTrigger.defaultProps = {
    defaultOverlayShown: false,
    trigger: ['hover', 'focus'],
};
OverlayTrigger.displayName = 'OverlayTrigger';

export default OverlayTrigger;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/* eslint-disable no-process-env */
/* eslint-disable @typescript-eslint/no-unused-vars */

import {
    StripeError,
    ConfirmCardSetupData,
    ConfirmCardSetupOptions,
    SetupIntent,
} from '@stripe/stripe-js';

type ConfirmCardSetupType = (clientSecret: string, data?: ConfirmCardSetupData | undefined, options?: ConfirmCardSetupOptions | undefined) => Promise<{ setupIntent?: SetupIntent | undefined; error?: StripeError | undefined }> | undefined;

function prodConfirmCardSetup(confirmCardSetup: ConfirmCardSetupType): ConfirmCardSetupType {
    return confirmCardSetup;
}

function devConfirmCardSetup(confirmCardSetup: ConfirmCardSetupType): ConfirmCardSetupType {
    return async (clientSecret: string, data?: ConfirmCardSetupData | undefined, options?: ConfirmCardSetupOptions | undefined) => {
        return {setupIntent: {id: 'testid', status: 'succeeded'} as SetupIntent};
    };
}

export const getConfirmCardSetup = (isDevMode: boolean) => (isDevMode ? devConfirmCardSetup : prodConfirmCardSetup);

export const STRIPE_CSS_SRC = 'https://fonts.googleapis.com/css?family=Open+Sans:400,400i,600,600i&display=swap';
export const STRIPE_PUBLIC_KEY = 'pk_test_ttEpW6dCHksKyfAFzh6MvgBj';

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

export type Props = {

    /**
     * Permissions enough to pass the gate (binary OR)
     */
    permissions: string[];

    /**
     * Has permission
     */
    hasPermission: boolean;

    /**
     * Invert the permission (used for else)
     */
    invert: boolean;

    /**
     * Content protected by the permissions gate
     */
    children: React.ReactNode;
}

export default class AnyTeamPermissionGate extends React.PureComponent<Props> {
    static defaultProps = {
        invert: false,
    }

    render() {
        if (this.props.hasPermission !== this.props.invert) {
            return this.props.children;
        }
        return null;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {haveITeamPermission} from 'mattermost-redux/selectors/entities/roles';
import {getMyTeams} from 'mattermost-redux/selectors/entities/teams';
import {GlobalState} from '@mattermost/types/store';

import AnyTeamPermissionGate from './any_team_permission_gate';

type Props = {
    permissions: string[];
}

function mapStateToProps(state: GlobalState, ownProps: Props) {
    const teams = getMyTeams(state);
    for (const team of teams) {
        for (const permission of ownProps.permissions) {
            if (haveITeamPermission(state, team.id, permission)) {
                return {hasPermission: true};
            }
        }
    }

    return {hasPermission: false};
}

export default connect(mapStateToProps)(AnyTeamPermissionGate);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

type Props = {

    /**
     * Channel to check the permission
     */
    channelId?: string;

    /**
     * Team to check the permission
     */
    teamId?: string;

    /**
     * Permissions enough to pass the gate (binary OR)
     */
    permissions: string[];

    /**
     * Has permission
     */
    hasPermission: boolean;

    /**
     * Invert the permission (used for else)
     */
    invert?: boolean;

    /**
     * Content protected by the permissions gate
     */
    children: React.ReactNode;
}

export default class ChannelPermissionGate extends React.PureComponent<Props> {
    render() {
        const {hasPermission, children, invert = false} = this.props;

        if (hasPermission && !invert) {
            return children;
        }
        if (!hasPermission && invert) {
            return children;
        }
        return null;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {haveIChannelPermission} from 'mattermost-redux/selectors/entities/roles';
import {GlobalState} from '@mattermost/types/store';

import ChannelPermissionGate from './channel_permission_gate';

type Props = {
    channelId?: string;
    teamId?: string;
    permissions: string[];
}

function mapStateToProps(state: GlobalState, ownProps: Props) {
    if (!ownProps.channelId || ownProps.teamId === null || typeof ownProps.teamId === 'undefined') {
        return {hasPermission: false};
    }

    for (const permission of ownProps.permissions) {
        if (haveIChannelPermission(state, ownProps.teamId, ownProps.channelId, permission)) {
            return {hasPermission: true};
        }
    }

    return {hasPermission: false};
}

export default connect(mapStateToProps)(ChannelPermissionGate);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

type Props = {
    permissions: string[];

    /**
     * Has permission
     * This prop is will always be passed by the mapStateToProps function
     * it should be required when this component is converted to TS, for now its optional to make the TS compiler quite.
     * about this prop not being passed from where this component is used
     */
    hasPermission: boolean;

    /**
     * Invert the permission (used for else)
     */
    invert: boolean;

    /**
     * Content protected by the permissions gate
     */
    children: React.ReactNode;
};

export default class SystemPermissionGate extends React.PureComponent<Props> {
    public static defaultProps = {
        invert: false,
    }

    render() {
        if (this.props.hasPermission && !this.props.invert) {
            return this.props.children;
        }
        if (!this.props.hasPermission && this.props.invert) {
            return this.props.children;
        }
        return null;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {haveISystemPermission} from 'mattermost-redux/selectors/entities/roles';

import {GlobalState} from 'types/store';

import SystemPermissionGate from './system_permission_gate';

type Props = {
    permissions: string[];
}
function mapStateToProps(state: GlobalState, ownProps: Props) {
    for (const permission of ownProps.permissions) {
        if (haveISystemPermission(state, {permission})) {
            return {hasPermission: true};
        }
    }

    return {hasPermission: false};
}

export default connect(mapStateToProps)(SystemPermissionGate);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

type Props = {

    /**
     * Team to check the permission
     */
    teamId?: string;

    /**
     * Permissions enough to pass the gate (binary OR)
     */
    permissions: string[];

    /**
     * Has permission
     */
    hasPermission: boolean;

    /**
     * Invert the permission (used for else)
     */
    invert: boolean;

    /**
     * Content protected by the permissions gate
     */
    children: React.ReactNode;
};

export default class TeamPermissionGate extends React.PureComponent<Props> {
    public static defaultProps = {
        invert: false,
    }

    render() {
        if (this.props.hasPermission && !this.props.invert) {
            return this.props.children;
        }
        if (!this.props.hasPermission && this.props.invert) {
            return this.props.children;
        }
        return null;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {haveITeamPermission} from 'mattermost-redux/selectors/entities/roles';

import {GlobalState} from 'types/store';

import TeamPermissionGate from './team_permission_gate';

type Props = {
    teamId: string;
    permissions: string[];
}

function mapStateToProps(state: GlobalState, ownProps: Props) {
    if (!ownProps.teamId) {
        return {hasPermission: false};
    }

    for (const permission of ownProps.permissions) {
        if (haveITeamPermission(state, ownProps.teamId, permission)) {
            return {hasPermission: true};
        }
    }

    return {hasPermission: false};
}

export default connect(mapStateToProps)(TeamPermissionGate);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {connect} from 'react-redux';
import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';

import {GenericAction, ActionFunc} from 'mattermost-redux/types/actions';

import {GlobalState} from 'types/store';
import {getListing, getInstalledListing} from 'selectors/views/marketplace';
import {setFirstAdminVisitMarketplaceStatus} from 'mattermost-redux/actions/general';
import {getPluginStatuses} from 'mattermost-redux/actions/admin';
import {getFirstAdminVisitMarketplaceStatus} from 'mattermost-redux/selectors/entities/general';

import {makeAsyncComponent} from 'components/async_load';

import {isModalOpen} from 'selectors/views/modals';
import {ModalIdentifiers} from 'utils/constants';
import {getSiteURL} from 'utils/url';

import {closeModal} from 'actions/views/modals';
import {fetchListing, filterListing} from 'actions/marketplace';

const MarketplaceModal = makeAsyncComponent('MarketplaceModal', React.lazy(() => import('./marketplace_modal')));

function mapStateToProps(state: GlobalState) {
    return {
        show: isModalOpen(state, ModalIdentifiers.PLUGIN_MARKETPLACE),
        listing: getListing(state),
        installedListing: getInstalledListing(state),
        siteURL: getSiteURL(),
        pluginStatuses: state.entities.admin.pluginStatuses,
        firstAdminVisitMarketplaceStatus: getFirstAdminVisitMarketplaceStatus(state),
    };
}

type Actions = {
    closeModal(): void;
    fetchListing(localOnly?: boolean): Promise<{error?: Error}>;
    filterListing(filter: string): Promise<{error?: Error}>;
    setFirstAdminVisitMarketplaceStatus(): Promise<void>;
    getPluginStatuses(): Promise<void>;
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc | GenericAction>, Actions>({
            closeModal: () => closeModal(ModalIdentifiers.PLUGIN_MARKETPLACE),
            fetchListing,
            filterListing,
            setFirstAdminVisitMarketplaceStatus,
            getPluginStatuses,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(MarketplaceModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {injectIntl, IntlShape, MessageDescriptor} from 'react-intl';

import {Posts} from 'mattermost-redux/constants';

import {t} from 'utils/i18n';
import Markdown from 'components/markdown';
import {TextFormattingOptions} from 'utils/text_formatting';

const typeMessage = {
    [Posts.POST_TYPES.ADD_TO_CHANNEL]: {
        id: t('last_users_message.added_to_channel.type'),
        defaultMessage: 'were **added to the channel** by {actor}.',
    },
    [Posts.POST_TYPES.JOIN_CHANNEL]: {
        id: t('last_users_message.joined_channel.type'),
        defaultMessage: '**joined the channel**.',
    },
    [Posts.POST_TYPES.LEAVE_CHANNEL]: {
        id: t('last_users_message.left_channel.type'),
        defaultMessage: '**left the channel**.',
    },
    [Posts.POST_TYPES.REMOVE_FROM_CHANNEL]: {
        id: t('last_users_message.removed_from_channel.type'),
        defaultMessage: 'were **removed from the channel**.',
    },
    [Posts.POST_TYPES.ADD_TO_TEAM]: {
        id: t('last_users_message.added_to_team.type'),
        defaultMessage: 'were **added to the team** by {actor}.',
    },
    [Posts.POST_TYPES.JOIN_TEAM]: {
        id: t('last_users_message.joined_team.type'),
        defaultMessage: '**joined the team**.',
    },
    [Posts.POST_TYPES.LEAVE_TEAM]: {
        id: t('last_users_message.left_team.type'),
        defaultMessage: '**left the team**.',
    },
    [Posts.POST_TYPES.REMOVE_FROM_TEAM]: {
        id: t('last_users_message.removed_from_team.type'),
        defaultMessage: 'were **removed from the team**.',
    },
};

type Props = {
    actor?: string;
    expandedLocale: MessageDescriptor;
    formatOptions: Partial<TextFormattingOptions>;
    intl: IntlShape;
    postType: string;
    usernames: string[];
}

type State = {
    expand: boolean;
}

export class LastUsers extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            expand: false,
        };
    }

    handleOnClick = (e: React.MouseEvent<HTMLAnchorElement, MouseEvent>): void => {
        e.preventDefault();

        this.setState({expand: true});
    }

    renderMessage = (formattedMessage: string): JSX.Element => {
        return (
            <Markdown
                message={formattedMessage}
                options={this.props.formatOptions}
            />
        );
    }

    render(): JSX.Element {
        const {formatMessage} = this.props.intl;
        const {expand} = this.state;
        const {
            actor,
            expandedLocale,
            postType,
            usernames,
        } = this.props;

        const firstUser = usernames[0];
        const lastIndex = usernames.length - 1;
        const lastUser = usernames[lastIndex];

        if (expand) {
            const formattedMessage = formatMessage(expandedLocale, {
                users: usernames.slice(0, lastIndex).join(', '),
                lastUser,
                actor,
            });

            return this.renderMessage(formattedMessage);
        }

        const firstUserMessage = formatMessage(
            {id: 'last_users_message.first', defaultMessage: '{firstUser} and '},
            {firstUser},
        );

        const otherUsersMessage = formatMessage(
            {id: 'last_users_message.others', defaultMessage: '{numOthers} others '},
            {numOthers: lastIndex},
        );

        const actorMessage = formatMessage(
            {id: typeMessage[postType].id, defaultMessage: typeMessage[postType].defaultMessage},
            {actor},
        );

        return (
            <span>
                {this.renderMessage(firstUserMessage)}
                <a onClick={this.handleOnClick}>
                    {otherUsersMessage}
                </a>
                {this.renderMessage(actorMessage)}
            </span>
        );
    }
}
export default injectIntl(LastUsers);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {injectIntl, IntlShape, MessageDescriptor} from 'react-intl';

import {Posts} from 'mattermost-redux/constants';

import {UserProfile} from '@mattermost/types/users';

import {ActionFunc} from 'mattermost-redux/types/actions';

import {t} from 'utils/i18n';
import Markdown from 'components/markdown';

import LastUsers from './last_users';

const {
    JOIN_CHANNEL, ADD_TO_CHANNEL, REMOVE_FROM_CHANNEL, LEAVE_CHANNEL,
    JOIN_TEAM, ADD_TO_TEAM, REMOVE_FROM_TEAM, LEAVE_TEAM,
} = Posts.POST_TYPES;

const postTypeMessage = {
    [JOIN_CHANNEL]: {
        one: {
            id: t('combined_system_message.joined_channel.one'),
            defaultMessage: '{firstUser} **joined the channel**.',
        },
        one_you: {
            id: t('combined_system_message.joined_channel.one_you'),
            defaultMessage: 'You **joined the channel**.',
        },
        two: {
            id: t('combined_system_message.joined_channel.two'),
            defaultMessage: '{firstUser} and {secondUser} **joined the channel**.',
        },
        many_expanded: {
            id: t('combined_system_message.joined_channel.many_expanded'),
            defaultMessage: '{users} and {lastUser} **joined the channel**.',
        },
    },
    [ADD_TO_CHANNEL]: {
        one: {
            id: t('combined_system_message.added_to_channel.one'),
            defaultMessage: '{firstUser} **added to the channel** by {actor}.',
        },
        one_you: {
            id: t('combined_system_message.added_to_channel.one_you'),
            defaultMessage: 'You were **added to the channel** by {actor}.',
        },
        two: {
            id: t('combined_system_message.added_to_channel.two'),
            defaultMessage: '{firstUser} and {secondUser} **added to the channel** by {actor}.',
        },
        many_expanded: {
            id: t('combined_system_message.added_to_channel.many_expanded'),
            defaultMessage: '{users} and {lastUser} were **added to the channel** by {actor}.',
        },
    },
    [REMOVE_FROM_CHANNEL]: {
        one: {
            id: t('combined_system_message.removed_from_channel.one'),
            defaultMessage: '{firstUser} was **removed from the channel**.',
        },
        one_you: {
            id: t('combined_system_message.removed_from_channel.one_you'),
            defaultMessage: 'You were **removed from the channel**.',
        },
        two: {
            id: t('combined_system_message.removed_from_channel.two'),
            defaultMessage: '{firstUser} and {secondUser} were **removed from the channel**.',
        },
        many_expanded: {
            id: t('combined_system_message.removed_from_channel.many_expanded'),
            defaultMessage: '{users} and {lastUser} were **removed from the channel**.',
        },
    },
    [LEAVE_CHANNEL]: {
        one: {
            id: t('combined_system_message.left_channel.one'),
            defaultMessage: '{firstUser} **left the channel**.',
        },
        one_you: {
            id: t('combined_system_message.left_channel.one_you'),
            defaultMessage: 'You **left the channel**.',
        },
        two: {
            id: t('combined_system_message.left_channel.two'),
            defaultMessage: '{firstUser} and {secondUser} **left the channel**.',
        },
        many_expanded: {
            id: t('combined_system_message.left_channel.many_expanded'),
            defaultMessage: '{users} and {lastUser} **left the channel**.',
        },
    },
    [JOIN_TEAM]: {
        one: {
            id: t('combined_system_message.joined_team.one'),
            defaultMessage: '{firstUser} **joined the team**.',
        },
        one_you: {
            id: t('combined_system_message.joined_team.one_you'),
            defaultMessage: 'You **joined the team**.',
        },
        two: {
            id: t('combined_system_message.joined_team.two'),
            defaultMessage: '{firstUser} and {secondUser} **joined the team**.',
        },
        many_expanded: {
            id: t('combined_system_message.joined_team.many_expanded'),
            defaultMessage: '{users} and {lastUser} **joined the team**.',
        },
    },
    [ADD_TO_TEAM]: {
        one: {
            id: t('combined_system_message.added_to_team.one'),
            defaultMessage: '{firstUser} **added to the team** by {actor}.',
        },
        one_you: {
            id: t('combined_system_message.added_to_team.one_you'),
            defaultMessage: 'You were **added to the team** by {actor}.',
        },
        two: {
            id: t('combined_system_message.added_to_team.two'),
            defaultMessage: '{firstUser} and {secondUser} **added to the team** by {actor}.',
        },
        many_expanded: {
            id: t('combined_system_message.added_to_team.many_expanded'),
            defaultMessage: '{users} and {lastUser} were **added to the team** by {actor}.',
        },
    },
    [REMOVE_FROM_TEAM]: {
        one: {
            id: t('combined_system_message.removed_from_team.one'),
            defaultMessage: '{firstUser} was **removed from the team**.',
        },
        one_you: {
            id: t('combined_system_message.removed_from_team.one_you'),
            defaultMessage: 'You were **removed from the team**.',
        },
        two: {
            id: t('combined_system_message.removed_from_team.two'),
            defaultMessage: '{firstUser} and {secondUser} were **removed from the team**.',
        },
        many_expanded: {
            id: t('combined_system_message.removed_from_team.many_expanded'),
            defaultMessage: '{users} and {lastUser} were **removed from the team**.',
        },
    },
    [LEAVE_TEAM]: {
        one: {
            id: t('combined_system_message.left_team.one'),
            defaultMessage: '{firstUser} **left the team**.',
        },
        one_you: {
            id: t('combined_system_message.left_team.one_you'),
            defaultMessage: 'You **left the team**.',
        },
        two: {
            id: t('combined_system_message.left_team.two'),
            defaultMessage: '{firstUser} and {secondUser} **left the team**.',
        },
        many_expanded: {
            id: t('combined_system_message.left_team.many_expanded'),
            defaultMessage: '{users} and {lastUser} **left the team**.',
        },
    },
};

export type Props = {
    allUserIds: string[];
    allUsernames: string[];
    currentUserId: string;
    currentUsername: string;
    intl: IntlShape;
    messageData: Array<{
        actorId?: string;
        postType: string;
        userIds: string[];
    }>;
    showJoinLeave: boolean;
    userProfiles: UserProfile[];
    actions: {
        getMissingProfilesByIds: (userIds: string[]) => ActionFunc ;
        getMissingProfilesByUsernames: (usernames: string[]) => ActionFunc;
    };
}

export class CombinedSystemMessage extends React.PureComponent<Props> {
    static defaultProps = {
        allUserIds: [],
        allUsernames: [],
    };

    componentDidMount(): void {
        this.loadUserProfiles(this.props.allUserIds, this.props.allUsernames);
    }

    componentDidUpdate(prevProps: Props): void {
        const {allUserIds, allUsernames} = this.props;
        if (allUserIds !== prevProps.allUserIds || allUsernames !== prevProps.allUsernames) {
            this.loadUserProfiles(allUserIds, allUsernames);
        }
    }

    loadUserProfiles = (allUserIds: string[], allUsernames: string[]): void => {
        if (allUserIds.length > 0) {
            this.props.actions.getMissingProfilesByIds(allUserIds);
        }

        if (allUsernames.length > 0) {
            this.props.actions.getMissingProfilesByUsernames(allUsernames);
        }
    }

    getAllUsernames = (): {[p: string]: string} => {
        const {
            allUserIds,
            allUsernames,
            currentUserId,
            currentUsername,
            userProfiles,
        } = this.props;
        const {formatMessage} = this.props.intl;
        const usernames = userProfiles.reduce((acc: {[key: string]: string}, user: UserProfile) => {
            acc[user.id] = user.username;
            acc[user.username] = user.username;
            return acc;
        }, {});

        const currentUserDisplayName = formatMessage({id: t('combined_system_message.you'), defaultMessage: 'You'});
        if (allUserIds.includes(currentUserId)) {
            usernames[currentUserId] = currentUserDisplayName;
        } else if (allUsernames.includes(currentUsername)) {
            usernames[currentUsername] = currentUserDisplayName;
        }

        return usernames;
    }

    getUsernamesByIds = (userIds: string[] = []): string[] => {
        const {currentUserId, currentUsername} = this.props;
        const allUsernames = this.getAllUsernames();

        const {formatMessage} = this.props.intl;
        const someone = formatMessage({id: t('channel_loader.someone'), defaultMessage: 'Someone'});

        const usernames = userIds.
            filter((userId) => {
                return userId !== currentUserId && userId !== currentUsername;
            }).
            map((userId) => {
                return allUsernames[userId] ? `@${allUsernames[userId]}` : someone;
            }).filter((username) => {
                return username && username !== '';
            });

        if (userIds.includes(currentUserId)) {
            usernames.unshift(allUsernames[currentUserId]);
        } else if (userIds.includes(currentUsername)) {
            usernames.unshift(allUsernames[currentUsername]);
        }

        return usernames;
    }

    renderFormattedMessage(postType: string, userIds: string[], actorId?: string): JSX.Element {
        const {formatMessage} = this.props.intl;
        const {currentUserId, currentUsername} = this.props;
        const usernames = this.getUsernamesByIds(userIds);
        let actor = actorId ? this.getUsernamesByIds([actorId])[0] : '';
        if (actor && (actorId === currentUserId || actorId === currentUsername)) {
            actor = actor.toLowerCase();
        }

        const firstUser = usernames[0];
        const secondUser = usernames[1];
        const numOthers = usernames.length - 1;

        const options = {
            atMentions: true,
            mentionKeys: [{key: firstUser}, {key: secondUser}, {key: actor}],
            mentionHighlight: false,
            singleline: true,
        };

        if (numOthers > 1) {
            return (
                <LastUsers
                    actor={actor}
                    expandedLocale={postTypeMessage[postType].many_expanded}
                    formatOptions={options}
                    postType={postType}
                    usernames={usernames}
                />
            );
        }

        let localeHolder: MessageDescriptor = {};
        if (numOthers === 0) {
            localeHolder = postTypeMessage[postType].one;

            if (
                (userIds[0] === this.props.currentUserId || userIds[0] === this.props.currentUsername) &&
                postTypeMessage[postType].one_you
            ) {
                localeHolder = postTypeMessage[postType].one_you;
            }
        } else if (numOthers === 1) {
            localeHolder = postTypeMessage[postType].two;
        }

        const formattedMessage = formatMessage(localeHolder, {firstUser, secondUser, actor});

        return (
            <Markdown
                message={formattedMessage}
                options={options}
            />
        );
    }

    renderMessage(postType: string, userIds: string[], actorId?: string): JSX.Element {
        return (
            <React.Fragment key={postType + actorId}>
                {this.renderFormattedMessage(postType, userIds, actorId)}
                <br/>
            </React.Fragment>
        );
    }

    render(): JSX.Element {
        const {
            currentUserId,
            messageData,
        } = this.props;

        const content = [];
        const removedUserIds = [];
        for (const message of messageData) {
            const {
                postType,
                actorId,
            } = message;
            let userIds = message.userIds;

            if (!this.props.showJoinLeave && actorId !== currentUserId) {
                const affectsCurrentUser = userIds.indexOf(currentUserId) !== -1;

                if (affectsCurrentUser) {
                    // Only show the message that the current user was added, etc
                    userIds = [currentUserId];
                } else {
                    // Not something the current user did or was affected by
                    continue;
                }
            }

            if (postType === REMOVE_FROM_CHANNEL) {
                removedUserIds.push(...userIds);
                continue;
            }

            content.push(this.renderMessage(postType, userIds, actorId));
        }

        if (removedUserIds.length > 0) {
            const uniqueRemovedUserIds = removedUserIds.filter((id, index, arr) => arr.indexOf(id) === index);
            content.push(this.renderMessage(REMOVE_FROM_CHANNEL, uniqueRemovedUserIds, currentUserId));
        }

        return (
            <React.Fragment>
                {content}
            </React.Fragment>
        );
    }
}

export default injectIntl(CombinedSystemMessage);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {getMissingProfilesByIds, getMissingProfilesByUsernames} from 'mattermost-redux/actions/users';
import {Preferences} from 'mattermost-redux/constants';
import {getBool} from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentUser, makeGetProfilesByIdsAndUsernames} from 'mattermost-redux/selectors/entities/users';
import {GlobalState} from '@mattermost/types/store';
import {GenericAction} from 'mattermost-redux/types/actions';

import CombinedSystemMessage from './combined_system_message';

type OwnProps = {
    allUserIds: string[];
    allUsernames: string[];
}

function makeMapStateToProps() {
    const getProfilesByIdsAndUsernames = makeGetProfilesByIdsAndUsernames();

    return (state: GlobalState, ownProps: OwnProps) => {
        const currentUser = getCurrentUser(state);
        const {allUserIds, allUsernames} = ownProps;

        return {
            currentUserId: currentUser.id,
            currentUsername: currentUser.username,
            showJoinLeave: getBool(state, Preferences.CATEGORY_ADVANCED_SETTINGS, Preferences.ADVANCED_FILTER_JOIN_LEAVE, true),
            userProfiles: getProfilesByIdsAndUsernames(state, {allUserIds, allUsernames}),
        };
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            getMissingProfilesByIds,
            getMissingProfilesByUsernames,
        }, dispatch),
    };
}

export default connect(makeMapStateToProps, mapDispatchToProps)(CombinedSystemMessage);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {Post} from '@mattermost/types/posts';
import {UserProfile} from '@mattermost/types/users';

import {sendAddToChannelEphemeralPost} from 'actions/global_actions';
import {Constants} from 'utils/constants';
import {t} from 'utils/i18n';
import AtMention from 'components/at_mention';

interface Actions {
    addChannelMember: (channelId: string, userId: string, rootId: string) => void;
    removePost: (post: Post) => void;
}

export interface Props {
    currentUser: UserProfile;
    channelType: string;
    postId: string;
    post: Post;
    userIds: string[];
    usernames: string[];
    noGroupsUsernames: string[];
    actions: Actions;
}

interface State {
    expanded: boolean;
}

export default class PostAddChannelMember extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            expanded: false,
        };
    }

    handleAddChannelMember = () => {
        const {currentUser, post, userIds, usernames} = this.props;

        if (post && post.channel_id) {
            let createAt = post.create_at;
            userIds.forEach((userId, index) => {
                createAt++;
                this.props.actions.addChannelMember(post.channel_id, userId, post.root_id);
                sendAddToChannelEphemeralPost(currentUser, usernames[index], userId, post.channel_id, post.root_id, createAt);
            });

            this.props.actions.removePost(post);
        }
    }

    expand = () => {
        this.setState({expanded: true});
    }

    generateAtMentions(usernames = [] as string[]) {
        if (usernames.length === 1) {
            return (
                <AtMention
                    mentionName={usernames[0]}
                    channelId={this.props.post?.channel_id}
                />
            );
        } else if (usernames.length > 1) {
            function andSeparator(key: number) {
                return (
                    <FormattedMessage
                        key={key}
                        id={'post_body.check_for_out_of_channel_mentions.link.and'}
                        defaultMessage={' and '}
                    />
                );
            }

            function commaSeparator(key: number) {
                return <span key={key}>{', '}</span>;
            }

            if (this.state.expanded || usernames.length <= 3) {
                return (
                    <span>
                        {
                            usernames.map((username) => {
                                return (
                                    <AtMention
                                        key={username}
                                        mentionName={username}
                                        channelId={this.props.post?.channel_id}
                                    />
                                );
                            }).reduce((acc, el, idx, arr) => {
                                if (idx === 0) {
                                    return [el];
                                } else if (idx === arr.length - 1) {
                                    return [...acc, andSeparator(idx), el];
                                }

                                return [...acc, commaSeparator(idx), el];
                            }, [] as JSX.Element[])
                        }
                    </span>
                );
            }
            const otherUsers = [...usernames];
            const firstUserName = otherUsers.shift();
            const lastUserName = otherUsers.pop();
            return (
                <span>
                    <AtMention
                        key={firstUserName}
                        mentionName={firstUserName}
                        channelId={this.props.post?.channel_id}
                    />
                    {commaSeparator(1)}
                    <a
                        className='PostBody_otherUsersLink'
                        onClick={this.expand}
                    >
                        <FormattedMessage
                            id={'post_body.check_for_out_of_channel_mentions.others'}
                            defaultMessage={'{numOthers} others'}
                            values={{
                                numOthers: otherUsers.length,
                            }}
                        />
                    </a>
                    {andSeparator(1)}
                    <AtMention
                        key={lastUserName}
                        mentionName={lastUserName}
                        channelId={this.props.post?.channel_id}
                    />
                </span>
            );
        }

        return '';
    }

    render() {
        const {channelType, postId, usernames, noGroupsUsernames} = this.props;
        if (!postId || !channelType) {
            return null;
        }

        let linkId;
        let linkText;
        if (channelType === Constants.PRIVATE_CHANNEL) {
            linkId = t('post_body.check_for_out_of_channel_mentions.link.private');
            linkText = 'add them to this private channel';
        } else if (channelType === Constants.OPEN_CHANNEL) {
            linkId = t('post_body.check_for_out_of_channel_mentions.link.public');
            linkText = 'add them to the channel';
        }

        let outOfChannelMessageID;
        let outOfChannelMessageText;
        const outOfChannelAtMentions = this.generateAtMentions(usernames);
        if (usernames.length === 1) {
            outOfChannelMessageID = t('post_body.check_for_out_of_channel_mentions.message.one');
            outOfChannelMessageText = 'did not get notified by this mention because they are not in the channel. Would you like to ';
        } else if (usernames.length > 1) {
            outOfChannelMessageID = t('post_body.check_for_out_of_channel_mentions.message.multiple');
            outOfChannelMessageText = 'did not get notified by this mention because they are not in the channel. Would you like to ';
        }

        let outOfGroupsMessageID;
        let outOfGroupsMessageText;
        const outOfGroupsAtMentions = this.generateAtMentions(noGroupsUsernames);
        if (noGroupsUsernames.length) {
            outOfGroupsMessageID = t('post_body.check_for_out_of_channel_groups_mentions.message');
            outOfGroupsMessageText = 'did not get notified by this mention because they are not in the channel. They cannot be added to the channel because they are not a member of the linked groups. To add them to this channel, they must be added to the linked groups.';
        }

        let outOfChannelMessage = null;
        let outOfGroupsMessage = null;

        if (usernames.length) {
            outOfChannelMessage = (
                <p>
                    {outOfChannelAtMentions}
                    {' '}
                    <FormattedMessage
                        id={outOfChannelMessageID}
                        defaultMessage={outOfChannelMessageText}
                    />
                    <a
                        className='PostBody_addChannelMemberLink'
                        onClick={this.handleAddChannelMember}
                    >
                        <FormattedMessage
                            id={linkId}
                            defaultMessage={linkText}
                        />
                    </a>
                    <FormattedMessage
                        id={'post_body.check_for_out_of_channel_mentions.message_last'}
                        defaultMessage={'? They will have access to all message history.'}
                    />
                </p>
            );
        }

        if (noGroupsUsernames.length) {
            outOfGroupsMessage = (
                <p>
                    {outOfGroupsAtMentions}
                    {' '}
                    <FormattedMessage
                        id={outOfGroupsMessageID}
                        defaultMessage={outOfGroupsMessageText}
                    />
                </p>
            );
        }

        return (
            <>
                {outOfChannelMessage}
                {outOfGroupsMessage}
            </>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {bindActionCreators, Dispatch} from 'redux';
import {connect} from 'react-redux';

import {addChannelMember} from 'mattermost-redux/actions/channels';
import {removePost} from 'mattermost-redux/actions/posts';
import {getPost} from 'mattermost-redux/selectors/entities/posts';
import {getChannel} from 'mattermost-redux/selectors/entities/channels';
import {getCurrentUser} from 'mattermost-redux/selectors/entities/users';
import {GlobalState} from '@mattermost/types/store';
import {GenericAction} from 'mattermost-redux/types/actions';

import PostAddChannelMember from './post_add_channel_member';

type OwnProps = {
    postId: string;
}

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const post = getPost(state, ownProps.postId) || {};
    let channelType = '';
    if (post && post.channel_id) {
        const channel = getChannel(state, post.channel_id);
        if (channel && channel.type) {
            channelType = channel.type;
        }
    }

    return {
        channelType,
        currentUser: getCurrentUser(state),
        post,
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            addChannelMember,
            removePost,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(PostAddChannelMember);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode} from 'react';
import {FormattedMessage} from 'react-intl';

import {General, Posts} from 'mattermost-redux/constants';
import {Post} from '@mattermost/types/posts';

import {Channel} from '@mattermost/types/channels';

import * as Utils from 'utils/utils';
import {TextFormattingOptions} from 'utils/text_formatting';

import Markdown from 'components/markdown';
import CombinedSystemMessage from 'components/post_view/combined_system_message';
import PostAddChannelMember from 'components/post_view/post_add_channel_member';

function renderUsername(value: string): ReactNode {
    const username = (value[0] === '@') ? value : `@${value}`;

    const options = {
        markdown: false,
    };

    return renderFormattedText(username, options);
}

function renderFormattedText(value: string, options?: Partial<TextFormattingOptions>, post?: Post): ReactNode {
    return (
        <Markdown
            message={value}
            options={options}
            postId={post && post.id}
            postType={post && post.type}
        />
    );
}

function renderJoinChannelMessage(post: Post): ReactNode {
    const username = renderUsername(post.props.username);

    return (
        <FormattedMessage
            id='api.channel.join_channel.post_and_forget'
            defaultMessage='{username} joined the channel.'
            values={{username}}
        />
    );
}

function renderGuestJoinChannelMessage(post: Post): ReactNode {
    const username = renderUsername(post.props.username);

    return (
        <FormattedMessage
            id='api.channel.guest_join_channel.post_and_forget'
            defaultMessage='{username} joined the channel as a guest.'
            values={{username}}
        />
    );
}

function renderLeaveChannelMessage(post: Post): ReactNode {
    const username = renderUsername(post.props.username);

    return (
        <FormattedMessage
            id='api.channel.leave.left'
            defaultMessage='{username} has left the channel.'
            values={{username}}
        />
    );
}

function renderAddToChannelMessage(post: Post): ReactNode {
    const username = renderUsername(post.props.username);
    const addedUsername = renderUsername(post.props.addedUsername);

    return (
        <FormattedMessage
            id='api.channel.add_member.added'
            defaultMessage='{addedUsername} added to the channel by {username}.'
            values={{
                username,
                addedUsername,
            }}
        />
    );
}

function renderAddGuestToChannelMessage(post: Post): ReactNode {
    const username = renderUsername(post.props.username);
    const addedUsername = renderUsername(post.props.addedUsername);

    return (
        <FormattedMessage
            id='api.channel.add_guest.added'
            defaultMessage='{addedUsername} added to the channel as a guest by {username}.'
            values={{
                username,
                addedUsername,
            }}
        />
    );
}

function renderRemoveFromChannelMessage(post: Post): ReactNode {
    const removedUsername = renderUsername(post.props.removedUsername);

    return (
        <FormattedMessage
            id='api.channel.remove_member.removed'
            defaultMessage='{removedUsername} was removed from the channel'
            values={{
                removedUsername,
            }}
        />
    );
}

function renderJoinTeamMessage(post: Post): ReactNode {
    const username = renderUsername(post.props.username);

    return (
        <FormattedMessage
            id='api.team.join_team.post_and_forget'
            defaultMessage='{username} joined the team.'
            values={{username}}
        />
    );
}

function renderLeaveTeamMessage(post: Post): ReactNode {
    const username = renderUsername(post.props.username);

    return (
        <FormattedMessage
            id='api.team.leave.left'
            defaultMessage='{username} left the team.'
            values={{username}}
        />
    );
}

function renderAddToTeamMessage(post: Post): ReactNode {
    const username = renderUsername(post.props.username);
    const addedUsername = renderUsername(post.props.addedUsername);

    return (
        <FormattedMessage
            id='api.team.add_member.added'
            defaultMessage='{addedUsername} added to the team by {username}.'
            values={{
                username,
                addedUsername,
            }}
        />
    );
}

function renderRemoveFromTeamMessage(post: Post): ReactNode {
    const removedUsername = renderUsername(post.props.username);

    return (
        <FormattedMessage
            id='api.team.remove_user_from_team.removed'
            defaultMessage='{removedUsername} was removed from the team.'
            values={{
                removedUsername,
            }}
        />
    );
}

function renderHeaderChangeMessage(post: Post): ReactNode {
    if (!post.props.username) {
        return null;
    }

    const headerOptions = {
        singleline: true,
        channelNamesMap: post.props && post.props.channel_mentions,
        mentionHighlight: true,
    };

    const username = renderUsername(post.props.username);
    const oldHeader = post.props.old_header ? renderFormattedText(post.props.old_header, headerOptions, post) : null;
    const newHeader = post.props.new_header ? renderFormattedText(post.props.new_header, headerOptions, post) : null;

    if (post.props.new_header) {
        if (post.props.old_header) {
            return (
                <FormattedMessage
                    id='api.channel.post_update_channel_header_message_and_forget.updated_from'
                    defaultMessage='{username} updated the channel header <br></br><strong>From:</strong> {old} <br></br><strong>To:</strong> {new}'
                    values={{
                        username,
                        old: oldHeader,
                        new: newHeader,
                        strong: (chunks: React.ReactNode) => (<strong>{chunks}</strong>),
                        br: (x: React.ReactNode) => (<><br/>{x}</>),
                    }}
                />
            );
        }

        return (
            <FormattedMessage
                id='api.channel.post_update_channel_header_message_and_forget.updated_to'
                defaultMessage='{username} updated the channel header to: {new}'
                values={{
                    username,
                    new: newHeader,
                }}
            />
        );
    } else if (post.props.old_header) {
        return (
            <FormattedMessage
                id='api.channel.post_update_channel_header_message_and_forget.removed'
                defaultMessage='{username} removed the channel header (was: {old})'
                values={{
                    username,
                    old: oldHeader,
                }}
            />
        );
    }

    return null;
}

function renderDisplayNameChangeMessage(post: Post): ReactNode {
    if (!(post.props.username && post.props.old_displayname && post.props.new_displayname)) {
        return null;
    }

    const username = renderUsername(post.props.username);
    const oldDisplayName = post.props.old_displayname;
    const newDisplayName = post.props.new_displayname;

    return (
        <FormattedMessage
            id='api.channel.post_update_channel_displayname_message_and_forget.updated_from'
            defaultMessage='{username} updated the channel display name from: {old} to: {new}'
            values={{
                username,
                old: oldDisplayName,
                new: newDisplayName,
            }}
        />
    );
}

function renderConvertChannelToPrivateMessage(post: Post): ReactNode {
    if (!(post.props.username)) {
        return null;
    }

    const username = renderUsername(post.props.username);

    return (
        <FormattedMessage
            id='api.channel.post_convert_channel_to_private.updated_from'
            defaultMessage='{username} converted the channel from public to private'
            values={{
                username,
            }}
        />
    );
}

function renderPurposeChangeMessage(post: Post): ReactNode {
    if (!post.props.username) {
        return null;
    }

    const username = renderUsername(post.props.username);
    const oldPurpose = post.props.old_purpose;
    const newPurpose = post.props.new_purpose;

    if (post.props.new_purpose) {
        if (post.props.old_purpose) {
            return (
                <FormattedMessage
                    id='app.channel.post_update_channel_purpose_message.updated_from'
                    defaultMessage='{username} updated the channel purpose from: {old} to: {new}'
                    values={{
                        username,
                        old: oldPurpose,
                        new: newPurpose,
                    }}
                />
            );
        }

        return (
            <FormattedMessage
                id='app.channel.post_update_channel_purpose_message.updated_to'
                defaultMessage='{username} updated the channel purpose to: {new}'
                values={{
                    username,
                    new: newPurpose,
                }}
            />
        );
    } else if (post.props.old_purpose) {
        return (
            <FormattedMessage
                id='app.channel.post_update_channel_purpose_message.removed'
                defaultMessage='{username} removed the channel purpose (was: {old})'
                values={{
                    username,
                    old: oldPurpose,
                }}
            />
        );
    }

    return null;
}

function renderChannelDeletedMessage(post: Post): ReactNode {
    if (!post.props.username) {
        return null;
    }

    const username = renderUsername(post.props.username);

    return (
        <FormattedMessage
            id='api.channel.delete_channel.archived'
            defaultMessage='{username} has archived the channel.'
            values={{username}}
        />
    );
}

function renderChannelUnarchivedMessage(post: Post): ReactNode {
    if (!post.props.username) {
        return null;
    }

    const username = renderUsername(post.props.username);

    return (
        <FormattedMessage
            id='api.channel.restore_channel.unarchived'
            defaultMessage='{username} has unarchived the channel.'
            values={{username}}
        />
    );
}

function renderMeMessage(post: Post): ReactNode {
    // Trim off the leading and trailing asterisk added to /me messages
    const message = post.message.replace(/^\*|\*$/g, '');

    return renderFormattedText(message);
}

const systemMessageRenderers = {
    [Posts.POST_TYPES.JOIN_CHANNEL]: renderJoinChannelMessage,
    [Posts.POST_TYPES.GUEST_JOIN_CHANNEL]: renderGuestJoinChannelMessage,
    [Posts.POST_TYPES.LEAVE_CHANNEL]: renderLeaveChannelMessage,
    [Posts.POST_TYPES.ADD_TO_CHANNEL]: renderAddToChannelMessage,
    [Posts.POST_TYPES.ADD_GUEST_TO_CHANNEL]: renderAddGuestToChannelMessage,
    [Posts.POST_TYPES.REMOVE_FROM_CHANNEL]: renderRemoveFromChannelMessage,
    [Posts.POST_TYPES.JOIN_TEAM]: renderJoinTeamMessage,
    [Posts.POST_TYPES.LEAVE_TEAM]: renderLeaveTeamMessage,
    [Posts.POST_TYPES.ADD_TO_TEAM]: renderAddToTeamMessage,
    [Posts.POST_TYPES.REMOVE_FROM_TEAM]: renderRemoveFromTeamMessage,
    [Posts.POST_TYPES.HEADER_CHANGE]: renderHeaderChangeMessage,
    [Posts.POST_TYPES.DISPLAYNAME_CHANGE]: renderDisplayNameChangeMessage,
    [Posts.POST_TYPES.CONVERT_CHANNEL]: renderConvertChannelToPrivateMessage,
    [Posts.POST_TYPES.PURPOSE_CHANGE]: renderPurposeChangeMessage,
    [Posts.POST_TYPES.CHANNEL_DELETED]: renderChannelDeletedMessage,
    [Posts.POST_TYPES.CHANNEL_UNARCHIVED]: renderChannelUnarchivedMessage,
    [Posts.POST_TYPES.ME]: renderMeMessage,
};

export function renderSystemMessage(post: Post, channel: Channel, isUserCanManageMembers?: boolean): ReactNode {
    if (post.props && post.props.add_channel_member) {
        const isEphemeral = Utils.isPostEphemeral(post);

        if (channel && (channel.type === General.PRIVATE_CHANNEL || channel.type === General.OPEN_CHANNEL) &&
            isUserCanManageMembers &&
            isEphemeral
        ) {
            const addMemberProps = post.props.add_channel_member;
            return (
                <PostAddChannelMember
                    postId={addMemberProps.post_id}
                    userIds={addMemberProps.not_in_channel_user_ids}
                    noGroupsUsernames={addMemberProps.not_in_groups_usernames}
                    usernames={addMemberProps.not_in_channel_usernames}
                />
            );
        }

        return null;
    } else if (systemMessageRenderers[post.type]) {
        return systemMessageRenderers[post.type](post);
    } else if (post.type === Posts.POST_TYPES.EPHEMERAL_ADD_TO_CHANNEL) {
        return renderAddToChannelMessage(post);
    } else if (post.type === Posts.POST_TYPES.COMBINED_USER_ACTIVITY) {
        const {allUserIds, allUsernames, messageData} = post.props.user_activity;

        return (
            <CombinedSystemMessage
                allUserIds={allUserIds}
                allUsernames={allUsernames}
                messageData={messageData}
            />
        );
    }

    return null;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import memoize from 'memoize-one';

import {Post} from '@mattermost/types/posts';
import {Channel} from '@mattermost/types/channels';

import Markdown from 'components/markdown';

import {MentionKey, TextFormattingOptions} from 'utils/text_formatting';

import {renderSystemMessage} from './system_message_helpers';

type Props = {

    /*
     * Any extra props that should be passed into the image component
     */
    imageProps?: Record<string, any>;

    /*
     * Whether or not this text is part of the RHS
     */
    isRHS?: boolean;

    /*
     * The post text to be rendered
     */
    message: string;

    /*
     * The optional post for which this message is being rendered
     */
    post?: Post;

    /*
     * The id of the channel that this post is being rendered in
     */
    channelId?: string;
    channel: Channel;
    options?: TextFormattingOptions;
    pluginHooks?: Array<Record<string, any>>;

    /**
     * Whether or not to place the LinkTooltip component inside links
     */
    hasPluginTooltips?: boolean;
    isUserCanManageMembers?: boolean;
    mentionKeys: MentionKey[];
}

export default class PostMarkdown extends React.PureComponent<Props> {
    static defaultProps = {
        isRHS: false,
        pluginHooks: [],
        options: {},
    };

    getOptions = memoize(
        (options?: TextFormattingOptions, disableGroupHighlight?: boolean, mentionHighlight?: boolean, editedAt?: number) => {
            return {
                ...options,
                disableGroupHighlight,
                mentionHighlight,
                editedAt,
            };
        })

    render() {
        let {message} = this.props;
        const {post, mentionKeys} = this.props;

        if (post) {
            const renderedSystemMessage = renderSystemMessage(post, this.props.channel, this.props.isUserCanManageMembers);
            if (renderedSystemMessage) {
                return <div>{renderedSystemMessage}</div>;
            }
        }

        // Proxy images if we have an image proxy and the server hasn't already rewritten the post's image URLs.
        const proxyImages = !post || !post.message_source || post.message === post.message_source;
        const channelNamesMap = post && post.props && post.props.channel_mentions;

        this.props.pluginHooks?.forEach((o) => {
            if (o && o.hook && post) {
                message = o.hook(post, message);
            }
        });

        let mentionHighlight = this.props.options?.mentionHighlight;
        if (post && post.props) {
            mentionHighlight = !post.props.mentionHighlightDisabled;
        }

        const options = this.getOptions(
            this.props.options,
            post?.props?.disable_group_highlight === true, // eslint-disable-line camelcase
            mentionHighlight,
            post?.edit_at,
        );

        return (
            <Markdown
                imageProps={this.props.imageProps}
                isRHS={this.props.isRHS}
                message={message}
                proxyImages={proxyImages}
                mentionKeys={mentionKeys}
                options={options}
                channelNamesMap={channelNamesMap}
                hasPluginTooltips={this.props.hasPluginTooltips}
                imagesMetadata={this.props.post?.metadata?.images}
                postId={this.props.post?.id}
                editedAt={this.props.post?.edit_at}
            />
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {createSelector} from 'reselect';

import {getChannel} from 'mattermost-redux/selectors/entities/channels';
import {
    getMyGroupMentionKeysForChannel,
    getMyGroupMentionKeys,
} from 'mattermost-redux/selectors/entities/groups';
import {getCurrentUserMentionKeys} from 'mattermost-redux/selectors/entities/users';
import {Post} from '@mattermost/types/posts';
import {Channel} from '@mattermost/types/channels';

import {GlobalState} from 'types/store';

import {canManageMembers} from 'utils/channel_utils';

import {MentionKey} from 'utils/text_formatting';

import PostMarkdown from './post_markdown';

export function makeGetMentionKeysForPost(): (
    state: GlobalState,
    post?: Post,
    channel?: Channel
) => MentionKey[] {
    return createSelector(
        'makeGetMentionKeysForPost',
        getCurrentUserMentionKeys,
        (state: GlobalState, post?: Post) => post,
        (state: GlobalState, post?: Post, channel?: Channel) =>
            (channel ? getMyGroupMentionKeysForChannel(state, channel.team_id, channel.id) : getMyGroupMentionKeys(state)),
        (mentionKeysWithoutGroups, post, groupMentionKeys) => {
            let mentionKeys = mentionKeysWithoutGroups;
            if (!post?.props?.disable_group_highlight) {
                // eslint-disable-line camelcase
                mentionKeys = mentionKeys.concat(groupMentionKeys);
            }

            if (post?.props?.mentionHighlightDisabled) {
                mentionKeys = mentionKeys.filter(
                    (value) => !['@all', '@channel', '@here'].includes(value.key),
                );
            }

            return mentionKeys;
        },
    );
}

type OwnProps = {
    channelId: string;
    mentionKeys: MentionKey[];
    post?: Post;
};

function makeMapStateToProps() {
    const getMentionKeysForPost = makeGetMentionKeysForPost();

    return (state: GlobalState, ownProps: OwnProps) => {
        const channel = getChannel(state, ownProps.channelId);

        return {
            channel,
            pluginHooks: state.plugins.components.MessageWillFormat,
            hasPluginTooltips: Boolean(state.plugins.components.LinkTooltip),
            isUserCanManageMembers: channel && canManageMembers(state, channel),
            mentionKeys: getMentionKeysForPost(state, ownProps.post, channel),
        };
    };
}

export default connect(makeMapStateToProps)(PostMarkdown);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useMemo} from 'react';
import {useIntl} from 'react-intl';
import styled from 'styled-components';

import {AlertOutlineIcon, AlertCircleOutlineIcon} from '@mattermost/compass-icons/components';

import Badge, {BadgeSize} from 'components/widgets/badges/badge';

import {PostPriority} from '@mattermost/types/posts';

type Props = {
    priority?: PostPriority|'';
    size?: BadgeSize;
    uppercase?: boolean;
}

const NoSpaceBadge = styled(Badge)`
    margin-left: 0;
`;

export default function PriorityLabel({
    priority,
    size = 'xs',
}: Props) {
    const {formatMessage} = useIntl();

    const iconSize = useMemo(() => {
        switch (size) {
        case 'xs':
            return 10;
        case 'sm':
            return 12;
        case 'md':
            return 14;
        case 'lg':
            return 16;
        default:
            return 10;
        }
    }, [size]);

    if (priority === PostPriority.URGENT) {
        return (
            <NoSpaceBadge
                size={size}
                uppercase={true}
                variant='danger'
                icon={(
                    <AlertOutlineIcon
                        color={'currentColor'}
                        size={iconSize}
                    />
                )}
            >
                {formatMessage({id: 'post_priority.priority.urgent', defaultMessage: 'URGENT'})}
            </NoSpaceBadge>
        );
    }

    if (priority === PostPriority.IMPORTANT) {
        return (
            <NoSpaceBadge
                size={size}
                uppercase={true}
                variant='info'
                icon={(
                    <AlertCircleOutlineIcon
                        color={'currentColor'}
                        size={iconSize}
                    />
                )}
            >
                {formatMessage({id: 'post_priority.priority.important', defaultMessage: 'IMPORTANT'})}
            </NoSpaceBadge>
        );
    }

    return null;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import ProfilePicture from 'components/profile_picture';
import MattermostLogo from 'components/widgets/icons/mattermost_logo';

import Constants, {UserStatuses} from 'utils/constants';
import * as PostUtils from 'utils/post_utils';
import * as Utils from 'utils/utils';

import {Post} from '@mattermost/types/posts';
import {UserProfile} from '@mattermost/types/users';

type Props = {
    availabilityStatusOnPosts: string;
    compactDisplay?: boolean;
    enablePostIconOverride: boolean;
    hasImageProxy: boolean;
    isBusy?: boolean;
    isRHS?: boolean;
    post: Post;
    status?: string;
    user: UserProfile;
    isBot?: boolean;
    postIconOverrideURL?: string;
    overwriteIcon?: string;
}

export default class PostProfilePicture extends React.PureComponent<Props> {
    static defaultProps = {
        status: UserStatuses.OFFLINE,
    };

    getProfilePictureURL = (): string => {
        const {post, user} = this.props;

        if (user && user.id === post.user_id) {
            return Utils.imageURLForUser(user.id, user.last_picture_update);
        } else if (post.user_id) {
            return Utils.imageURLForUser(post.user_id);
        }

        return '';
    };

    getStatus = (fromAutoResponder: boolean, fromWebhook: boolean, user: UserProfile): string | undefined => {
        if (fromAutoResponder || fromWebhook || (user && user.is_bot)) {
            return '';
        }

        return this.props.status;
    };

    getPostIconURL = (defaultURL: string, fromAutoResponder: boolean, fromWebhook: boolean): string => {
        const {enablePostIconOverride, hasImageProxy, post} = this.props;
        const postProps = post.props;
        let postIconOverrideURL = '';
        let useUserIcon = '';
        if (postProps) {
            postIconOverrideURL = postProps.override_icon_url;
            useUserIcon = postProps.use_user_icon;
        }

        if (this.props.compactDisplay) {
            return '';
        }

        if (!fromAutoResponder && fromWebhook && !useUserIcon && enablePostIconOverride) {
            if (postIconOverrideURL && postIconOverrideURL !== '') {
                return PostUtils.getImageSrc(postIconOverrideURL, hasImageProxy);
            }

            return Constants.DEFAULT_WEBHOOK_LOGO;
        }

        return defaultURL;
    };

    render() {
        const {
            availabilityStatusOnPosts,
            compactDisplay,
            isBusy,
            isRHS,
            post,
            user,
            isBot,
        } = this.props;

        const isSystemMessage = PostUtils.isSystemMessage(post);
        const fromWebhook = PostUtils.isFromWebhook(post);

        if (isSystemMessage && !compactDisplay && !fromWebhook && !isBot) {
            return <MattermostLogo className='icon'/>;
        }
        const fromAutoResponder = PostUtils.fromAutoResponder(post);

        const hasMention = !fromAutoResponder && !fromWebhook;
        const profileSrc = this.getProfilePictureURL();
        const src = this.getPostIconURL(profileSrc, fromAutoResponder, fromWebhook);

        const overrideIconEmoji = post.props ? post.props.override_icon_emoji : '';
        const overwriteName = post.props ? post.props.override_username : '';
        const isEmoji = typeof overrideIconEmoji == 'string' && overrideIconEmoji !== '';
        const status = this.getStatus(fromAutoResponder, fromWebhook, user);

        return (
            <ProfilePicture
                hasMention={hasMention}
                isBusy={isBusy}
                isRHS={isRHS}
                size='md'
                src={src}
                profileSrc={profileSrc}
                isEmoji={isEmoji}
                status={availabilityStatusOnPosts === 'true' ? status : ''}
                userId={user?.id}
                channelId={post.channel_id}
                username={user?.username}
                overwriteIcon={this.props.overwriteIcon}
                overwriteName={overwriteName}
                isBot={user?.is_bot}
                fromAutoResponder={fromAutoResponder}
                fromWebhook={fromWebhook}
            />
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getUser, getStatusForUserId} from 'mattermost-redux/selectors/entities/users';
import {get} from 'mattermost-redux/selectors/entities/preferences';
import {Client4} from 'mattermost-redux/client';
import {Post} from '@mattermost/types/posts';

import {GlobalState} from '../../types/store';

import {Preferences} from 'utils/constants';

import PostProfilePicture from './post_profile_picture';

type Props = {
    userId: string;
    post: Post;
}

function mapStateToProps(state: GlobalState, ownProps: Props) {
    const config = getConfig(state);
    const user = getUser(state, ownProps.userId);
    const enablePostIconOverride = config.EnablePostIconOverride === 'true';
    const availabilityStatusOnPosts = get(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.AVAILABILITY_STATUS_ON_POSTS, Preferences.AVAILABILITY_STATUS_ON_POSTS_DEFAULT);
    const overrideIconUrl = enablePostIconOverride && ownProps.post && ownProps.post.props && ownProps.post.props.override_icon_url;
    let overwriteIcon;
    if (overrideIconUrl) {
        overwriteIcon = Client4.getAbsoluteUrl(overrideIconUrl);
    }

    return {
        availabilityStatusOnPosts,
        enablePostIconOverride: config.EnablePostIconOverride === 'true',
        overwriteIcon,
        hasImageProxy: config.HasImageProxy === 'true',
        status: getStatusForUserId(state, ownProps.userId),
        isBot: Boolean(user && user.is_bot),
        user,
    };
}

export default connect(mapStateToProps)(PostProfilePicture);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useMemo} from 'react';
import {FormattedMessage} from 'react-intl';
import {useSelector} from 'react-redux';
import styled from 'styled-components';

import Timestamp from 'components/timestamp';
import Avatar from 'components/widgets/users/avatar';
import Nbsp from 'components/html_entities/nbsp';

import {Client4} from 'mattermost-redux/client';
import {makeGetDisplayName} from 'mattermost-redux/selectors/entities/users';

import {GlobalState} from 'types/store';

import type {UserProfile} from '@mattermost/types/users';
import type {PostAcknowledgement} from '@mattermost/types/posts';

type Props = {
    currentUserId: UserProfile['id'];
    list: Array<{user: UserProfile; acknowledgedAt: PostAcknowledgement['acknowledged_at']}>;
};

const Item = styled.div`
    display: flex;
    gap: 12px;
    padding: 10px 20px;
`;

const Info = styled.div`
    display: flex;
    flex-direction: column;
    min-width: 0;
    overflow-x: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
`;

const Title = styled.div`
    color: rgba(var(--center-channel-color-rgb), 0.56);
    font-size: 12px;
    font-weight: 600;
    line-height: 16px;
    padding: 8px 20px;
`;

const Span = styled.span`
    color: rgba(var(--center-channel-color-rgb), 0.56);
    font-size: 12px;
    line-height: 18px;
`;

const Popover = styled.div`
    background: var(--center-channel-bg);
    border-radius: 4px;
    border: solid 1px rgba(var(--center-channel-color-rgb), 0.16);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
    color: lighten($black, 25%);
    font-family: inherit;
    max-height: 400px;
    overflow-y: scroll;
    padding: 8px 0;
`;

function Row({
    acknowledgedAt,
    id,
    isMe,
    lastPictureUpdate,
    username,
}: {
    acknowledgedAt: number;
    id: UserProfile['id'];
    isMe: boolean;
    lastPictureUpdate: UserProfile['last_picture_update'];
    username: UserProfile['username'];
}) {
    const getDisplayName = useMemo(makeGetDisplayName, []);
    const displayName = useSelector((state: GlobalState) => getDisplayName(state, id));

    return (
        <Item>
            <Avatar
                size='sm'
                url={Client4.getProfilePictureUrl(id, lastPictureUpdate)}
                username={username}
            />
            <Info>
                <div>
                    {displayName}
                    {isMe && (
                        <>
                            <Nbsp/>
                            <FormattedMessage
                                id={'post_priority.you.acknowledge'}
                                defaultMessage={'(you)'}
                            />
                        </>
                    )}
                </div>
                <Span>
                    <Timestamp value={acknowledgedAt}/>
                </Span>
            </Info>
        </Item>
    );
}

export default function PostAcknowledgementsUserPopover({list, currentUserId}: Props) {
    return (
        <Popover>
            <Title>
                <FormattedMessage
                    id={'post_priority.acknowledgements.title'}
                    defaultMessage={'Acknowledgements'}
                />
            </Title>
            {list.map((item) => (
                <Row
                    key={item.user.id}
                    acknowledgedAt={item.acknowledgedAt}
                    isMe={currentUserId === item.user.id}
                    id={item.user.id}
                    lastPictureUpdate={item.user.last_picture_update}
                    username={item.user.username}
                />
            ))}
        </Popover>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo, useState} from 'react';
import {FormattedMessage} from 'react-intl';
import classNames from 'classnames';
import {useDispatch} from 'react-redux';
import {
    useFloating,
    autoUpdate,
    offset,
    flip,
    shift,
    useHover,
    useRole,
    useInteractions,
    safePolygon,
    FloatingFocusManager,
    useId,
} from '@floating-ui/react-dom-interactions';

import {CheckCircleOutlineIcon} from '@mattermost/compass-icons/components';

import {acknowledgePost, unacknowledgePost} from 'mattermost-redux/actions/posts';

import {Post, PostAcknowledgement} from '@mattermost/types/posts';
import {UserProfile} from '@mattermost/types/users';

import PostAcknowledgementsUserPopover from './post_acknowledgements_users_popover';

import './post_acknowledgements.scss';

type Props = {
    currentUserId: UserProfile['id'];
    hasReactions: boolean;
    list?: Array<{user: UserProfile; acknowledgedAt: PostAcknowledgement['acknowledged_at']}>;
    postId: Post['id'];
}

function moreThan5minAgo(time: number) {
    const now = new Date().getTime();
    return now - time > 5 * 60 * 1000;
}

function PostAcknowledgements({
    currentUserId,
    hasReactions,
    list,
    postId,
}: Props) {
    let acknowledgedAt = 0;
    const dispatch = useDispatch();
    const [open, setOpen] = useState(false);

    if (list && list.length) {
        const ack = list.find((ack) => ack.user.id === currentUserId);
        if (ack) {
            acknowledgedAt = ack.acknowledgedAt;
        }
    }

    const {x, y, reference, floating, strategy, context} = useFloating({
        open,
        onOpenChange: setOpen,
        placement: 'top-start',
        whileElementsMounted: autoUpdate,
        middleware: [
            offset(5),
            flip({fallbackPlacements: ['bottom', 'right'], padding: 5}),
            shift(),
        ],
    });

    const headingId = useId();

    const {getReferenceProps, getFloatingProps} = useInteractions([
        useHover(context, {
            enabled: list && list.length > 0,
            mouseOnly: true,
            delay: {
                open: 300,
                close: 0,
            },
            handleClose: safePolygon({
                blockPointerEvents: false,
                restMs: 100,
            }),
        }),
        useRole(context),
    ]);

    const handleClick = () => {
        if (acknowledgedAt) {
            dispatch(unacknowledgePost(postId));
        } else {
            dispatch(acknowledgePost(postId));
        }
    };

    const button = (
        <>
            <button
                ref={reference}
                onClick={handleClick}
                className={classNames({
                    AcknowledgementButton: true,
                    'AcknowledgementButton--acked': Boolean(acknowledgedAt),
                    'AcknowledgementButton--disabled': Boolean(acknowledgedAt) && moreThan5minAgo(acknowledgedAt),
                    'AcknowledgementButton--default': !list || list.length === 0,
                })}
                {...getReferenceProps()}
            >
                <CheckCircleOutlineIcon size={16}/>
                {(list && list.length > 0) ? list!.length : (
                    <FormattedMessage
                        id={'post_priority.button.acknowledge'}
                        defaultMessage={'Acknowledge'}
                    />
                )}
            </button>
            {hasReactions && <div className='AcknowledgementButton__divider'/>}
        </>
    );

    if (!list || !list.length) {
        return button;
    }

    return (
        <>
            {button}
            {open && (
                <FloatingFocusManager
                    context={context}
                    modal={false}
                >
                    <div
                        ref={floating}
                        style={{
                            position: strategy,
                            top: y ?? 0,
                            left: x ?? 0,
                            width: 248,
                            zIndex: 999,
                        }}
                        aria-labelledby={headingId}
                        {...getFloatingProps()}
                    >
                        <PostAcknowledgementsUserPopover
                            currentUserId={currentUserId}
                            list={list}
                        />
                    </div>
                </FloatingFocusManager>
            )}
        </>
    );
}

export default memo(PostAcknowledgements);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getCurrentUserId} from 'mattermost-redux/selectors/entities/common';
import {getHasReactions, makeGetPostAcknowledgementsWithProfiles} from 'mattermost-redux/selectors/entities/posts';

import {GlobalState} from 'types/store';

import {Post} from '@mattermost/types/posts';

import PostAcknowledgements from './post_acknowledgements';

type OwnProps = {
    postId: Post['id'];
};

function makeMapStateToProps() {
    const getPostAcknowledgementsWithProfiles = makeGetPostAcknowledgementsWithProfiles();
    return (state: GlobalState, ownProps: OwnProps) => {
        const currentUserId = getCurrentUserId(state);
        const hasReactions = getHasReactions(state, ownProps.postId);
        const list = getPostAcknowledgementsWithProfiles(state, ownProps.postId);

        return {
            currentUserId,
            hasReactions,
            list,
        };
    };
}

export default connect(makeMapStateToProps)(PostAcknowledgements);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {makeGenerateCombinedPost} from 'mattermost-redux/utils/post_list';

import {GlobalState} from '@mattermost/types/store';

import Post from 'components/post_view/post';

type Props = {
    combinedId: string;
}

function makeMapStateToProps() {
    const generateCombinedPost = makeGenerateCombinedPost();

    return (state: GlobalState, ownProps: Props) => {
        return {
            post: generateCombinedPost(state, ownProps.combinedId),
            postId: ownProps.combinedId,
        };
    };
}

// Note that this also passes through Post's mapStateToProps
export default connect(makeMapStateToProps)(Post);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import PropTypes from 'prop-types';
import React, {FC, memo} from 'react';

import Timestamp, {RelativeRanges} from 'components/timestamp';

import BasicSeparator from 'components/widgets/separator/basic-separator';

const DATE_RANGES = [
    RelativeRanges.TODAY_TITLE_CASE,
    RelativeRanges.YESTERDAY_TITLE_CASE,
];

type Props = {
    date: number | Date;
}

const DateSeparator: FC<Props> = ({date}) => {
    return (
        <BasicSeparator>
            <Timestamp
                value={date}
                useTime={false}
                useSemanticOutput={false}
                ranges={DATE_RANGES}
            />
        </BasicSeparator>
    );
};

DateSeparator.propTypes = {
    date: PropTypes.oneOfType([
        PropTypes.number,
        PropTypes.instanceOf(Date),
    ]).isRequired,
};

export default memo(DateSeparator);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {MouseEvent} from 'react';
import {FormattedMessage} from 'react-intl';

import {Post} from '@mattermost/types/posts';
import {FileInfo} from '@mattermost/types/files';
import {DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';
import {ExtendedPost} from 'mattermost-redux/actions/posts';

type CreatePostAction =
    (post: Post, files: FileInfo[]) => (dispatch: DispatchFunc) => Promise<{data?: boolean}>;
type RemovePostAction =
    (post: ExtendedPost) => (dispatch: DispatchFunc, getState: GetStateFunc) => void;

type Props = {
    post: Post;
    actions: {
        createPost: CreatePostAction;
        removePost: RemovePostAction;
    };
};

export default class FailedPostOptions extends React.PureComponent<Props> {
    retryPost = (e: MouseEvent): void => {
        e.preventDefault();

        const post = {...this.props.post};
        Reflect.deleteProperty(post, 'id');
        this.props.actions.createPost(post, []);
    }

    cancelPost = (e: MouseEvent): void => {
        e.preventDefault();

        this.props.actions.removePost(this.props.post);
    }

    render(): JSX.Element {
        return (
            <span className='pending-post-actions'>
                <a
                    className='post-retry'
                    href='#'
                    onClick={this.retryPost}
                >
                    <FormattedMessage
                        id='pending_post_actions.retry'
                        defaultMessage='Retry'
                    />
                </a>
                {' - '}
                <a
                    className='post-cancel'
                    href='#'
                    onClick={this.cancelPost}
                >
                    <FormattedMessage
                        id='pending_post_actions.cancel'
                        defaultMessage='Cancel'
                    />
                </a>
            </span>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {removePost} from 'mattermost-redux/actions/posts';
import {GenericAction} from 'mattermost-redux/types/actions';

import {createPost} from 'actions/post_actions';

import FailedPostOptions from './failed_post_options';

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            createPost,
            removePost,
        }, dispatch),
    };
}

export default connect(null, mapDispatchToProps)(FailedPostOptions);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import classNames from 'classnames';

import Timestamp, {RelativeRanges} from 'components/timestamp';

const DATE_RANGES = [
    RelativeRanges.TODAY_TITLE_CASE,
    RelativeRanges.YESTERDAY_TITLE_CASE,
];
type Props = {
    isScrolling: boolean;
    createAt: Date | number;
    toastPresent: boolean;
    isRhsPost?: boolean;
}

export default class FloatingTimestamp extends React.PureComponent<Props> {
    render() {
        const {createAt, isScrolling, isRhsPost, toastPresent} = this.props;

        if (createAt === 0) {
            return null;
        }

        const classes = classNames('post-list__timestamp', {
            scrolling: isScrolling,
            rhs: isRhsPost,
            toastAdjustment: toastPresent,
        });

        return (
            <div
                className={classes}
                data-testid='floatingTimestamp'
            >
                <div>
                    <span>
                        <Timestamp
                            value={createAt}
                            useTime={false}
                            ranges={DATE_RANGES}
                        />
                    </span>
                </div>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getPost} from 'mattermost-redux/selectors/entities/posts';
import * as PostListUtils from 'mattermost-redux/utils/post_list';

import {getToastStatus} from 'selectors/views/channel';
import {getThreadToastStatus} from 'selectors/views/threads';
import {GlobalState} from 'types/store';

import FloatingTimestamp from './floating_timestamp';

type OwnProps = {
    postId: string;
    isRhsPost?: boolean;
}

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    let postId = ownProps.postId;
    if (PostListUtils.isCombinedUserActivityPost(postId)) {
        const combinedIds = PostListUtils.getPostIdsForCombinedUserActivityPost(postId);

        postId = combinedIds[combinedIds.length - 1];
    }

    const post = getPost(state, postId);

    const toastPresent = ownProps.isRhsPost ? getThreadToastStatus(state) : getToastStatus(state);
    return {
        createAt: post ? post.create_at : 0,
        toastPresent,
    };
}

export default connect(mapStateToProps)(FloatingTimestamp);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import './separator.scss';
import './notification-separator.scss';

export default class NotificationSeparator extends React.PureComponent<React.PropsWithChildren<any>> {
    public render() {
        const {children} = this.props;
        return (
            <div
                className='Separator NotificationSeparator'
                data-testid='NotificationSeparator'
            >
                <hr className='separator__hr'/>
                {children && (
                    <div className='separator__text'>
                        {children}
                    </div>
                )}
            </div>
        );
    }
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import NotificationSeparator from 'components/widgets/separator/notification-separator';

type Props = {
    separatorId: string;
    wrapperRef?: React.RefObject<HTMLDivElement>;
}

export default class NewMessageSeparator extends React.PureComponent<Props> {
    render(): JSX.Element {
        return (
            <div
                ref={this.props.wrapperRef}
                className='new-separator'
            >
                <NotificationSeparator id={this.props.separatorId}>
                    <FormattedMessage
                        id='posts_view.newMsg'
                        defaultMessage='New Messages'
                    />

                </NotificationSeparator>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

interface Props {

    /*
     * The id of the post that was commented on
     */
    parentPostId: string;

    /*
     * An array of file metadata for the parent post
     */
    fileInfos?: Array<{name: string}>;
}

export default class CommentedOnFilesMessage extends React.PureComponent<Props> {
    render() {
        if (!this.props.fileInfos || this.props.fileInfos.length === 0) {
            return null;
        }

        let plusMore = null;
        if (this.props.fileInfos.length > 1) {
            plusMore = (
                <FormattedMessage
                    id='post_body.plusMore'
                    defaultMessage=' plus {count, number} other {count, plural, one {file} other {files}}'
                    values={{
                        count: this.props.fileInfos.length - 1,
                    }}
                />
            );
        }

        return (
            <span>
                {this.props.fileInfos[0].name}
                {plusMore}
            </span>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {GlobalState} from '@mattermost/types/store';

import {makeGetFilesForPost} from 'mattermost-redux/selectors/entities/files';

import CommentedOnFilesMessage from './commented_on_files_message';

function makeMapStateToProps() {
    const selectFileInfosForPost = makeGetFilesForPost();

    return function mapStateToProps(state: GlobalState, ownProps: {parentPostId: string}) {
        let fileInfos;
        if (ownProps.parentPostId) {
            fileInfos = selectFileInfosForPost(state, ownProps.parentPostId);
        }

        return {
            fileInfos,
        };
    };
}

export default connect(makeMapStateToProps)(CommentedOnFilesMessage);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {PureComponent} from 'react';
import {FormattedMessage} from 'react-intl';

import {UserProfile as UserProfileType} from '@mattermost/types/users';

import {Post} from '@mattermost/types/posts';

import * as Utils from 'utils/utils';
import {stripMarkdown} from 'utils/markdown';

import CommentedOnFilesMessage from 'components/post_view/commented_on_files_message';
import UserProfile from '../../user_profile/user_profile';

type Props = {
    displayName?: string;
    enablePostUsernameOverride?: boolean;
    parentPostUser?: UserProfileType;
    onCommentClick?: React.EventHandler<React.MouseEvent>;
    post: Post;
}

export default class CommentedOn extends PureComponent<Props> {
    makeUsername = () => {
        const postProps = this.props.post.props;
        let username = this.props.displayName;
        if (this.props.enablePostUsernameOverride && postProps && postProps.from_webhook === 'true' && postProps.override_username) {
            username = postProps.override_username;
        }
        return username;
    }

    makeCommentedOnMessage = () => {
        const {post} = this.props;
        let message: React.ReactNode = '';
        if (post.message) {
            message = Utils.replaceHtmlEntities(post.message);
        } else if (post.file_ids && post.file_ids.length > 0) {
            message = (
                <CommentedOnFilesMessage parentPostId={post.id}/>
            );
        } else if (post.props && post.props.attachments && post.props.attachments.length > 0) {
            const attachment = post.props.attachments[0];
            const webhookMessage = attachment.pretext || attachment.title || attachment.text || attachment.fallback || '';
            message = Utils.replaceHtmlEntities(webhookMessage);
        }

        return message;
    }

    render() {
        const username = this.makeUsername();
        const message = this.makeCommentedOnMessage();
        const parentPostUser = this.props.parentPostUser;
        const parentPostUserId = (parentPostUser && parentPostUser.id) || '';

        const parentUserProfile = (
            <UserProfile
                user={parentPostUser}
                userId={parentPostUserId}
                displayName={username}
                hasMention={true}
                disablePopover={false}
            />
        );

        return (
            <div
                data-testid='post-link'
                className='post__link'
            >
                <span>
                    <FormattedMessage
                        id='post_body.commentedOn'
                        defaultMessage="Commented on {name}'s message: "
                        values={{
                            name: <a className='theme user_name'>{parentUserProfile}</a>,
                        }}
                    />
                    <a
                        className='theme'
                        onClick={this.props.onCommentClick}
                    >
                        {typeof message === 'string' ? stripMarkdown(message) : message}
                    </a>
                </span>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getUser} from 'mattermost-redux/selectors/entities/users';

import {Post} from '@mattermost/types/posts';

import {GlobalState} from 'types/store';

import {getDisplayNameByUser} from 'utils/utils';

import CommentedOn from './commented_on';

type Props = {
    post: Post;
}

function mapStateToProps(state: GlobalState, ownProps: Props) {
    let displayName = '';
    if (ownProps.post) {
        const user = getUser(state, ownProps.post.user_id);
        displayName = getDisplayNameByUser(state, user);
    }

    const config = getConfig(state);
    const enablePostUsernameOverride = config.EnablePostUsernameOverride === 'true';

    return {
        displayName,
        enablePostUsernameOverride,
    };
}

export default connect(mapStateToProps)(CommentedOn);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {PostPluginComponent} from 'types/store/plugins';

import {Posts} from 'mattermost-redux/constants';

import * as PostUtils from 'utils/post_utils';
import * as Utils from 'utils/utils';
import DelayedAction from 'utils/delayed_action';
import Constants from 'utils/constants';

import CommentedOn from 'components/post_view/commented_on';
import FileAttachmentListContainer from 'components/file_attachment_list';
import FailedPostOptions from 'components/post_view/failed_post_options';
import PostBodyAdditionalContent from 'components/post_view/post_body_additional_content';
import PostMessageView from 'components/post_view/post_message_view';
import ReactionList from 'components/post_view/reaction_list';
import LoadingSpinner from 'components/widgets/loading/loading_spinner';

import {Post} from '@mattermost/types/posts';
import {UserProfile} from '@mattermost/types/users';

import PostAcknowledgements from '../acknowledgements';

const SENDING_ANIMATION_DELAY = 3000;

export interface Props {

    /**
     * The post to render the body of
     */
    post: Post;

    /**
     * The parent post of the thread this post is in
     */
    parentPost?: Post;

    /**
     * The poster of the parent post, if exists
     */
    parentPostUser?: UserProfile | null;

    /**
     * Callback func for file menu open
     */
    handleFileDropdownOpened: (opened: boolean) => void;

    /**
     * The function called when the comment icon is clicked
     */
    handleCommentClick?: React.EventHandler<React.MouseEvent>;

    /**
     * Set to render post body compactly
     */
    compactDisplay: boolean;

    /**
     * Set to highlight comment as a mention
     */
    isCommentMention: boolean;

    /**
     * Set to render a preview of the parent post above this reply
     */
    isFirstReply: boolean;

    /*
     * Post type components from plugins
     */
    pluginPostTypes: Record<string, PostPluginComponent>;

    isPostAcknowledgementsEnabled: boolean;
}

interface State {
    sending: boolean;
}

export default class PostBody extends React.PureComponent<Props, State> {
    private sendingAction: DelayedAction;

    constructor(props: Props) {
        super(props);

        this.sendingAction = new DelayedAction(() => {
            const post = this.props.post;
            if (post && post.id === post.pending_post_id) {
                this.setState({sending: true});
            }
        });

        this.state = {sending: false};
    }

    static getDerivedStateFromProps(props: Props, state: State) {
        if (state.sending && props.post && props.post.id !== props.post.pending_post_id) {
            return {
                sending: false,
            };
        }

        return null;
    }

    componentDidUpdate() {
        if (this.state.sending === false) {
            this.sendingAction.cancel();
        }
    }

    componentDidMount() {
        const post = this.props.post;
        if (post && post.id === post.pending_post_id) {
            this.sendingAction.fireAfter(SENDING_ANIMATION_DELAY);
        }
    }

    componentWillUnmount() {
        this.sendingAction.cancel();
    }

    render() {
        const {post, parentPost, parentPostUser} = this.props;

        let comment;
        let postClass = '';
        const isEphemeral = Utils.isPostEphemeral(post);

        //We want to show the commented on component even if the post was deleted
        if (this.props.isFirstReply && parentPost && parentPostUser && post.type !== Constants.PostTypes.EPHEMERAL) {
            comment = (
                <CommentedOn
                    post={parentPost}
                    parentPostUser={parentPostUser}
                    onCommentClick={this.props.handleCommentClick}
                />
            );
        }

        let failedOptions;
        if (this.props.post.failed) {
            postClass += ' post--fail';
            failedOptions = <FailedPostOptions post={this.props.post}/>;
        }

        if (PostUtils.isEdited(this.props.post)) {
            postClass += ' post--edited';
        }

        let fileAttachmentHolder = null;
        if (
            ((post.file_ids && post.file_ids.length > 0) ||
                (post.filenames && post.filenames.length > 0)) &&
            this.props.post.state !== Posts.POST_DELETED
        ) {
            fileAttachmentHolder = (
                <FileAttachmentListContainer
                    post={post}
                    compactDisplay={this.props.compactDisplay}
                    handleFileDropdownOpened={this.props.handleFileDropdownOpened}
                />
            );
        }

        if (this.state.sending) {
            postClass += ' post-waiting';
        }

        const messageWrapper = (
            <>
                {failedOptions}
                {this.state.sending && <LoadingSpinner/>}
                <PostMessageView
                    post={this.props.post}
                    compactDisplay={this.props.compactDisplay}
                />
            </>
        );

        const hasPlugin =
            (post.type && this.props.pluginPostTypes.hasOwnProperty(post.type)) ||
            (post.props &&
                post.props.type &&
                this.props.pluginPostTypes.hasOwnProperty(post.props.type));

        let messageWithAdditionalContent;
        if (this.props.post.state === Posts.POST_DELETED || hasPlugin) {
            messageWithAdditionalContent = messageWrapper;
        } else {
            messageWithAdditionalContent = (
                <PostBodyAdditionalContent
                    post={this.props.post}
                    handleFileDropdownOpened={this.props.handleFileDropdownOpened}
                >
                    {messageWrapper}
                </PostBodyAdditionalContent>
            );
        }

        let mentionHighlightClass = '';
        if (this.props.isCommentMention) {
            mentionHighlightClass = 'mention-comment';
        }

        let ephemeralPostClass = '';
        if (isEphemeral) {
            ephemeralPostClass = 'post--ephemeral';
        }

        return (
            <>
                {comment}
                <div
                    id={`${post.id}_message`}
                    className={`post__body ${mentionHighlightClass} ${ephemeralPostClass} ${postClass}`}
                >
                    {messageWithAdditionalContent}
                    {fileAttachmentHolder}
                    <div className='post__body-reactions-acks'>
                        {this.props.isPostAcknowledgementsEnabled && post.metadata?.priority?.requested_ack && (
                            <PostAcknowledgements postId={post.id}/>
                        )}
                        <ReactionList post={post}/>
                    </div>
                </div>
            </>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getPost, isPostAcknowledgementsEnabled} from 'mattermost-redux/selectors/entities/posts';
import {getUser} from 'mattermost-redux/selectors/entities/users';

import {GlobalState} from 'types/store';

import {Post} from '@mattermost/types/posts';

import PostBody from './post_body';

interface OwnProps {
    post: Post;
}

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    let parentPost;
    let parentPostUser;
    if (ownProps.post.root_id) {
        parentPost = getPost(state, ownProps.post.root_id);
        parentPostUser = parentPost ? getUser(state, parentPost.user_id) : null;
    }

    return {
        parentPost,
        parentPostUser,
        pluginPostTypes: state.plugins.postTypes,
        isPostAcknowledgementsEnabled: isPostAcknowledgementsEnabled(state),
    };
}

export default connect(mapStateToProps)(PostBody);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getPost, makeGetCommentCountForPost} from 'mattermost-redux/selectors/entities/posts';
import {isCollapsedThreadsEnabled} from 'mattermost-redux/selectors/entities/preferences';

import {GlobalState} from 'types/store';

import CommentIcon from 'components/common/comment_icon';

type OwnProps = {
    postId: string;
}

function makeMapStateToProps() {
    const getReplyCount = makeGetCommentCountForPost();

    return (state: GlobalState, ownProps: OwnProps) => {
        const post = getPost(state, ownProps.postId);

        const collapsedThreadsEnabled = isCollapsedThreadsEnabled(state);

        return {
            commentCount: collapsedThreadsEnabled ? 0 : getReplyCount(state, post),
        };
    };
}

export default connect(makeMapStateToProps)(CommentIcon);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import ActionsMenu from 'components/actions_menu';

import {Posts, Preferences} from 'mattermost-redux/constants';
import * as ReduxPostUtils from 'mattermost-redux/utils/post_utils';

import {Post} from '@mattermost/types/posts';
import {ExtendedPost} from 'mattermost-redux/actions/posts';

import type {emitShortcutReactToLastPostFrom} from 'actions/post_actions';
import {trackEvent} from 'actions/telemetry_actions';
import * as PostUtils from 'utils/post_utils';
import * as Utils from 'utils/utils';
import Constants, {EventTypes, TELEMETRY_CATEGORIES, TELEMETRY_LABELS, Locations} from 'utils/constants';
import CommentIcon from 'components/post_view/comment_icon';
import DotMenu from 'components/dot_menu';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import PostFlagIcon from 'components/post_view/post_flag_icon';
import PostReaction from 'components/post_view/post_reaction';
import PostRecentReactions from 'components/post_view/post_recent_reactions';
import PostTime from 'components/post_view/post_time';
import InfoSmallIcon from 'components/widgets/icons/info_small_icon';
import PriorityLabel from 'components/post_priority/post_priority_label';
import {Emoji} from '@mattermost/types/emojis';

type Props = {

    /**
     * The post to render the info for
     */
    post: Post;

    /**
     * The id of the team which belongs the post
     */
    teamId?: string;

    /**
     * Function called when the comment icon is clicked
     */
    handleCommentClick: React.EventHandler<React.MouseEvent>;

    /**
     * Function called when the card icon is clicked
     */
    handleCardClick: (post: Post) => void;

    /**
     * Function called when the post options dropdown is opened
     */
    handleDropdownOpened: (e: boolean) => void;

    /**
     * Set to mark the post as flagged
     */
    isFlagged?: boolean;

    /**
     * Set to mark the post as open the extra info in the rhs
     */
    isCardOpen?: boolean;

    /**
     * Set to indicate that this is previous post was not a reply to the same thread
     */
    isFirstReply?: boolean;

    /**
     * Set to indicate that this is post has replies
     */
    hasReplies?: boolean;

    /**
     * Set to render in mobile view
     */
    isMobile?: boolean;

    /**
     * Set to render in compact view
     */
    compactDisplay?: boolean;

    /**
     * Set to mark post as being hovered over
     */
    hover: boolean;

    /**
     * Set to render the post time when not hovering
     */
    showTimeWithoutHover: boolean;

    /**
     * Whether to show the emoji picker.
     */
    enableEmojiPicker?: boolean;

    /**
     * Set not to allow edits on post
     */
    isReadOnly?: boolean;

    /**
     * To check if the state of emoji for last message and from where it was emitted
     */
    shortcutReactToLastPostEmittedFrom?: string;

    /**
     * To Check if the current post is last in the list
     */
    isLastPost?: boolean;

    /**
     * true when want to show the Actions Menu with pulsating dot for tutorial
     */
    showActionsMenuPulsatingDot: boolean;

    isPostPriorityEnabled: boolean;

    actions: {

        /**
         * Function to remove the post
         */
        removePost: (post: ExtendedPost) => void;

        /**
         * Function to set or unset emoji picker for last message
         */
        emitShortcutReactToLastPostFrom?: typeof emitShortcutReactToLastPostFrom;

        /**
         * Function to set viewed Actions Menu for first time
         */
        setActionsMenuInitialisationState: (viewed: Record<string, boolean>) => void;
    };

    isPostBeingEdited: boolean;

    shouldShowDotMenu: boolean;

    shouldShowActionsMenu: boolean;

    collapsedThreadsEnabled: boolean;

    oneClickReactionsEnabled: boolean;
    recentEmojis: Emoji[];
};

type State = {
    showEmojiPicker: boolean;
    showDotMenu: boolean;
    showActionsMenu: boolean;
    showOptionsMenuWithoutHover: boolean;
    showActionTip: boolean;
};

export default class PostInfo extends React.PureComponent<Props, State> {
    private postHeaderRef: React.RefObject<HTMLDivElement>;
    private dotMenuRef: React.RefObject<HTMLDivElement>;

    constructor(props: Props) {
        super(props);

        this.state = {
            showEmojiPicker: false,
            showOptionsMenuWithoutHover: false,
            showDotMenu: false,
            showActionsMenu: false,
            showActionTip: false,
        };

        this.postHeaderRef = React.createRef<HTMLDivElement>();
        this.dotMenuRef = React.createRef<HTMLDivElement>();
    }

    toggleEmojiPicker = (e?: React.MouseEvent<HTMLButtonElement, MouseEvent>): void => {
        e?.stopPropagation();
        const showEmojiPicker = !this.state.showEmojiPicker;

        this.setState({
            showEmojiPicker,
            showOptionsMenuWithoutHover: false,
        });
        this.props.handleDropdownOpened(showEmojiPicker);
    };

    removePost = (): void => this.props.actions.removePost(this.props.post);

    createRemovePostButton = (): JSX.Element => {
        return (
            <button
                className='post__remove theme color--link style--none'
                type='button'
                onClick={this.removePost}
            >
                {''}
            </button>
        );
    };

    handleDotMenuOpened = (open: boolean): void => {
        this.setState({showDotMenu: open});
        this.props.handleDropdownOpened(open || this.state.showEmojiPicker);
    };

    handleActionsMenuOpened = (open: boolean) => {
        if (this.props.showActionsMenuPulsatingDot) {
            return;
        }
        this.props.handleDropdownOpened(open);
        this.setState({showActionsMenu: open});
        this.props.handleDropdownOpened(open);
    };

    handleActionsMenuTipOpened = (): void => {
        this.setState({showActionTip: true});
        this.props.handleDropdownOpened(true);
    };

    handleActionsMenuGotItClick = (): void => {
        this.props.actions.setActionsMenuInitialisationState({[Preferences.ACTIONS_MENU_VIEWED]: true});
        this.props.handleDropdownOpened(false);
        this.setState({showActionTip: false});
    };

    handleTipDismissed = () => {
        this.props.actions.setActionsMenuInitialisationState({[Preferences.ACTIONS_MENU_VIEWED]: false});
        this.props.handleDropdownOpened(false);
        this.setState({showActionTip: false});
    };

    handleCommentClick = (e: any) => {
        trackEvent(TELEMETRY_CATEGORIES.POST_INFO, EventTypes.CLICK + '_' + TELEMETRY_LABELS.REPLY);
        this.props.handleCommentClick(e);
    }

    getDotMenu = (): HTMLDivElement => this.dotMenuRef.current as HTMLDivElement;

    buildOptions = (post: Post, isSystemMessage: boolean, fromAutoResponder: boolean): React.ReactNode => {
        if (!this.props.shouldShowDotMenu || this.props.isPostBeingEdited) {
            return null;
        }

        const {isMobile, isReadOnly, collapsedThreadsEnabled} = this.props;

        const hover = this.props.hover ||
            this.state.showEmojiPicker ||
            this.state.showDotMenu ||
            this.state.showActionsMenu ||
            this.state.showActionTip ||
            this.state.showOptionsMenuWithoutHover;

        const showCommentIcon = fromAutoResponder ||
        (!isSystemMessage && (isMobile || hover || (!post.root_id && Boolean(this.props.hasReplies)) || this.props.isFirstReply));
        const commentIconExtraClass = isMobile ? '' : 'pull-right';
        let commentIcon;
        if (showCommentIcon) {
            commentIcon = (
                <CommentIcon
                    handleCommentClick={this.handleCommentClick}
                    postId={post.id}
                    extraClass={commentIconExtraClass}
                />
            );
        }

        const showRecentlyUsedReactions = !isMobile && !isSystemMessage && hover && !isReadOnly && this.props.oneClickReactionsEnabled && this.props.enableEmojiPicker;
        let showRecentReacions;
        if (showRecentlyUsedReactions) {
            showRecentReacions = (
                <PostRecentReactions
                    channelId={post.channel_id}
                    postId={post.id}
                    emojis={this.props.recentEmojis}
                    teamId={this.props.teamId!}
                    getDotMenuRef={this.getDotMenu}
                />
            );
        }

        const showReactionIcon = !isSystemMessage && hover && !isReadOnly && this.props.enableEmojiPicker;
        let postReaction;
        if (showReactionIcon) {
            postReaction = (
                <PostReaction
                    channelId={post.channel_id}
                    postId={post.id}
                    teamId={this.props.teamId}
                    getDotMenuRef={this.getDotMenu}
                    showEmojiPicker={this.state.showEmojiPicker}
                    toggleEmojiPicker={this.toggleEmojiPicker}
                />
            );
        }

        const showDotMenuIcon = isMobile || hover;
        let dotMenu;
        if (showDotMenuIcon) {
            dotMenu = (
                <DotMenu
                    post={post}
                    isFlagged={this.props.isFlagged}
                    handleCommentClick={this.props.handleCommentClick}
                    handleDropdownOpened={this.handleDotMenuOpened}
                    handleAddReactionClick={this.toggleEmojiPicker}
                    isMenuOpen={this.state.showDotMenu}
                    isReadOnly={isReadOnly}
                    enableEmojiPicker={this.props.enableEmojiPicker}
                />
            );
        }

        const showActionsMenuIcon = this.props.shouldShowActionsMenu && (isMobile || hover);
        const actionsMenu = showActionsMenuIcon && (
            <ActionsMenu
                post={post}
                handleDropdownOpened={this.handleActionsMenuOpened}
                isMenuOpen={this.state.showActionsMenu}
                showPulsatingDot={this.props.showActionsMenuPulsatingDot}
                showTutorialTip={this.state.showActionTip}
                handleOpenTip={this.handleActionsMenuTipOpened}
                handleNextTip={this.handleActionsMenuGotItClick}
                handleDismissTip={this.handleTipDismissed}
            />
        );

        const showFlagIcon = !isSystemMessage && !isMobile && (hover || this.props.isFlagged);
        let postFlagIcon;
        if (showFlagIcon) {
            postFlagIcon = (
                <PostFlagIcon
                    postId={post.id}
                    isFlagged={Boolean(this.props.isFlagged)}
                />
            );
        }

        return (
            <div
                ref={this.dotMenuRef}
                data-testid={`post-menu-${post.id}`}
                className={'col post-menu'}
            >
                {!collapsedThreadsEnabled && !showRecentlyUsedReactions && dotMenu}
                {showRecentReacions}
                {postReaction}
                {postFlagIcon}
                {actionsMenu}
                {commentIcon}
                {(collapsedThreadsEnabled || showRecentlyUsedReactions) && dotMenu}
            </div>
        );
    };

    handleShortcutReactToLastPost = (isLastPost: boolean): void => {
        if (isLastPost) {
            const {post, isReadOnly, enableEmojiPicker, isMobile, actions} = this.props;

            // Setting the last message emoji action to empty to clean up the redux state
            actions.emitShortcutReactToLastPostFrom?.(Locations.NO_WHERE);

            // Following are the types of posts on which adding reaction is not possible
            const isDeletedPost = post && post.state === Posts.POST_DELETED;
            const isEphemeralPost = post && Utils.isPostEphemeral(post);
            const isSystemMessage = post && PostUtils.isSystemMessage(post);
            const isAutoRespondersPost = post && PostUtils.fromAutoResponder(post);
            const isFailedPost = post && post.failed;

            // Checking if post is at scroll view of the user
            const boundingRectOfPostInfo: DOMRect | undefined = this.postHeaderRef?.current?.getBoundingClientRect();
            if (boundingRectOfPostInfo) {
                const isPostHeaderVisibleToUser = (boundingRectOfPostInfo.top - 65) > 0 &&
                    boundingRectOfPostInfo.bottom < (window.innerHeight - 85);

                if (isPostHeaderVisibleToUser && !isEphemeralPost && !isSystemMessage && !isAutoRespondersPost &&
                        !isFailedPost && !isDeletedPost && !isReadOnly && !isMobile && enableEmojiPicker) {
                    this.setState({
                        showOptionsMenuWithoutHover: true,
                    }, () => {
                        this.toggleEmojiPicker();
                    });
                }
            }
        }
    }

    componentDidUpdate(prevProps: Props): void {
        const {shortcutReactToLastPostEmittedFrom, isLastPost} = this.props;

        const shortcutReactToLastPostEmittedFromCenter = prevProps.shortcutReactToLastPostEmittedFrom !== shortcutReactToLastPostEmittedFrom &&
        shortcutReactToLastPostEmittedFrom === Locations.CENTER;
        if (shortcutReactToLastPostEmittedFromCenter && isLastPost !== undefined) {
            this.handleShortcutReactToLastPost(isLastPost);
        }
    }

    render(): React.ReactNode {
        const {post, isPostPriorityEnabled} = this.props;

        const isEphemeral = Utils.isPostEphemeral(post);
        const isSystemMessage = PostUtils.isSystemMessage(post);
        const fromAutoResponder = PostUtils.fromAutoResponder(post);

        let postInfoIcon;
        if (post.props && post.props.card) {
            postInfoIcon = (
                <OverlayTrigger
                    delayShow={Constants.OVERLAY_TIME_DELAY}
                    placement='top'
                    overlay={
                        <Tooltip id={`viewAdditionalInfo-${post.id}`}>
                            <FormattedMessage
                                id='post_info.info.view_additional_info'
                                defaultMessage='View additional info'
                            />
                        </Tooltip>
                    }
                >
                    <button
                        className={'card-icon__container icon--show style--none ' + (this.props.isCardOpen ? 'active' : '')}
                        onClick={(e) => {
                            e.preventDefault();
                            this.props.handleCardClick(this.props.post);
                        }}
                    >
                        <InfoSmallIcon
                            className='icon icon__info'
                            aria-hidden='true'
                        />
                    </button>
                </OverlayTrigger>
            );
        }

        let options;
        if (isEphemeral) {
            options = (
                <div className='col col__remove'>
                    {this.createRemovePostButton()}
                </div>
            );
        } else if (!post.failed) {
            options = this.buildOptions(post, isSystemMessage, fromAutoResponder);
        }

        let visibleMessage;
        if (isEphemeral && !this.props.compactDisplay && post.state !== Posts.POST_DELETED) {
            visibleMessage = (
                <span className='post__visibility'>
                    <FormattedMessage
                        id='post_info.message.visible'
                        defaultMessage='(Only visible to you)'
                    />
                </span>
            );
        }

        const showPostTime = this.props.hover || this.props.showTimeWithoutHover;
        let postTime;
        if (showPostTime) {
            // timestamp should not be a permalink if the post has been deleted, is ephemeral message, is pending, or is combined activity
            const isPermalink = !(isEphemeral || Posts.POST_DELETED === post.state || ReduxPostUtils.isPostPendingOrFailed(post) || post.type === Posts.POST_TYPES.COMBINED_USER_ACTIVITY);

            postTime = (
                <PostTime
                    isPermalink={isPermalink}
                    eventTime={post.create_at}
                    postId={post.id}
                />
            );
        }

        let priority;
        if (post.metadata?.priority && isPostPriorityEnabled) {
            priority = <span className='d-flex mr-2 ml-1'><PriorityLabel priority={post.metadata.priority.priority}/></span>;
        }

        return (
            <div
                className='post__header--info'
                ref={this.postHeaderRef}
            >
                <div className='col d-flex align-items-center'>
                    {postTime}
                    {priority}
                    {postInfoIcon}
                    {visibleMessage}
                </div>
                {options}
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {AnyAction, bindActionCreators, Dispatch} from 'redux';

import {showActionsDropdownPulsatingDot} from 'selectors/actions_menu';
import {setActionsMenuInitialisationState} from 'mattermost-redux/actions/preferences';

import {DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';
import {Emoji} from '@mattermost/types/emojis';
import {removePost, ExtendedPost} from 'mattermost-redux/actions/posts';
import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {makeGetCommentCountForPost, isPostPriorityEnabled} from 'mattermost-redux/selectors/entities/posts';

import {
    get,
    isCollapsedThreadsEnabled,
} from 'mattermost-redux/selectors/entities/preferences';
import {getConfig} from 'mattermost-redux/selectors/entities/general';

import {Post} from '@mattermost/types/posts';

import {GlobalState} from 'types/store';

import {closeRightHandSide} from 'actions/views/rhs';
import {emitShortcutReactToLastPostFrom} from 'actions/post_actions';
import {Preferences} from 'utils/constants';
import {shouldShowDotMenu, shouldShowActionsMenu} from 'utils/post_utils';
import {getSelectedPostCard} from 'selectors/rhs';
import {isThreadOpen} from 'selectors/views/threads';
import {getShortcutReactToLastPostEmittedFrom, getOneClickReactionEmojis} from 'selectors/emojis';
import {getIsPostBeingEdited} from '../../../selectors/posts';

import PostInfo from './post_info';

type OwnProps = {
    post: Post;
}

function removePostAndCloseRHS(post: ExtendedPost) {
    return (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState() as GlobalState;
        if (isThreadOpen(state, post.id)) {
            dispatch(closeRightHandSide());
        }
        return dispatch(removePost(post));
    };
}

function makeMapStateToProps() {
    const getReplyCount = makeGetCommentCountForPost();

    return (state: GlobalState, ownProps: OwnProps) => {
        const selectedCard = getSelectedPostCard(state);
        const config = getConfig(state);
        const channel = state.entities.channels.channels[ownProps.post.channel_id];
        const channelIsArchived = channel ? channel.delete_at !== 0 : undefined;
        const enableEmojiPicker = config.EnableEmojiPicker === 'true' && !channelIsArchived;
        const teamId = getCurrentTeamId(state);
        const shortcutReactToLastPostEmittedFrom = getShortcutReactToLastPostEmittedFrom(state);
        const showActionsMenuPulsatingDot = showActionsDropdownPulsatingDot(state);

        let emojis: Emoji[] = [];
        const oneClickReactionsEnabled = get(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.ONE_CLICK_REACTIONS_ENABLED, Preferences.ONE_CLICK_REACTIONS_ENABLED_DEFAULT) === 'true';
        if (oneClickReactionsEnabled) {
            emojis = getOneClickReactionEmojis(state);
        }

        return {
            teamId,
            isFlagged: get(state, Preferences.CATEGORY_FLAGGED_POST, ownProps.post.id, null) != null,
            isMobile: state.views.channel.mobileView,
            isCardOpen: selectedCard && selectedCard.id === ownProps.post.id,

            isPostBeingEdited: getIsPostBeingEdited(state, ownProps.post.id),
            enableEmojiPicker,
            isReadOnly: channelIsArchived,
            shouldShowDotMenu: shouldShowDotMenu(state, ownProps.post, channel),
            shouldShowActionsMenu: shouldShowActionsMenu(state, ownProps.post),
            shortcutReactToLastPostEmittedFrom,
            collapsedThreadsEnabled: isCollapsedThreadsEnabled(state),
            hasReplies: getReplyCount(state, ownProps.post) > 0,
            showActionsMenuPulsatingDot,
            oneClickReactionsEnabled,
            recentEmojis: emojis,
            isPostPriorityEnabled: isPostPriorityEnabled(state),
        };
    };
}

function mapDispatchToProps(dispatch: Dispatch<AnyAction>) {
    return {
        actions: bindActionCreators({
            removePost: removePostAndCloseRHS,
            emitShortcutReactToLastPostFrom,
            setActionsMenuInitialisationState,
        }, dispatch),
    };
}

export default connect(makeMapStateToProps, mapDispatchToProps)(PostInfo);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useMemo} from 'react';

import {useDispatch, useSelector} from 'react-redux';

import {FormattedMessage} from 'react-intl';

import {setStatusDropdown} from 'actions/views/status_dropdown';
import CustomStatusEmoji from 'components/custom_status/custom_status_emoji';
import {makeGetCustomStatus, showPostHeaderUpdateStatusButton, isCustomStatusEnabled} from 'selectors/views/custom_status';
import {GlobalState} from 'types/store';
import EmojiIcon from 'components/widgets/icons/emoji_icon';

interface ComponentProps {
    userId: string;
    isSystemMessage: boolean;
    isBot: boolean;
}

const PostHeaderCustomStatus = (props: ComponentProps) => {
    const getCustomStatus = useMemo(makeGetCustomStatus, []);
    const {userId, isSystemMessage, isBot} = props;
    const dispatch = useDispatch();
    const userCustomStatus = useSelector((state: GlobalState) => getCustomStatus(state, userId));
    const showUpdateStatusButton = useSelector(showPostHeaderUpdateStatusButton);
    const customStatusEnabled = useSelector(isCustomStatusEnabled);

    const isCustomStatusSet = userCustomStatus && userCustomStatus.emoji;
    if (!customStatusEnabled || isSystemMessage || isBot) {
        return null;
    }

    if (isCustomStatusSet) {
        return (
            <CustomStatusEmoji
                userID={userId}
                showTooltip={true}
                emojiStyle={{
                    marginLeft: 4,
                    marginTop: 2,
                }}
            />
        );
    }

    // This must be checked after checking that custom status is not null
    if (!showUpdateStatusButton) {
        return null;
    }

    const updateStatus = (event: React.MouseEvent) => {
        event.preventDefault();
        dispatch(setStatusDropdown(true));
    };

    return (
        <button
            onClick={updateStatus}
            className='post__header-set-custom-status cursor--pointer style--none'
        >
            <EmojiIcon className='post__header-set-custom-status-icon'/>
            <span className='post__header-set-custom-status-text'>
                <FormattedMessage
                    id='post_header.update_status'
                    defaultMessage='Update your status'
                />
            </span>
        </button>
    );
};

export default PostHeaderCustomStatus;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {EventHandler, MouseEvent} from 'react';
import {FormattedMessage} from 'react-intl';

import {Post} from '@mattermost/types/posts';

import Constants from 'utils/constants';
import * as PostUtils from 'utils/post_utils';
import PostInfo from 'components/post_view/post_info';
import UserProfile from 'components/user_profile';
import BotBadge from 'components/widgets/badges/bot_badge';
import Badge from 'components/widgets/badges/badge';

import PostHeaderCustomStatus from './post_header_custom_status';

import './post_header.scss';

export type Props = {

    /*
     * The post to render the header for
     */
    post: Post;

    /*
     * Function called when the comment icon is clicked
     */
    handleCommentClick: EventHandler<MouseEvent>;

    /*
     * Function called when the card icon is clicked
     */
    handleCardClick: (post: Post) => void;

    /*
     * Function called when the post options dropdown is opened
     */
    handleDropdownOpened: (opened: boolean) => void;

    /*
     * Set to render compactly
     */
    compactDisplay?: boolean;

    /*
     * Set to colorize usernames according to their hash
     */
    colorizeUsernames?: boolean;

    /**
     * Set to indicate that this is previous post was not a reply to the same thread
     */
    isFirstReply?: boolean;

    /**
     * Set to mark post as being hovered over
     */
    hover: boolean;

    /*
     * Set to render the post time when not hovering
     */
    showTimeWithoutHover: boolean;

    /**
     * Whether or not the post username can be overridden.
     */
    enablePostUsernameOverride: boolean;

    /**
     * If the user that made the post is a bot.
     */
    isBot: boolean;

    /**
     * If the user that made the post is a guest.
     */
    isGuest: boolean;

    /**
     * To Check if the current post is last in the list
     */
    isLastPost?: boolean;

    /**
     * Source of image that should be override current user profile.
     */
    overwriteIcon?: string;
};

export default class PostHeader extends React.PureComponent<Props> {
    render(): JSX.Element {
        const {post} = this.props;
        const isSystemMessage = PostUtils.isSystemMessage(post);
        const fromAutoResponder = PostUtils.fromAutoResponder(post);
        const fromWebhook = post?.props?.from_webhook === 'true';

        let userProfile = (
            <UserProfile
                userId={post.user_id}
                hasMention={true}
                colorize={this.props.colorizeUsernames}
            />
        );
        let indicator;
        let colon;

        if (fromWebhook) {
            if (post.props.override_username && this.props.enablePostUsernameOverride) {
                userProfile = (
                    <UserProfile
                        userId={post.user_id}
                        hideStatus={true}
                        overwriteName={post.props.override_username}
                        overwriteIcon={this.props.overwriteIcon}
                        colorize={this.props.colorizeUsernames}
                    />
                );
            } else {
                userProfile = (
                    <UserProfile
                        userId={post.user_id}
                        hideStatus={true}
                        colorize={this.props.colorizeUsernames}
                    />
                );
            }

            if (!this.props.isBot) {
                indicator = (<BotBadge/>);
            }
        } else if (fromAutoResponder) {
            userProfile = (
                <UserProfile
                    userId={post.user_id}
                    hideStatus={true}
                    hasMention={true}
                    colorize={this.props.colorizeUsernames}
                />
            );

            indicator = (
                <Badge>
                    <FormattedMessage
                        id='post_info.auto_responder'
                        defaultMessage='AUTOMATIC REPLY'
                    />
                </Badge>
            );
        } else if (isSystemMessage && this.props.isBot) {
            userProfile = (
                <UserProfile
                    userId={post.user_id}
                    hideStatus={true}
                />
            );
        } else if (isSystemMessage) {
            userProfile = (
                <UserProfile
                    userId=''
                    overwriteName={
                        <FormattedMessage
                            id='post_info.system'
                            defaultMessage='System'
                        />
                    }
                    overwriteImage={Constants.SYSTEM_MESSAGE_PROFILE_IMAGE}
                    disablePopover={true}
                />
            );
        }

        if (this.props.compactDisplay) {
            colon = (<strong className='colon'>{':'}</strong>);
        }

        const customStatus = (
            <PostHeaderCustomStatus
                userId={this.props.post.user_id}
                isBot={this.props.isBot || fromWebhook}
                isSystemMessage={isSystemMessage}
            />
        );

        return (
            <div className='post__header'>
                <div className='col col__name'>
                    {userProfile}
                    {colon}
                    {indicator}
                    {customStatus}
                </div>
                <div className='col d-flex align-items-center'>
                    <PostInfo
                        post={post}
                        handleCommentClick={this.props.handleCommentClick}
                        handleCardClick={this.props.handleCardClick}
                        handleDropdownOpened={this.props.handleDropdownOpened}
                        compactDisplay={this.props.compactDisplay}
                        isFirstReply={this.props.isFirstReply}
                        showTimeWithoutHover={this.props.showTimeWithoutHover}
                        hover={this.props.hover}
                        isLastPost={this.props.isLastPost}
                    />
                </div>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getUser} from 'mattermost-redux/selectors/entities/users';

import {Client4} from 'mattermost-redux/client';

import {GlobalState} from 'types/store';
import {isGuest} from 'mattermost-redux/utils/user_utils';

import PostHeader, {Props} from './post_header';

function mapStateToProps(state: GlobalState, ownProps: Pick<Props, 'post'>) {
    const config = getConfig(state);
    const enablePostUsernameOverride = config.EnablePostUsernameOverride === 'true';
    const enablePostIconOverride = config.EnablePostIconOverride === 'true';

    const overrideIconUrl = enablePostIconOverride && ownProps.post?.props?.override_icon_url;
    let overwriteIcon;
    if (overrideIconUrl) {
        overwriteIcon = Client4.getAbsoluteUrl(overrideIconUrl);
    }

    const user = getUser(state, ownProps.post.user_id);
    const isBot = Boolean(user && user.is_bot);

    return {
        enablePostUsernameOverride,
        isBot,
        overwriteIcon,
        isGuest: Boolean(user && isGuest(user.roles)),
    };
}

export default connect(mapStateToProps)(PostHeader);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {Posts} from 'mattermost-redux/constants';
import {isMeMessage as checkIsMeMessage} from 'mattermost-redux/utils/post_utils';
import {UserActivityPost} from 'mattermost-redux/selectors/entities/posts';

import {makeIsEligibleForClick} from 'utils/utils';
import * as PostUtils from 'utils/post_utils';
import Constants, {A11yCustomEventTypes, AppEvents} from 'utils/constants';

import PostProfilePicture from 'components/post_profile_picture';
import PostAriaLabelDiv from 'components/post_view/post_aria_label_div';
import PostBody from 'components/post_view/post_body';
import PostHeader from 'components/post_view/post_header';
import PostContext from 'components/post_view/post_context';
import PostPreHeader from 'components/post_view/post_pre_header';
import ThreadFooter from 'components/threading/channel_threads/thread_footer';
import {trackEvent} from 'actions/telemetry_actions';
import EditPost from 'components/edit_post';
import AutoHeightSwitcher, {AutoHeightSlots} from 'components/common/auto_height_switcher';

// When adding clickable targets within a root post to exclude from post's on click to open thread,
// please add to/maintain the selector below
const isEligibleForClick = makeIsEligibleForClick('.post-image__column, .embed-responsive-item, .attachment, .hljs, code');

import {Post as PostType} from '@mattermost/types/posts';

interface Props {

    /**
     * The post to render
     */
    post: PostType & {system_post_ids?: UserActivityPost['system_post_ids']};

    /**
     * The logged in user ID
     */
    currentUserId: string;

    /**
     * Set to center the post
     */
    center: boolean;

    /**
     * Set to render post compactly
     */
    compactDisplay: boolean;

    /**
     * Set to colorize usernames according to their hash in compact view
     */
    colorizeUsernames: boolean;

    /**
     * Set to render a preview of the parent post above this reply
     */
    isFirstReply: boolean;

    /**
     * Set to highlight the background of the post
     */
    shouldHighlight: boolean;

    /**
     * Set to render this post as if it was attached to the previous post
     */
    consecutivePostByUser: boolean;

    /**
     * Set if the previous post is a comment
     */
    previousPostIsComment: boolean;

    /*
     * Function called when the post options dropdown is opened
     */
    togglePostMenu: (opened: boolean) => void;

    /**
     * Set to render this comment as a mention
     */
    isCommentMention: boolean;

    /**
     * If the post has replies
     */
    hasReplies: boolean;

    /**
     * To Check if the current post is last in the list
     */
    isLastPost?: boolean;

    isBeingEdited: boolean;

    /**
     * Whether or not the channel that contains this post is archived
     */
    channelIsArchived: boolean;

    actions: {
        selectPost: (post: PostType) => void;
        selectPostCard: (post: PostType) => void;
        markPostAsUnread: (post: PostType, location: string) => void;
    };

    /*
     * Set to mark the post as flagged
     */
    isFlagged: boolean;

    isCollapsedThreadsEnabled?: boolean;

    clickToReply?: boolean;
}

interface State {
    dropdownOpened: boolean;
    fileDropdownOpened: boolean;
    hover: boolean;
    alt: boolean;
    a11yActive: boolean;
    ariaHidden: boolean;
    fadeOutHighlight: boolean;
}

export default class Post extends React.PureComponent<Props, State> {
    private postRef: React.RefObject<HTMLDivElement>;
    private highlightTimeout!: NodeJS.Timeout;

    constructor(props: Props) {
        super(props);

        this.postRef = React.createRef();

        this.state = {
            dropdownOpened: false,
            fileDropdownOpened: false,
            hover: false,
            alt: false,
            a11yActive: false,
            ariaHidden: true,
            fadeOutHighlight: false,
        };
    }

    componentDidMount() {
        // Refs can be null when this component is shallowly rendered for testing
        if (this.postRef.current) {
            this.postRef.current.addEventListener(A11yCustomEventTypes.ACTIVATE, this.handleA11yActivateEvent);
            this.postRef.current.addEventListener(A11yCustomEventTypes.DEACTIVATE, this.handleA11yDeactivateEvent);
        }

        if (this.props.shouldHighlight) {
            this.highlightTimeout = setTimeout(() => {
                this.setState({fadeOutHighlight: true});
            }, Constants.PERMALINK_FADEOUT);
        }
    }

    componentWillUnmount() {
        if (this.state.hover) {
            this.removeKeyboardListeners();
        }

        if (this.postRef.current) {
            this.postRef.current.removeEventListener(A11yCustomEventTypes.ACTIVATE, this.handleA11yActivateEvent);
            this.postRef.current.removeEventListener(A11yCustomEventTypes.DEACTIVATE, this.handleA11yDeactivateEvent);
        }

        clearTimeout(this.highlightTimeout);
    }

    componentDidUpdate() {
        if (this.state.a11yActive) {
            this.postRef.current?.dispatchEvent(new Event(A11yCustomEventTypes.UPDATE));
        }
    }

    handleCommentClick = (e: React.MouseEvent) => {
        e.preventDefault();

        const post = this.props.post;
        if (!post) {
            return;
        }
        this.props.actions.selectPost(post);
    }

    handleCardClick = (post?: PostType) => {
        if (!post) {
            return;
        }
        this.props.actions.selectPostCard(post);
    }

    handlePostClick = (e: React.MouseEvent) => {
        const {post, clickToReply, isBeingEdited} = this.props;

        if (!post) {
            return;
        }

        const isSystemMessage = PostUtils.isSystemMessage(post);
        const fromAutoResponder = PostUtils.fromAutoResponder(post);

        if (
            !e.altKey &&
            clickToReply &&
            (fromAutoResponder || !isSystemMessage) &&
            isEligibleForClick(e) &&
            !isBeingEdited
        ) {
            trackEvent('crt', 'clicked_to_reply');
            this.props.actions.selectPost(post);
        }

        if (this.props.channelIsArchived || post.system_post_ids) {
            return;
        }

        if (e.altKey) {
            this.props.actions.markPostAsUnread(post, 'CENTER');
        }
    }

    handleDropdownOpened = (opened: boolean) => {
        if (this.props.togglePostMenu) {
            this.props.togglePostMenu(opened);
        }

        this.setState({
            dropdownOpened: opened,
        });
    }

    handleFileDropdownOpened = (opened: boolean) => {
        this.setState({
            fileDropdownOpened: opened,
        });
    }

    hasSameRoot = (props: Props) => {
        const post = props.post;

        if (props.isFirstReply) {
            return false;
        } else if (!post.root_id && !props.previousPostIsComment && props.consecutivePostByUser) {
            return true;
        } else if (post.root_id) {
            return true;
        }

        return false;
    }

    getClassName = (post: Props['post'], isSystemMessage?: boolean, isMeMessage?: boolean, fromWebhook?: boolean, fromAutoResponder?: boolean, fromBot?: boolean) => {
        let className = 'post';

        if (post.failed || post.state === Posts.POST_DELETED) {
            className += ' post--hide-controls';
        }

        if (!this.state.fadeOutHighlight && this.props.shouldHighlight) {
            className += ' post--highlight';
            if (post.is_pinned || this.props.isFlagged) {
                className += ' post--pinned-or-flagged-highlight';
            }
        }

        let rootUser = '';
        if (this.hasSameRoot(this.props)) {
            rootUser = 'same--root';
        } else {
            rootUser = 'other--root';
        }

        if (fromBot) {
            className += ' post--bot';
        }

        let currentUserCss = '';
        if (this.props.currentUserId === post.user_id && !fromWebhook && !isSystemMessage) {
            currentUserCss = 'current--user';
        }

        let sameUserClass = '';
        if (this.props.consecutivePostByUser) {
            sameUserClass = 'same--user';
        }

        let postType = '';
        if (post.root_id && post.root_id.length > 0) {
            postType = 'post--comment';
        } else if (this.props.hasReplies) {
            postType = 'post--root';
            sameUserClass = '';
            rootUser = '';
        }

        if (isSystemMessage || isMeMessage) {
            className += ' post--system';
            if (isSystemMessage) {
                currentUserCss = '';
                postType = '';
                rootUser = '';
            }
        }

        if (fromAutoResponder) {
            postType = 'post--comment same--root';
        }

        if (this.props.compactDisplay) {
            sameUserClass = '';
            className += ' post--compact';
        }

        if ((this.state.dropdownOpened || this.state.fileDropdownOpened || this.state.a11yActive) && !this.props.isBeingEdited) {
            className += ' post--hovered';
        }

        if (post.is_pinned || this.props.isFlagged) {
            className += ' post--pinned-or-flagged';
        }

        if (this.props.isBeingEdited) {
            className += ' post--editing';
        }

        if (this.state.alt && !(this.props.channelIsArchived || post.system_post_ids)) {
            className += ' cursor--pointer';
        }

        return className + ' ' + sameUserClass + ' ' + rootUser + ' ' + postType + ' ' + currentUserCss;
    }

    setHover = (e: {altKey: boolean}) => {
        this.setState({
            hover: true,
            alt: e.altKey,
        });

        this.addKeyboardListeners();
    }

    unsetHover = () => {
        this.setState({
            hover: false,
            alt: false,
        });

        this.removeKeyboardListeners();
    }

    addKeyboardListeners = () => {
        document.addEventListener('keydown', this.handleAlt);
        document.addEventListener('keyup', this.handleAlt);
    }

    removeKeyboardListeners = () => {
        document.removeEventListener('keydown', this.handleAlt);
        document.removeEventListener('keyup', this.handleAlt);
    }

    handleAlt = (e: {altKey: boolean}) => {
        if (this.state.alt !== e.altKey) {
            this.setState({alt: e.altKey});
        }
    }

    handleA11yActivateEvent = () => {
        if (!this.props.isBeingEdited) {
            this.setState({
                a11yActive: true,
                ariaHidden: false,
            });
        }
    }

    handleA11yDeactivateEvent = () => {
        this.setState({
            a11yActive: false,
            ariaHidden: true,
        });
    }

    render() {
        const {
            post,
            hasReplies,
            compactDisplay,
            isCollapsedThreadsEnabled,
            isBeingEdited,
        } = this.props;

        if (!post.id) {
            return null;
        }

        const isSystemMessage = PostUtils.isSystemMessage(post);
        const isMeMessage = checkIsMeMessage(post);
        const fromAutoResponder = PostUtils.fromAutoResponder(post);
        const fromWebhook = post && PostUtils.isFromWebhook(post);
        const fromBot = post && PostUtils.isFromBot(post);

        let profilePic;
        const hideProfilePicture = this.hasSameRoot(this.props) && this.props.consecutivePostByUser && (!post.root_id && !hasReplies) && !fromBot;
        if (!hideProfilePicture) {
            profilePic = (
                <PostProfilePicture
                    compactDisplay={this.props.compactDisplay}
                    post={post}
                    userId={post.user_id}
                />
            );

            if (fromAutoResponder) {
                profilePic = (
                    <span className='auto-responder'>
                        {profilePic}
                    </span>
                );
            }
        }

        let centerClass = '';
        if (this.props.center) {
            centerClass = 'center';
        }

        const postHeader = (
            <PostHeader
                post={post}
                handleCommentClick={this.handleCommentClick}
                handleCardClick={this.handleCardClick}
                handleDropdownOpened={this.handleDropdownOpened}
                compactDisplay={this.props.compactDisplay}
                colorizeUsernames={this.props.compactDisplay && this.props.colorizeUsernames}
                isFirstReply={this.props.isFirstReply}
                showTimeWithoutHover={!hideProfilePicture}
                hover={(this.state.hover || this.state.a11yActive || this.state.fileDropdownOpened) && !isBeingEdited}
                isLastPost={this.props.isLastPost}
            />
        );

        const postBody = (
            <PostBody
                post={post}
                handleCommentClick={this.handleCommentClick}
                compactDisplay={this.props.compactDisplay}
                isCommentMention={this.props.isCommentMention}
                isFirstReply={this.props.isFirstReply}
                handleFileDropdownOpened={this.handleFileDropdownOpened}
            />
        );

        const threadFooter = isCollapsedThreadsEnabled && !post.root_id && (hasReplies || post.is_following) ? <ThreadFooter threadId={post.id}/> : null;

        const slot1 = (
            <>
                {compactDisplay && postHeader}
                {postBody}
            </>
        );

        const slot2 = (
            <>
                {compactDisplay && postHeader}
                {(compactDisplay && isBeingEdited) && <div className={'clearfix'}/>}
                <EditPost/>
            </>
        );

        const showSlot = isBeingEdited ? AutoHeightSlots.SLOT2 : AutoHeightSlots.SLOT1;

        return (
            <PostContext.Provider value={{handlePopupOpened: this.handleDropdownOpened}}>
                <PostAriaLabelDiv
                    ref={this.postRef}
                    id={'post_' + post.id}
                    data-testid='postView'
                    role='listitem'
                    className={`a11y__section ${this.getClassName(post, isSystemMessage, isMeMessage, fromWebhook, fromAutoResponder, fromBot)}`}
                    tabIndex={0}
                    onMouseOver={this.setHover}
                    onMouseLeave={this.unsetHover}
                    onTouchStart={this.setHover}
                    onClick={this.handlePostClick}
                    aria-atomic={true}
                    post={post}
                >
                    <PostPreHeader
                        isFlagged={this.props.isFlagged}
                        isPinned={post.is_pinned}
                        channelId={post.channel_id}
                    />
                    <div
                        role='application'
                        data-testid='postContent'
                        className={'post__content ' + centerClass}
                        aria-hidden={this.state.ariaHidden}
                    >
                        <div className='post__img'>
                            {profilePic}
                        </div>
                        <div>
                            {!compactDisplay && postHeader}
                            <AutoHeightSwitcher
                                showSlot={showSlot}
                                slot1={slot1}
                                slot2={slot2}
                                shouldScrollIntoView={isBeingEdited}
                                onTransitionEnd={() => document.dispatchEvent(new Event(AppEvents.FOCUS_EDIT_TEXTBOX))}
                            />
                            {threadFooter}
                        </div>
                    </div>
                </PostAriaLabelDiv>
            </PostContext.Provider>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {getChannel} from 'mattermost-redux/selectors/entities/channels';
import {getPost, makeIsPostCommentMention, makeGetCommentCountForPost, UserActivityPost} from 'mattermost-redux/selectors/entities/posts';

import {
    get,
    isCollapsedThreadsEnabled,
} from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';

import {GenericAction} from 'mattermost-redux/types/actions';
import {Post} from '@mattermost/types/posts';

import {markPostAsUnread} from 'actions/post_actions';
import {selectPost, selectPostCard} from 'actions/views/rhs';

import {GlobalState} from 'types/store';

import {isArchivedChannel} from 'utils/channel_utils';
import {Preferences} from 'utils/constants';
import {areConsecutivePostsBySameUser} from 'utils/post_utils';
import {getIsPostBeingEdited, getIsPostBeingEditedInRHS} from '../../../selectors/posts';

import PostComponent from './post';

interface OwnProps {
    post?: UserActivityPost;
    postId: string;
    previousPostId?: string;
}

// isFirstReply returns true when the given post a comment that isn't part of the same thread as the previous post.
export function isFirstReply(post: Post, previousPost?: Post | null): boolean {
    if (post.root_id) {
        if (previousPost) {
            // Returns true as long as the previous post is part of a different thread
            return post.root_id !== previousPost.id && post.root_id !== previousPost.root_id;
        }

        // The previous post is not a real post
        return true;
    }

    // This post is not a reply
    return false;
}

function makeMapStateToProps() {
    const getReplyCount = makeGetCommentCountForPost();
    const isPostCommentMention = makeIsPostCommentMention();

    return (state: GlobalState, ownProps: OwnProps) => {
        const post: UserActivityPost = ownProps.post || getPost(state, ownProps.postId) as UserActivityPost;
        const channel = getChannel(state, post.channel_id);

        let previousPost = null;
        if (ownProps.previousPostId) {
            previousPost = getPost(state, ownProps.previousPostId);
        }

        let consecutivePostByUser = false;
        let previousPostIsComment = false;

        if (previousPost && !post.metadata?.priority?.priority) {
            consecutivePostByUser = areConsecutivePostsBySameUser(post, previousPost);
            previousPostIsComment = Boolean(previousPost.root_id);
        }

        return {
            post,
            isBeingEdited: getIsPostBeingEdited(state, post.id) && !getIsPostBeingEditedInRHS(state, post.id),
            currentUserId: getCurrentUserId(state),
            isFirstReply: previousPost ? isFirstReply(post, previousPost) : false,
            consecutivePostByUser,
            previousPostIsComment,
            hasReplies: getReplyCount(state, post) > 0,
            isCommentMention: isPostCommentMention(state, post.id),
            center: get(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.CHANNEL_DISPLAY_MODE, Preferences.CHANNEL_DISPLAY_MODE_DEFAULT) === Preferences.CHANNEL_DISPLAY_MODE_CENTERED,
            compactDisplay: get(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.MESSAGE_DISPLAY, Preferences.MESSAGE_DISPLAY_DEFAULT) === Preferences.MESSAGE_DISPLAY_COMPACT,
            colorizeUsernames: get(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.COLORIZE_USERNAMES, Preferences.COLORIZE_USERNAMES_DEFAULT) === 'true',
            channelIsArchived: isArchivedChannel(channel),
            isFlagged: get(state, Preferences.CATEGORY_FLAGGED_POST, post.id, null) != null,
            isCollapsedThreadsEnabled: isCollapsedThreadsEnabled(state),
            clickToReply: get(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.CLICK_TO_REPLY, Preferences.CLICK_TO_REPLY_DEFAULT) === 'true',
        };
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            selectPost,
            selectPostCard,
            markPostAsUnread,
        }, dispatch),
    };
}

export default connect(makeMapStateToProps, mapDispatchToProps)(PostComponent);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useRef} from 'react';
import {useSelector} from 'react-redux';
import {useIntl} from 'react-intl';

import {Post} from '@mattermost/types/posts';

import {GlobalState} from 'types/store';

import {makeCreateAriaLabelForPost} from 'utils/post_utils';

export type Props = React.HTMLProps<HTMLDivElement> & {
    labelPrefix?: string;
    post: Post;
}

const PostAriaLabelDiv = React.forwardRef((props: Props, ref: React.Ref<HTMLDivElement>) => {
    const {
        children,
        labelPrefix,
        post,
        ...otherProps
    } = props;

    const intl = useIntl();

    const createAriaLabelForPost = useRef(makeCreateAriaLabelForPost());
    let ariaLabel = useSelector<GlobalState, string>((state) => createAriaLabelForPost.current(state, post)(intl));
    if (labelPrefix) {
        ariaLabel = labelPrefix + ariaLabel;
    }

    return (
        <div
            ref={ref}
            aria-label={ariaLabel}
            {...otherProps}
        >
            {children}
        </div>
    );
});

PostAriaLabelDiv.displayName = 'PostAriaLabelDiv';

export default PostAriaLabelDiv;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

type Point = {
    height: number;
    width: number;
};

type PartialPoint = Partial<Point>;

function isPointDefined(point: PartialPoint): point is Point {
    return point.height !== undefined && point.width !== undefined;
}

export function getDistanceBW2Points(point1: Point, point2: Point) {
    return Math.sqrt(Math.pow(point1.width - point2.width, 2) + Math.pow(point1.height - point2.height, 2));
}

/**
 * Funtion to return nearest point of given pivot point.
 * It return two points one nearest and other nearest but having both coorditanes smaller than the given point's coordinates.
 */
export function getNearestPoint<T extends PartialPoint>(pivot: Point, points: T[]): T {
    return points.reduce((nearest, point) => {
        if (isPointDefined(nearest) && isPointDefined(point) &&
            getDistanceBW2Points(point, pivot) >= getDistanceBW2Points(nearest, pivot)) {
            return nearest;
        }
        return point;
    }, {} as T);
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo, useRef} from 'react';
import classNames from 'classnames';
import {CloseIcon, MenuDownIcon, MenuRightIcon} from '@mattermost/compass-icons/components';

import {useIntl} from 'react-intl';

import {
    OpenGraphMetadata,
    OpenGraphMetadataImage,
    Post,
    PostImage,
} from '@mattermost/types/posts';

import AutoHeightSwitcher from 'components/common/auto_height_switcher';
import ExternalImage from 'components/external_image';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import Constants, {PostTypes} from 'utils/constants';
import {isSystemMessage} from 'utils/post_utils';
import {makeUrlSafe} from 'utils/url';

import {getNearestPoint} from './get_nearest_point';

import './post_attachment_opengraph.scss';

const DIMENSIONS_NEAREST_POINT_IMAGE = {
    height: 80,
    width: 80,
};

const LARGE_IMAGE_RATIO = 4 / 3;
const LARGE_IMAGE_WIDTH = 150;

export type Props = {
    postId: string;
    link: string;
    currentUserId?: string;
    post: Post;
    openGraphData?: OpenGraphMetadata;
    enableLinkPreviews?: boolean;
    previewEnabled?: boolean;
    isEmbedVisible?: boolean;
    toggleEmbedVisibility: () => void;
    actions: {
        editPost: (post: { id: string; props: Record<string, any> }) => void;
    };
    isInPermalink?: boolean;
    imageCollapsed?: boolean;
};

type ImageMetadata = Partial<OpenGraphMetadataImage> & PostImage;

export function getBestImage(openGraphData?: OpenGraphMetadata, imagesMetadata?: Record<string, PostImage>) {
    if (!openGraphData?.images?.length) {
        return null;
    }

    // Get the dimensions from the post metadata if they weren't provided by the website as part of the OpenGraph data
    const images = openGraphData.images.map((image: OpenGraphMetadataImage) => {
        const imageUrl = image.secure_url || image.url;

        return {
            ...image,
            height: image.height || imagesMetadata?.[imageUrl]?.height || -1,
            width: image.width || imagesMetadata?.[imageUrl]?.width || -1,
            format: image.type?.split('/')[1] || image.type || '',
            frameCount: 0,
        };
    });

    return getNearestPoint<ImageMetadata>(DIMENSIONS_NEAREST_POINT_IMAGE, images);
}

export const getIsLargeImage = (data: ImageMetadata|null) => {
    if (!data) {
        return false;
    }

    const {height, width} = data;

    return width >= LARGE_IMAGE_WIDTH && (width / height) >= LARGE_IMAGE_RATIO;
};

const PostAttachmentOpenGraph = ({openGraphData, post, actions, link, isInPermalink, previewEnabled, ...rest}: Props) => {
    const {formatMessage} = useIntl();
    const {current: bestImageData} = useRef<ImageMetadata>(getBestImage(openGraphData, post.metadata.images));
    const isPreviewRemoved = post?.props?.[PostTypes.REMOVE_LINK_PREVIEW] === 'true';

    // block of early return statements
    if (!rest.enableLinkPreviews || !previewEnabled || isPreviewRemoved) {
        return null;
    }

    if (!post || isSystemMessage(post)) {
        return null;
    }

    if (!openGraphData) {
        return null;
    }

    const handleRemovePreview = async (e: React.MouseEvent<HTMLButtonElement>) => {
        e.preventDefault();

        // prevent the button-click to trigger visiting the link
        e.stopPropagation();
        const props = Object.assign({}, post.props);
        props[PostTypes.REMOVE_LINK_PREVIEW] = 'true';

        const patchedPost = {
            id: post.id,
            props,
        };

        return actions.editPost(patchedPost);
    };

    const removeButtonTooltip = (
        <Tooltip id={`removeLinkPreview-${post.id}`}>
            {formatMessage({id: 'link_preview.remove_link_preview', defaultMessage: 'Remove link preview'})}
        </Tooltip>
    );

    const safeLink = makeUrlSafe(openGraphData?.url || link);

    return (
        <a
            className='PostAttachmentOpenGraph'
            role='link'
            href={safeLink}
            target='_blank'
            rel='noopener noreferrer'
            title={openGraphData?.title || openGraphData?.url || link}
        >
            {rest.currentUserId === post.user_id && !isInPermalink && (
                <OverlayTrigger
                    placement='top'
                    delayShow={Constants.OVERLAY_TIME_DELAY}
                    overlay={removeButtonTooltip}
                >
                    <button
                        type='button'
                        className='remove-button style--none'
                        aria-label='Remove'
                        onClick={handleRemovePreview}
                        data-testid='removeLinkPreviewButton'
                    >
                        <CloseIcon
                            size={14}
                            color={'currentColor'}
                        />
                    </button>
                </OverlayTrigger>
            )}
            <PostAttachmentOpenGraphBody
                isInPermalink={isInPermalink}
                sitename={openGraphData?.site_name}
                title={openGraphData?.title || openGraphData?.url || link}
                description={openGraphData?.description}
            />
            <PostAttachmentOpenGraphImage
                imageMetadata={bestImageData}
                title={openGraphData?.title}
                isInPermalink={isInPermalink}
                isEmbedVisible={rest.isEmbedVisible}
                toggleEmbedVisibility={rest.toggleEmbedVisibility}
            />
        </a>
    );
};

type BodyProps = {
    title: string;
    isInPermalink?: boolean;
    sitename?: string;
    description?: string;
}

export const PostAttachmentOpenGraphBody = memo(({title, isInPermalink, sitename = '', description = ''}: BodyProps) => {
    return title ? (
        <div className={classNames('PostAttachmentOpenGraph__body', {isInPermalink})}>
            {(!isInPermalink && sitename) && <span className='sitename'>{sitename}</span>}
            <span className='title'>{title}</span>
            {description && <span className='description'>{description}</span>}
        </div>
    ) : null;
});

type ImageProps = {
    title?: string;
    imageMetadata?: ImageMetadata|null;
    isInPermalink: Props['isInPermalink'];
    isEmbedVisible: Props['isEmbedVisible'];
    toggleEmbedVisibility: Props['toggleEmbedVisibility'];
}

export const PostAttachmentOpenGraphImage = memo(({imageMetadata, isInPermalink, toggleEmbedVisibility, isEmbedVisible = true, title = ''}: ImageProps) => {
    const {formatMessage} = useIntl();

    if (!imageMetadata || isInPermalink) {
        return null;
    }

    const large = getIsLargeImage(imageMetadata);
    const src = imageMetadata.secure_url || imageMetadata.url || '';

    const toggleImagePreview = (e: React.MouseEvent<HTMLButtonElement>) => {
        e.preventDefault();

        // prevent the button-click to trigger visiting the link
        e.stopPropagation();
        toggleEmbedVisibility();
    };

    const collapsedLabel = formatMessage({id: 'link_preview.image_preview', defaultMessage: 'Show image preview'});

    const imageCollapseButton = (
        <button
            className='preview-toggle style--none'
            onClick={toggleImagePreview}
        >
            {isEmbedVisible ? (
                <MenuDownIcon
                    size={18}
                    color='currentColor'
                />
            ) : (
                <>
                    <MenuRightIcon
                        size={18}
                        color='currentColor'
                    />
                    {collapsedLabel}
                </>
            )}
        </button>
    );

    const image = (
        <ExternalImage
            src={src}
            imageMetadata={imageMetadata}
        >
            {(source) => (
                <>
                    {large && imageCollapseButton}
                    <figure>
                        <img
                            src={source}
                            alt={title}
                        />
                    </figure>
                </>
            )}
        </ExternalImage>
    );

    return (
        <div className={classNames('PostAttachmentOpenGraph__image', {large, collapsed: !isEmbedVisible})}>
            {large ? (
                <AutoHeightSwitcher
                    showSlot={isEmbedVisible ? 1 : 2}
                    slot1={image}
                    slot2={imageCollapseButton}
                />
            ) : image}
        </div>
    );
});

export default PostAttachmentOpenGraph;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {bindActionCreators, Dispatch} from 'redux';

import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getOpenGraphMetadataForUrl} from 'mattermost-redux/selectors/entities/posts';
import {getBool} from 'mattermost-redux/selectors/entities/preferences';
import {arePreviewsCollapsed} from 'selectors/preferences';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {GenericAction} from 'mattermost-redux/types/actions';

import {editPost} from 'actions/views/posts';
import {GlobalState} from 'types/store';
import {Preferences} from 'utils/constants';

import PostAttachmentOpenGraph, {Props} from './post_attachment_opengraph';

type OwnProps = Pick<Props, 'postId' | 'link'>;

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const config = getConfig(state);
    const imageCollapsed = arePreviewsCollapsed(state);

    return {
        currentUserId: getCurrentUserId(state),
        enableLinkPreviews: config.EnableLinkPreviews === 'true',
        openGraphData: getOpenGraphMetadataForUrl(
            state,
            ownProps.postId,
            ownProps.link,
        ),
        previewEnabled: getBool(
            state,
            Preferences.CATEGORY_DISPLAY_SETTINGS,
            Preferences.LINK_PREVIEW_DISPLAY,
            true,
        ),
        imageCollapsed,
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({editPost}, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(PostAttachmentOpenGraph);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {getScheme} from 'utils/url';

import RemoveMarkdown from './remove_markdown';

export default class LinkOnlyRenderer extends RemoveMarkdown {
    public link(href: string, title: string, text: string) {
        let outHref = href;

        if (!getScheme(href)) {
            outHref = `http://${outHref}`;
        }

        let output = `<a class="theme markdown__link" href="${outHref}" target="_blank"`;

        if (title) {
            output += ' title="' + title + '"';
        }

        output += `>${text}</a>`;

        return output;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {changeOpacity} from 'mattermost-redux/utils/theme_utils';
import {Theme} from 'mattermost-redux/selectors/entities/preferences';
import {PostAction, PostActionOption} from '@mattermost/types/integration_actions';

import LoadingWrapper from 'components/widgets/loading/loading_wrapper';
import Markdown from 'components/markdown';

type Props = {
    action: PostAction;
    handleAction: (e: React.MouseEvent, options?: PostActionOption[]) => void;
    disabled?: boolean;
    theme: Theme;
    actionExecuting?: boolean;
    actionExecutingMessage?: string;
}

export default class ActionButton extends React.PureComponent<Props> {
    getStatusColors(theme: Theme) {
        return {
            good: '#00c100',
            warning: '#dede01',
            danger: theme.errorTextColor,
            default: theme.centerChannelColor,
            primary: theme.buttonBg,
            success: theme.onlineIndicator,
        } as Record<string, string>;
    }

    render() {
        const {action, handleAction, disabled, theme} = this.props;
        let customButtonStyle;

        if (action.style) {
            const STATUS_COLORS = this.getStatusColors(theme);
            const hexColor =
                STATUS_COLORS[action.style] ||
                theme[action.style] ||
                (action.style.match('^#(?:[0-9a-fA-F]{3}){1,2}$') && action.style);

            if (hexColor) {
                customButtonStyle = {
                    borderColor: changeOpacity(hexColor, 0.25),
                    color: hexColor,
                    borderWidth: 2,
                };
            }
        }

        return (
            <button
                data-action-id={action.id}
                data-action-cookie={action.cookie}
                disabled={disabled}
                key={action.id}
                onClick={(e) => handleAction(e, this.props.action.options)}
                style={customButtonStyle}
            >
                <LoadingWrapper
                    loading={this.props.actionExecuting}
                    text={this.props.actionExecutingMessage}
                >
                    <Markdown
                        message={action.name}
                        options={{
                            mentionHighlight: false,
                            markdown: false,
                            autolinkedUrlSchemes: [],
                        }}
                    />
                </LoadingWrapper>
            </button>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getTheme} from 'mattermost-redux/selectors/entities/preferences';
import {GlobalState} from '@mattermost/types/store';

import ActionButton from './action_button';

function mapStateToProps(state: GlobalState) {
    return {
        theme: getTheme(state),
    };
}

export default connect(mapStateToProps)(ActionButton);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {UserProfile} from '@mattermost/types/users';
import {Channel} from '@mattermost/types/channels';

import MenuActionProvider from 'components/suggestion/menu_action_provider';
import GenericUserProvider from 'components/suggestion/generic_user_provider';
import GenericChannelProvider from 'components/suggestion/generic_channel_provider.jsx';
import AutocompleteSelector from 'components/autocomplete_selector';
import PostContext from 'components/post_view/post_context';

import type {OwnProps, PropsFromRedux} from './index';

type Option = {
    text: string;
    value: string;
};

type Provider = GenericUserProvider | GenericChannelProvider | MenuActionProvider;

type Selected = Option | UserProfile | Channel;

export type Props = OwnProps & PropsFromRedux;

type State = {
    selected?: Selected;
    value: string;
};

export default class ActionMenu extends React.PureComponent<Props, State> {
    private providers: Provider[];

    constructor(props: Props) {
        super(props);

        const action = props.action;
        this.providers = [];
        if (action) {
            if (action.data_source === 'users') {
                this.providers = [new GenericUserProvider(props.autocompleteUsers)];
            } else if (action.data_source === 'channels') {
                this.providers = [new GenericChannelProvider(props.autocompleteChannels)];
            } else if (action.options) {
                this.providers = [new MenuActionProvider(action.options)];
            }
        }

        let selected;
        let value = '';

        if (action.default_option && action.options) {
            selected = action.options.find((option) => option.value === action.default_option);
            value = selected ? selected.text : '';
        }

        this.state = {
            selected,
            value,
        };
    }

    static getDerivedStateFromProps(props: Props, state: State) {
        if (props.selected && props.selected !== state.selected) {
            const selected = props.selected as Option;
            return {
                value: selected.text,
                selected: props.selected,
            };
        }

        return null;
    }

    handleSelected = (selected: Selected) => {
        if (!selected) {
            return;
        }

        const {action} = this.props;

        let value = '';
        let text = '';
        if (action.data_source === 'users') {
            const user = selected as UserProfile;
            text = user.username;
            value = user.id;
        } else if (action.data_source === 'channels') {
            const channel = selected as Channel;
            text = channel.display_name;
            value = channel.id;
        } else {
            const option = selected as Option;
            text = option.text;
            value = option.value;
        }

        this.props.selectAttachmentMenuAction(
            this.props.postId, this.props.action.id || '', this.props.action.cookie || '', this.props.action?.data_source, text, value);

        this.setState({value: text});
    }

    render() {
        const {action, disabled} = this.props;

        return (
            <PostContext.Consumer>
                {({handlePopupOpened}) => (
                    <AutocompleteSelector
                        providers={this.providers}
                        onSelected={this.handleSelected}
                        placeholder={action.name}
                        inputClassName='post-attachment-dropdown'
                        value={this.state.value}
                        toggleFocus={handlePopupOpened}
                        disabled={disabled}
                    />
                )}
            </PostContext.Consumer>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect, ConnectedProps} from 'react-redux';

import {PostAction} from '@mattermost/types/integration_actions';

import {GlobalState} from 'types/store';
import {autocompleteChannels} from 'actions/channel_actions';
import {autocompleteUsers} from 'actions/user_actions';
import {selectAttachmentMenuAction} from 'actions/views/posts';

import ActionMenu from './action_menu';

export type OwnProps = {
    postId: string;
    action: PostAction;
    disabled?: boolean;
}

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const actions = state.views.posts.menuActions[ownProps.postId];
    const selected = (ownProps.action && ownProps.action.id) ? actions && actions[ownProps.action && ownProps.action.id] : undefined;

    return {
        selected,
    };
}

const mapDispatchToProps = {
    selectAttachmentMenuAction,
    autocompleteChannels,
    autocompleteUsers,
};

const connector = connect(mapStateToProps, mapDispatchToProps);

export type PropsFromRedux = ConnectedProps<typeof connector>;

export default connector(ActionMenu);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/* eslint-disable react/no-string-refs */

import React, {CSSProperties} from 'react';
import truncate from 'lodash/truncate';

import {ActionResult} from 'mattermost-redux/types/actions';
import {PostAction, PostActionOption} from '@mattermost/types/integration_actions';
import {
    MessageAttachment as MessageAttachmentType,
    MessageAttachmentField,
} from '@mattermost/types/message_attachments';
import {PostImage} from '@mattermost/types/posts';

import {isUrlSafe} from 'utils/url';
import {Constants, ModalIdentifiers} from 'utils/constants';
import * as Utils from 'utils/utils';
import LinkOnlyRenderer from 'utils/markdown/link_only_renderer';
import {TextFormattingOptions} from 'utils/text_formatting';

import ExternalImage from 'components/external_image';
import Markdown from 'components/markdown';
import ShowMore from 'components/post_view/show_more';
import SizeAwareImage from 'components/size_aware_image';

import ActionButton from '../action_button';
import ActionMenu from '../action_menu';

import {trackEvent} from 'actions/telemetry_actions';
import FilePreviewModal from '../../../file_preview_modal';
import {ModalData} from 'types/actions';

type Props = {

    /**
     * The post id
     */
    postId: string;

    /**
     * The attachment to render
     */
    attachment: MessageAttachmentType;

    /**
     * Options specific to text formatting
     */
    options?: Partial<TextFormattingOptions>;

    /**
     * images object for dimensions
     */
    imagesMetadata?: Record<string, PostImage>;

    actions: {
        doPostActionWithCookie: (postId: string, actionId: string, actionCookie: string, selectedOption?: string) => Promise<ActionResult>;
        openModal: <P>(modalData: ModalData<P>) => void;
    };

    currentRelativeTeamUrl: string;
}

type State = {
    checkOverflow: number;
    actionExecuting: boolean;
    actionExecutingMessage: string | null;
}

export default class MessageAttachment extends React.PureComponent<Props, State> {
    private mounted = false;
    private imageProps = {};

    constructor(props: Props) {
        super(props);

        this.state = {
            checkOverflow: 0,
            actionExecuting: false,
            actionExecutingMessage: null,
        };

        this.imageProps = {
            onImageLoaded: this.handleHeightReceived,
            onImageHeightChanged: this.checkPostOverflow,
        };
    }

    componentDidMount() {
        this.mounted = true;
    }

    componentWillUnmount() {
        this.mounted = false;
    }

    handleHeightReceivedForThumbUrl = ({height}: {height: number}) => {
        const {attachment} = this.props;
        if (!this.props.imagesMetadata || (this.props.imagesMetadata && !this.props.imagesMetadata[attachment.thumb_url])) {
            this.handleHeightReceived(height);
        }
    }

    handleHeightReceivedForImageUrl = ({height}: {height: number}) => {
        const {attachment} = this.props;
        if (!this.props.imagesMetadata || (this.props.imagesMetadata && !this.props.imagesMetadata[attachment.image_url])) {
            this.handleHeightReceived(height);
        }
    }

    handleHeightReceived = (height: number) => {
        if (!this.mounted) {
            return;
        }

        if (height > 0) {
            this.checkPostOverflow();
        }
    };

    checkPostOverflow = () => {
        // Increment checkOverflow to indicate change in height
        // and recompute textContainer height at ShowMore component
        // and see whether overflow text of show more/less is necessary or not.
        this.setState((prevState) => {
            return {checkOverflow: prevState.checkOverflow + 1};
        });
    }

    renderPostActions = () => {
        const actions = this.props.attachment.actions;
        if (!actions || !actions.length) {
            return '';
        }

        const content = [] as JSX.Element[];

        actions.forEach((action: PostAction) => {
            if (!action.id || !action.name) {
                return;
            }

            switch (action.type) {
            case 'select':
                content.push(
                    <ActionMenu
                        key={action.id}
                        postId={this.props.postId}
                        action={action}
                        disabled={action.disabled}
                    />,
                );
                break;
            case 'button':
            default:
                content.push(
                    <ActionButton
                        key={action.id}
                        action={action}
                        disabled={action.disabled}
                        handleAction={this.handleAction}
                        actionExecuting={this.state.actionExecuting}
                        actionExecutingMessage={this.state.actionExecutingMessage || undefined}
                    />,
                );
                break;
            }
        });

        return (
            <div
                className='attachment-actions'
            >
                {content}
            </div>
        );
    };

    handleAction = (e: React.MouseEvent, actionOptions?: PostActionOption[]) => {
        e.preventDefault();

        const actionExecutingMessage = this.getActionOption(actionOptions, 'ActionExecutingMessage');
        if (actionExecutingMessage) {
            this.setState({actionExecuting: true, actionExecutingMessage: actionExecutingMessage.value});
        }

        const trackOption = this.getActionOption(actionOptions, 'TrackEventId');
        if (trackOption) {
            trackEvent('admin', 'click_warn_metric_bot_id', {metric: trackOption.value});
        }

        const actionId = e.currentTarget.getAttribute('data-action-id') || '';
        const actionCookie = e.currentTarget.getAttribute('data-action-cookie') || '';

        this.props.actions.doPostActionWithCookie(this.props.postId, actionId, actionCookie).then(() => {
            this.handleCustomActions(actionOptions);
            if (actionExecutingMessage) {
                this.setState({actionExecuting: false, actionExecutingMessage: null});
            }
        });
    };

    handleCustomActions = (actionOptions?: PostActionOption[]) => {
        const extUrlOption = this.getActionOption(actionOptions, 'WarnMetricMailtoUrl');
        if (extUrlOption) {
            const mailtoPayload = JSON.parse(extUrlOption.value);
            window.location.href = 'mailto:' + mailtoPayload.mail_recipient + '?cc=' + mailtoPayload.mail_cc + '&subject=' + encodeURIComponent(mailtoPayload.mail_subject) + '&body=' + encodeURIComponent(mailtoPayload.mail_body);
        }
    }

    getActionOption = (actionOptions: PostActionOption[] | undefined, optionName: string) => {
        let opt = null;
        if (actionOptions) {
            opt = actionOptions.find((option) => option.text === optionName);
        }
        return opt;
    }

    getFieldsTable = () => {
        const fields = this.props.attachment.fields;
        if (!fields || !fields.length) {
            return '';
        }

        const fieldTables = [];

        let headerCols = [] as JSX.Element[];
        let bodyCols = [] as JSX.Element[];
        let rowPos = 0;
        let lastWasLong = false;
        let nrTables = 0;
        const markdown = {markdown: false, mentionHighlight: false};

        fields.forEach((field: MessageAttachmentField, i: number) => {
            if (rowPos === 2 || !(field.short === true) || lastWasLong) {
                fieldTables.push(
                    <table
                        className='attachment-fields'
                        key={'attachment__table__' + nrTables}
                    >
                        <thead>
                            <tr>
                                {headerCols}
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                {bodyCols}
                            </tr>
                        </tbody>
                    </table>,
                );
                headerCols = [];
                bodyCols = [];
                rowPos = 0;
                nrTables += 1;
                lastWasLong = false;
            }
            headerCols.push(
                <th
                    className='attachment-field__caption'
                    key={'attachment__field-caption-' + i + '__' + nrTables}
                >
                    <Markdown
                        message={field.title}
                        options={markdown}
                        postId={this.props.postId}
                    />
                </th>,
            );

            bodyCols.push(
                <td
                    className='attachment-field'
                    key={'attachment__field-' + i + '__' + nrTables}
                >
                    <Markdown
                        message={String(field.value)}
                        postId={this.props.postId}
                    />
                </td>,
            );
            rowPos += 1;
            lastWasLong = !(field.short === true);
        });
        if (headerCols.length > 0) { // Flush last fields
            fieldTables.push(
                <table
                    className='attachment-fields'
                    key={'attachment__table__' + nrTables}
                >
                    <thead>
                        <tr>
                            {headerCols}
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            {bodyCols}
                        </tr>
                    </tbody>
                </table>,
            );
        }
        return (
            <div>
                {fieldTables}
            </div>
        );
    };

    handleFormattedTextClick = (e: React.MouseEvent) => Utils.handleFormattedTextClick(e, this.props.currentRelativeTeamUrl);

    getFileExtensionFromUrl = (url: string) => {
        const index = url.lastIndexOf('.');
        return index > 0 ? url.substring(index + 1) : null;
    };

    showModal = (e: {preventDefault: () => void}, link: string) => {
        e.preventDefault();

        const extension = this.getFileExtensionFromUrl(link);

        this.props.actions.openModal({
            modalId: ModalIdentifiers.FILE_PREVIEW_MODAL,
            dialogType: FilePreviewModal,
            dialogProps: {
                postId: this.props.postId,
                fileInfos: [{
                    has_preview_image: false,
                    link,
                    extension: extension ?? '',
                    name: link,
                }],
                startIndex: 0,
            },
        });
    }

    render() {
        const {attachment, options} = this.props;
        let preTextClass = '';

        let preText;
        if (attachment.pretext) {
            preTextClass = 'attachment--pretext';
            preText = (
                <div className='attachment__thumb-pretext'>
                    <Markdown
                        message={attachment.pretext}
                        postId={this.props.postId}
                    />
                </div>
            );
        }

        let author = [] as JSX.Element[];
        if (attachment.author_name || attachment.author_icon) {
            if (attachment.author_icon) {
                author.push(
                    <ExternalImage
                        key={'attachment__author-icon'}
                        src={attachment.author_icon}
                        imageMetadata={this.props.imagesMetadata && this.props.imagesMetadata[attachment.author_icon]}
                    >
                        {(iconUrl) => (
                            <img
                                alt={'attachment author icon'}
                                className='attachment__author-icon'
                                src={iconUrl}
                                height='14'
                                width='14'
                            />
                        )}
                    </ExternalImage>,
                );
            }
            if (attachment.author_name) {
                author.push(
                    <span
                        className='attachment__author-name'
                        key={'attachment__author-name'}
                    >
                        {attachment.author_name}
                    </span>,
                );
            }
        }
        if (attachment.author_link && isUrlSafe(attachment.author_link)) {
            author = [(
                <a
                    href={attachment.author_link}
                    target='_blank'
                    rel='noopener noreferrer'
                    key={'attachment__author-name'}
                >
                    {author}
                </a>
            )];
        }

        let title;
        if (attachment.title) {
            if (attachment.title_link && isUrlSafe(attachment.title_link)) {
                title = (
                    <h1 className='attachment__title'>
                        <a
                            className='attachment__title-link'
                            href={attachment.title_link}
                            target='_blank'
                            rel='noopener noreferrer'
                        >
                            {attachment.title}
                        </a>
                    </h1>
                );
            } else {
                title = (
                    <h1 className='attachment__title'>
                        <Markdown
                            message={attachment.title}
                            options={{
                                mentionHighlight: false,
                                renderer: new LinkOnlyRenderer(),
                                autolinkedUrlSchemes: [],
                            }}
                            postId={this.props.postId}
                        />
                    </h1>
                );
            }
        }

        let attachmentText;
        if (attachment.text) {
            attachmentText = (
                <ShowMore
                    checkOverflow={this.state.checkOverflow}
                    isAttachmentText={true}
                    text={attachment.text}
                    maxHeight={200}
                >
                    <Markdown
                        message={attachment.text || ''}
                        options={options}
                        postId={this.props.postId}
                        imageProps={this.imageProps}
                    />
                </ShowMore>
            );
        }

        let image;
        if (attachment.image_url) {
            const imageMetadata = this.props.imagesMetadata && this.props.imagesMetadata[attachment.image_url];

            image = (
                <div className='attachment__image-container'>
                    <ExternalImage
                        src={attachment.image_url}
                        imageMetadata={imageMetadata}
                    >
                        {(imageUrl) => (
                            <SizeAwareImage
                                className='attachment__image'
                                onImageLoaded={this.handleHeightReceivedForImageUrl}
                                src={imageUrl}
                                dimensions={imageMetadata}
                                onClick={this.showModal}
                            />
                        )}
                    </ExternalImage>
                </div>
            );
        }

        let footer;
        if (attachment.footer) {
            let footerIcon;
            if (attachment.footer_icon) {
                const footerIconMetadata = this.props.imagesMetadata && this.props.imagesMetadata[attachment.footer_icon];

                footerIcon = (
                    <ExternalImage
                        src={attachment.footer_icon}
                        imageMetadata={footerIconMetadata}
                    >
                        {(footerIconUrl) => (
                            <img
                                alt={'attachment footer icon'}
                                className='attachment__footer-icon'
                                src={footerIconUrl}
                                height='16'
                                width='16'
                            />
                        )}
                    </ExternalImage>
                );
            }

            footer = (
                <div className='attachment__footer-container'>
                    {footerIcon}
                    <span>{truncate(attachment.footer, {length: Constants.MAX_ATTACHMENT_FOOTER_LENGTH, omission: ''})}</span>
                </div>
            );
        }

        let thumb;
        if (attachment.thumb_url) {
            const thumbMetadata = this.props.imagesMetadata && this.props.imagesMetadata[attachment.thumb_url];

            thumb = (
                <div className='attachment__thumb-container'>
                    <ExternalImage
                        src={attachment.thumb_url}
                        imageMetadata={thumbMetadata}
                    >
                        {(thumbUrl) => (
                            <SizeAwareImage
                                onImageLoaded={this.handleHeightReceivedForThumbUrl}
                                src={thumbUrl}
                                dimensions={thumbMetadata}
                            />
                        )}
                    </ExternalImage>
                </div>
            );
        }

        const fields = this.getFieldsTable();
        const actions = this.renderPostActions();

        let useBorderStyle;
        if (attachment.color && attachment.color[0] === '#') {
            useBorderStyle = {borderLeftColor: attachment.color};
        }

        return (
            <div
                className={'attachment ' + preTextClass}
                onClick={this.handleFormattedTextClick}
            >
                {preText}
                <div className='attachment__content'>
                    <div
                        className={useBorderStyle ? 'clearfix attachment__container' : 'clearfix attachment__container attachment__container--' + attachment.color}
                        style={useBorderStyle}
                    >
                        {author}
                        {title}
                        <div>
                            <div
                                className={thumb ? 'attachment__body' : 'attachment__body attachment__body--no_thumb'}
                            >
                                {attachmentText}
                                {image}
                                {fields}
                                {footer}
                                {actions}
                            </div>
                            {thumb}
                            <div style={style.footer}/>
                        </div>
                    </div>
                </div>
            </div>
        );
    }
}

const style = {
    footer: {clear: 'both'} as CSSProperties,
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {doPostActionWithCookie} from 'mattermost-redux/actions/posts';
import {getCurrentRelativeTeamUrl} from 'mattermost-redux/selectors/entities/teams';
import {GlobalState} from '@mattermost/types/store';
import {ActionFunc, ActionResult, GenericAction} from 'mattermost-redux/types/actions';

import {openModal} from 'actions/views/modals';
import {ModalData} from 'types/actions';

import MessageAttachment from './message_attachment';

function mapStateToProps(state: GlobalState) {
    return {
        currentRelativeTeamUrl: getCurrentRelativeTeamUrl(state),
    };
}

type Actions = {
    doPostActionWithCookie: (postId: string, actionId: string, actionCookie: string, selectedOption?: string | undefined) => Promise<ActionResult>;
    openModal: <P>(modalData: ModalData<P>) => void;
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc | GenericAction>, Actions>({
            doPostActionWithCookie, openModal,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(MessageAttachment);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {MessageAttachment as MessageAttachmentType} from '@mattermost/types/message_attachments';
import {PostImage} from '@mattermost/types/posts';

import {TextFormattingOptions} from 'utils/text_formatting';

import MessageAttachment from './message_attachment';

type Props = {

    /**
     * The post id
     */
    postId: string;

    /**
     * Array of attachments to render
     */
    attachments: MessageAttachmentType[];

    /**
     * Options specific to text formatting
     */
    options?: Partial<TextFormattingOptions>;

    /**
     * Images object used for creating placeholders to prevent scroll popup
     */
    imagesMetadata?: Record<string, PostImage>;
}

export default class MessageAttachmentList extends React.PureComponent<Props> {
    static defaultProps = {
        imagesMetadata: {},
    }

    render() {
        const content = [] as JSX.Element[];
        this.props.attachments.forEach((attachment, i) => {
            content.push(
                <MessageAttachment
                    attachment={attachment}
                    postId={this.props.postId}
                    key={'att_' + i}
                    options={this.props.options}
                    imagesMetadata={this.props.imagesMetadata}
                />,
            );
        });

        return (
            <div
                id={`messageAttachmentList_${this.props.postId}`}
                className='attachment__list'
            >
                {content}
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {Post, PostImage as PostImageMetadata} from '@mattermost/types/posts';

import {ModalData} from 'types/actions';

import {ModalIdentifiers} from 'utils/constants';

import ExternalImage from 'components/external_image';
import SizeAwareImage from 'components/size_aware_image';
import FilePreviewModal from 'components/file_preview_modal';

interface Props {
    imageMetadata: PostImageMetadata;
    link: string;
    post: Post;
    actions: {
        openModal: <P>(modalData: ModalData<P>) => void;
    };
}

export default class PostImage extends React.PureComponent<Props> {
    showModal = (e: React.MouseEvent, link: string) => {
        e.preventDefault();

        this.props.actions.openModal({
            modalId: ModalIdentifiers.FILE_PREVIEW_MODAL,
            dialogType: FilePreviewModal,
            dialogProps: {
                post: this.props.post,
                startIndex: 0,
                fileInfos: [{
                    has_preview_image: false,
                    link,
                    extension: this.props.imageMetadata.format,
                    name: this.props.link,
                }],
            },
        });
    }

    render() {
        return (
            <div className='post__embed-container'>
                <ExternalImage
                    src={this.props.link}
                    imageMetadata={this.props.imageMetadata}
                >
                    {(safeLink) => (
                        <React.Fragment>
                            <SizeAwareImage
                                className='img-div attachment__image cursor--pointer'
                                src={safeLink}
                                dimensions={this.props.imageMetadata}
                                showLoader={true}
                                onClick={this.showModal}
                            />
                        </React.Fragment>
                    )}
                </ExternalImage>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {openModal} from 'actions/views/modals';

import PostImage from './post_image';

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators({
            openModal,
        }, dispatch),
    };
}

const connector = connect(null, mapDispatchToProps);

export default connector(PostImage);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

export const ytRegex = /(?:http|https):\/\/(?:www\.|m\.)?(?:(?:youtube\.com\/(?:(?:v\/)|(?:(?:watch|embed\/watch)(?:\/|.*v=))|(?:embed\/)|(?:user\/[^/]+\/u\/[0-9]\/)))|(?:youtu\.be\/))([^#&?]*)/;

export function handleYoutubeTime(link: string) {
    const timeRegex = /[\\?&](t|time|start|time_continue)=([0-9]+h)?([0-9]+m)?([0-9]+s?)/;

    const time = link.match(timeRegex);
    if (!time?.[0]) {
        return '';
    }

    const hours = time[2]?.match(/([0-9]+)h/) ?? null;
    const minutes = time[3]?.match(/([0-9]+)m/) ?? null;
    const seconds = time[4]?.match(/([0-9]+)s?/) ?? null;

    let startSeconds = 0;

    if (hours?.[1]) {
        startSeconds += parseInt(hours[1], 10) * 3600;
    }

    if (minutes?.[1]) {
        startSeconds += parseInt(minutes[1], 10) * 60;
    }

    if (seconds?.[1]) {
        startSeconds += parseInt(seconds[1], 10);
    }

    return `&start=${startSeconds}`;
}

export function getVideoId(link: string) {
    const match = link.trim().match(ytRegex);
    if (!match || match[1].length !== 11) {
        return null;
    }

    return match[1];
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {getVideoId, ytRegex, handleYoutubeTime} from 'utils/youtube';

import ExternalImage from 'components/external_image';
import {OpenGraphMetadata} from '@mattermost/types/posts';

type Props = {
    postId: string;
    link: string;
    show: boolean;
    metadata?: OpenGraphMetadata;
}

type State = {
    playing: boolean;
}

export default class YoutubeVideo extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            playing: false,
        };
    }

    static getDerivedStateFromProps(props: Props, state: State): State | null {
        if (!props.show && state.playing) {
            return {playing: false};
        }
        return null;
    }

    play = () => {
        this.setState({playing: true});
    }

    stop = () => {
        this.setState({playing: false});
    }

    render() {
        const {metadata, link} = this.props;

        const videoId = getVideoId(link);
        const time = handleYoutubeTime(link);

        const header = (
            <h4>
                <span className='video-type'>{'YouTube - '}</span>
                <span className='video-title'>
                    <a
                        href={this.props.link}
                        target='blank'
                        rel='noopener noreferrer'
                    >
                        {metadata?.title || 'unknown'}
                    </a>
                </span>
            </h4>
        );

        let content;

        if (this.state.playing) {
            content = (
                <iframe
                    src={'https://www.youtube.com/embed/' + videoId + '?autoplay=1&autohide=1&border=0&wmode=opaque&fs=1&enablejsapi=1' + time}
                    width='480px'
                    height='360px'
                    frameBorder='0'
                    allowFullScreen={true}
                />
            );
        } else {
            const image = metadata?.images[0];

            content = (
                <div className='embed-responsive video-div__placeholder'>
                    <div className='video-thumbnail__container'>
                        <ExternalImage src={image?.secure_url || image?.url || ''}>
                            {(safeUrl) => (
                                <img
                                    src={safeUrl}
                                    alt='youtube video thumbnail'
                                    className='video-thumbnail'
                                />
                            )}
                        </ExternalImage>
                        <div className='block'>
                            <span className='play-button'><span/></span>
                        </div>
                    </div>
                </div>
            );
        }

        return (
            <div
                className='post__embed-container'
            >
                <div>
                    {header}
                    <div
                        className='video-div embed-responsive-item'
                        onClick={this.play}
                    >
                        {content}
                    </div>
                </div>
            </div>
        );
    }

    public static isYoutubeLink(link: string): boolean {
        return Boolean(link.trim().match(ytRegex));
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getCurrentChannelId} from 'mattermost-redux/selectors/entities/channels';
import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getOpenGraphMetadataForUrl} from 'mattermost-redux/selectors/entities/posts';

import {GlobalState} from 'types/store';

import YoutubeVideo from './youtube_video';

type OwnProps = {
    postId: string;
    link: string;
}

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const config = getConfig(state);

    return {
        currentChannelId: getCurrentChannelId(state),
        googleDeveloperKey: config.GoogleDeveloperKey,
        hasImageProxy: config.HasImageProxy === 'true',
        metadata: getOpenGraphMetadataForUrl(state, ownProps.postId, ownProps.link),
    };
}

export default connect(mapStateToProps)(YoutubeVideo);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {injectIntl, IntlShape} from 'react-intl';

import {AppBinding} from '@mattermost/types/apps';
import {ActionResult} from 'mattermost-redux/types/actions';
import {AppBindingLocations, AppCallResponseTypes} from 'mattermost-redux/constants/apps';
import {Channel} from '@mattermost/types/channels';
import {Post} from '@mattermost/types/posts';

import {PostEphemeralCallResponseForPost, HandleBindingClick, OpenAppsModal} from 'types/apps';

import Markdown from 'components/markdown';
import LoadingWrapper from 'components/widgets/loading/loading_wrapper';
import {createCallContext} from 'utils/apps';

type Props = {
    intl: IntlShape;
    binding: AppBinding;
    post: Post;
    actions: {
        handleBindingClick: HandleBindingClick;
        getChannel: (channelId: string) => Promise<ActionResult>;
        postEphemeralCallResponseForPost: PostEphemeralCallResponseForPost;
        openAppsModal: OpenAppsModal;
    };
}

type State = {
    executing: boolean;
}

export class ButtonBinding extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);
        this.state = {
            executing: false,
        };
    }

    handleClick = async () => {
        const {binding, post, intl} = this.props;

        let teamID = '';
        const {data} = await this.props.actions.getChannel(post.channel_id) as {data?: any; error?: any};
        if (data) {
            const channel = data as Channel;
            teamID = channel.team_id;
        }

        const context = createCallContext(
            binding.app_id,
            AppBindingLocations.IN_POST + '/' + binding.location,
            post.channel_id,
            teamID,
            post.id,
            post.root_id,
        );

        this.setState({executing: true});
        const res = await this.props.actions.handleBindingClick(binding, context, intl);
        this.setState({executing: false});

        if (res.error) {
            const errorResponse = res.error;
            const errorMessage = errorResponse.text || intl.formatMessage({
                id: 'apps.error.unknown',
                defaultMessage: 'Unknown error occurred.',
            });
            this.props.actions.postEphemeralCallResponseForPost(errorResponse, errorMessage, post);
            return;
        }

        const callResp = res.data!;
        switch (callResp.type) {
        case AppCallResponseTypes.OK:
            if (callResp.text) {
                this.props.actions.postEphemeralCallResponseForPost(callResp, callResp.text, post);
            }
            break;
        case AppCallResponseTypes.NAVIGATE:
            // already handled
            break;
        case AppCallResponseTypes.FORM:
            if (callResp.form) {
                this.props.actions.openAppsModal(callResp.form, context);
            }
            break;
        default: {
            const errorMessage = intl.formatMessage({
                id: 'apps.error.responses.unknown_type',
                defaultMessage: 'App response type not supported. Response type: {type}.',
            }, {
                type: callResp.type,
            });
            this.props.actions.postEphemeralCallResponseForPost(callResp, errorMessage, post);
        }
        }
    }

    render() {
        const {binding} = this.props;
        let customButtonStyle;

        if (!binding.submit && !binding.form?.submit && !binding.form?.source) {
            return null;
        }

        const label = binding.label || binding.location;
        if (!label) {
            return null;
        }

        return (
            <button
                onClick={this.handleClick}
                style={customButtonStyle}
            >
                <LoadingWrapper
                    loading={this.state.executing}
                >
                    <Markdown
                        message={label}
                        options={{
                            mentionHighlight: false,
                            markdown: false,
                            autolinkedUrlSchemes: [],
                        }}
                    />
                </LoadingWrapper>
            </button>
        );
    }
}

export default injectIntl(ButtonBinding);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {ActionResult, GenericAction} from 'mattermost-redux/types/actions';

import {getChannel} from 'mattermost-redux/actions/channels';

import {PostEphemeralCallResponseForPost, HandleBindingClick, OpenAppsModal} from 'types/apps';

import {postEphemeralCallResponseForPost, handleBindingClick, openAppsModal} from 'actions/apps';

import ButtonBinding from './button_binding';

type Actions = {
    handleBindingClick: HandleBindingClick;
    getChannel: (channelId: string) => Promise<ActionResult>;
    postEphemeralCallResponseForPost: PostEphemeralCallResponseForPost;
    openAppsModal: OpenAppsModal;
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<any>, Actions>({
            handleBindingClick,
            getChannel,
            postEphemeralCallResponseForPost,
            openAppsModal,
        }, dispatch),
    };
}

export default connect(null, mapDispatchToProps)(ButtonBinding);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {injectIntl, IntlShape} from 'react-intl';

import {ActionResult} from 'mattermost-redux/types/actions';

import {Post} from '@mattermost/types/posts';

import {AppBinding} from '@mattermost/types/apps';
import {Channel} from '@mattermost/types/channels';

import {AppBindingLocations, AppCallResponseTypes} from 'mattermost-redux/constants/apps';

import {HandleBindingClick, OpenAppsModal, PostEphemeralCallResponseForPost} from 'types/apps';

import MenuActionProvider from 'components/suggestion/menu_action_provider';
import AutocompleteSelector from 'components/autocomplete_selector';
import PostContext from 'components/post_view/post_context';
import {createCallContext} from 'utils/apps';

type Option = {
    text: string;
    value: string;
};

type Props = {
    intl: IntlShape;
    post: Post;
    binding: AppBinding;
    actions: {
        handleBindingClick: HandleBindingClick;
        getChannel: (channelId: string) => Promise<ActionResult>;
        postEphemeralCallResponseForPost: PostEphemeralCallResponseForPost;
        openAppsModal: OpenAppsModal;
    };
};

type State = {
    selected?: Option;
};

class SelectBinding extends React.PureComponent<Props, State> {
    private providers: MenuActionProvider[];
    private nOptions = 0;
    constructor(props: Props) {
        super(props);

        const binding = props.binding;
        this.providers = [];
        if (binding.bindings) {
            const options: Array<{text: string; value: string}> = [];
            const usedLabels: {[label: string]: boolean} = {};
            const usedValues: {[label: string]: boolean} = {};
            binding.bindings.forEach((b) => {
                const label = b.label || b.location;
                if (!label) {
                    return;
                }

                if (!b.location) {
                    return;
                }

                if (usedLabels[label]) {
                    return;
                }

                if (usedValues[b.location]) {
                    return;
                }

                usedLabels[label] = true;
                usedValues[b.location] = true;

                options.push({text: label, value: b.location});
            });

            this.nOptions = options.length;
            this.providers = [new MenuActionProvider(options)];
        }

        this.state = {};
    }

    handleSelected = async (selected: Option) => {
        if (!selected) {
            return;
        }

        this.setState({selected});
        const binding = this.props.binding.bindings?.find((b) => b.location === selected.value);
        if (!binding) {
            console.debug('Trying to select element not present in binding.'); //eslint-disable-line no-console
            return;
        }

        const {post, intl} = this.props;

        let teamID = '';
        const {data} = await this.props.actions.getChannel(post.channel_id) as {data?: any; error?: any};
        if (data) {
            const channel = data as Channel;
            teamID = channel.team_id;
        }

        const context = createCallContext(
            binding.app_id,
            AppBindingLocations.IN_POST + '/' + binding.location,
            post.channel_id,
            teamID,
            post.id,
            post.root_id,
        );

        const res = await this.props.actions.handleBindingClick(binding, context, intl);

        if (res.error) {
            const errorResponse = res.error;
            const errorMessage = errorResponse.text || intl.formatMessage({
                id: 'apps.error.unknown',
                defaultMessage: 'Unknown error occurred.',
            });
            this.props.actions.postEphemeralCallResponseForPost(errorResponse, errorMessage, post);
            return;
        }

        const callResp = res.data!;
        switch (callResp.type) {
        case AppCallResponseTypes.OK:
            if (callResp.text) {
                this.props.actions.postEphemeralCallResponseForPost(callResp, callResp.text, post);
            }
            break;
        case AppCallResponseTypes.NAVIGATE:
            break;
        case AppCallResponseTypes.FORM:
            if (callResp.form) {
                this.props.actions.openAppsModal(callResp.form, context);
            }
            break;
        default: {
            const errorMessage = this.props.intl.formatMessage({
                id: 'apps.error.responses.unknown_type',
                defaultMessage: 'App response type not supported. Response type: {type}.',
            }, {
                type: callResp.type,
            });
            this.props.actions.postEphemeralCallResponseForPost(callResp, errorMessage, post);
        }
        }
    }

    render() {
        if (!this.nOptions) {
            return null;
        }

        const {binding} = this.props;
        const label = binding.label || binding.location;
        if (!label) {
            return null;
        }

        return (
            <PostContext.Consumer>
                {({handlePopupOpened}) => (
                    <AutocompleteSelector
                        providers={this.providers}
                        onSelected={this.handleSelected}
                        placeholder={label}
                        inputClassName='post-attachment-dropdown'
                        value={this.state.selected?.text}
                        toggleFocus={handlePopupOpened}
                    />
                )}
            </PostContext.Consumer>
        );
    }
}

export {SelectBinding as RawSelectBinding};

export default injectIntl(SelectBinding);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {ActionResult, GenericAction} from 'mattermost-redux/types/actions';

import {getChannel} from 'mattermost-redux/actions/channels';

import {PostEphemeralCallResponseForPost, HandleBindingClick, OpenAppsModal} from 'types/apps';

import {postEphemeralCallResponseForPost, handleBindingClick, openAppsModal} from 'actions/apps';

import SelectBinding from './select_binding';

type Actions = {
    handleBindingClick: HandleBindingClick;
    getChannel: (channelId: string) => Promise<ActionResult>;
    postEphemeralCallResponseForPost: PostEphemeralCallResponseForPost;
    openAppsModal: OpenAppsModal;
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<any>, Actions>({
            handleBindingClick,
            getChannel,
            postEphemeralCallResponseForPost,
            openAppsModal,
        }, dispatch),
    };
}

export default connect(null, mapDispatchToProps)(SelectBinding);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/* eslint-disable react/no-string-refs */

import React, {CSSProperties} from 'react';

import {AppBinding} from '@mattermost/types/apps';

import {Post} from '@mattermost/types/posts';

import * as Utils from 'utils/utils';
import LinkOnlyRenderer from 'utils/markdown/link_only_renderer';
import {TextFormattingOptions} from 'utils/text_formatting';

import Markdown from 'components/markdown';
import ShowMore from 'components/post_view/show_more';

import ButtonBinding from '../button_binding';
import SelectBinding from '../select_binding';

import {cleanBinding} from 'mattermost-redux/utils/apps';
import {AppBindingLocations} from 'mattermost-redux/constants/apps';

type Props = {

    /**
     * The post id
     */
    post: Post;

    /**
     * The attachment to render
     */
    embed: AppBinding;

    /**
     * Options specific to text formatting
     */
    options?: Partial<TextFormattingOptions>;

    currentRelativeTeamUrl: string;
}

type State = {
    checkOverflow: number;
    embed: AppBinding;
    bindings: AppBinding[];
}

export default class EmbeddedBinding extends React.PureComponent<Props, State> {
    private imageProps: Record<string, any>;
    constructor(props: Props) {
        super(props);

        const state: State = {
            checkOverflow: 0,
            embed: props.embed,
            bindings: [],
        };

        if (props.embed.app_id && props.embed.bindings) {
            state.bindings = EmbeddedBinding.fillBindings(props.embed);
        }

        this.state = state;

        this.imageProps = {
            onImageLoaded: this.handleHeightReceived,
            onImageHeightChanged: this.checkPostOverflow,
        };
    }

    static getDerivedStateFromProps(props: Props, prevState: State) {
        if (props.embed !== prevState.embed) {
            return {
                embed: props.embed,
                bindings: EmbeddedBinding.fillBindings(props.embed),
            };
        }

        return null;
    }

    static fillBindings = (binding: AppBinding): AppBinding[] => {
        const copiedBindings = JSON.parse(JSON.stringify(binding)) as AppBinding;
        cleanBinding(copiedBindings, AppBindingLocations.IN_POST);
        return copiedBindings.bindings!;
    }

    renderBindings = () => {
        if (!this.props.embed.app_id) {
            return null;
        }

        if (!this.props.embed.bindings) {
            return null;
        }

        const bindings = this.state.bindings;
        if (!bindings || !bindings.length) {
            return null;
        }

        const content = [] as JSX.Element[];

        bindings.forEach((binding: AppBinding) => {
            if (binding.bindings && binding.bindings.length > 0) {
                content.push(
                    <SelectBinding
                        key={binding.location}
                        post={this.props.post}
                        binding={binding}
                    />,
                );
                return;
            }

            content.push(
                <ButtonBinding
                    key={binding.location}
                    post={this.props.post}
                    binding={binding}
                />,
            );
        });

        return (
            <div
                className='attachment-actions'
            >
                {content}
            </div>
        );
    };

    handleFormattedTextClick = (e: React.MouseEvent) => Utils.handleFormattedTextClick(e, this.props.currentRelativeTeamUrl);

    checkPostOverflow = () => {
        // Increment checkOverflow to indicate change in height
        // and recompute textContainer height at ShowMore component
        // and see whether overflow text of show more/less is necessary or not.
        this.setState((prevState) => {
            return {checkOverflow: prevState.checkOverflow + 1};
        });
    }

    handleHeightReceived = (height: number) => {
        if (height > 0) {
            this.checkPostOverflow();
        }
    };

    render() {
        const {embed, options} = this.props;

        let title;
        if (embed.label) {
            title = (
                <h1 className='attachment__title'>
                    <Markdown
                        message={embed.label}
                        options={{
                            mentionHighlight: false,
                            renderer: new LinkOnlyRenderer(),
                            autolinkedUrlSchemes: [],
                        }}
                        postId={this.props.post.id}
                    />
                </h1>
            );
        }

        let attachmentText;
        if (embed.description) {
            attachmentText = (
                <ShowMore
                    isAttachmentText={true}
                    text={embed.description}
                    maxHeight={200}
                >
                    <Markdown
                        message={embed.description}
                        imageProps={this.imageProps}
                        options={options}
                        postId={this.props.post.id}
                    />
                </ShowMore>
            );
        }

        const bindings = this.renderBindings();

        return (
            <div
                className={'attachment'}
                onClick={this.handleFormattedTextClick}
            >
                <div className='attachment__content'>
                    <div
                        className={'clearfix attachment__container attachment__container--'}
                    >
                        {title}
                        <div>
                            <div
                                className={'attachment__body attachment__body--no_thumb'}
                            >
                                {attachmentText}
                                {bindings}
                            </div>
                            <div style={style.footer}/>
                        </div>
                    </div>
                </div>
            </div>
        );
    }
}

const style = {
    footer: {clear: 'both'} as CSSProperties,
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getCurrentRelativeTeamUrl} from 'mattermost-redux/selectors/entities/teams';
import {GlobalState} from '@mattermost/types/store';

import EmbeddedBinding from './embedded_binding';

function mapStateToProps(state: GlobalState) {
    return {
        currentRelativeTeamUrl: getCurrentRelativeTeamUrl(state),
    };
}

export default connect(mapStateToProps)(EmbeddedBinding);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {Post} from '@mattermost/types/posts';

import {AppBinding} from '@mattermost/types/apps';

import {TextFormattingOptions} from 'utils/text_formatting';

import EmbeddedBinding from './embedded_binding';

type Props = {

    /**
     * The post id
     */
    post: Post;

    /**
     * Array of attachments to render
     */
    embeds: AppBinding[]; // Type App Embed Wrapper

    /**
     * Options specific to text formatting
     */
    options?: Partial<TextFormattingOptions>;

}

export default class EmbeddedBindings extends React.PureComponent<Props> {
    static defaultProps = {
        imagesMetadata: {},
    }

    render() {
        const content = [] as JSX.Element[];
        this.props.embeds.forEach((embed, i) => {
            content.push(
                <EmbeddedBinding
                    embed={embed}
                    post={this.props.post}
                    key={'att_' + i}
                    options={this.props.options}
                />,
            );
        });

        return (
            <div
                id={`messageAttachmentList_${this.props.post.id}`}
                className='attachment__list'
            >
                {content}
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {Post, PostEmbed} from '@mattermost/types/posts';

import {getEmbedFromMetadata} from 'mattermost-redux/utils/post_utils';
import {AppBinding} from '@mattermost/types/apps';

import MessageAttachmentList from 'components/post_view/message_attachments/message_attachment_list';
import PostAttachmentOpenGraph from 'components/post_view/post_attachment_opengraph';
import PostImage from 'components/post_view/post_image';
import YoutubeVideo from 'components/youtube_video';

import {PostWillRenderEmbedPluginComponent} from 'types/store/plugins';
import EmbeddedBindings from '../embedded_bindings/embedded_bindings';
import {TextFormattingOptions} from 'utils/text_formatting';
import PostMessagePreview from 'components/post_view/post_message_preview';

import webSocketClient from 'client/web_websocket_client.jsx';

export type Props = {
    post: Post;
    pluginPostWillRenderEmbedComponents?: PostWillRenderEmbedPluginComponent[];
    children?: JSX.Element;
    isEmbedVisible?: boolean;
    options?: Partial<TextFormattingOptions>;
    appsEnabled: boolean;
    handleFileDropdownOpened?: (open: boolean) => void;
    actions: {
        toggleEmbedVisibility: (id: string) => void;
    };
};

export default class PostBodyAdditionalContent extends React.PureComponent<Props> {
    toggleEmbedVisibility = () => {
        this.props.actions.toggleEmbedVisibility(this.props.post.id);
    }

    getEmbed = () => {
        const {metadata} = this.props.post;
        return getEmbedFromMetadata(metadata);
    }

    isEmbedToggleable = (embed: PostEmbed) => {
        const postWillRenderEmbedComponents = this.props.pluginPostWillRenderEmbedComponents || [];
        for (const c of postWillRenderEmbedComponents) {
            if (c.match(embed)) {
                return Boolean(c.toggleable);
            }
        }

        return embed.type === 'image' || (embed.type === 'opengraph' && YoutubeVideo.isYoutubeLink(embed.url));
    }

    renderEmbed = (embed: PostEmbed) => {
        const postWillRenderEmbedComponents = this.props.pluginPostWillRenderEmbedComponents || [];
        for (const c of postWillRenderEmbedComponents) {
            if (c.match(embed)) {
                const Component = c.component;
                return this.props.isEmbedVisible && (
                    <Component
                        embed={embed}
                        webSocketClient={webSocketClient}
                    />
                );
            }
        }
        switch (embed.type) {
        case 'image':
            if (!this.props.isEmbedVisible) {
                return null;
            }

            return (
                <PostImage
                    imageMetadata={this.props.post.metadata.images[embed.url]}
                    link={embed.url}
                    post={this.props.post}
                />
            );

        case 'message_attachment': {
            let attachments = [];
            if (this.props.post.props && this.props.post.props.attachments) {
                attachments = this.props.post.props.attachments;
            }

            return (
                <MessageAttachmentList
                    attachments={attachments}
                    postId={this.props.post.id}
                    options={this.props.options}
                    imagesMetadata={this.props.post.metadata.images}
                />
            );
        }

        case 'opengraph':
            if (YoutubeVideo.isYoutubeLink(embed.url)) {
                if (!this.props.isEmbedVisible) {
                    return null;
                }

                return (
                    <YoutubeVideo
                        postId={this.props.post.id}
                        link={embed.url}
                        show={this.props.isEmbedVisible}
                    />
                );
            }

            return (
                <PostAttachmentOpenGraph
                    postId={this.props.post.id}
                    link={embed.url}
                    isEmbedVisible={this.props.isEmbedVisible}
                    post={this.props.post}
                    toggleEmbedVisibility={this.toggleEmbedVisibility}
                />
            );
        case 'permalink':
            if (embed.data && 'post_id' in embed.data && embed.data.post_id) {
                return (
                    <PostMessagePreview
                        metadata={embed.data}
                        previewPost={embed.data.post}
                        handleFileDropdownOpened={this.props.handleFileDropdownOpened}
                    />
                );
            }
            return null;
        default:
            return null;
        }
    }

    renderToggle = (prependToggle: boolean) => {
        return (
            <button
                key='toggle'
                className={`style--none post__embed-visibility color--link ${prependToggle ? 'pull-left' : ''}`}
                data-expanded={this.props.isEmbedVisible}
                aria-label='Toggle Embed Visibility'
                onClick={this.toggleEmbedVisibility}
            />
        );
    }

    render() {
        const embed = this.getEmbed();

        if (this.props.appsEnabled) {
            if (hasValidEmbeddedBinding(this.props.post.props)) {
                // TODO Put some log / message if the form is not valid?
                return (
                    <React.Fragment>
                        {this.props.children}
                        <EmbeddedBindings
                            embeds={this.props.post.props.app_bindings}
                            post={this.props.post}
                        />
                    </React.Fragment>
                );
            }
        }

        if (embed) {
            const toggleable = this.isEmbedToggleable(embed);
            const prependToggle = (/^\s*https?:\/\/.*$/).test(this.props.post.message);

            return (
                <div>
                    {(toggleable && prependToggle) && this.renderToggle(true)}
                    {this.props.children}
                    {(toggleable && !prependToggle) && this.renderToggle(false)}
                    {this.renderEmbed(embed)}
                </div>
            );
        }

        return this.props.children;
    }
}

function hasValidEmbeddedBinding(props: Record<string, any>) {
    if (!props) {
        return false;
    }

    if (!props.app_bindings) {
        return false;
    }

    const embeds = props.app_bindings as AppBinding[];

    if (!embeds.length) {
        return false;
    }

    return true;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {GenericAction} from 'mattermost-redux/types/actions';
import {appsEnabled} from 'mattermost-redux/selectors/entities/apps';

import {toggleEmbedVisibility} from 'actions/post_actions';
import {isEmbedVisible} from 'selectors/posts';
import {GlobalState} from 'types/store';
import {PostWillRenderEmbedPluginComponent} from 'types/store/plugins';

import PostBodyAdditionalContent, {
    Props,
} from './post_body_additional_content';

function mapStateToProps(state: GlobalState, ownProps: Omit<Props, 'appsEnabled' | 'actions'>) {
    return {
        isEmbedVisible: isEmbedVisible(state, ownProps.post.id),
        pluginPostWillRenderEmbedComponents: state.plugins.components.PostWillRenderEmbedComponent as unknown as PostWillRenderEmbedPluginComponent[],
        appsEnabled: appsEnabled(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({toggleEmbedVisibility}, dispatch),
    };
}

export default connect(
    mapStateToProps,
    mapDispatchToProps,
)(PostBodyAdditionalContent);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

interface PostContextValue {
    handlePopupOpened: ((opened: boolean) => void) | null;
}
const PostContext = React.createContext<PostContextValue>({

    // Post component event handler that should be
    // called when any child component opens/closes a
    // popup type component.
    handlePopupOpened: null,
});

export default PostContext;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';
import Icon from '@mattermost/compass-components/foundations/icon';

import {getDateForTimezone} from 'mattermost-redux/utils/timezone_utils';
import {isSameDay, isWithinLastWeek, isYesterday} from 'utils/datetime';
import OverlayTrigger from '../../overlay_trigger';
import Tooltip from '../../tooltip';

import {Props} from './index';

const PostEditedIndicator = ({postId, isMilitaryTime, timeZone, editedAt = 0}: Props): JSX.Element | null => {
    const {formatMessage, formatDate, formatTime} = useIntl();

    if (!postId || editedAt === 0) {
        return null;
    }

    const editedDate = timeZone ? getDateForTimezone(new Date(editedAt), timeZone) : new Date(editedAt);

    let date;
    switch (true) {
    case isSameDay(editedDate):
        date = formatMessage({id: 'datetime.today', defaultMessage: 'today '});
        break;
    case isYesterday(editedDate):
        date = formatMessage({id: 'datetime.yesterday', defaultMessage: 'yesterday '});
        break;
    case isWithinLastWeek(editedDate):
        date = formatDate(editedDate, {weekday: 'long'});
        break;
    case !isWithinLastWeek(editedDate):
    default:
        date = formatDate(editedDate, {month: 'long', day: 'numeric'});
    }

    const time = formatTime(editedDate, {hour: 'numeric', minute: '2-digit', hour12: !isMilitaryTime});

    const editedText = formatMessage({
        id: 'post_message_view.edited',
        defaultMessage: 'Edited',
    });

    const formattedTime = formatMessage({
        id: 'timestamp.datetime',
        defaultMessage: '{relativeOrDate} at {time}',
    },
    {
        relativeOrDate: date,
        time,
    });

    const tooltip = (
        <Tooltip
            id={`edited-post-tooltip_${postId}`}
            className='hidden-xs'
        >
            {`${editedText} ${formattedTime}`}
        </Tooltip>
    );

    return !postId || editedAt === 0 ? null : (
        <OverlayTrigger
            delayShow={250}
            placement='top'
            overlay={tooltip}
        >
            <span
                id={`postEdited_${postId}`}
                className='post-edited__indicator'
                data-post-id={postId}
                data-edited-at={editedAt}
            >
                <Icon
                    glyph={'pencil-outline'}
                    size={10}
                />
                {editedText}
            </span>
        </OverlayTrigger>
    );
};

export default PostEditedIndicator;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getCurrentUserId} from 'mattermost-redux/selectors/entities/common';
import {makeGetUserTimezone} from 'mattermost-redux/selectors/entities/timezone';
import {getUserCurrentTimezone} from 'mattermost-redux/utils/timezone_utils';

import {getBool} from 'mattermost-redux/selectors/entities/preferences';
import {Preferences} from 'utils/constants';
import {areTimezonesEnabledAndSupported} from '../../../selectors/general';
import {GlobalState} from '../../../types/store';
import {Props as TimestampProps} from '../../timestamp/timestamp';

import PostEditedIndicator from './post_edited_indicator';

type OwnProps = {
    postId?: string;
    editedAt?: number;
}

type StateProps = {
    isMilitaryTime: boolean;
    timeZone?: string;
}

export type Props = OwnProps & StateProps;

function makeMapStateToProps() {
    const getUserTimezone = makeGetUserTimezone();

    return (state: GlobalState): StateProps => {
        const currentUserId = getCurrentUserId(state);

        let timeZone: TimestampProps['timeZone'];

        if (areTimezonesEnabledAndSupported(state)) {
            timeZone = getUserCurrentTimezone(getUserTimezone(state, currentUserId)) ?? undefined;
        }

        const isMilitaryTime = getBool(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.USE_MILITARY_TIME, false);
        return {isMilitaryTime, timeZone};
    };
}

export default connect<StateProps, null, OwnProps, GlobalState>(makeMapStateToProps)(PostEditedIndicator);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';
import classNames from 'classnames';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import FlagIcon from 'components/widgets/icons/flag_icon';
import FlagIconFilled from 'components/widgets/icons/flag_icon_filled';
import Constants, {Locations, A11yCustomEventTypes} from 'utils/constants';
import {localizeMessage} from 'utils/utils';
import {t} from 'utils/i18n';
import type {flagPost, unflagPost} from 'actions/post_actions';

export type Actions = {
    flagPost: typeof flagPost;
    unflagPost: typeof unflagPost;
}

interface Props {
    location?: typeof Locations.CENTER | typeof Locations.RHS_ROOT | typeof Locations.RHS_COMMENT | typeof Locations.SEARCH;
    postId: string;
    isFlagged: boolean;
    actions: Actions;
}

interface State {
    a11yActive: boolean;
}

export default class PostFlagIcon extends React.PureComponent<Props, State> {
    static defaultProps = {
        location: Locations.CENTER,
    };

    private buttonRef: React.RefObject<HTMLButtonElement>

    constructor(props: Props) {
        super(props);

        this.buttonRef = React.createRef();

        this.state = {
            a11yActive: false,
        };
    }

    componentDidMount() {
        if (this.buttonRef.current) {
            this.buttonRef.current.addEventListener(A11yCustomEventTypes.ACTIVATE, this.handleA11yActivateEvent);
            this.buttonRef.current.addEventListener(A11yCustomEventTypes.DEACTIVATE, this.handleA11yDeactivateEvent);
        }
    }
    componentWillUnmount() {
        if (this.buttonRef.current) {
            this.buttonRef.current.removeEventListener(A11yCustomEventTypes.ACTIVATE, this.handleA11yActivateEvent);
            this.buttonRef.current.removeEventListener(A11yCustomEventTypes.DEACTIVATE, this.handleA11yDeactivateEvent);
        }
    }

    componentDidUpdate() {
        if (this.state.a11yActive && this.buttonRef.current) {
            this.buttonRef.current.dispatchEvent(new Event(A11yCustomEventTypes.UPDATE));
        }
    }

    handlePress = (e: React.MouseEvent) => {
        e.preventDefault();

        const {
            actions,
            isFlagged,
            postId,
        } = this.props;

        if (isFlagged) {
            actions.unflagPost(postId);
        } else {
            actions.flagPost(postId);
        }
    }

    handleA11yActivateEvent = () => {
        this.setState({a11yActive: true});
    }

    handleA11yDeactivateEvent = () => {
        this.setState({a11yActive: false});
    }

    render() {
        const isFlagged = this.props.isFlagged;

        let flagIcon;
        if (isFlagged) {
            flagIcon = <FlagIconFilled className={classNames('icon', 'icon--small', 'icon--small-filled', {'post-menu__item--selected': isFlagged})}/>;
        } else {
            flagIcon = <FlagIcon className={classNames('icon', 'icon--small')}/>;
        }

        return (
            <OverlayTrigger
                className='hidden-xs'
                key={`flagtooltipkey${isFlagged ? 'flagged' : ''}`}
                delayShow={Constants.OVERLAY_TIME_DELAY}
                placement='top'
                overlay={
                    <Tooltip
                        id='flagTooltip'
                        className='hidden-xs'
                    >
                        <FormattedMessage
                            id={isFlagged ? t('flag_post.unflag') : t('flag_post.flag')}
                            defaultMessage={isFlagged ? 'Remove from Saved' : 'Save'}
                        />
                    </Tooltip>
                }
            >
                <button
                    ref={this.buttonRef}
                    id={`${this.props.location}_flagIcon_${this.props.postId}`}
                    aria-label={isFlagged ? localizeMessage('flag_post.unflag', 'Remove from Saved').toLowerCase() : localizeMessage('flag_post.flag', 'Save').toLowerCase()}
                    className='post-menu__item'
                    onClick={this.handlePress}
                >
                    {flagIcon}
                </button>
            </OverlayTrigger>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {Action} from 'mattermost-redux/types/actions';

import {flagPost, unflagPost} from 'actions/post_actions';

import PostFlagIcon, {Actions} from './post_flag_icon';

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, Actions>({
            flagPost,
            unflagPost,
        }, dispatch),
    };
}

export default connect(null, mapDispatchToProps)(PostFlagIcon);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback} from 'react';

import {matchPath, useHistory} from 'react-router-dom';

import {useDispatch, useSelector} from 'react-redux';

import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {isTeamSameWithCurrentTeam} from 'mattermost-redux/selectors/entities/teams';
import {focusPost} from 'components/permalink_view/actions';
import {GlobalState} from 'types/store';
import {getPost} from 'mattermost-redux/selectors/entities/posts';
import {isCollapsedThreadsEnabled} from 'mattermost-redux/selectors/entities/preferences';

export type Props = {
    className?: string;
    children?: JSX.Element;
    preventClickAction?: boolean;
    link: string;
};

type LinkParams = {
    postId: string;
    teamName: string;
}

const getTeamAndPostIdFromLink = (link: string) => {
    const match = matchPath<LinkParams>(link, {path: '/:teamName/pl/:postId'});
    return match?.params;
};

const PostAttachmentContainer = (props: Props) => {
    const {children, className, link, preventClickAction} = props;
    const history = useHistory();

    const params = getTeamAndPostIdFromLink(link);

    const dispatch = useDispatch();

    const currentUserId = useSelector(getCurrentUserId);
    const shouldFocusPostWithoutRedirect = useSelector((state: GlobalState) => isTeamSameWithCurrentTeam(state, params?.teamName ?? ''));
    const post = useSelector((state: GlobalState) => getPost(state, params?.postId ?? ''));
    const crtEnabled = useSelector(isCollapsedThreadsEnabled);

    const handleOnClick = useCallback((e) => {
        const {tagName} = e.target;
        e.stopPropagation();
        const elements = ['A', 'IMG', 'BUTTON', 'I'];

        if (
            !elements.includes(tagName) &&
                e.target.getAttribute('role') !== 'button' &&
                e.target.className !== `attachment attachment--${className}`
        ) {
            const classNames = [
                'icon icon-menu-down',
                'icon icon-menu-right',
                'post-image',
                'file-icon',
            ];

            if (params && shouldFocusPostWithoutRedirect && crtEnabled && post && post.root_id) {
                dispatch(focusPost(params.postId, link, currentUserId, {skipRedirectReplyPermalink: true}));
                return;
            }
            if (!classNames.some((className) => e.target.className.includes(className)) && e.target.id !== 'image-name-text') {
                history.push(link);
            }
        }
    }, [className, crtEnabled, dispatch, history, link, params, post, shouldFocusPostWithoutRedirect, currentUserId]);
    return (
        <div
            className={`attachment attachment--${className}`}
            role={preventClickAction ? undefined : 'button'}
            onClick={preventClickAction ? undefined : handleOnClick}
        >
            <div
                className={`attachment__content attachment__content--${className}`}
            >
                <div
                    className={`clearfix attachment__container attachment__container--${className}`}
                >
                    <div
                        className={`attachment__body__wrap attachment__body__wrap--${className}`}
                    >
                        {children}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default PostAttachmentContainer;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {FormattedMessage} from 'react-intl';

import classNames from 'classnames';

import UserProfileComponent from 'components/user_profile';
import {UserProfile} from '@mattermost/types/users';
import Avatar from 'components/widgets/users/avatar';
import * as PostUtils from 'utils/post_utils';
import * as Utils from 'utils/utils';
import PostMessageView from 'components/post_view/post_message_view';
import PriorityLabel from 'components/post_priority/post_priority_label';

import Timestamp from 'components/timestamp';
import PostAttachmentContainer from '../post_attachment_container/post_attachment_container';
import FileAttachmentListContainer from 'components/file_attachment_list';
import PostAttachmentOpenGraph from 'components/post_view/post_attachment_opengraph';

import MattermostLogo from 'components/widgets/icons/mattermost_logo';
import {Constants} from 'utils/constants';
import {General} from 'mattermost-redux/constants';

import {OwnProps} from './index';

export type Props = OwnProps & {
    currentTeamUrl: string;
    channelDisplayName?: string;
    user: UserProfile | null;
    hasImageProxy: boolean;
    enablePostIconOverride: boolean;
    isEmbedVisible: boolean;
    compactDisplay: boolean;
    isPostPriorityEnabled: boolean;
    handleFileDropdownOpened?: (open: boolean) => void;
    actions: {
        toggleEmbedVisibility: (id: string) => void;
    };
};

const PostMessagePreview = (props: Props) => {
    const {currentTeamUrl, channelDisplayName, user, previewPost, metadata, isEmbedVisible, compactDisplay, preventClickAction, previewFooterMessage, handleFileDropdownOpened, isPostPriorityEnabled} = props;

    const toggleEmbedVisibility = () => {
        if (previewPost) {
            props.actions.toggleEmbedVisibility(previewPost.id);
        }
    };

    const getPostIconURL = (defaultURL: string, fromAutoResponder: boolean, fromWebhook: boolean): string => {
        const {enablePostIconOverride, hasImageProxy, previewPost} = props;
        const postProps = previewPost?.props;
        let postIconOverrideURL = '';
        let useUserIcon = '';
        if (postProps) {
            postIconOverrideURL = postProps.override_icon_url;
            useUserIcon = postProps.use_user_icon;
        }

        if (!fromAutoResponder && fromWebhook && !useUserIcon && enablePostIconOverride) {
            if (postIconOverrideURL && postIconOverrideURL !== '') {
                return PostUtils.getImageSrc(postIconOverrideURL, hasImageProxy);
            }
            return Constants.DEFAULT_WEBHOOK_LOGO;
        }

        return defaultURL;
    };

    if (!previewPost) {
        return null;
    }

    const isBot = Boolean(user && user.is_bot);
    const isSystemMessage = PostUtils.isSystemMessage(previewPost);
    const fromWebhook = PostUtils.isFromWebhook(previewPost);
    const fromAutoResponder = PostUtils.fromAutoResponder(previewPost);
    const profileSrc = Utils.imageURLForUser(user?.id ?? '');
    const src = getPostIconURL(profileSrc, fromAutoResponder, fromWebhook);

    let avatar = (
        <Avatar
            size={'sm'}
            url={src}
            className={'avatar-post-preview'}
        />
    );
    if (isSystemMessage && !fromWebhook && !isBot) {
        avatar = (<MattermostLogo className='icon'/>);
    } else if (user?.id) {
        avatar = (
            <Avatar
                username={user.username}
                size={'sm'}
                url={src}
                className={'avatar-post-preview'}
            />
        );
    }

    let fileAttachmentPreview = null;

    if (((previewPost.file_ids && previewPost.file_ids.length > 0) || (previewPost.filenames && previewPost.filenames.length > 0))) {
        fileAttachmentPreview = (
            <FileAttachmentListContainer
                post={previewPost}
                compactDisplay={compactDisplay}
                isInPermalink={true}
                handleFileDropdownOpened={handleFileDropdownOpened}
            />
        );
    }

    let urlPreview = null;

    if (previewPost && previewPost.metadata && previewPost.metadata.embeds) {
        const embed = previewPost.metadata.embeds[0];

        if (embed && embed.type === 'opengraph') {
            urlPreview = (
                <PostAttachmentOpenGraph
                    postId={previewPost.id}
                    link={embed.url}
                    isEmbedVisible={isEmbedVisible}
                    post={previewPost}
                    toggleEmbedVisibility={toggleEmbedVisibility}
                    isInPermalink={true}
                />
            );
        }
    }

    let teamUrl = `/${metadata.team_name}`;
    if (metadata.channel_type === General.DM_CHANNEL || metadata.channel_type === General.GM_CHANNEL) {
        teamUrl = currentTeamUrl;
    }

    const previewFooter = channelDisplayName || previewFooterMessage ? (
        <div className='post__preview-footer'>
            <p>
                {previewFooterMessage || (
                    <FormattedMessage
                        id='post_message_preview.channel'
                        defaultMessage='Only visible to users in ~{channel}'
                        values={{
                            channel: channelDisplayName,
                        }}
                    />
                )}
            </p>
        </div>
    ) : null;

    return (
        <PostAttachmentContainer
            className='permalink'
            link={`${teamUrl}/pl/${metadata.post_id}`}
            preventClickAction={preventClickAction}
        >
            <div className='post-preview'>
                <div className='post-preview__header'>
                    <div className='col col__name'>
                        <div className='post__img'>
                            <span className='profile-icon'>
                                {avatar}
                            </span>
                        </div>
                    </div>
                    <div className={classNames('col col__name', 'permalink--username')}>
                        <UserProfileComponent
                            userId={user?.id}
                            hasMention={true}
                            disablePopover={true}
                            overwriteName={previewPost.props?.override_username || ''}
                        />
                    </div>
                    <div className='col d-flex align-items-center'>
                        <Timestamp
                            value={previewPost.create_at}
                            units={[
                                'now',
                                'minute',
                                'hour',
                                'day',
                            ]}
                            useTime={false}
                            day={'numeric'}
                            className='post-preview__time'
                        />
                        {previewPost.metadata?.priority && isPostPriorityEnabled && (
                            <span className='d-flex mr-2 ml-1'>
                                <PriorityLabel priority={previewPost.metadata.priority.priority}/>
                            </span>
                        )}
                    </div>
                </div>
                <PostMessageView
                    post={previewPost}
                    overflowType='ellipsis'
                    maxHeight={105}
                />
                {urlPreview}
                {fileAttachmentPreview}
                {previewFooter}
            </div>
        </PostAttachmentContainer>
    );
};

export default PostMessagePreview;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {bindActionCreators, Dispatch} from 'redux';

import {GlobalState} from 'types/store';

import {GenericAction} from 'mattermost-redux/types/actions';
import {Post, PostPreviewMetadata} from '@mattermost/types/posts';

import {makeGetChannel} from 'mattermost-redux/selectors/entities/channels';
import {get} from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentRelativeTeamUrl} from 'mattermost-redux/selectors/entities/teams';
import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getUser} from 'mattermost-redux/selectors/entities/users';
import {getPost, isPostPriorityEnabled} from 'mattermost-redux/selectors/entities/posts';

import {isEmbedVisible} from 'selectors/posts';

import {toggleEmbedVisibility} from 'actions/post_actions';

import {Preferences} from 'utils/constants';

import {General} from 'mattermost-redux/constants';

import PostMessagePreview from './post_message_preview';

export type OwnProps = {
    metadata: PostPreviewMetadata;
    previewPost?: Post;
    preventClickAction?: boolean;
    previewFooterMessage?: string;
}

function makeMapStateToProps() {
    const getChannel = makeGetChannel();

    return (state: GlobalState, ownProps: OwnProps) => {
        const config = getConfig(state);
        const currentTeamUrl = getCurrentRelativeTeamUrl(state);
        let user = null;
        let embedVisible = false;
        let channelDisplayName = ownProps.metadata.channel_display_name;
        const previewPost = getPost(state, ownProps.metadata.post_id) || ownProps.previewPost;

        if (previewPost && previewPost.user_id) {
            user = getUser(state, previewPost.user_id);
        }
        if (previewPost && previewPost.id) {
            embedVisible = isEmbedVisible(state, previewPost.id);
        }

        if (ownProps.metadata.channel_type === General.DM_CHANNEL) {
            channelDisplayName = getChannel(state, {id: ownProps.metadata.channel_id}).display_name;
        }

        return {
            currentTeamUrl,
            channelDisplayName,
            hasImageProxy: config.HasImageProxy === 'true',
            enablePostIconOverride: config.EnablePostIconOverride === 'true',
            previewPost,
            user,
            isEmbedVisible: embedVisible,
            compactDisplay: get(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.MESSAGE_DISPLAY, Preferences.MESSAGE_DISPLAY_DEFAULT) === Preferences.MESSAGE_DISPLAY_COMPACT,
            isPostPriorityEnabled: isPostPriorityEnabled(state),
        };
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({toggleEmbedVisibility}, dispatch),
    };
}

export default connect(makeMapStateToProps, mapDispatchToProps)(PostMessagePreview);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {Posts} from 'mattermost-redux/constants';
import {Post} from '@mattermost/types/posts';

import {Theme} from 'mattermost-redux/selectors/entities/preferences';

import * as Utils from 'utils/utils';

import PostMarkdown from 'components/post_markdown';
import Pluggable from 'plugins/pluggable';
import ShowMore from 'components/post_view/show_more';
import {TextFormattingOptions} from 'utils/text_formatting';
import {AttachmentTextOverflowType} from 'components/post_view/show_more/show_more';

type Props = {
    post: Post; /* The post to render the message for */
    enableFormatting?: boolean; /* Set to enable Markdown formatting */
    options?: TextFormattingOptions; /* Options specific to text formatting */
    compactDisplay?: boolean; /* Set to render post body compactly */
    isRHS?: boolean; /* Flags if the post_message_view is for the RHS (Reply). */
    isRHSOpen?: boolean; /* Whether or not the RHS is visible */
    isRHSExpanded?: boolean; /* Whether or not the RHS is expanded */
    theme: Theme; /* Logged in user's theme */
    pluginPostTypes?: any; /* Post type components from plugins */
    currentRelativeTeamUrl: string;
    overflowType?: AttachmentTextOverflowType;
    maxHeight?: number; /* The max height used by the show more component */
}

type State = {
    collapse: boolean;
    hasOverflow: boolean;
    checkOverflow: number;
}

export default class PostMessageView extends React.PureComponent<Props, State> {
    private imageProps: any;

    static defaultProps = {
        options: {},
        isRHS: false,
        pluginPostTypes: {},
        overflowType: undefined,
    };

    constructor(props: Props) {
        super(props);

        this.state = {
            collapse: true,
            hasOverflow: false,
            checkOverflow: 0,
        };

        this.imageProps = {
            onImageLoaded: this.handleHeightReceived,
            onImageHeightChanged: this.checkPostOverflow,
        };
    }

    checkPostOverflow = () => {
        // Increment checkOverflow to indicate change in height
        // and recompute textContainer height at ShowMore component
        // and see whether overflow text of show more/less is necessary or not.
        this.setState((prevState) => {
            return {checkOverflow: prevState.checkOverflow + 1};
        });
    }

    handleHeightReceived = (height: number) => {
        if (height > 0) {
            this.checkPostOverflow();
        }
    };

    renderDeletedPost() {
        return (
            <p>
                <FormattedMessage
                    id='post_body.deleted'
                    defaultMessage='(message deleted)'
                />
            </p>
        );
    }

    handleFormattedTextClick = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) =>
        Utils.handleFormattedTextClick(e, this.props.currentRelativeTeamUrl);

    render() {
        const {
            post,
            enableFormatting,
            options,
            pluginPostTypes,
            compactDisplay,
            isRHS,
            theme,
            overflowType,
            maxHeight,
        } = this.props;

        if (post.state === Posts.POST_DELETED) {
            return this.renderDeletedPost();
        }

        if (!enableFormatting) {
            return <span>{post.message}</span>;
        }

        const postType = post.props && post.props.type ? post.props.type : post.type;

        if (pluginPostTypes && pluginPostTypes.hasOwnProperty(postType)) {
            const PluginComponent = pluginPostTypes[postType].component;
            return (
                <PluginComponent
                    post={post}
                    compactDisplay={compactDisplay}
                    isRHS={isRHS}
                    theme={theme}
                />
            );
        }

        let message = post.message;
        const isEphemeral = Utils.isPostEphemeral(post);
        if (compactDisplay && isEphemeral) {
            const visibleMessage = Utils.localizeMessage('post_info.message.visible.compact', ' (Only visible to you)');
            message = message.concat(visibleMessage);
        }

        const id = isRHS ? `rhsPostMessageText_${post.id}` : `postMessageText_${post.id}`;

        return (
            <ShowMore
                checkOverflow={this.state.checkOverflow}
                text={message}
                overflowType={overflowType}
                maxHeight={maxHeight}
            >
                <div
                    aria-readonly='true'
                    tabIndex={0}
                    id={id}
                    className='post-message__text'
                    dir='auto'
                    onClick={this.handleFormattedTextClick}
                >
                    <PostMarkdown
                        message={message}
                        imageProps={this.imageProps}
                        isRHS={isRHS}
                        options={options}
                        post={post}
                        channelId={post.channel_id}
                        mentionKeys={[]}
                    />
                </div>
                <Pluggable
                    pluggableName='PostMessageAttachment'
                    postId={post.id}
                    onHeightChange={this.handleHeightReceived}
                />
            </ShowMore>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {Preferences} from 'mattermost-redux/constants';
import {getTheme, getBool} from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentRelativeTeamUrl} from 'mattermost-redux/selectors/entities/teams';

import {getIsRhsExpanded, getIsRhsOpen} from 'selectors/rhs';

import {GlobalState} from 'types/store';

import PostMessageView from './post_message_view';

function mapStateToProps(state: GlobalState) {
    return {
        enableFormatting: getBool(state, Preferences.CATEGORY_ADVANCED_SETTINGS, 'formatting', true),
        isRHSExpanded: getIsRhsExpanded(state),
        isRHSOpen: getIsRhsOpen(state),
        pluginPostTypes: state.plugins.postTypes,
        theme: getTheme(state),
        currentRelativeTeamUrl: getCurrentRelativeTeamUrl(state),
    };
}

export default connect(mapStateToProps)(PostMessageView);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage, injectIntl, IntlShape} from 'react-intl';

import {t} from 'utils/i18n';

import FlagIconFilled from 'components/widgets/icons/flag_icon_filled';

export type Props = {
    intl: IntlShape;
    isFlagged: boolean;
    isPinned?: boolean;
    skipPinned?: boolean;
    skipFlagged?: boolean;
    channelId: string;
    actions: {
        showFlaggedPosts: () => void;
        showPinnedPosts: (channelId: string) => void;
    };
}

export enum PostPinnedOrFlagged {
    Flagged,
    Pinned,
    PinnedAndFlagged,
    Neither,
}

enum MessageInfoKey {
    Flagged = 'flagged',
    Pinned = 'pinned',
    PinnedAndFlagged = 'pinnedAndFlagged',
}

class PostPreHeader extends React.PureComponent<Props> {
    messageInfos = {
        flagged: {id: t('post_pre_header.flagged'), defaultMessage: 'Saved'},
        pinned: {id: t('post_pre_header.pinned'), defaultMessage: 'Pinned'},
    };

    getPostStatus(isFlagged: boolean, isPinned?: boolean): PostPinnedOrFlagged {
        if (isFlagged) {
            if (isPinned) {
                return PostPinnedOrFlagged.PinnedAndFlagged;
            }

            return PostPinnedOrFlagged.Flagged;
        }

        if (isPinned) {
            return PostPinnedOrFlagged.Pinned;
        }

        return PostPinnedOrFlagged.Neither;
    }

    getMessageInfo(postStatus: PostPinnedOrFlagged, skipFlagged?: boolean, skipPinned?: boolean): MessageInfoKey | false {
        if (skipFlagged && skipPinned) {
            return false;
        }

        if (postStatus === PostPinnedOrFlagged.PinnedAndFlagged) {
            if (!skipPinned && !skipFlagged) {
                return MessageInfoKey.PinnedAndFlagged;
            }

            if (skipPinned) {
                return MessageInfoKey.Flagged;
            }

            if (skipFlagged) {
                return MessageInfoKey.Pinned;
            }
        }

        if (postStatus === PostPinnedOrFlagged.Flagged && !skipFlagged) {
            return MessageInfoKey.Flagged;
        }

        if (postStatus === PostPinnedOrFlagged.Pinned && !skipPinned) {
            return MessageInfoKey.Pinned;
        }

        return false;
    }

    handleLinkClick = (messageKey: MessageInfoKey, channelId?: string) => {
        if (messageKey === MessageInfoKey.Pinned && channelId) {
            this.props.actions.showPinnedPosts(channelId);
        } else {
            this.props.actions.showFlaggedPosts();
        }
    }

    render() {
        const {isFlagged, isPinned, skipPinned, skipFlagged, channelId} = this.props;

        const messageKey = this.getMessageInfo(this.getPostStatus(isFlagged, isPinned), skipFlagged, skipPinned);

        if ((!isFlagged && !isPinned) || !messageKey) {
            return null;
        }

        return (
            <div className='post-pre-header'>
                <div className='post-pre-header__icons-container'>
                    {isPinned && !skipPinned && <span className='icon-pin icon icon--post-pre-header'/>}
                    {isFlagged && !skipFlagged && <FlagIconFilled className='icon icon--post-pre-header'/>}
                </div>
                <div className='post-pre-header__text-container'>
                    {messageKey &&
                    messageKey !== MessageInfoKey.PinnedAndFlagged && (
                        <span>
                            <a onClick={() => this.handleLinkClick(messageKey, channelId)}>
                                <FormattedMessage
                                    id={this.messageInfos[messageKey].id}
                                    defaultMessage={this.messageInfos[messageKey].defaultMessage}
                                />
                            </a>
                        </span>
                    )}
                    {messageKey &&
                    messageKey === MessageInfoKey.PinnedAndFlagged && (
                        <span>
                            <a onClick={() => this.handleLinkClick(MessageInfoKey.Pinned, channelId)}>
                                <FormattedMessage
                                    id={this.messageInfos[MessageInfoKey.Pinned].id}
                                    defaultMessage={this.messageInfos[MessageInfoKey.Pinned].defaultMessage}
                                />
                            </a>
                            <span className='post-pre-header__link-separator'>{'\u2B24'}</span>
                            <a onClick={() => this.handleLinkClick(MessageInfoKey.Flagged)}>
                                <FormattedMessage
                                    id={this.messageInfos[MessageInfoKey.Flagged].id}
                                    defaultMessage={this.messageInfos[MessageInfoKey.Flagged].defaultMessage}
                                />
                            </a>
                        </span>
                    )}
                </div>
            </div>
        );
    }
}

export default injectIntl(PostPreHeader);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {bindActionCreators, Dispatch} from 'redux';
import {connect} from 'react-redux';

import {showFlaggedPosts, showPinnedPosts} from 'actions/views/rhs';

import PostPreHeader from './post_pre_header';

const mapDispatchToProps = (dispatch: Dispatch) => ({
    actions: bindActionCreators({
        showFlaggedPosts,
        showPinnedPosts,
    }, dispatch),
});

export default connect(null, mapDispatchToProps)(PostPreHeader);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import classNames from 'classnames';
import {FormattedMessage} from 'react-intl';

import {Dispatch} from 'redux';

import Permissions from 'mattermost-redux/constants/permissions';

import {Emoji} from '@mattermost/types/emojis';

import {Locations} from 'utils/constants';
import {localizeMessage} from 'utils/utils';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import ChannelPermissionGate from 'components/permissions_gates/channel_permission_gate';
import EmojiIcon from 'components/widgets/icons/emoji_icon';
import EmojiPickerOverlay from 'components/emoji_picker/emoji_picker_overlay';

const TOP_OFFSET = -7;

type LocationTypes = 'CENTER' | 'RHS_ROOT' | 'RHS_COMMENT';

export type Props = {
    channelId?: string;
    postId: string;
    teamId: string;
    getDotMenuRef: () => HTMLDivElement | null;
    location: LocationTypes;
    showEmojiPicker: boolean;
    toggleEmojiPicker: (e?: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;
    actions: {
        addReaction: (postId: string, emojiName: string) => (dispatch: Dispatch) => {data: boolean};
    };
}

type State = {
    location: LocationTypes;
    showEmojiPicker: boolean;
}

export default class PostReaction extends React.PureComponent<Props, State> {
    public static defaultProps: Partial<Props> = {
        location: Locations.CENTER as 'CENTER',
        showEmojiPicker: false,
    };

    handleAddEmoji = (emoji: Emoji): void => {
        this.setState({showEmojiPicker: false});
        const emojiName = 'short_name' in emoji ? emoji.short_name : emoji.name;
        this.props.actions.addReaction(this.props.postId, emojiName);
        this.props.toggleEmojiPicker();
    };

    render() {
        const {
            channelId,
            location,
            postId,
            showEmojiPicker,
            teamId,
        } = this.props;

        let spaceRequiredAbove;
        let spaceRequiredBelow;
        if (location === Locations.RHS_ROOT || location === Locations.RHS_COMMENT) {
            spaceRequiredAbove = EmojiPickerOverlay.RHS_SPACE_REQUIRED_ABOVE;
            spaceRequiredBelow = EmojiPickerOverlay.RHS_SPACE_REQUIRED_BELOW;
        }

        return (
            <ChannelPermissionGate
                channelId={channelId}
                teamId={teamId}
                permissions={[Permissions.ADD_REACTION]}
            >
                <React.Fragment>
                    <EmojiPickerOverlay
                        show={showEmojiPicker}
                        target={this.props.getDotMenuRef}
                        onHide={this.props.toggleEmojiPicker}
                        onEmojiClick={this.handleAddEmoji}
                        topOffset={TOP_OFFSET}
                        spaceRequiredAbove={spaceRequiredAbove}
                        spaceRequiredBelow={spaceRequiredBelow}
                    />
                    <OverlayTrigger
                        className='hidden-xs'
                        delayShow={500}
                        placement='top'
                        overlay={
                            <Tooltip
                                id='reaction-icon-tooltip'
                                className='hidden-xs'
                            >
                                <FormattedMessage
                                    id='post_info.tooltip.add_reactions'
                                    defaultMessage='Add Reaction'
                                />
                            </Tooltip>
                        }
                    >
                        <button
                            data-testid='post-reaction-emoji-icon'
                            id={`${location}_reaction_${postId}`}
                            aria-label={localizeMessage('post_info.tooltip.add_reactions', 'Add Reaction').toLowerCase()}
                            className={classNames('post-menu__item', 'post-menu__item--reactions', {
                                'post-menu__item--active': showEmojiPicker,
                            })}
                            onClick={this.props.toggleEmojiPicker}
                        >
                            <EmojiIcon className='icon icon--small'/>
                        </button>
                    </OverlayTrigger>
                </React.Fragment>
            </ChannelPermissionGate>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, ActionCreatorsMapObject, Dispatch} from 'redux';

import {Action} from 'mattermost-redux/types/actions';

import {addReaction} from 'actions/post_actions';

import PostReaction, {Props} from './post_reaction';

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, Props['actions']>({
            addReaction,
        }, dispatch),
    };
}

export default connect(null, mapDispatchToProps)(PostReaction);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';
import classNames from 'classnames';

import {getEmojiImageUrl, isSystemEmoji} from 'mattermost-redux/utils/emoji_utils';
import {Emoji} from '@mattermost/types/emojis';

type Props = {
    emoji: Emoji;
    onItemClick: (emoji: Emoji) => void;
    order?: number;
}
const EmojiItem = ({emoji, onItemClick, order}: Props) => {
    const {formatMessage} = useIntl();

    const handleClick = (e: React.MouseEvent) => {
        e.stopPropagation();
        onItemClick(emoji);
    };

    const itemClassName = 'post-menu__item';

    const emojiName = isSystemEmoji(emoji) ? emoji.short_name ?? emoji.name : emoji.name;

    return (
        <div
            className={classNames(itemClassName, 'post-menu__emoticon')}
            onClick={handleClick}
        >
            <button
                id={`recent_reaction_${order}`}
                data-testid={itemClassName + '_emoji'}
                className='emoticon--post-menu'
                style={{backgroundImage: `url(${getEmojiImageUrl(emoji)})`, backgroundColor: 'transparent'}}
                aria-label={formatMessage(
                    {
                        id: 'emoji_picker_item.emoji_aria_label',
                        defaultMessage: '{emojiName} emoji',
                    },
                    {
                        emojiName: (emojiName).replace(/_/g, ' '),
                    },
                )}
            />
        </div>
    );
};

export default EmojiItem;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import Permissions from 'mattermost-redux/constants/permissions';
import {Emoji} from '@mattermost/types/emojis';
import {Locations} from 'utils/constants';
import ChannelPermissionGate from 'components/permissions_gates/channel_permission_gate';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';

import EmojiItem from './recent_reactions_emoji_item';

type LocationTypes = 'CENTER' | 'RHS_ROOT' | 'RHS_COMMENT';

type Props = {
    channelId?: string;
    postId: string;
    teamId: string;
    getDotMenuRef: () => HTMLDivElement | null;
    location?: LocationTypes;
    locale: string;
    emojis: Emoji[];
    size: number;
    defaultEmojis: Emoji[];
    actions: {
        addReaction: (postId: string, emojiName: string) => void;
    };
}

type State = {
    location: LocationTypes;
}

export default class PostRecentReactions extends React.PureComponent<Props, State> {
    public static defaultProps: Partial<Props> = {
        location: Locations.CENTER as 'CENTER',
        size: 3,
    };

    handleAddEmoji = (emoji: Emoji): void => {
        const emojiName = 'short_name' in emoji ? emoji.short_name : emoji.name;
        this.props.actions.addReaction(this.props.postId, emojiName);
    };

    complementEmojis = (emojis: Emoji[]): (Emoji[]) => {
        const additional = this.props.defaultEmojis.filter((e) => {
            let ignore = false;
            for (const emoji of emojis) {
                if (e.name === emoji.name) {
                    ignore = true;
                    break;
                }
            }
            return !ignore;
        });
        const l = emojis.length;
        for (let i = 0; i < this.props.size - l; i++) {
            emojis.push(additional[i]);
        }

        return emojis;
    };

    emojiName = (emoji: Emoji, locale: string): string => {
        function capitalizeFirstLetter(s: string) {
            return s[0].toLocaleUpperCase(locale) + s.slice(1);
        }
        const name = 'short_name' in emoji ? emoji.short_name : emoji.name;
        return capitalizeFirstLetter(name.replace(/_/g, ' '));
    };

    render() {
        const {
            channelId,
            teamId,
        } = this.props;

        let emojis = [...this.props.emojis].slice(0, this.props.size);
        if (emojis.length < this.props.size) {
            emojis = this.complementEmojis(emojis);
        }

        return emojis.map((emoji, n) => (
            <ChannelPermissionGate
                key={this.emojiName(emoji, this.props.locale)} // emojis will be unique therefore no duplication expected.
                channelId={channelId}
                teamId={teamId}
                permissions={[Permissions.ADD_REACTION]}
            >
                <OverlayTrigger
                    className='hidden-xs'
                    delayShow={500}
                    placement='top'
                    overlay={
                        <Tooltip
                            id='post_info.emoji.tooltip'
                            className='hidden-xs'
                        >
                            {this.emojiName(emoji, this.props.locale)}
                        </Tooltip>
                    }
                >
                    <div>
                        <React.Fragment>
                            <EmojiItem
                                // eslint-disable-next-line react/no-array-index-key
                                emoji={emoji}
                                onItemClick={this.handleAddEmoji}
                                order={n}
                            />
                        </React.Fragment>
                    </div>
                </OverlayTrigger>
            </ChannelPermissionGate>
        ),
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {getEmojiMap} from 'selectors/emojis';
import {getCurrentLocale} from 'selectors/i18n';
import {GlobalState} from 'types/store';
import {GenericAction} from 'mattermost-redux/types/actions';

import {addReaction} from 'actions/post_actions';
import {Emoji} from '@mattermost/types/emojis';

import PostReaction from './post_recent_reactions';

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            addReaction,
        }, dispatch),
    };
}

function mapStateToProps(state: GlobalState) {
    const locale = getCurrentLocale(state);
    const emojiMap = getEmojiMap(state);
    const defaultEmojis = [emojiMap.get('thumbsup'), emojiMap.get('grinning'), emojiMap.get('white_check_mark')] as Emoji[];

    return {
        defaultEmojis,
        locale,
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(PostReaction);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ComponentProps} from 'react';
import {Link} from 'react-router-dom';

import * as GlobalActions from 'actions/global_actions';
import {isMobile} from 'utils/user_agent';
import {Locations} from 'utils/constants';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';

import Timestamp, {RelativeRanges} from 'components/timestamp';

const POST_TOOLTIP_RANGES = [
    RelativeRanges.TODAY_TITLE_CASE,
    RelativeRanges.YESTERDAY_TITLE_CASE,
];

type Props = {

    /*
     * If true, time will be rendered as a permalink to the post
     */
    isPermalink: boolean;

    /*
     * The time to display
     */
    eventTime: number;

    isMobileView: boolean;
    location: string;

    /*
     * The post id of posting being rendered
     */
    postId: string;
    teamUrl: string;
    timestampProps?: ComponentProps<typeof Timestamp>;
}

export default class PostTime extends React.PureComponent<Props> {
    static defaultProps: Partial<Props> = {
        eventTime: 0,
        location: Locations.CENTER,
    };

    handleClick = () => {
        if (this.props.isMobileView) {
            GlobalActions.emitCloseRightHandSide();
        }
    };

    render() {
        const {
            eventTime,
            isPermalink,
            location,
            postId,
            teamUrl,
            timestampProps = {},
        } = this.props;

        const postTime = (
            <Timestamp
                value={eventTime}
                className='post__time'
                useDate={false}
                {...timestampProps}
            />
        );

        const content = isMobile() || !isPermalink ? (
            <div
                role='presentation'
                className='post__permalink post_permalink_mobile_view'
            >
                {postTime}
            </div>
        ) : (
            <Link
                id={`${location}_time_${postId}`}
                to={`${teamUrl}/pl/${postId}`}
                className='post__permalink'
                onClick={this.handleClick}
            >
                {postTime}
            </Link>
        );

        return (
            <OverlayTrigger
                delayShow={500}
                placement='top'
                overlay={
                    <Tooltip
                        id={eventTime.toString()}
                        className='hidden-xs'
                    >
                        <Timestamp
                            value={eventTime}
                            ranges={POST_TOOLTIP_RANGES}
                        />
                    </Tooltip>
                }
            >
                {content}
            </OverlayTrigger>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getCurrentRelativeTeamUrl} from 'mattermost-redux/selectors/entities/teams';

import {getIsMobileView} from 'selectors/views/browser';

import {GlobalState} from 'types/store';

import PostTime from './post_time';

type OwnProps = {
    teamName?: string;
}

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    return {
        isMobileView: getIsMobileView(state),
        teamUrl: ownProps.teamName ? `/${ownProps.teamName}` : getCurrentRelativeTeamUrl(state),
    };
}

export default connect(mapStateToProps)(PostTime);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {Permissions} from 'mattermost-redux/constants';

import {GlobalState} from '@mattermost/types/store';

import {getChannel} from './channels';
import {haveIChannelPermission} from './roles';

export function canAddReactions(state: GlobalState, channelId: string) {
    const channel = getChannel(state, channelId);

    if (!channel || channel.delete_at > 0) {
        return false;
    }

    return haveIChannelPermission(state, channel.team_id, channelId, Permissions.ADD_REACTION);
}

export function canRemoveReactions(state: GlobalState, channelId: string) {
    const channel = getChannel(state, channelId);

    if (!channel || channel.delete_at > 0) {
        return false;
    }

    return haveIChannelPermission(state, channel.team_id, channelId, Permissions.REMOVE_REACTION);
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import * as React from 'react';
import {FormattedMessage} from 'react-intl';

import {Reaction as ReactionType} from '@mattermost/types/reactions';

type Props = {
    canAddReactions: boolean;
    canRemoveReactions: boolean;
    currentUserReacted: boolean;
    emojiName: string;
    reactions: ReactionType[];
    users: string[];
};

const ReactionTooltip: React.FC<Props> = (props: Props) => {
    const {
        canAddReactions,
        canRemoveReactions,
        currentUserReacted,
        emojiName,
        reactions,
        users,
    } = props;

    const otherUsersCount = reactions.length - users.length;

    let names: React.ReactNode;
    if (otherUsersCount > 0) {
        if (users.length > 0) {
            names = (
                <FormattedMessage
                    id='reaction.usersAndOthersReacted'
                    defaultMessage='{users} and {otherUsers, number} other {otherUsers, plural, one {user} other {users}}'
                    values={{
                        users: users.join(', '),
                        otherUsers: otherUsersCount,
                    }}
                />
            );
        } else {
            names = (
                <FormattedMessage
                    id='reaction.othersReacted'
                    defaultMessage='{otherUsers, number} {otherUsers, plural, one {user} other {users}}'
                    values={{
                        otherUsers: otherUsersCount,
                    }}
                />
            );
        }
    } else if (users.length > 1) {
        names = (
            <FormattedMessage
                id='reaction.usersReacted'
                defaultMessage='{users} and {lastUser}'
                values={{
                    users: users.slice(0, -1).join(', '),
                    lastUser: users[users.length - 1],
                }}
            />
        );
    } else {
        names = users[0];
    }

    let reactionVerb: React.ReactNode;
    if (users.length + otherUsersCount > 1) {
        if (currentUserReacted) {
            reactionVerb = (
                <FormattedMessage
                    id='reaction.reactionVerb.youAndUsers'
                    defaultMessage='reacted'
                />
            );
        } else {
            reactionVerb = (
                <FormattedMessage
                    id='reaction.reactionVerb.users'
                    defaultMessage='reacted'
                />
            );
        }
    } else if (currentUserReacted) {
        reactionVerb = (
            <FormattedMessage
                id='reaction.reactionVerb.you'
                defaultMessage='reacted'
            />
        );
    } else {
        reactionVerb = (
            <FormattedMessage
                id='reaction.reactionVerb.user'
                defaultMessage='reacted'
            />
        );
    }

    const tooltip = (
        <FormattedMessage
            id='reaction.reacted'
            defaultMessage='{users} {reactionVerb} with {emoji}'
            values={{
                users: <b>{names}</b>,
                reactionVerb,
                emoji: <b>{':' + emojiName + ':'}</b>,
            }}
        />
    );

    let clickTooltip: React.ReactNode;
    if (currentUserReacted && canRemoveReactions) {
        clickTooltip = (
            <FormattedMessage
                id='reaction.clickToRemove'
                defaultMessage='(click to remove)'
            />
        );
    } else if (!currentUserReacted && canAddReactions) {
        clickTooltip = (
            <FormattedMessage
                id='reaction.clickToAdd'
                defaultMessage='(click to add)'
            />
        );
    }

    return (
        <>
            {tooltip}
            <br/>
            {clickTooltip}
        </>
    );
};

export default ReactionTooltip;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {createSelector} from 'reselect';

import {getCurrentUserId, makeGetProfilesForReactions} from 'mattermost-redux/selectors/entities/users';
import {getTeammateNameDisplaySetting} from 'mattermost-redux/selectors/entities/preferences';

import {Reaction as ReactionType} from '@mattermost/types/reactions';
import {UserProfile} from '@mattermost/types/users';

import {displayUsername} from 'mattermost-redux/utils/user_utils';

import {GlobalState} from '@mattermost/types/store';

import * as Utils from 'utils/utils';

import ReactionTooltip from './reaction_tooltip';

type OwnProps = {
    reactions: ReactionType[];
};

export const makeGetNamesOfUsers = () => createSelector(
    'makeGetNamesOfUsers',
    (state: GlobalState, reactions: ReactionType[]) => reactions,
    getCurrentUserId,
    makeGetProfilesForReactions(),
    getTeammateNameDisplaySetting,
    (reactions: ReactionType[], currentUserId: string, profiles: UserProfile[], teammateNameDisplay: string) => {
        // Sort users by who reacted first with "you" being first if the current user reacted

        let currentUserReacted = false;
        const sortedReactions = reactions.sort((a, b) => a.create_at - b.create_at);
        const users = sortedReactions.reduce((accumulator, current) => {
            if (current.user_id === currentUserId) {
                currentUserReacted = true;
            } else {
                const user = profiles.find((u) => u.id === current.user_id);
                if (user) {
                    accumulator.push(displayUsername(user, teammateNameDisplay));
                }
            }
            return accumulator;
        }, [] as string[]);

        if (currentUserReacted) {
            users.unshift(Utils.localizeMessage('reaction.you', 'You'));
        }

        return users;
    },
);

function makeMapStateToProps() {
    const getNamesOfUsers = makeGetNamesOfUsers();

    return (state: GlobalState, ownProps: OwnProps) => {
        return {
            users: getNamesOfUsers(state, ownProps.reactions),
        };
    };
}

export default connect(makeMapStateToProps)(ReactionTooltip);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {Post} from '@mattermost/types/posts';
import {Reaction as ReactionType} from '@mattermost/types/reactions';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';

import * as Utils from 'utils/utils';

import ReactionTooltip from './reaction_tooltip';
import './reaction.scss';

type State = {
    displayNumber: number;
    reactedClass: 'Reaction--reacted' | 'Reaction--reacting' | 'Reaction--unreacted' | 'Reaction--unreacting';
};

declare module 'react-bootstrap/lib/OverlayTrigger' {
    interface OverlayTriggerProps {
        shouldUpdatePosition?: boolean;
    }
}

type Props = {

    /*
     * The post to render the reaction for
     */
    post: Post;

    /*
     * The user id of the logged in user
     */
    currentUserId: string;

    /*
     * The name of the emoji for the reaction
     */
    emojiName: string;

    /*
     * The number of reactions to this post for this emoji
     */
    reactionCount: number;

    /*
     * Array of reactions by user
     */
    reactions: ReactionType[];

    /*
     * True if the user has the permission to add a reaction in this channel
     */
    canAddReactions: boolean;

    /*
     * True if user has the permission to remove his own reactions in this channel
     */
    canRemoveReactions: boolean;

    /*
     * The URL of the emoji image
     */
    emojiImageUrl: string;

    /*
     * Whether or not the current user has used this reaction
     */
    currentUserReacted: boolean;

    actions: {

        /*
         * Function to add a reaction to a post
         */
        addReaction: (postId: string, emojiName: string) => void;

        /*
         * Function to get non-loaded profiles by id
         */
        getMissingProfilesByIds: (ids: string[]) => void;

        /*
         * Function to remove a reaction from a post
         */
        removeReaction: (postId: string, emojiName: string) => void;
    };
}

export default class Reaction extends React.PureComponent<Props, State> {
    private reactionButtonRef = React.createRef<HTMLButtonElement>();
    private reactionCountRef = React.createRef<HTMLSpanElement>();
    private animating = false;

    constructor(props: Props) {
        super(props);

        const {currentUserReacted, reactionCount} = this.props;

        if (currentUserReacted) {
            this.state = {
                reactedClass: 'Reaction--reacted',
                displayNumber: reactionCount,
            };
        } else {
            this.state = {
                reactedClass: 'Reaction--unreacted',
                displayNumber: reactionCount,
            };
        }
    }

    componentDidUpdate(prevProps: Props): void {
        if (prevProps.reactionCount !== this.props.reactionCount) {
            const {currentUserReacted} = this.props;
            const reactedClass = currentUserReacted ? 'Reaction--reacted' : 'Reaction--unreacted';

            this.animating = false;
            /* eslint-disable-next-line react/no-did-update-set-state */
            this.setState({
                displayNumber: this.props.reactionCount,
                reactedClass,
            });
        }
    }

    handleClick = (): void => {
        // only proceed if user has permission to react
        // and we are not animating
        if (
            !(this.props.canAddReactions && this.props.canRemoveReactions) || this.animating
        ) {
            return;
        }

        const {currentUserReacted} = this.props;

        this.animating = true;
        this.setState((state) => {
            if (currentUserReacted) {
                return {
                    displayNumber: state.displayNumber - 1,
                    reactedClass: 'Reaction--unreacting',
                };
            }

            return {
                displayNumber: state.displayNumber + 1,
                reactedClass: 'Reaction--reacting',
            };
        });
    }

    handleAnimationEnded = (): void => {
        const {actions, currentUserReacted, post, emojiName} = this.props;

        this.animating = false;
        this.setState<'reactedClass'>((state) => {
            if (state.reactedClass === 'Reaction--reacting') {
                return {
                    reactedClass: 'Reaction--reacted',
                };
            } else if (state.reactedClass === 'Reaction--unreacting') {
                return {
                    reactedClass: 'Reaction--unreacted',
                };
            }
            return state;
        });

        if (currentUserReacted) {
            actions.removeReaction(post.id, emojiName);
        } else {
            actions.addReaction(post.id, emojiName);
        }
    }

    loadMissingProfiles = async (): Promise<void> => {
        const ids = this.props.reactions.map((reaction) => reaction.user_id);
        this.props.actions.getMissingProfilesByIds(ids);
    }

    render(): React.ReactNode {
        if (!this.props.emojiImageUrl) {
            return null;
        }
        const {
            canAddReactions,
            canRemoveReactions,
            currentUserReacted,
            emojiName,
            reactionCount,
            reactions,
        } = this.props;
        const {displayNumber} = this.state;
        const reactedNumber = currentUserReacted ? reactionCount : reactionCount + 1;
        const unreactedNumber = currentUserReacted ? reactionCount - 1 : reactionCount;
        const unreacted = (unreactedNumber > 0) ? unreactedNumber : '';
        const reacted = (reactedNumber > 0) ? reactedNumber : '';
        const display = (displayNumber > 0) ? displayNumber : '';
        const readOnlyClass = (canAddReactions && canRemoveReactions) ? '' : 'Reaction--read-only';

        const emojiNameWithSpaces = this.props.emojiName.replace(/_/g, ' ');
        let ariaLabelEmoji = `${Utils.localizeMessage('reaction.reactWidth.ariaLabel', 'react with')} ${emojiNameWithSpaces}`;
        if (currentUserReacted && canRemoveReactions) {
            ariaLabelEmoji = `${Utils.localizeMessage('reaction.removeReact.ariaLabel', 'remove reaction')} ${emojiNameWithSpaces}`;
        }

        return (
            <OverlayTrigger
                delayShow={500}
                placement='top'
                shouldUpdatePosition={true}
                overlay={
                    <Tooltip id={`${this.props.post.id}-${this.props.emojiName}-reaction`}>
                        <ReactionTooltip
                            canAddReactions={canAddReactions}
                            canRemoveReactions={canRemoveReactions}
                            currentUserReacted={currentUserReacted}
                            emojiName={emojiName}
                            reactions={reactions}
                        />
                    </Tooltip>
                }
                onEnter={this.loadMissingProfiles}
            >
                <button
                    id={`postReaction-${this.props.post.id}-${this.props.emojiName}`}
                    aria-label={ariaLabelEmoji}
                    className={`Reaction ${this.state.reactedClass} ${readOnlyClass}`}
                    onClick={this.handleClick}
                    ref={this.reactionButtonRef}
                >
                    <span className='d-flex align-items-center'>
                        <span
                            className='Reaction__emoji emoticon'
                            style={{backgroundImage: 'url(' + this.props.emojiImageUrl + ')'}}
                        />
                        <span
                            ref={this.reactionCountRef}
                            className='Reaction__count'
                        >
                            <span className='Reaction__number'>
                                <span className='Reaction__number--display'>{display}</span>
                                <span
                                    className='Reaction__number--unreacted'
                                    onAnimationEnd={this.handleAnimationEnded}
                                >
                                    {unreacted}
                                </span>
                                <span className='Reaction__number--reacted'>{reacted}</span>
                            </span>
                        </span>
                    </span>
                </button>
            </OverlayTrigger>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {createSelector} from 'reselect';

import {removeReaction} from 'mattermost-redux/actions/posts';
import {getMissingProfilesByIds} from 'mattermost-redux/actions/users';

import {getCustomEmojisByName} from 'mattermost-redux/selectors/entities/emojis';
import {canAddReactions, canRemoveReactions} from 'mattermost-redux/selectors/entities/reactions';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';

import {GenericAction} from 'mattermost-redux/types/actions';
import {Emoji as EmojiType} from '@mattermost/types/emojis';
import {Post} from '@mattermost/types/posts';
import {Reaction as ReactionType} from '@mattermost/types/reactions';
import {GlobalState} from '@mattermost/types/store';

import {getEmojiImageUrl} from 'mattermost-redux/utils/emoji_utils';

import {addReaction} from 'actions/post_actions';

import * as Emoji from 'utils/emoji';

import Reaction from './reaction';

type Props = {
    emojiName: string;
    post: Post;
    reactions: ReactionType[];
};

function makeMapStateToProps() {
    const didCurrentUserReact = createSelector(
        'didCurrentUserReact',
        getCurrentUserId,
        (state: GlobalState, reactions: ReactionType[]) => reactions,
        (currentUserId: string, reactions: ReactionType[]) => {
            return reactions.some((reaction) => reaction.user_id === currentUserId);
        },
    );

    return function mapStateToProps(state: GlobalState, ownProps: Props) {
        const channelId = ownProps.post.channel_id;

        let emoji;
        if (Emoji.EmojiIndicesByAlias.has(ownProps.emojiName)) {
            emoji = Emoji.Emojis[Emoji.EmojiIndicesByAlias.get(ownProps.emojiName) as number];
        } else {
            const emojis = getCustomEmojisByName(state);
            emoji = emojis.get(ownProps.emojiName);
        }

        let emojiImageUrl = '';
        if (emoji) {
            emojiImageUrl = getEmojiImageUrl(emoji as EmojiType);
        }
        const currentUserId = getCurrentUserId(state);

        return {
            currentUserId,
            reactionCount: ownProps.reactions.length,
            canAddReactions: canAddReactions(state, channelId),
            canRemoveReactions: canRemoveReactions(state, channelId),
            emojiImageUrl,
            currentUserReacted: didCurrentUserReact(state, ownProps.reactions),
        };
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            addReaction,
            removeReaction,
            getMissingProfilesByIds,
        }, dispatch),
    };
}

export default connect(makeMapStateToProps, mapDispatchToProps)(Reaction);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function AddReactionIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='16px'
                height='16px'
                viewBox='0 0 16 16'
                role='img'
                aria-label={formatMessage({id: 'generic_icons.add-reaction', defaultMessage: 'Add Reaction Icon'})}
            >
                <path d='M10 8.00001C10.32 8.00001 10.5973 7.88267 10.832 7.64801C11.0773 7.40267 11.2 7.12001 11.2 6.80001C11.2 6.48001 11.0773 6.20267 10.832 5.96801C10.5973 5.72267 10.32 5.60001 10 5.60001C9.68 5.60001 9.39733 5.72267 9.152 5.96801C8.91733 6.20267 8.8 6.48001 8.8 6.80001C8.8 7.12001 8.91733 7.40267 9.152 7.64801C9.39733 7.88267 9.68 8.00001 10 8.00001ZM5.2 8.00001C5.52 8.00001 5.79733 7.88267 6.032 7.64801C6.27733 7.40267 6.4 7.12001 6.4 6.80001C6.4 6.48001 6.27733 6.20267 6.032 5.96801C5.79733 5.72267 5.52 5.60001 5.2 5.60001C4.88 5.60001 4.59733 5.72267 4.352 5.96801C4.11733 6.20267 4 6.48001 4 6.80001C4 7.12001 4.11733 7.40267 4.352 7.64801C4.59733 7.88267 4.88 8.00001 5.2 8.00001ZM13.584 7.93601C13.584 7.97867 13.584 8.05334 13.584 8.16001L13.6 8.40001C13.6 9.48801 13.328 10.496 12.784 11.424C12.2507 12.3307 11.5307 13.0507 10.624 13.584C9.696 14.128 8.688 14.4 7.6 14.4C6.512 14.4 5.504 14.128 4.576 13.584C3.66933 13.0507 2.94933 12.3307 2.416 11.424C1.872 10.496 1.6 9.48801 1.6 8.40001C1.6 7.31201 1.872 6.30401 2.416 5.37601C2.94933 4.46934 3.66933 3.74934 4.576 3.21601C5.504 2.67201 6.512 2.40001 7.6 2.40001L8.064 2.41601C8.17067 1.84001 8.352 1.32801 8.608 0.880006C8.23467 0.826673 7.89867 0.800006 7.6 0.800006C6.224 0.800006 4.944 1.14667 3.76 1.84001C2.61867 2.51201 1.712 3.41867 1.04 4.56001C0.346667 5.74401 0 7.02401 0 8.40001C0 9.77601 0.346667 11.056 1.04 12.24C1.712 13.3813 2.61867 14.288 3.76 14.96C4.944 15.6533 6.224 16 7.6 16C8.976 16 10.256 15.6533 11.44 14.96C12.5813 14.288 13.488 13.3813 14.16 12.24C14.8533 11.056 15.2 9.77601 15.2 8.40001C15.2 8.10134 15.1733 7.76534 15.12 7.39201C14.672 7.64801 14.16 7.82934 13.584 7.93601ZM12 5.72205e-06H13.6V2.40001H16V4.00001H13.6V6.40001H12V4.00001H9.6V2.40001H12V5.72205e-06ZM3.504 10C3.83467 10.832 4.36267 11.504 5.088 12.016C5.84533 12.5387 6.68267 12.8 7.6 12.8C8.51733 12.8 9.35467 12.5387 10.112 12.016C10.8373 11.504 11.3653 10.832 11.696 10H3.504Z'/>
            </svg>
        </span>
    );
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/* eslint-disable react/no-string-refs */

import React from 'react';
import {FormattedMessage} from 'react-intl';

import Permissions from 'mattermost-redux/constants/permissions';
import {Post} from '@mattermost/types/posts';
import {Reaction as ReactionType} from '@mattermost/types/reactions';
import {Emoji} from '@mattermost/types/emojis';
import {isSystemEmoji} from 'mattermost-redux/utils/emoji_utils';

import Constants from 'utils/constants';
import Reaction from 'components/post_view/reaction';
import EmojiPickerOverlay from 'components/emoji_picker/emoji_picker_overlay';
import AddReactionIcon from 'components/widgets/icons/add_reaction_icon';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import ChannelPermissionGate from 'components/permissions_gates/channel_permission_gate';
import {localizeMessage} from 'utils/utils';

const DEFAULT_EMOJI_PICKER_RIGHT_OFFSET = 15;
const EMOJI_PICKER_WIDTH_OFFSET = 260;

type Props = {

    /**
     * The post to render reactions for
     */
    post: Post;

    /*
     * The id of the team which belongs the post
     */
    teamId: string;

    /**
     * The reactions to render
     */
    reactions: { [x: string]: ReactionType } | undefined | null;

    /**
     * Whether or not the user can add reactions to this post.
     */
    canAddReactions: boolean;

    actions: {

        /**
         * Function to add a reaction to the post
         */
        addReaction: (postId: string, emojiName: string) => void;
    };
};

type State = {
    emojiNames: string[];
    showEmojiPicker: boolean;
};

export default class ReactionList extends React.PureComponent<Props, State> {
    private addReactionButtonRef = React.createRef<HTMLButtonElement>();

    constructor(props: Props) {
        super(props);

        this.state = {
            emojiNames: [],
            showEmojiPicker: false,
        };
    }

    static getDerivedStateFromProps(props: Props, state: State): Partial<State> | null {
        let emojiNames = state.emojiNames;

        for (const {emoji_name: emojiName} of Object.values(props.reactions ?? {})) {
            if (!emojiNames.includes(emojiName)) {
                emojiNames = [...emojiNames, emojiName];
            }
        }

        return (emojiNames === state.emojiNames) ? null : {emojiNames};
    }

    getTarget = (): HTMLButtonElement | null => {
        return this.addReactionButtonRef.current;
    }

    handleEmojiClick = (emoji: Emoji): void => {
        this.setState({showEmojiPicker: false});
        const emojiName = isSystemEmoji(emoji) ? emoji.short_names[0] : emoji.name;
        this.props.actions.addReaction(this.props.post.id, emojiName);
    }

    hideEmojiPicker = (): void => {
        this.setState({showEmojiPicker: false});
    }

    toggleEmojiPicker = (e?: React.MouseEvent<HTMLButtonElement, MouseEvent>): void => {
        e?.stopPropagation();
        this.setState({showEmojiPicker: !this.state.showEmojiPicker});
    }

    render(): React.ReactNode {
        const reactionsByName = new Map();

        if (this.props.reactions) {
            for (const reaction of Object.values(this.props.reactions)) {
                const emojiName = reaction.emoji_name;

                if (reactionsByName.has(emojiName)) {
                    reactionsByName.get(emojiName).push(reaction);
                } else {
                    reactionsByName.set(emojiName, [reaction]);
                }
            }
        }

        if (reactionsByName.size === 0) {
            return null;
        }

        const reactions = this.state.emojiNames.map((emojiName) => {
            if (reactionsByName.has(emojiName)) {
                return (
                    <Reaction
                        key={emojiName}
                        post={this.props.post}
                        emojiName={emojiName}
                        reactions={reactionsByName.get(emojiName) || []}
                    />
                );
            }
            return null;
        });

        const addReactionButton = this.getTarget();
        let rightOffset = DEFAULT_EMOJI_PICKER_RIGHT_OFFSET;
        if (addReactionButton) {
            rightOffset = window.innerWidth - addReactionButton.getBoundingClientRect().right - EMOJI_PICKER_WIDTH_OFFSET;

            if (rightOffset < 0) {
                rightOffset = DEFAULT_EMOJI_PICKER_RIGHT_OFFSET;
            }
        }

        let emojiPicker = null;
        if (this.props.canAddReactions) {
            const addReactionTooltip = (
                <Tooltip id='addReactionTooltip'>
                    <FormattedMessage
                        id='reaction_list.addReactionTooltip'
                        defaultMessage='Add a reaction'
                    />
                </Tooltip>
            );

            emojiPicker = (
                <span className='emoji-picker__container'>
                    <EmojiPickerOverlay
                        show={this.state.showEmojiPicker}
                        target={this.getTarget}
                        onHide={this.hideEmojiPicker}
                        onEmojiClick={this.handleEmojiClick}
                        rightOffset={rightOffset}
                        topOffset={-5}
                    />
                    <ChannelPermissionGate
                        channelId={this.props.post.channel_id}
                        teamId={this.props.teamId}
                        permissions={[Permissions.ADD_REACTION]}
                    >
                        <OverlayTrigger
                            placement='top'
                            delayShow={Constants.OVERLAY_TIME_DELAY}
                            overlay={addReactionTooltip}
                        >
                            <button
                                aria-label={localizeMessage('reaction.add.ariaLabel', 'Add a reaction')}
                                className='Reaction'
                                onClick={this.toggleEmojiPicker}
                            >
                                <span
                                    id={`addReaction-${this.props.post.id}`}
                                    className='Reaction__add'
                                    ref={this.addReactionButtonRef}
                                >
                                    <AddReactionIcon/>
                                </span>
                            </button>
                        </OverlayTrigger>
                    </ChannelPermissionGate>
                </span>
            );
        }

        let addReactionClassName = 'post-add-reaction';
        if (this.state.showEmojiPicker) {
            addReactionClassName += ' post-add-reaction-emoji-picker-open';
        }

        return (
            <div
                aria-label={localizeMessage('reaction.container.ariaLabel', 'reactions')}
                className='post-reaction-list'
            >
                {reactions}
                <div className={addReactionClassName}>
                    {emojiPicker}
                </div>
            </div>
        );
    }
}
/* eslint-enable react/no-string-refs */

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {getChannel} from 'mattermost-redux/selectors/entities/channels';
import {canAddReactions} from 'mattermost-redux/selectors/entities/reactions';

import {GenericAction} from 'mattermost-redux/types/actions';
import {Post} from '@mattermost/types/posts';

import {GlobalState} from 'types/store';

import {addReaction} from 'actions/post_actions';

import {makeGetUniqueReactionsToPost} from 'utils/post_utils';

import ReactionList from './reaction_list';

type Props = {
    post: Post;
};

function makeMapStateToProps() {
    const getReactionsForPost = makeGetUniqueReactionsToPost();

    return function mapStateToProps(state: GlobalState, ownProps: Props) {
        const channelId = ownProps.post.channel_id;

        const channel = getChannel(state, channelId);
        const teamId = channel?.team_id ?? '';

        return {
            teamId,
            reactions: getReactionsForPost(state, ownProps.post.id),
            canAddReactions: canAddReactions(state, channelId),
        };
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            addReaction,
        }, dispatch),
    };
}

export default connect(makeMapStateToProps, mapDispatchToProps)(ReactionList);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/* eslint-disable react/no-string-refs */

import React from 'react';

import {localizeMessage} from 'utils/utils';

export type AttachmentTextOverflowType = 'ellipsis';

const MAX_POST_HEIGHT = 600;
const MARGIN_CHANGE_FOR_COMPACT_POST = 22;

type Props = {
    children?: React.ReactNode;
    checkOverflow?: number;
    isAttachmentText?: boolean;
    isRHSExpanded: boolean;
    isRHSOpen: boolean;
    text?: string;
    compactDisplay: boolean;
    overflowType?: AttachmentTextOverflowType;
    maxHeight?: number;
}

type State = {
    isCollapsed: boolean;
    isOverflow: boolean;
}

export default class ShowMore extends React.PureComponent<Props, State> {
    private maxHeight: number;
    private textContainer: React.RefObject<HTMLDivElement>;
    private overflowRef?: number;

    constructor(props: Props) {
        super(props);
        this.maxHeight = this.props.maxHeight || MAX_POST_HEIGHT;
        this.textContainer = React.createRef();
        this.state = {
            isCollapsed: true,
            isOverflow: false,
        };
    }

    componentDidMount() {
        this.checkTextOverflow();

        window.addEventListener('resize', this.handleResize);
    }

    componentDidUpdate(prevProps: Props) {
        if (
            this.props.text !== prevProps.text ||
            this.props.isRHSExpanded !== prevProps.isRHSExpanded ||
            this.props.isRHSOpen !== prevProps.isRHSOpen ||
            this.props.checkOverflow !== prevProps.checkOverflow
        ) {
            this.checkTextOverflow();
        }
    }

    componentWillUnmount() {
        window.removeEventListener('resize', this.handleResize);
        if (this.overflowRef) {
            window.cancelAnimationFrame(this.overflowRef);
        }
    }

    toggleCollapse = (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {
        e.preventDefault();
        e.stopPropagation();
        this.setState((prevState) => {
            return {
                isCollapsed: !prevState.isCollapsed,
            };
        });
    };

    checkTextOverflow = () => {
        if (this.overflowRef) {
            window.cancelAnimationFrame(this.overflowRef);
        }
        this.overflowRef = window.requestAnimationFrame(() => {
            let isOverflow = false;

            if (this.textContainer.current && this.textContainer.current.scrollHeight > this.maxHeight) {
                isOverflow = true;
            }

            if (isOverflow !== this.state.isOverflow) {
                this.setState({
                    isOverflow,
                });
            }
        });
    };

    handleResize = () => {
        this.checkTextOverflow();
    };

    render() {
        const {
            isCollapsed,
            isOverflow,
        } = this.state;

        const {
            children,
            isAttachmentText,
            compactDisplay,
            overflowType,
        } = this.props;

        let className = 'post-message';
        let collapsedMaxHeightStyle: number | undefined;
        if (isCollapsed) {
            collapsedMaxHeightStyle = this.maxHeight;
            className += ' post-message--collapsed';
        } else {
            className += ' post-message--expanded';
        }

        const collapseGradientClass = isAttachmentText ? 'post-attachment-collapse__gradient' : 'post-collapse__gradient';
        const collapseShowMoreClass = isAttachmentText ? 'post-attachment-collapse__show-more' : 'post-collapse__show-more';

        let attachmentTextOverflow = null;
        if (isOverflow) {
            if (!isAttachmentText && isCollapsed && compactDisplay) {
                if (collapsedMaxHeightStyle) {
                    collapsedMaxHeightStyle -= MARGIN_CHANGE_FOR_COMPACT_POST;
                }
            }

            let showIcon = 'fa fa-angle-up';
            let showText = localizeMessage('post_info.message.show_less', 'Show less');
            if (isCollapsed) {
                showIcon = 'fa fa-angle-down';
                showText = localizeMessage('post_info.message.show_more', 'Show more');
            }
            switch (overflowType) {
            case 'ellipsis':
                attachmentTextOverflow = (
                    <button
                        id='showMoreButton'
                        className='post-preview-collapse__show-more-button color--link'
                        onClick={this.toggleCollapse}
                    >
                        {showText}
                    </button>
                );
                className += ' post-message-preview--overflow';
                break;

            default:
                attachmentTextOverflow = (
                    <div className='post-collapse'>
                        <div
                            id='collapseGradient'
                            className={collapseGradientClass}
                        />
                        <div className={collapseShowMoreClass}>
                            <div className='post-collapse__show-more-line'/>
                            <button
                                id='showMoreButton'
                                className='post-collapse__show-more-button'
                                onClick={this.toggleCollapse}
                            >
                                <span className={showIcon}/>
                                {showText}
                            </button>
                            <div className='post-collapse__show-more-line'/>
                        </div>
                    </div>
                );
                className += ' post-message--overflow';
                break;
            }
        }

        return (
            <div className={className}>
                <div
                    style={{maxHeight: collapsedMaxHeightStyle}}
                    className='post-message__text-container'
                    ref={this.textContainer}
                >
                    {children}
                </div>
                {attachmentTextOverflow}
            </div>
        );
    }
}
/* eslint-enable react/no-string-refs */

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {get} from 'mattermost-redux/selectors/entities/preferences';

import {getIsRhsExpanded, getIsRhsOpen} from 'selectors/rhs';
import {Preferences} from 'utils/constants';

import {GlobalState} from 'types/store';

import ShowMore from './show_more';

function mapStateToProps(state: GlobalState) {
    return {
        isRHSExpanded: getIsRhsExpanded(state),
        isRHSOpen: getIsRhsOpen(state),
        compactDisplay: get(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.MESSAGE_DISPLAY, Preferences.MESSAGE_DISPLAY_DEFAULT) === Preferences.MESSAGE_DISPLAY_COMPACT,
    };
}

export default connect(mapStateToProps)(ShowMore);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import './description.scss';

type Props = {
    children: React.ReactNode | React.ReactNodeArray;
}

const Description = (props: Props) => {
    return (<p className='PreparingWorkspaceDescription'>
        {props.children}
    </p>);
};

export default Description;

export default __webpack_public_path__ + "files/bc39a70bb1048e5a929335dd8e40d958.apng";
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState, useEffect} from 'react';
import {useDispatch} from 'react-redux';
import {CSSTransition} from 'react-transition-group';
import {FormattedMessage} from 'react-intl';

import {GeneralTypes} from 'mattermost-redux/action_types';

import LogoSvg from 'components/common/svg_images_components/logo_dark_blue_svg';

import loadingIcon from 'images/spinner-48x48-blue.apng';

import Title from './title';
import Description from './description';
import {Animations, mapAnimationReasonToClass, PreparingWorkspacePageProps} from './steps';

import './launching_workspace.scss';

type Props = PreparingWorkspacePageProps & {
    fullscreen?: boolean;
    zIndex?: number;
};

// Want to make sure background channels has rendered to limit animation jank,
// including things like tour tips auto-showing
export const START_TRANSITIONING_OUT = 500;
const TRANSITION_DURATION = 500;

// needs to be on top. Current known highest is tour tip at 1000
export const LAUNCHING_WORKSPACE_FULLSCREEN_Z_INDEX = 1001;

function LaunchingWorkspace(props: Props) {
    const [hasEntered, setHasEntered] = useState(false);
    const dispatch = useDispatch();
    useEffect(() => {
        // This component is showed in both the preparing workspace route as an outro (!fullscreen)
        // and in the main webapp as an intro (fullscreen)
        // We only want to track the page view once
        if (!props.fullscreen && props.show) {
            props.onPageView();
        }
    }, [props.show, props.fullscreen]);

    useEffect(() => {
        if (hasEntered) {
            return;
        }
        if (!props.fullscreen) {
            return;
        }
        setTimeout(() => {
            setHasEntered(true);

            // Needs to happen after animation time plays out
            setTimeout(() => {
                dispatch({type: GeneralTypes.SHOW_LAUNCHING_WORKSPACE, open: false});
            }, TRANSITION_DURATION);
        }, START_TRANSITIONING_OUT);
    }, [hasEntered, props.fullscreen]);

    let bodyClass = 'LaunchingWorkspace-body';
    if (!props.fullscreen) {
        bodyClass += ' LaunchingWorkspace-body--non-fullscreen';
    }
    const body = (
        <div className={bodyClass}>
            <div className='LaunchingWorkspace__spinner'>
                <img
                    src={loadingIcon}
                />
            </div>
            <Title>
                <FormattedMessage
                    id='onboarding_wizard.launching_workspace.title'
                    defaultMessage='Launching your workspace now'
                />
            </Title>
            <Description>
                <FormattedMessage
                    id='onboarding_wizard.launching_workspace.description'
                    defaultMessage='Itll be ready in a moment'
                />
            </Description>
        </div>
    );

    let content = null;
    if (props.fullscreen) {
        content = (
            <CSSTransition
                in={props.show && !hasEntered}
                timeout={TRANSITION_DURATION}
                classNames={'LaunchingWorkspaceFullscreenWrapper'}
                exit={true}
                enter={false}
                mountOnEnter={true}
                unmountOnExit={true}
            >
                <div
                    className='LaunchingWorkspaceFullscreenWrapper-body'
                    style={{
                        zIndex: props.zIndex,
                    }}
                >
                    <div className='LaunchingWorkspaceFullscreenWrapper__logo'>
                        <LogoSvg/>
                    </div>
                    {body}
                </div>
            </CSSTransition>

        );
    } else {
        content = (
            <CSSTransition
                in={props.show}
                timeout={Animations.PAGE_SLIDE}
                classNames={mapAnimationReasonToClass('LaunchingWorkspace', props.transitionDirection)}
                mountOnEnter={true}
                unmountOnExit={true}
            >
                {body}
            </CSSTransition>
        );
    }
    return content;
}

export default LaunchingWorkspace;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import deepFreeze from 'mattermost-redux/utils/deep_freeze';

export const WizardSteps = {
    Plugins: 'Plugins',
    LaunchingWorkspace: 'LaunchingWorkspace',
} as const;

export const Animations = {
    PAGE_SLIDE: 300,
    Reasons: {
        EnterFromBefore: 'EnterFromBefore',
        EnterFromAfter: 'EnterFromAfter',
        ExitToBefore: 'ExitToBefore',
        ExitToAfter: 'ExitToAfter',
    } as const,
};

export function mapStepToNextName(step: WizardStep): string {
    switch (step) {
    case WizardSteps.Plugins:
        return 'admin_onboarding_next_plugins';
    case WizardSteps.LaunchingWorkspace:
        return 'admin_onboarding_next_transitioning_out';
    default:
        return 'admin_onboarding_next_unknown';
    }
}

export function mapStepToPrevious(step: WizardStep): string {
    switch (step) {
    case WizardSteps.Plugins:
        return 'admin_onboarding_previous_plugins';
    case WizardSteps.LaunchingWorkspace:
        return 'admin_onboarding_previous_transitioning_out';
    default:
        return 'admin_onboarding_previous_unknown';
    }
}

export function mapStepToPageView(step: WizardStep): string {
    switch (step) {
    case WizardSteps.Plugins:
        return 'pageview_admin_onboarding_plugins';
    case WizardSteps.LaunchingWorkspace:
        return 'pageview_admin_onboarding_transitioning_out';
    default:
        return 'pageview_admin_onboarding_unknown';
    }
}

export function mapStepToSubmitFail(step: WizardStep): string {
    switch (step) {
    case WizardSteps.Plugins:
        return 'admin_onboarding_plugins_submit_fail';
    case WizardSteps.LaunchingWorkspace:
        return 'admin_onboarding_transitioning_out_submit_fail';
    default:
        return 'admin_onboarding_unknown_submit_fail';
    }
}

export function mapStepToSkipName(step: WizardStep): string {
    switch (step) {
    case WizardSteps.Plugins:
        return 'admin_onboarding_skip_plugins';
    case WizardSteps.LaunchingWorkspace:
        return 'admin_onboarding_skip_transitioning_out';
    default:
        return 'admin_onboarding_skip_unknown';
    }
}

export type AnimationReason = typeof Animations['Reasons'][keyof typeof Animations['Reasons']];

export type WizardStep = typeof WizardSteps[keyof typeof WizardSteps];

export function mapAnimationReasonToClass(classPrefix: string, animationReason: AnimationReason): string {
    switch (animationReason) {
    case Animations.Reasons.ExitToBefore:
        return `${classPrefix}--exit-to-before`;
    case Animations.Reasons.ExitToAfter:
        return `${classPrefix}--exit-to-after`;
    case Animations.Reasons.EnterFromAfter:
        return `${classPrefix}--enter-from-after`;
    case Animations.Reasons.EnterFromBefore:
        return `${classPrefix}--enter-from-before`;
    default:
        return `${classPrefix}--enter-from-before`;
    }
}

type PluginNameMap = {
    [Key in keyof Omit<Form['plugins'], 'skipped'>]: string
};
export const PLUGIN_NAME_TO_ID_MAP: PluginNameMap = {
    github: 'github',
    gitlab: 'com.github.manland.mattermost-plugin-gitlab',
    jira: 'jira',
    zoom: 'zoom',
    todo: 'com.mattermost.plugin-todo',
} as const;

export type Form = {
    organization?: string;
    url?: string;
    urlSkipped: boolean;
    inferredProtocol: 'http' | 'https' | null;
    useCase: {
        boards: boolean;
        playbooks: boolean;
        channels: boolean;
    };
    plugins: {
        github: boolean;
        gitlab: boolean;
        jira: boolean;
        zoom: boolean;
        todo: boolean;

        // set if user clicks skip for now
        skipped: boolean;
    };
    channel: {
        name: string;
        skipped: boolean;
    };
    teamMembers: {
        invites: string[];
        skipped: boolean;
    };
}

export const emptyForm = deepFreeze({
    inferredProtocol: null,
    urlSkipped: false,
    useCase: {
        boards: false,
        playbooks: false,
        channels: false,
    },
    plugins: {
        github: false,
        gitlab: false,
        jira: false,
        zoom: false,
        todo: false,

        // set if user clicks skip for now
        skipped: false,
    },
    channel: {
        name: '',
        skipped: false,
    },
    teamMembers: {
        invites: [],
        skipped: false,
    },
});

export type PreparingWorkspacePageProps = {
    transitionDirection: AnimationReason;
    next?: () => void;
    skip?: () => void;
    previous?: JSX.Element;
    show: boolean;
    onPageView: () => void;
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import './title.scss';

type Props = {
    children: React.ReactNode | React.ReactNodeArray;
}
const Title = (props: Props) => {
    return (<h1 className='PreparingWorkspaceTitle'>
        {props.children}
    </h1>);
};

export default Title;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {useDispatch, useSelector} from 'react-redux';

import {getSubscriptionProduct} from 'mattermost-redux/selectors/entities/cloud';

import PaymentSuccessStandardSvg from 'components/common/svg_images_components/payment_success_standard_svg';

import IconMessage from 'components/purchase_modal/icon_message';

import FullScreenModal from 'components/widgets/modals/full_screen_modal';

import {closeModal} from 'actions/views/modals';
import {ModalIdentifiers} from 'utils/constants';
import {isModalOpen} from 'selectors/views/modals';
import {GlobalState} from 'types/store';

import './style.scss';

type Props = {
    onHide?: () => void;
};

function SuccessModal(props: Props) {
    const dispatch = useDispatch();
    const subscriptionProduct = useSelector(getSubscriptionProduct);

    const isSuccessModalOpen = useSelector((state: GlobalState) =>
        isModalOpen(state, ModalIdentifiers.SUCCESS_MODAL),
    );

    const onHide = () => {
        dispatch(closeModal(ModalIdentifiers.SUCCESS_MODAL));
        if (typeof props.onHide === 'function') {
            props.onHide();
        }
    };

    return (
        <FullScreenModal
            show={isSuccessModalOpen}
            onClose={onHide}
        >
            <div className='cloud_subscribe_result_modal'>
                <IconMessage
                    formattedTitle={
                        <FormattedMessage
                            defaultMessage={
                                'You are now subscribed to {selectedProductName}'
                            }
                            id={
                                'admin.billing.subscription.proratedPayment.title'
                            }
                            values={{
                                selectedProductName: subscriptionProduct?.name,
                            }}
                        />
                    }
                    formattedSubtitle={
                        <FormattedMessage
                            id={'success_modal.subtitle'}
                            defaultMessage={
                                'Your final bill will be prorated. Your workspace now has {plan} limits.'
                            }
                            values={{plan: subscriptionProduct?.name}}
                        />
                    }
                    error={false}
                    icon={
                        <PaymentSuccessStandardSvg
                            width={444}
                            height={313}
                        />
                    }
                    formattedButtonText={
                        <FormattedMessage
                            defaultMessage={'Return to workspace'}
                            id={'success_modal.return_to_workspace'}
                        />
                    }
                    buttonHandler={onHide}
                    className={'success'}
                />
            </div>
        </FullScreenModal>
    );
}

export default SuccessModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {useDispatch, useSelector} from 'react-redux';

import {getSubscriptionProduct} from 'mattermost-redux/selectors/entities/cloud';

import PaymentFailedSvg from 'components/common/svg_images_components/payment_failed_svg';

import IconMessage from 'components/purchase_modal/icon_message';

import FullScreenModal from 'components/widgets/modals/full_screen_modal';
import useOpenSalesLink from 'components/common/hooks/useOpenSalesLink';

import {InquiryType} from 'selectors/cloud';
import {closeModal} from 'actions/views/modals';
import {ModalIdentifiers} from 'utils/constants';
import {isModalOpen} from 'selectors/views/modals';
import {GlobalState} from 'types/store';

import './style.scss';

type Props = {
    onHide?: () => void;
    backButtonAction?: () => void;
};

function ErrorModal(props: Props) {
    const dispatch = useDispatch();
    const subscriptionProduct = useSelector(getSubscriptionProduct);
    const openContactUs = useOpenSalesLink(undefined, InquiryType.Technical);

    const isSuccessModalOpen = useSelector((state: GlobalState) =>
        isModalOpen(state, ModalIdentifiers.ERROR_MODAL),
    );

    const onBackButtonPress = () => {
        if (props.backButtonAction) {
            props.backButtonAction();
        }
        dispatch(closeModal(ModalIdentifiers.ERROR_MODAL));
    };

    const onHide = () => {
        dispatch(closeModal(ModalIdentifiers.ERROR_MODAL));
        if (typeof props.onHide === 'function') {
            props.onHide();
        }
    };

    return (
        <FullScreenModal
            show={isSuccessModalOpen}
            onClose={onHide}
        >
            <div className='cloud_subscribe_result_modal'>
                <IconMessage
                    formattedTitle={
                        <FormattedMessage
                            defaultMessage={'We were unable to change your plan'}
                            id={'error_modal.title'}
                            values={{
                                selectedProductName: subscriptionProduct?.name,
                            }}
                        />
                    }
                    formattedSubtitle={
                        <FormattedMessage
                            id={'error_modal.subtitle'}
                            defaultMessage={
                                'An error occurred while changing your plan. Please go back and try again, or contact the support team.'
                            }
                            values={{plan: subscriptionProduct?.name}}
                        />
                    }
                    error={true}
                    icon={
                        <PaymentFailedSvg
                            width={444}
                            height={313}
                        />
                    }
                    formattedButtonText={
                        <FormattedMessage
                            defaultMessage={'Try again'}
                            id={'error_modal.try_again'}
                        />
                    }
                    formattedTertiaryButonText={
                        <FormattedMessage
                            defaultMessage={'Contact Support'}
                            id={
                                'admin.billing.subscription.privateCloudCard.contactSupport'
                            }
                        />
                    }
                    tertiaryButtonHandler={openContactUs}
                    buttonHandler={onBackButtonPress}
                    className={'success'}
                />
            </div>
        </FullScreenModal>
    );
}

export default ErrorModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

export default function CheckMarkSvg() {
    return (
        <svg
            width='16'
            height='16'
            viewBox='0 0 16 16'
            fill='none'
            xmlns='http://www.w3.org/2000/svg'
        >
            <path
                d='M8 0.493804C6.644 0.493804 5.384 0.835804 4.22 1.5198C3.08 2.1798 2.18 3.0798 1.52 4.2198C0.836 5.3838 0.494 6.6438 0.494 7.9998C0.494 9.3558 0.836 10.6158 1.52 11.7798C2.18 12.9198 3.08 13.8198 4.22 14.4798C5.384 15.1638 6.644 15.5058 8 15.5058C9.356 15.5058 10.616 15.1638 11.78 14.4798C12.92 13.8198 13.82 12.9198 14.48 11.7798C15.164 10.6158 15.506 9.3558 15.506 7.9998C15.506 6.6438 15.164 5.3838 14.48 4.2198C13.82 3.0798 12.92 2.1798 11.78 1.5198C10.616 0.835804 9.356 0.493804 8 0.493804ZM6.686 11.5098L5.624 10.4658L3.5 8.3418L4.562 7.2798L6.686 9.4038L11.456 4.6158L12.518 5.6778L6.686 11.5098Z'
                fill='#3DB887'
            />
        </svg>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import IconMessage from 'components/purchase_modal/icon_message';
import './icon_message_with_progress_bar.scss';

export const enum ProcessState {
    PROCESSING = 0,
    SUCCESS,
    FAILED,
}

type PageCopy = {
    title: string;
    subtitle: string;
    icon: JSX.Element;
    buttonText?: string;
    linkText?: string;
}

type Props = {
    processingState: ProcessState;
    progress: number;
    successPage: () => JSX.Element;
    processingCopy: PageCopy;
    failedCopy: PageCopy;
    handleGoBack: () => void;
    error: boolean;
}

export default function IconMessageWithProgressBar({processingState, progress, successPage, handleGoBack, error, processingCopy, failedCopy}: Props) {
    const progressBar: JSX.Element | null = (
        <div className='IconMessageWithProgressBar-progress'>
            <div
                className='IconMessageWithProgressBar-progress-fill'
                style={{width: `${progress}%`}}
            />
        </div>
    );

    switch (processingState) {
    case ProcessState.PROCESSING:
        return (
            <IconMessage
                footer={progressBar}
                className={'processing'}
                {...processingCopy}
            />
        );
    case ProcessState.SUCCESS:
        return successPage();
    case ProcessState.FAILED:
        return (
            <IconMessage
                {...failedCopy}
                error={error}
                buttonHandler={handleGoBack}
                className={'failed'}
            />
        );
    default:
        return null;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState, useEffect, useRef} from 'react';
import {FormattedMessage} from 'react-intl';
import {RouteComponentProps, withRouter} from 'react-router-dom';
import {useSelector, useDispatch} from 'react-redux';

import {ModalIdentifiers} from 'utils/constants';
import {GlobalState} from 'types/store';
import {subscribeCloudSubscription} from 'actions/cloud';
import {closeModal} from 'actions/views/modals';
import {Team} from '@mattermost/types/teams';
import {Product} from '@mattermost/types/cloud';
import {t} from 'utils/i18n';
import {isModalOpen} from 'selectors/views/modals';
import FullScreenModal from 'components/widgets/modals/full_screen_modal';
import CreditCardSvg from 'components/common/svg_images_components/credit_card_svg';
import PaymentSuccessStandardSvg from 'components/common/svg_images_components/payment_success_standard_svg';
import PaymentFailedSvg from 'components/common/svg_images_components/payment_failed_svg';
import IconMessage from 'components/purchase_modal/icon_message';
import ProgressBar, {ProcessState} from 'components/icon_message_with_progress_bar';
import {
    archiveAllTeamsExcept,
} from 'mattermost-redux/actions/teams';

type Props = RouteComponentProps & {
    onBack: () => void;
    onClose?: () => void;
    teamToKeep?: Team;
    selectedProduct?: Product | null | undefined;
};

const MIN_PROCESSING_MILLISECONDS = 8000;
const MAX_FAKE_PROGRESS = 95;

function CloudSubscribeWithLoad(props: Props) {
    const intervalId = useRef<NodeJS.Timeout>({} as NodeJS.Timeout);
    const [progress, setProgress] = useState(0);
    const dispatch = useDispatch();
    const [error, setError] = useState(false);
    const [processingState, setProcessingState] = useState(ProcessState.PROCESSING);
    const modalOpen = useSelector((state: GlobalState) =>
        isModalOpen(state, ModalIdentifiers.CLOUD_SUBSCRIBE_WITH_LOADING_MODAL),
    );
    useEffect(() => {
        handleSubscribe();
        intervalId.current = setInterval(
            updateProgress,
            MIN_PROCESSING_MILLISECONDS / MAX_FAKE_PROGRESS,
        );
    }, []);

    const handleSubscribe = async () => {
        const start = new Date();
        if (props.teamToKeep) {
            await dispatch(archiveAllTeamsExcept(props.teamToKeep.id));
        }

        const productUpdated = await dispatch(subscribeCloudSubscription(
            props.selectedProduct?.id as string,
        ));

        // the action subscribeCloudSubscription returns a true boolean when successful and an error when it fails
        if (typeof productUpdated !== 'boolean') {
            setError(true);
            setProcessingState(ProcessState.FAILED);
            return;
        }

        const end = new Date();
        const millisecondsElapsed = end.valueOf() - start.valueOf();
        if (millisecondsElapsed < MIN_PROCESSING_MILLISECONDS) {
            setTimeout(
                completeSubscribe,
                MIN_PROCESSING_MILLISECONDS - millisecondsElapsed,
            );
            return;
        }
        completeSubscribe();
    };

    const completeSubscribe = () => {
        clearInterval(intervalId.current);
        setProcessingState(ProcessState.SUCCESS);
        setProgress(100);
    };

    const updateProgress = () => {
        setProgress((progress) => {
            if (progress >= MAX_FAKE_PROGRESS) {
                clearInterval(intervalId.current);
            }
            return progress + 3 > MAX_FAKE_PROGRESS ? MAX_FAKE_PROGRESS : progress + 3;
        },
        );
    };

    const handleGoBack = () => {
        clearInterval(intervalId.current);
        setProgress(0);
        setError(false);
        setProcessingState(ProcessState.PROCESSING);
        props.onBack();
    };

    const handleClose = () => {
        dispatch(
            closeModal(
                ModalIdentifiers.CLOUD_SUBSCRIBE_WITH_LOADING_MODAL,
            ),
        );
        if (typeof props.onClose === 'function') {
            props.onClose();
        }
    };

    const successPage = () => {
        const formattedBtnText = (
            <FormattedMessage
                defaultMessage='Return to {team}'
                id='admin.billing.subscription.returnToTeam'
                values={{team: props.teamToKeep?.display_name}}
            />
        );
        const productName = props.selectedProduct?.name;
        const title = (
            <FormattedMessage
                id={'admin.billing.subscription.downgradedSuccess'}
                defaultMessage={"You're now subscribed to {productName}"}
                values={{productName}}
            />
        );

        const formattedSubtitle = (
            <FormattedMessage
                id='success_modal.subtitle'
                defaultMessage='Your final bill will be prorated. Your workspace now has {plan} limits.'
                values={{plan: productName}}
            />
        );
        return (
            <IconMessage
                formattedTitle={title}
                formattedSubtitle={formattedSubtitle}
                error={error}
                icon={
                    <PaymentSuccessStandardSvg
                        width={444}
                        height={313}
                    />
                }
                formattedButtonText={formattedBtnText}
                buttonHandler={handleClose}
                className={'success'}
                tertiaryBtnText={t('admin.billing.subscription.viewBilling')}
                tertiaryButtonHandler={() => {
                    handleClose();
                    props.history.push('/admin_console/billing/subscription');
                }}
            />
        );
    };

    return (
        <FullScreenModal
            show={modalOpen}
            onClose={handleClose}
        >
            <div className='loading-modal'>
                <ProgressBar
                    processingState={processingState}
                    processingCopy={{
                        title: t('admin.billing.subscription.downgrading'),
                        subtitle: '',
                        icon: (
                            <CreditCardSvg
                                width={444}
                                height={313}
                            />
                        ),
                    }}
                    failedCopy={{
                        title: t('admin.billing.subscription.paymentVerificationFailed'),
                        subtitle: t('admin.billing.subscription.paymentFailed'),
                        icon: (
                            <PaymentFailedSvg
                                width={444}
                                height={313}
                            />
                        ),
                        buttonText: t('admin.billing.subscription.goBackTryAgain'),
                        linkText:
                            t('admin.billing.subscription.constCloudCard.contactSupport'),
                    }}
                    progress={progress}
                    successPage={successPage}
                    handleGoBack={handleGoBack}
                    error={error}
                />
            </div>
        </FullScreenModal>
    );
}

export default withRouter(CloudSubscribeWithLoad);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useState} from 'react';
import {FormattedMessage, useIntl} from 'react-intl';
import {isEmpty} from 'lodash';
import {Modal} from 'react-bootstrap';

import {useDispatch, useSelector} from 'react-redux';

import {Team} from '@mattermost/types/teams';
import {Product} from '@mattermost/types/cloud';
import {t} from 'utils/i18n';
import RadioButtonGroup from 'components/common/radio_group';
import DropdownInput, {ValueType} from 'components/dropdown_input';
import CloudSubscribeWithLoadingModal from 'components/cloud_subscribe_with_loading_modal';
import useGetUsage from 'components/common/hooks/useGetUsage';
import {getTeams} from 'mattermost-redux/actions/teams';
import {getActiveTeamsList} from 'mattermost-redux/selectors/entities/teams';
import {closeModal, openModal} from 'actions/views/modals';
import {ModalIdentifiers} from 'utils/constants';
import {isModalOpen} from 'selectors/views/modals';
import {GlobalState} from 'types/store';

import {fallbackStarterLimits, asGBString} from 'utils/limits';

import './downgrade_team_removal_modal.scss';

type Props = {
    product_id: string;
    starterProduct: Product | null | undefined;
};

function DowngradeTeamRemovalModal(props: Props) {
    const dispatch = useDispatch();
    const [radioValue, setRadioValue] = useState('');
    const [dropdownValue, setDropdownValue] = useState<ValueType | undefined>();

    const intl = useIntl();
    const isCloudDowngradeChooseTeamModalOpen = useSelector(
        (state: GlobalState) =>
            isModalOpen(state, ModalIdentifiers.CLOUD_DOWNGRADE_CHOOSE_TEAM),
    );

    const teams = useSelector(getActiveTeamsList);
    useEffect(() => {
        if (!teams) {
            dispatch(getTeams(0, 10000));
        }
    }, [teams]);
    const usage = useGetUsage();

    const onHide = () => {
        dispatch(closeModal(ModalIdentifiers.CLOUD_DOWNGRADE_CHOOSE_TEAM));
    };

    const onConfirmDowngrade = async () => {
        dispatch(closeModal(ModalIdentifiers.CLOUD_DOWNGRADE_CHOOSE_TEAM));
        dispatch(closeModal(ModalIdentifiers.PRICING_MODAL));
        const teamToKeep = getSelectedTeam();
        dispatch(openModal({
            modalId: ModalIdentifiers.CLOUD_SUBSCRIBE_WITH_LOADING_MODAL,
            dialogType: CloudSubscribeWithLoadingModal,
            dialogProps: {
                onBack: () => {
                    dispatch(
                        closeModal(
                            ModalIdentifiers.CLOUD_SUBSCRIBE_WITH_LOADING_MODAL,
                        ),
                    );
                    dispatch(
                        openModal({
                            modalId:
                                ModalIdentifiers.CLOUD_DOWNGRADE_CHOOSE_TEAM,
                            dialogType: DowngradeTeamRemovalModal,
                            dialogProps: {
                                product_id: props.starterProduct?.id || '',
                                starterProduct: props.starterProduct,
                            },
                        }),
                    );
                },
                teamToKeep,
                selectedProduct: props.starterProduct,
            },
        }));
    };

    const getSelectedTeam = () => {
        let teamIdToKeep = '';
        if (radioValue && !dropdownValue) {
            teamIdToKeep = radioValue;
        } else {
            teamIdToKeep = dropdownValue?.value || '';
        }
        return teams.find((team: Team) => team.id === teamIdToKeep);
    };

    const selectionSection = (teamsList: Team[]) => {
        if (usage.teams.active < 4) {
            return (
                <RadioButtonGroup
                    id='deleteTeamRadioGroup'
                    testId='deleteTeamRadioGroup'
                    values={teamsList.map((team) => {
                        return {
                            value: team.id,
                            key: team.display_name,
                            testId: team.id,
                        };
                    })}
                    value={radioValue}
                    onChange={(e) => setRadioValue(e.target.value)}
                />
            );
        }

        return (
            <DropdownInput
                testId='deleteTeamDropdownInput'
                onChange={setDropdownValue}
                legend={intl.formatMessage({
                    id: t('admin.channel_settings.channel_list.teamHeader'),
                    defaultMessage: 'Team',
                })}
                placeholder={intl.formatMessage({
                    id: t('downgrade_plan_modal.selectTeam'),
                    defaultMessage: 'Select team',
                })}
                value={dropdownValue}
                options={teamsList.map((team) => {
                    return {
                        label: team.display_name,
                        value: team.id,
                    };
                })}
            />
        );
    };

    return (
        <Modal
            className='DowngradeTeamRemovalModal'
            show={isCloudDowngradeChooseTeamModalOpen}
            backdropClassName={'downgrade-modal-backdrop'}
            id='downgradeTeamRemovalModal'
            onExited={onHide}
            data-testid='downgradeTeamRemovalModal'
            dialogClassName='a11y__modal'
            onHide={onHide}
            role='dialog'
            aria-modal='true'
            aria-labelledby='downgradeTeamRemovalModalTitle'
        >
            <>
                <Modal.Header className='DowngradeTeamRemovalModal__header'>
                    <FormattedMessage
                        id='downgrade_plan_modal.title'
                        defaultMessage='Confirm Plan Downgrade'
                    />
                    <button
                        id='closeIcon'
                        className='icon icon-close'
                        aria-label='Close'
                        title='Close'
                        onClick={onHide}
                    />
                </Modal.Header>
                <Modal.Body>
                    <div className='DowngradeTeamRemovalModal__body'>
                        <div>
                            <FormattedMessage
                                id='downgrade_plan_modal.subtitle'
                                defaultMessage='{planName} is restricted to {teams} team, {messages} messages, {storage} file storage, and {boards} board cards. <strong>If you downgrade, some data will be archived</strong>. Archived data can be accessible when you upgrade back'
                                values={{
                                    strong: (msg: React.ReactNode) => (
                                        <strong>{msg}</strong>
                                    ),
                                    planName: props.starterProduct?.name,
                                    messages: intl.formatNumber(
                                        fallbackStarterLimits.messages.
                                            history,
                                    ),
                                    storage: asGBString(
                                        fallbackStarterLimits.files.
                                            totalStorage,
                                        intl.formatNumber,
                                    ),
                                    boards: fallbackStarterLimits.boards.
                                        cards,
                                    teams: fallbackStarterLimits.teams.
                                        active,
                                }}
                            />
                        </div>
                        <div className='cta'>
                            <FormattedMessage
                                id='downgrade_plan_modal.whichTeamToUse'
                                defaultMessage='Which team would you like to continue using?'
                            />
                        </div>
                        <div className='DowngradeTeamRemovalModal__selectionSection'>
                            {selectionSection(teams)}
                        </div>
                        <div className='warning'>
                            <i className='icon icon-alert-outline'/>
                            <span className='warning-text'>
                                <FormattedMessage
                                    id='downgrade_plan_modal.alert'
                                    defaultMessage='The unselected teams will be automatically archived in the system console, but not deleted'
                                />
                            </span>
                        </div>
                    </div>
                    <div className='DowngradeTeamRemovalModal__buttons'>
                        <button
                            onClick={() =>
                                dispatch(
                                    closeModal(
                                        ModalIdentifiers.CLOUD_DOWNGRADE_CHOOSE_TEAM,
                                    ),
                                )
                            }
                            className='btn btn-light'
                        >
                            <FormattedMessage
                                id='admin.team_channel_settings.cancel'
                                defaultMessage='Cancel'
                            />
                        </button>
                        <button
                            disabled={
                                isEmpty(radioValue) &&
                                    isEmpty(dropdownValue)
                            }
                            onClick={onConfirmDowngrade}
                            className='btn btn-primary'
                        >
                            <FormattedMessage
                                id='downgrade_plan_modal.confirmDowngrade'
                                defaultMessage='Confirm Downgrade'
                            />
                        </button>
                    </div>
                </Modal.Body>
            </>

        </Modal>
    );
}

export default DowngradeTeamRemovalModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';
import styled from 'styled-components';
import {useSelector} from 'react-redux';

import {isCurrentLicenseCloud} from 'mattermost-redux/selectors/entities/cloud';
import {trackEvent} from 'actions/telemetry_actions';

import useOpenSalesLink from 'components/common/hooks/useOpenSalesLink';

import {LicenseLinks, TELEMETRY_CATEGORIES} from 'utils/constants';

const StyledA = styled.a`
color: var(--denim-button-bg);
font-family: 'Open Sans';
font-size: 12px;
font-style: normal;
font-weight: 600;
line-height: 16px;
cursor: pointer;
text-align: center;
`;

function ContactSalesCTA() {
    const {formatMessage} = useIntl();
    const openSalesLink = useOpenSalesLink();

    const openSelfHostedLink = () => {
        window.open(LicenseLinks.CONTACT_SALES, '_blank');
    };

    const isCloud = useSelector(isCurrentLicenseCloud);

    return (
        <StyledA
            id='contact_sales_quote'
            onClick={(e: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => {
                e.preventDefault();
                if (isCloud) {
                    trackEvent(TELEMETRY_CATEGORIES.CLOUD_PRICING, 'click_enterprise_contact_sales');
                    openSalesLink();
                } else {
                    trackEvent('self_hosted_pricing', 'click_enterprise_contact_sales');
                    openSelfHostedLink();
                }
            }}
        >
            {formatMessage({id: 'pricing_modal.btn.contactSalesForQuote', defaultMessage: 'Contact Sales'})}
        </StyledA>
    );
}

export default ContactSalesCTA;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';
import {useDispatch, useSelector} from 'react-redux';
import styled from 'styled-components';

import {getCloudProducts} from 'mattermost-redux/selectors/entities/cloud';

import {openModal, closeModal} from 'actions/views/modals';
import CloudUsageModal from 'components/cloud_usage_modal';
import useGetLimits from 'components/common/hooks/useGetLimits';

import {CloudProducts, ModalIdentifiers} from 'utils/constants';
import {fallbackStarterLimits, asGBString, hasSomeLimits} from 'utils/limits';
import {t} from 'utils/i18n';

import {Product} from '@mattermost/types/cloud';

const Disclaimer = styled.div`
margin-bottom: 8px;
color: var(--error-text);
font-family: 'Open Sans';
font-size: 12px;
font-style: normal;
font-weight: 600;
line-height: 16px;
cursor: pointer;
`;

function StarterDisclaimerCTA() {
    const intl = useIntl();
    const dispatch = useDispatch();
    const [limits] = useGetLimits();
    const products = useSelector(getCloudProducts);
    const starterProductName = Object.values(products || {})?.find((product: Product) => product?.sku === CloudProducts.STARTER)?.name || 'Cloud Free';

    if (!hasSomeLimits(limits)) {
        return null;
    }

    const openLimitsMiniModal = () => {
        dispatch(openModal({
            modalId: ModalIdentifiers.CLOUD_LIMITS,
            dialogType: CloudUsageModal,
            dialogProps: {
                backdropClassName: 'cloud-usage-backdrop',
                title: {
                    id: t('workspace_limits.modals.informational.title'),
                    defaultMessage: '{planName} limits',
                    values: {
                        planName: starterProductName,
                    },
                },
                description: {
                    id: t('workspace_limits.modals.informational.description.freeLimits'),
                    defaultMessage: '{planName} is restricted to {messages} message history, {storage} file storage, and {boards} board cards.',
                    values: {
                        planName: starterProductName,
                        messages: intl.formatNumber(fallbackStarterLimits.messages.history),
                        storage: asGBString(fallbackStarterLimits.files.totalStorage, intl.formatNumber),
                        boards: fallbackStarterLimits.boards.cards,
                    },
                },
                secondaryAction: {
                    message: {
                        id: t('workspace_limits.modals.close'),
                        defaultMessage: 'Close',
                    },
                    onClick: () => {
                        dispatch(closeModal(ModalIdentifiers.CLOUD_LIMITS));
                    },
                },
                onClose: () => {
                    dispatch(closeModal(ModalIdentifiers.CLOUD_LIMITS));
                },
                ownLimits: {
                    messages: {
                        history: fallbackStarterLimits.messages.history,
                    },
                    files: {
                        total_storage: fallbackStarterLimits.files.totalStorage,
                    },
                    boards: {
                        cards: fallbackStarterLimits.boards.cards,
                        views: fallbackStarterLimits.boards.views,
                    },
                },
                needsTheme: true,
            },
        }));
    };
    return (
        <Disclaimer
            id='starter_plan_data_restrictions_cta'
            onClick={openLimitsMiniModal}
        >
            <i className='icon-alert-outline'/>
            {intl.formatMessage({id: 'pricing_modal.planDisclaimer.free', defaultMessage: 'This plan has data restrictions.'})}
        </Disclaimer>
    );
}

export default StarterDisclaimerCTA;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

function BuildingSvg() {
    return (
        <svg
            width='98'
            height='80'
            viewBox='0 0 98 80'
            fill='none'
            xmlns='http://www.w3.org/2000/svg'
        >
            <g clipPath='url(#clip0_249_14083)'>
                <path
                    d='M97.2396 28.5905C97.7492 29.0983 98.0081 29.735 98.0081 30.5008V77.324C98.0081 78.0897 97.7492 78.7265 97.2396 79.2343C96.73 79.7421 96.091 80 95.3225 80H2.87974C2.11127 80 1.43987 79.7421 0.865539 79.2343C0.291209 78.7265 0 78.0897 0 77.324V30.5008C0 29.735 0.291209 29.0983 0.865539 28.5905C1.43987 28.0826 2.11127 27.8247 2.87974 27.8247H95.3144C96.0829 27.8247 96.7219 28.0826 97.2315 28.5905H97.2396Z'
                    fill='#818698'
                />
                <path
                    d='M8.63085 48.4675H5.37092C4.47303 48.3385 3.96341 47.8952 3.83398 47.1295V38.1501C3.96341 37.2635 4.47303 36.8121 5.37092 36.8121H8.63085C9.52065 36.8121 10.0384 37.2635 10.1678 38.1501V47.1295C10.0384 47.8952 9.52874 48.3385 8.63085 48.4675ZM8.63085 59.1718H5.37092C4.47303 59.0428 3.96341 58.5995 3.83398 57.8337V54.7788C3.96341 53.8922 4.47303 53.4408 5.37092 53.4408H8.63085C9.52065 53.4408 10.0384 53.8922 10.1678 54.7788V57.8337C10.0384 58.5995 9.52874 59.0428 8.63085 59.1718ZM8.63085 69.4892H5.37092C4.47303 69.3602 3.96341 68.9169 3.83398 68.1511V65.0962C3.96341 64.3305 4.47303 63.8871 5.37092 63.7582H8.63085C9.52065 63.8871 10.0384 64.3305 10.1678 65.0962V68.1511C10.0384 68.9169 9.52874 69.3602 8.63085 69.4892ZM17.6422 48.4675H14.1881C13.2902 48.3385 12.8453 47.8952 12.8453 47.1295V38.1501C12.8453 37.2635 13.2902 36.8121 14.1881 36.8121H17.6422C18.4106 36.8121 18.8555 37.2635 18.985 38.1501V47.1295C18.8555 47.8952 18.4106 48.3385 17.6422 48.4675ZM17.6422 59.1718H14.1881C13.2902 59.0428 12.8453 58.5995 12.8453 57.8337V54.7788C12.8453 53.8922 13.2902 53.4408 14.1881 53.4408H17.6422C18.4106 53.4408 18.8555 53.8922 18.985 54.7788V57.8337C18.8555 58.5995 18.4106 59.0428 17.6422 59.1718ZM17.6422 69.4892H14.1881C13.2902 69.3602 12.8453 68.9169 12.8453 68.1511V65.0962C12.8453 64.3305 13.2902 63.8871 14.1881 63.7582H17.6422C18.4106 63.8871 18.8555 64.3305 18.985 65.0962V68.1511C18.8555 68.9169 18.4106 69.3602 17.6422 69.4892ZM85.9145 47.1295V38.1501C85.7851 37.2635 85.2755 36.8121 84.3776 36.8121H81.1177C80.2198 36.8121 79.7102 37.2635 79.5807 38.1501V47.1295C79.7102 47.8952 80.2198 48.3385 81.1177 48.4675H84.3776C85.2674 48.3385 85.7851 47.8952 85.9145 47.1295ZM84.3776 59.1718H81.1177C80.2198 59.0428 79.7102 58.5995 79.5807 57.8337V54.7788C79.7102 53.8922 80.2198 53.4408 81.1177 53.4408H84.3776C85.2674 53.4408 85.7851 53.8922 85.9145 54.7788V57.8337C85.7851 58.5995 85.2755 59.0428 84.3776 59.1718ZM84.3776 69.4892H81.1177C80.2198 69.3602 79.7102 68.9169 79.5807 68.1511V65.0962C79.7102 64.3305 80.2198 63.8871 81.1177 63.7582H84.3776C85.2674 63.8871 85.7851 64.3305 85.9145 65.0962V68.1511C85.7851 68.9169 85.2755 69.3602 84.3776 69.4892ZM93.3889 48.4675H89.9349C89.037 48.3385 88.592 47.8952 88.592 47.1295V38.1501C88.592 37.2635 89.037 36.8121 89.9349 36.8121H93.3889C94.1574 36.8121 94.6023 37.2635 94.7317 38.1501V47.1295C94.6023 47.8952 94.1574 48.3385 93.3889 48.4675ZM93.3889 59.1718H89.9349C89.037 59.0428 88.592 58.5995 88.592 57.8337V54.7788C88.592 53.8922 89.037 53.4408 89.9349 53.4408H93.3889C94.1574 53.4408 94.6023 53.8922 94.7317 54.7788V57.8337C94.6023 58.5995 94.1574 59.0428 93.3889 59.1718ZM93.3889 69.4892H89.9349C89.037 69.3602 88.592 68.9169 88.592 68.1511V65.0962C88.592 64.3305 89.037 63.8871 89.9349 63.7582H93.3889C94.1574 63.8871 94.6023 64.3305 94.7317 65.0962V68.1511C94.6023 68.9169 94.1574 69.3602 93.3889 69.4892Z'
                    fill='#EBEBEF'
                />
                <path
                    d='M75.7548 3.44179V77.8962C75.6254 79.1697 75.1805 79.871 74.412 80H25.1248C24.2269 79.871 23.7173 79.1697 23.5879 77.8962V3.44179C23.7173 2.16824 24.2269 1.46698 25.1248 1.33801H74.412C75.1805 1.46698 75.6254 2.16824 75.7548 3.44179Z'
                    fill='#BABEC9'
                />
                <path
                    d='M34.7109 41.2051C34.5814 42.0998 34.1365 42.5431 33.3681 42.5431H29.1455C28.2476 42.5431 27.8027 42.0998 27.8027 41.2051V30.6942C27.8027 29.8076 28.2476 29.3562 29.1455 29.3562H33.3681C34.1365 29.3562 34.5814 29.8076 34.7109 30.6942V41.2051ZM33.3681 53.8197C34.1365 53.8197 34.5814 53.3763 34.7109 52.4816V49.4267C34.5814 48.661 34.1365 48.2176 33.3681 48.0887H29.1455C28.2476 48.2176 27.8027 48.661 27.8027 49.4267V52.4816C27.8027 53.3763 28.2476 53.8197 29.1455 53.8197H33.3681ZM33.3681 64.9028C34.1365 64.9028 34.5814 64.4595 34.7109 63.5647V60.5098C34.5814 59.7441 34.1365 59.3008 33.3681 59.1718H29.1455C28.2476 59.3008 27.8027 59.7441 27.8027 60.5098V63.5647C27.8027 64.4595 28.2476 64.9028 29.1455 64.9028H33.3681ZM33.3681 75.0348C34.1365 74.9058 34.5814 74.4625 34.7109 73.6967V70.6418C34.5814 69.8761 34.1365 69.4328 33.3681 69.3038H29.1455C28.2476 69.4328 27.8027 69.8761 27.8027 70.6418V73.6967C27.8027 74.4625 28.2476 74.9058 29.1455 75.0348H33.3681ZM43.342 42.5431C44.2318 42.5431 44.7495 42.0998 44.8789 41.2051V30.6942C44.7495 29.8076 44.2399 29.3562 43.342 29.3562H39.1195C38.351 29.3562 37.9061 29.8076 37.7767 30.6942V41.2051C37.9061 42.0998 38.351 42.5431 39.1195 42.5431H43.342ZM43.342 53.8197C44.2318 53.8197 44.7495 53.3763 44.8789 52.4816V49.4267C44.7495 48.661 44.2399 48.2176 43.342 48.0887H39.1195C38.351 48.2176 37.9061 48.661 37.7767 49.4267V52.4816C37.9061 53.3763 38.351 53.8197 39.1195 53.8197H43.342ZM60.0299 42.5431C60.7984 42.5431 61.2433 42.0998 61.3727 41.2051V30.6942C61.2433 29.8076 60.7984 29.3562 60.0299 29.3562H55.8074C54.9095 29.3562 54.3998 29.8076 54.2704 30.6942V41.2051C54.3998 42.0998 54.9095 42.5431 55.8074 42.5431H60.0299ZM60.0299 53.8197C60.7984 53.8197 61.2433 53.3763 61.3727 52.4816V49.4267C61.2433 48.661 60.7984 48.2176 60.0299 48.0887H55.8074C54.9095 48.2176 54.3998 48.661 54.2704 49.4267V52.4816C54.3998 53.3763 54.9095 53.8197 55.8074 53.8197H60.0299ZM70.0038 42.5431C70.8936 42.5431 71.3466 42.0998 71.3466 41.2051V30.6942C71.3466 29.8076 70.8936 29.3562 70.0038 29.3562H65.7813C65.0128 29.3562 64.5679 29.8076 64.4385 30.6942V41.2051C64.5679 42.0998 65.0128 42.5431 65.7813 42.5431H70.0038ZM34.7109 22.1421C34.5814 23.0368 34.1365 23.4801 33.3681 23.4801H29.1455C28.2476 23.4801 27.8027 23.0368 27.8027 22.1421V11.6312C27.8027 10.7446 28.2476 10.2932 29.1455 10.2932H33.3681C34.1365 10.2932 34.5814 10.7446 34.7109 11.6312V22.1421ZM43.342 23.4801C44.2318 23.4801 44.7495 23.0368 44.8789 22.1421V11.6312C44.7495 10.7446 44.2399 10.2932 43.342 10.2932H39.1195C38.351 10.2932 37.9061 10.7446 37.7767 11.6312V22.1421C37.9061 23.0368 38.351 23.4801 39.1195 23.4801H43.342ZM60.0299 23.4801C60.7984 23.4801 61.2433 23.0368 61.3727 22.1421V11.6312C61.2433 10.7446 60.7984 10.2932 60.0299 10.2932H55.8074C54.9095 10.2932 54.3998 10.7446 54.2704 11.6312V22.1421C54.3998 23.0368 54.9095 23.4801 55.8074 23.4801H60.0299ZM70.0038 23.4801C70.8936 23.4801 71.3466 23.0368 71.3466 22.1421V11.6312C71.3466 10.7446 70.8936 10.2932 70.0038 10.2932H65.7813C65.0128 10.2932 64.5679 10.7446 64.4385 11.6312V22.1421C64.5679 23.0368 65.0128 23.4801 65.7813 23.4801H70.0038ZM70.0038 53.8197C70.8936 53.8197 71.3466 53.3763 71.3466 52.4816V49.4267C71.3466 48.661 70.8936 48.2176 70.0038 48.0887H65.7813C65.0128 48.2176 64.5679 48.661 64.4385 49.4267V52.4816C64.5679 53.3763 65.0128 53.8197 65.7813 53.8197H70.0038ZM70.0038 64.9028C70.8936 64.9028 71.3466 64.4595 71.3466 63.5647V60.5098C71.3466 59.7441 70.8936 59.3008 70.0038 59.1718H65.7813C65.0128 59.3008 64.5679 59.7441 64.4385 60.5098V63.5647C64.5679 64.4595 65.0128 64.9028 65.7813 64.9028H70.0038ZM70.0038 75.0348C70.8936 74.9058 71.3466 74.4625 71.3466 73.6967V70.6418C71.3466 69.8761 70.8936 69.4328 70.0038 69.3038H65.7813C65.0128 69.4328 64.5679 69.8761 64.4385 70.6418V73.6967C64.5679 74.4625 65.0128 74.9058 65.7813 75.0348H70.0038Z'
                    fill='#818698'
                />
                <path
                    d='M59.649 59.5506H39.7012V80H59.649V59.5506Z'
                    fill='#E0E9EF'
                />
                <path
                    d='M75.7548 5.15869H23.7821C22.8842 5.02972 22.3745 4.5864 22.2451 3.82065V1.33804C22.3745 0.451385 22.8842 0 23.7821 0H75.7548C76.5233 0 76.9682 0.451385 77.0976 1.33804V3.82065C76.9682 4.5864 76.5233 5.02972 75.7548 5.15869ZM59.8354 57.068H39.5074C38.6095 57.197 38.1646 57.6403 38.1646 58.406V60.7033C38.1646 61.598 38.6095 62.0413 39.5074 62.0413H49.093V80.0081H50.2416V62.0413H59.8273C60.7171 62.0413 61.2348 61.598 61.3642 60.7033V58.406C61.2348 57.6403 60.7252 57.197 59.8273 57.068H59.8354Z'
                    fill='#5A6072'
                />
            </g>
            <defs>
                <clipPath id='clip0_249_14083'>
                    <rect
                        width='98'
                        height='80'
                        fill='white'
                    />
                </clipPath>
            </defs>
        </svg>
    );
}

export default BuildingSvg;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

function TadaSvg() {
    return (
        <svg
            width='46'
            height='46'
            viewBox='0 0 46 46'
            fill='none'
            xmlns='http://www.w3.org/2000/svg'
        >
            <circle
                cx='23'
                cy='23'
                r='23'
                fill='white'
            />
            <path
                d='M9 36L13.004 34.6039L9.98 33.2079L9 36Z'
                fill='#CC8F00'
            />
            <path
                d='M20.648 24.5522L14.964 18.8563L14.04 21.4809L20.648 24.5522Z'
                fill='#FFBC1F'
            />
            <path
                d='M14.0412 21.4809L13.0332 24.4126L25.5492 30.2203L26.1092 30.0248L20.6492 24.5522L14.0412 21.4809Z'
                fill='#CC8F00'
            />
            <path
                d='M12.0234 27.3444L21.3474 31.6722L25.5474 30.2203L13.0314 24.4126L12.0234 27.3444Z'
                fill='#FFBC1F'
            />
            <path
                d='M10.9873 30.2761L17.1753 33.152L21.3473 31.6722L12.0233 27.3444L10.9873 30.2761Z'
                fill='#CC8F00'
            />
            <path
                d='M10.9885 30.2761L9.98047 33.2078L13.0045 34.6039L17.1765 33.152L10.9885 30.2761Z'
                fill='#FFBC1F'
            />
            <path
                d='M22.9448 22.123C26.0808 25.2223 27.7048 28.6287 26.5848 29.7456C25.4368 30.8625 21.9648 29.2709 18.8008 26.1717C15.6648 23.0724 14.0408 19.666 15.1608 18.5491C16.3088 17.4322 19.8088 19.0238 22.9448 22.123Z'
                fill='#66320A'
            />
            <path
                d='M19.0225 14.333C18.2665 13.272 19.0785 12.7973 20.0865 12.9928C19.1345 11.8201 19.7225 10.9824 21.2345 11.3175C21.7105 11.4292 21.0385 12.211 20.6185 12.183C21.9065 13.1324 21.2065 14.1375 19.8345 13.9142C21.0385 15.5615 18.9665 15.1427 18.0705 15.2265C17.8465 16.455 19.2465 17.8511 18.7705 17.8511C17.7625 17.8511 16.1105 13.97 19.0225 14.333Z'
                fill='#32A4EC'
            />
            <path
                d='M28.8515 16.5946C28.1515 16.9018 26.1915 13.8304 28.5995 13.8025C27.1995 12.546 27.3955 11.9317 29.2435 11.9038C27.1155 9.78179 30.5035 8.99999 30.8675 10.1448C30.9795 10.4798 29.8315 9.83763 29.4675 10.4519C29.0475 11.1499 32.0995 12.9369 28.9355 12.8531C30.0835 14.0258 30.1675 14.5843 28.3195 14.7797C28.5435 15.0869 29.2995 16.3992 28.8515 16.5946Z'
                fill='#E07315'
            />
            <path
                d='M29.6367 23.8542L30.3367 23.2399C30.3367 23.2399 31.0087 24.2172 31.4847 24.5801C31.8487 22.9328 31.7367 21.9276 33.6967 23.0724C32.6047 20.1965 34.3967 21.2854 36.1047 22.0672C35.9927 21.3413 36.1327 21.425 36.8607 21.2017C37.5047 23.6587 35.7687 22.9328 34.3127 22.151C35.1247 24.3568 34.2847 24.273 32.4647 23.5191C32.4367 24.4685 32.1287 25.5295 31.5687 25.6132C30.9247 25.697 29.6367 23.8542 29.6367 23.8542Z'
                fill='#C43133'
            />
            <path
                d='M24.399 16.9297C23.531 18.0465 22.215 18.6608 21.235 19.6381C20.199 20.6432 19.583 23.4633 19.583 23.4633C19.583 23.4633 19.947 20.5315 20.955 19.4147C21.851 18.4095 23.139 17.6556 23.839 16.4829C25.071 14.3609 23.979 11.5408 22.383 9.92141C22.719 9.61427 23.167 9.25129 23.419 9C24.903 10.8987 26.219 14.5843 24.399 16.9297Z'
                fill='#6167BD'
            />
            <path
                d='M25.8289 19.3309C24.5969 20.2244 23.7569 21.5088 22.8889 22.7094C22.1329 23.7984 19.7529 25.1107 19.7529 25.1107C19.7529 25.1107 21.9929 23.6029 22.6649 22.4581C23.4769 21.0621 24.3449 19.6101 25.6329 18.605C28.2369 16.5946 32.0169 16.818 34.9849 17.879C34.8169 18.2978 34.4809 19.1913 34.4809 19.1913C34.4809 19.1913 28.3209 17.544 25.8289 19.3309Z'
                fill='#E07315'
            />
            <path
                d='M31.0367 19.1076C30.2527 20.1406 29.8607 21.3971 29.2447 22.5419C28.6847 23.6029 27.9567 24.636 26.8647 25.1944C25.6607 25.8087 22.9727 25.5853 22.9727 25.5853C22.9727 25.5853 25.6607 25.5574 26.7527 24.8035C27.8727 24.0496 28.4607 22.7653 28.9087 21.5367C29.7207 19.2192 30.7567 16.7063 33.1927 15.6732C33.3607 16.12 33.6687 16.9855 33.6687 16.9855C33.6687 16.9855 32.3527 17.3764 31.0367 19.1076Z'
                fill='#32A4EC'
            />
            <path
                d='M10.8849 12.9145L9.55859 14.2375L10.8853 15.5601L12.2116 14.2371L10.8849 12.9145Z'
                fill='#32A4EC'
            />
            <path
                d='M12.7326 17.0697L11.4062 18.3927L12.733 19.7153L14.0593 18.3923L12.7326 17.0697Z'
                fill='#E07315'
            />
            <path
                d='M16.0949 10.8513L14.7686 12.1742L16.0953 13.4969L17.4216 12.1739L16.0949 10.8513Z'
                fill='#C43133'
            />
            <path
                d='M30.4818 26.5819L29.1553 27.9047L30.4818 29.2275L31.8083 27.9047L30.4818 26.5819Z'
                fill='#6167BD'
            />
            <path
                d='M27.5285 31.1187L26.2021 32.4417L27.5289 33.7643L28.8552 32.4413L27.5285 31.1187Z'
                fill='#C43133'
            />
            <path
                d='M33.3187 32.1512L31.9922 33.474L33.3187 34.7968L34.6452 33.474L33.3187 32.1512Z'
                fill='#E07315'
            />
            <path
                d='M34.6293 26.153L33.3027 27.4758L34.6293 28.7986L35.9558 27.4758L34.6293 26.153Z'
                fill='#32A4EC'
            />
            <path
                d='M32.44 12.2356L31.1133 13.5582L32.4396 14.8812L33.7663 13.5586L32.44 12.2356Z'
                fill='#32A4EC'
            />
            <path
                d='M18.2882 20.164L16.9619 21.487L18.2886 22.8096L19.615 21.4866L18.2882 20.164Z'
                fill='#E74C5C'
            />
        </svg>

    );
}

export default TadaSvg;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';
import styled from 'styled-components';

import BuildingSvg from './building.svg';
import TadaSvg from './tada.svg';

export enum ButtonCustomiserClasses {
    grayed = 'grayed',
    active = 'active',
    special = 'special',
    secondary = 'secondary',
}

type PlanBriefing = {
    title: string;
    items?: string[];
}

type PlanAddonsInfo = {
    title: string;
    items: PlanBriefing[];
}

type ButtonDetails = {
    action: () => void;
    text: string;
    disabled?: boolean;
    customClass?: ButtonCustomiserClasses;
}

type CardProps = {
    id: string;
    topColor: string;
    planLabel?: JSX.Element;
    plan: string;
    planSummary?: string;
    price?: string;
    rate?: string;
    planExtraInformation?: JSX.Element;
    buttonDetails?: ButtonDetails;
    customButtonDetails?: JSX.Element;
    contactSalesCTA?: JSX.Element;
    briefing: PlanBriefing;
    planAddonsInfo?: PlanAddonsInfo;
    planTrialDisclaimer?: JSX.Element;
}

type StyledProps = {
    bgColor?: string;
}

const StyledDiv = styled.div<StyledProps>`
background-color: ${(props) => props.bgColor};
`;

function Card(props: CardProps) {
    const {formatMessage} = useIntl();
    return (
        <div
            id={props.id}
            className='PlanCard'
        >
            {props.planLabel}
            <StyledDiv
                className='top'
                bgColor={props.topColor}
            />
            <div className='bottom'>
                <div className='bottom_container'>
                    <div className='plan_price_rate_section'>
                        <h3>{props.plan}</h3>
                        <p>{props.planSummary}</p>
                        {props.price ? <h1>{props.price}</h1> : <BuildingSvg/>}
                        <span>{props.rate}</span>
                    </div>

                    <div className='plan_limits_cta'>
                        {props.planExtraInformation}
                    </div>

                    <div className='plan_buttons'>
                        {props.customButtonDetails || (
                            <button
                                id={props.id + '_action'}
                                className={`plan_action_btn ${props.buttonDetails?.disabled ? ButtonCustomiserClasses.grayed : props.buttonDetails?.customClass}`}
                                disabled={props.buttonDetails?.disabled}
                                onClick={props.buttonDetails?.action}
                            >
                                {props.buttonDetails?.text}
                            </button>
                        )}
                    </div>

                    <div className='contact_sales_cta'>
                        {props.contactSalesCTA && (
                            <div>
                                <p>{formatMessage({id: 'pricing_modal.or', defaultMessage: 'or'})}</p>
                                {props.contactSalesCTA}
                            </div>)}
                    </div>

                    <div className='plan_briefing'>
                        <hr/>
                        {props.planTrialDisclaimer}
                        <div className='plan_briefing_content'>
                            <span className='title'>{props.briefing.title}</span>
                            {props.briefing.items?.map((i) => {
                                return (
                                    <div
                                        className='item'
                                        key={i}
                                    >
                                        <i className='fa fa-circle bullet'/><p>{i}</p>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                </div>

                {props.planAddonsInfo && (
                    <div className='plan_add_ons'>
                        <div className='illustration'><TadaSvg/></div>
                        <h4 className='title'>{props.planAddonsInfo.title}</h4>
                        {props.planAddonsInfo.items.map((i) => {
                            return (
                                <div
                                    className='item'
                                    key={i.title}
                                >
                                    <div className='item_title'><i className='fa fa-circle bullet fa-xs'/><p>{i.title}</p></div>
                                    {i.items?.map((sub) => {
                                        return (
                                            <div
                                                className='subitem'
                                                key={sub}
                                            >
                                                <div className='subitem_title'><i className='fa fa-circle bullet fa-xs'/><p>{sub}</p></div>
                                            </div>

                                        );
                                    })}
                                </div>
                            );
                        })}

                    </div>
                )}

            </div>
        </div>
    );
}

export default Card;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState} from 'react';
import {Modal} from 'react-bootstrap';
import {useIntl} from 'react-intl';
import {useDispatch, useSelector} from 'react-redux';

import {CloudLinks, CloudProducts, LicenseSkus, ModalIdentifiers, PaidFeatures, TELEMETRY_CATEGORIES, RecurringIntervals} from 'utils/constants';
import {fallbackStarterLimits, fallbackProfessionalLimits, asGBString, hasSomeLimits} from 'utils/limits';
import {findProductBySkuAndInterval} from 'utils/products';

import {getCloudContactUsLink, InquiryType} from 'selectors/cloud';

import {trackEvent} from 'actions/telemetry_actions';
import {closeModal, openModal} from 'actions/views/modals';
import {subscribeCloudSubscription} from 'actions/cloud';
import {
    getCloudSubscription as selectCloudSubscription,
    getSubscriptionProduct as selectSubscriptionProduct,
    getCloudProducts as selectCloudProducts,
} from 'mattermost-redux/selectors/entities/cloud';
import {isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';

import useGetUsage from 'components/common/hooks/useGetUsage';
import useGetLimits from 'components/common/hooks/useGetLimits';
import SuccessModal from 'components/cloud_subscribe_result_modal/success';
import ErrorModal from 'components/cloud_subscribe_result_modal/error';
import CheckMarkSvg from 'components/widgets/icons/check_mark_icon';
import PlanLabel from 'components/common/plan_label';
import CloudStartTrialButton from 'components/cloud_start_trial/cloud_start_trial_btn';
import NotifyAdminCTA from 'components/notify_admin_cta/notify_admin_cta';
import useOpenCloudPurchaseModal from 'components/common/hooks/useOpenCloudPurchaseModal';
import YearlyMonthlyToggle from 'components/yearly_monthly_toggle';

import {isAnnualSubscriptionEnabled} from 'mattermost-redux/selectors/entities/preferences';

import useOpenPricingModal from 'components/common/hooks/useOpenPricingModal';

import DowngradeTeamRemovalModal from './downgrade_team_removal_modal';
import ContactSalesCTA from './contact_sales_cta';
import StarterDisclaimerCTA from './starter_disclaimer_cta';
import StartTrialCaution from './start_trial_caution';
import Card, {ButtonCustomiserClasses} from './card';

import './content.scss';

type ContentProps = {
    onHide: () => void;

    // callerCTA is information about the cta that opened this modal. This helps us provide a telemetry path
    // showing information about how the modal was opened all the way to more CTAs within the modal itself
    callerCTA?: string;
}

function Content(props: ContentProps) {
    const {formatMessage, formatNumber} = useIntl();
    const dispatch = useDispatch();
    const usage = useGetUsage();
    const [limits] = useGetLimits();
    const openPricingModalBackAction = useOpenPricingModal();

    const isAdmin = useSelector(isCurrentUserSystemAdmin);
    const contactSalesLink = useSelector(getCloudContactUsLink)(InquiryType.Sales);

    const subscription = useSelector(selectCloudSubscription);
    const product = useSelector(selectSubscriptionProduct);
    const products = useSelector(selectCloudProducts);

    const annualSubscriptionEnabled = useSelector(isAnnualSubscriptionEnabled);

    const currentSubscriptionIsMonthly = product?.recurring_interval === RecurringIntervals.MONTH;
    const isEnterprise = product?.sku === CloudProducts.ENTERPRISE;
    const isEnterpriseTrial = subscription?.is_free_trial === 'true';
    const monthlyProfessionalProduct = findProductBySkuAndInterval(products || {}, CloudProducts.PROFESSIONAL, RecurringIntervals.MONTH);
    const yearlyProfessionalProduct = findProductBySkuAndInterval(products || {}, CloudProducts.PROFESSIONAL, RecurringIntervals.YEAR);

    const starterProduct = Object.values(products || {}).find(((product) => {
        return product.sku === CloudProducts.STARTER;
    }));

    const isStarter = product?.sku === CloudProducts.STARTER;
    const isProfessional = product?.sku === CloudProducts.PROFESSIONAL;

    const isPreTrial = subscription?.trial_end_at === 0;

    let isPostTrial = false;
    if ((subscription && subscription.trial_end_at > 0) && !isEnterpriseTrial && (isStarter || isEnterprise)) {
        isPostTrial = true;
    }

    const openCloudPurchaseModal = useOpenCloudPurchaseModal({});
    const openCloudDelinquencyModal = useOpenCloudPurchaseModal({
        isDelinquencyModal: true,
    });
    const openPurchaseModal = (callerInfo: string, isMonthlyPlan: boolean) => {
        props.onHide();
        const telemetryInfo = props.callerCTA + ' > ' + callerInfo;
        if (subscription?.delinquent_since) {
            openCloudDelinquencyModal({trackingLocation: telemetryInfo});
        }
        openCloudPurchaseModal({trackingLocation: telemetryInfo}, isMonthlyPlan);
    };

    const closePricingModal = () => {
        dispatch(closeModal(ModalIdentifiers.PRICING_MODAL));
    };

    const downgrade = async () => {
        if (!starterProduct) {
            return;
        }

        const result = await dispatch(subscribeCloudSubscription(starterProduct.id));

        if (typeof result === 'boolean' && result) {
            dispatch(closeModal(ModalIdentifiers.CLOUD_DOWNGRADE_CHOOSE_TEAM));
            dispatch(
                openModal({
                    modalId: ModalIdentifiers.SUCCESS_MODAL,
                    dialogType: SuccessModal,
                }),
            );
        } else {
            dispatch(closeModal(ModalIdentifiers.CLOUD_DOWNGRADE_CHOOSE_TEAM));
            dispatch(closeModal(ModalIdentifiers.PRICING_MODAL));
            dispatch(
                openModal({
                    modalId: ModalIdentifiers.ERROR_MODAL,
                    dialogType: ErrorModal,
                    dialogProps: {
                        backButtonAction: openPricingModalBackAction,
                    },
                }),
            );
            return;
        }

        props.onHide();
    };

    const hasLimits = hasSomeLimits(limits);

    const starterBriefing = [
        formatMessage({id: 'pricing_modal.briefing.free.recentMessageBoards', defaultMessage: 'Access to {messages} most recent messages, {boards} most recent board cards'}, {messages: formatNumber(fallbackStarterLimits.messages.history), boards: fallbackStarterLimits.boards.cards}),
        formatMessage({id: 'pricing_modal.briefing.storage', defaultMessage: '{storage} file storage limit'}, {storage: asGBString(fallbackStarterLimits.files.totalStorage, formatNumber)}),
        formatMessage({id: 'pricing_modal.briefing.free.oneTeamPerWorkspace', defaultMessage: 'One team per workspace'}),
        formatMessage({id: 'pricing_modal.extra_briefing.free.calls', defaultMessage: '1:1 voice calls and screen share'}),
    ];

    const legacyStarterBriefing = [
        formatMessage({id: 'admin.billing.subscription.planDetails.features.groupAndOneToOneMessaging', defaultMessage: 'Group and one-to-one messaging, file sharing, and search'}),
        formatMessage({id: 'admin.billing.subscription.planDetails.features.incidentCollaboration', defaultMessage: 'Incident collaboration'}),
        formatMessage({id: 'admin.billing.subscription.planDetails.features.unlimittedUsersAndMessagingHistory', defaultMessage: 'Unlimited users & message history'}),
        formatMessage({id: 'admin.billing.subscription.planDetails.features.mfa', defaultMessage: 'Multi-Factor Authentication (MFA)'}),
    ];

    // Default professional price
    const defaultProfessionalPrice = monthlyProfessionalProduct ? monthlyProfessionalProduct.price_per_seat : 0;
    const [professionalPrice, setProfessionalPrice] = useState(defaultProfessionalPrice);
    const [isMonthlyPlan, setIsMonthlyPlan] = useState(true);

    // Set professional price
    const updateProfessionalPrice = (newIsMonthly: boolean) => {
        if (newIsMonthly && monthlyProfessionalProduct) {
            setProfessionalPrice(monthlyProfessionalProduct.price_per_seat);
            setIsMonthlyPlan(true);
        } else if (!newIsMonthly && yearlyProfessionalProduct) {
            setProfessionalPrice(yearlyProfessionalProduct.price_per_seat / 12);
            setIsMonthlyPlan(false);
        }
    };

    return (
        <div className='Content'>
            <Modal.Header className='PricingModal__header'>
                <div className='header_lhs'>
                    <h1 className='title'>
                        {formatMessage({id: 'pricing_modal.title', defaultMessage: 'Select a plan'})}
                    </h1>
                    <div>{formatMessage({id: 'pricing_modal.subtitle', defaultMessage: 'Choose a plan to get started'})}</div>
                </div>
                <button
                    id='closeIcon'
                    className='icon icon-close'
                    aria-label='Close'
                    title='Close'
                    onClick={props.onHide}
                />
            </Modal.Header>
            <Modal.Body>
                <div className='pricing-options-container'>
                    {annualSubscriptionEnabled &&
                        <>
                            <div className='save-text'>
                                {formatMessage({id: 'pricing_modal.saveWithYearly', defaultMessage: 'Save 20% with Yearly!'})}
                            </div>
                            <YearlyMonthlyToggle
                                updatePrice={updateProfessionalPrice}
                                isPurchases={false}
                                isInitialPlanMonthly={true}
                            />
                        </>
                    }
                    <div className='alert-option-container'>
                        <div className='alert-option'>
                            <span>{formatMessage({id: 'pricing_modal.lookingToSelfHost', defaultMessage: 'Looking to self-host?'})}</span>
                            <a
                                onClick={() =>
                                    trackEvent(
                                        TELEMETRY_CATEGORIES.CLOUD_PURCHASING,
                                        'click_looking_to_self_host',
                                    )
                                }
                                href={CloudLinks.DEPLOYMENT_OPTIONS}
                                rel='noopener noreferrer'
                                target='_blank'
                            >{formatMessage({id: 'pricing_modal.reviewDeploymentOptions', defaultMessage: 'Review deployment options'})}</a>
                        </div>
                    </div>
                </div>

                <div className='PricingModal__body'>
                    <Card
                        id='free'
                        topColor='#339970'
                        plan='Free'
                        planSummary={formatMessage({id: 'pricing_modal.planSummary.free', defaultMessage: 'Increased productivity for small teams'})}
                        price='$0'
                        rate={formatMessage({id: 'pricing_modal.price.freeForever', defaultMessage: 'Free forever'})}
                        planLabel={
                            isStarter ? (
                                <PlanLabel
                                    text={formatMessage({id: 'pricing_modal.planLabel.currentPlan', defaultMessage: 'CURRENT PLAN'})}
                                    color='var(--denim-status-online)'
                                    bgColor='var(--center-channel-bg)'
                                    firstSvg={<CheckMarkSvg/>}
                                />) : undefined}
                        planExtraInformation={<StarterDisclaimerCTA/>}
                        buttonDetails={{
                            action: () => {
                                if (!starterProduct) {
                                    return;
                                }
                                if (usage.teams.active > 1) {
                                    dispatch(
                                        openModal({
                                            modalId: ModalIdentifiers.CLOUD_DOWNGRADE_CHOOSE_TEAM,
                                            dialogType: DowngradeTeamRemovalModal,
                                            dialogProps: {
                                                product_id: starterProduct?.id,
                                                starterProduct,
                                            },
                                        }),
                                    );
                                } else {
                                    downgrade();
                                }
                            },
                            text: formatMessage({id: 'pricing_modal.btn.downgrade', defaultMessage: 'Downgrade'}),
                            disabled: isStarter || isEnterprise || !isAdmin,
                            customClass: ButtonCustomiserClasses.secondary,
                        }}
                        briefing={{
                            title: formatMessage({id: 'pricing_modal.briefing.title', defaultMessage: 'Top features'}),
                            items: hasLimits ? starterBriefing : legacyStarterBriefing,
                        }}
                    />

                    <Card
                        id='professional'
                        topColor='var(--denim-button-bg)'
                        plan='Professional'
                        planSummary={formatMessage({id: 'pricing_modal.planSummary.professional', defaultMessage: 'Scalable solutions for growing teams'})}
                        price={`$${professionalPrice}`}
                        rate={formatMessage({id: 'pricing_modal.rate.userPerMonth', defaultMessage: 'USD per user/month'})}
                        planLabel={
                            isProfessional ? (
                                <PlanLabel
                                    text={formatMessage({id: 'pricing_modal.planLabel.currentPlan', defaultMessage: 'CURRENT PLAN'})}
                                    color='var(--denim-status-online)'
                                    bgColor='var(--center-channel-bg)'
                                    firstSvg={<CheckMarkSvg/>}
                                />) : undefined}
                        planExtraInformation={(!isAdmin && (isStarter || isEnterpriseTrial)) ? (
                            <NotifyAdminCTA
                                preTrial={isPreTrial}
                                notifyRequestData={{
                                    required_feature: PaidFeatures.ALL_PROFESSIONAL_FEATURES,
                                    required_plan: LicenseSkus.Professional,
                                    trial_notification: isPreTrial,
                                }}
                                callerInfo='professional_plan_pricing_modal_card'
                            />) : undefined}
                        buttonDetails={{
                            action: () => openPurchaseModal('click_pricing_modal_professional_card_upgrade_button', isMonthlyPlan),
                            text: formatMessage({id: 'pricing_modal.btn.upgrade', defaultMessage: 'Upgrade'}),
                            disabled: !isAdmin || (isProfessional && !currentSubscriptionIsMonthly) || (isProfessional && currentSubscriptionIsMonthly === isMonthlyPlan) || (isEnterprise && !isEnterpriseTrial),
                            customClass: isPostTrial ? ButtonCustomiserClasses.special : ButtonCustomiserClasses.active,
                        }}
                        briefing={{
                            title: formatMessage({id: 'pricing_modal.briefing.title', defaultMessage: 'Top features'}),
                            items: [
                                formatMessage({id: 'pricing_modal.briefing.professional.messageBoardsIntegrationsCalls', defaultMessage: 'Unlimited access to messages and boards history, teams, and calls'}),
                                formatMessage({id: 'pricing_modal.briefing.storage', defaultMessage: '{storage} file storage limit'}, {storage: asGBString(fallbackProfessionalLimits.files.totalStorage, formatNumber)}),
                                formatMessage({id: 'pricing_modal.briefing.professional.advancedPlaybook', defaultMessage: 'Advanced Playbook workflows with retrospectives'}),
                                formatMessage({id: 'pricing_modal.extra_briefing.professional.ssoSaml', defaultMessage: 'SSO with SAML 2.0, including Okta, OneLogin and ADFS'}),
                                formatMessage({id: 'pricing_modal.extra_briefing.professional.ssoadLdap', defaultMessage: 'SSO support with AD/LDAP, Google, O365, OpenID'}),
                                formatMessage({id: 'pricing_modal.extra_briefing.professional.guestAccess', defaultMessage: 'Guest access with MFA enforcement'}),
                            ],
                        }}
                        planAddonsInfo={{
                            title: formatMessage({id: 'pricing_modal.addons.title', defaultMessage: 'Available Add-ons'}),
                            items: [
                                {
                                    title: formatMessage({id: 'pricing_modal.addons.professionalPlusSupport', defaultMessage: 'Professional-Plus Support'}),
                                    items: [
                                        formatMessage({id: 'pricing_modal.addons.247Coverage', defaultMessage: '24x7 coverage'}),
                                        formatMessage({id: 'pricing_modal.addons.4hourL1L2Response', defaultMessage: '4 hour L1&L2 response'}),
                                    ],
                                },
                            ],
                        }}
                    />

                    <Card
                        id='enterprise'
                        topColor='#E07315'
                        plan='Enterprise'
                        planSummary={formatMessage({id: 'pricing_modal.planSummary.enterprise', defaultMessage: 'Administration, security, and compliance for large teams'})}
                        planLabel={
                            isEnterprise ? (
                                <PlanLabel
                                    text={formatMessage({id: 'pricing_modal.planLabel.currentPlan', defaultMessage: 'CURRENT PLAN'})}
                                    color='var(--denim-status-online)'
                                    bgColor='var(--center-channel-bg)'
                                    firstSvg={<CheckMarkSvg/>}
                                    renderLastDaysOnTrial={true}
                                />) : undefined}
                        planExtraInformation={(!isAdmin && (isStarter || isEnterpriseTrial)) ? (
                            <NotifyAdminCTA
                                preTrial={isPreTrial}
                                callerInfo='enterprise_plan_pricing_modal_card'
                                notifyRequestData={{
                                    required_feature: PaidFeatures.ALL_ENTERPRISE_FEATURES,
                                    required_plan: LicenseSkus.Enterprise,
                                    trial_notification: isPreTrial,
                                }}
                            />) : undefined}
                        buttonDetails={(isPostTrial || !isAdmin) ? {
                            action: () => {
                                trackEvent(TELEMETRY_CATEGORIES.CLOUD_PRICING, 'click_enterprise_contact_sales');
                                window.open(contactSalesLink, '_blank');
                            },
                            text: formatMessage({id: 'pricing_modal.btn.contactSales', defaultMessage: 'Contact Sales'}),
                            customClass: ButtonCustomiserClasses.active,
                        } : undefined}
                        customButtonDetails={(!isPostTrial && isAdmin) ? (
                            <CloudStartTrialButton
                                message={formatMessage({id: 'pricing_modal.btn.tryDays', defaultMessage: 'Try free for {days} days'}, {days: '30'})}
                                telemetryId='start_cloud_trial_from_pricing_modal'
                                disabled={isEnterprise || isEnterpriseTrial || isProfessional}
                                extraClass={`plan_action_btn ${(isEnterprise || isEnterpriseTrial || isProfessional) ? ButtonCustomiserClasses.grayed : ButtonCustomiserClasses.special}`}
                                afterTrialRequest={closePricingModal}
                            />
                        ) : undefined}
                        planTrialDisclaimer={(!isPostTrial && isAdmin) ? <StartTrialCaution/> : undefined}
                        contactSalesCTA={(isPostTrial || !isAdmin) ? undefined : <ContactSalesCTA/>}
                        briefing={{
                            title: formatMessage({id: 'pricing_modal.briefing.title', defaultMessage: 'Top features'}),
                            items: [
                                formatMessage({id: 'pricing_modal.briefing.enterprise.unlimitedFileStorage', defaultMessage: 'Unlimited file storage'}),
                                formatMessage({id: 'pricing_modal.briefing.enterprise.groupSync', defaultMessage: 'AD/LDAP group sync'}),
                                formatMessage({id: 'pricing_modal.briefing.enterprise.mobileSecurity', defaultMessage: 'Advanced mobile security via ID-only push notifications'}),
                                formatMessage({id: 'pricing_modal.briefing.enterprise.rolesAndPermissions', defaultMessage: 'Advanced roles and permissions'}),
                                formatMessage({id: 'pricing_modal.briefing.enterprise.compliance', defaultMessage: 'Advanced compliance management'}),
                                formatMessage({id: 'pricing_modal.extra_briefing.enterprise.playBookAnalytics', defaultMessage: 'Playbook analytics dashboard'}),
                            ],
                        }}
                        planAddonsInfo={{
                            title: formatMessage({id: 'pricing_modal.addons.title', defaultMessage: 'Available Add-ons'}),
                            items: [
                                {title: formatMessage({id: 'pricing_modal.addons.premiumSupport', defaultMessage: 'Premium support'})},
                                {title: formatMessage({id: 'pricing_modal.addons.missionCritical', defaultMessage: 'Mission-critical 24x7'})},
                                {title: '1hr-L1, 2hr-L2'},
                                {title: formatMessage({id: 'pricing_modal.addons.USSupport', defaultMessage: 'U.S.- only based support'})},
                                {title: formatMessage({id: 'pricing_modal.addons.dedicatedDeployment', defaultMessage: 'Dedicated virtual secure cloud deployment (Cloud)'})},
                                {title: formatMessage({id: 'pricing_modal.addons.dedicatedK8sCluster', defaultMessage: 'Dedicated Kubernetes cluster'})},
                                {title: formatMessage({id: 'pricing_modal.addons.dedicatedDB', defaultMessage: 'Dedicated database'})},
                                {title: formatMessage({id: 'pricing_modal.addons.dedicatedEncryption', defaultMessage: 'Dedicated encryption keys 99%'})},
                                {title: formatMessage({id: 'pricing_modal.addons.uptimeGuarantee', defaultMessage: '99% uptime guarantee'})},
                            ],
                        }}
                    />
                </div>
            </Modal.Body>
        </div>
    );
}

export default Content;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect} from 'react';
import {Modal} from 'react-bootstrap';
import {useIntl} from 'react-intl';
import {useDispatch, useSelector} from 'react-redux';

import {CloudLinks, LicenseLinks, ModalIdentifiers, LicenseSkus, TELEMETRY_CATEGORIES} from 'utils/constants';

import {trackEvent} from 'actions/telemetry_actions';
import {closeModal} from 'actions/views/modals';
import {isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';
import {getLicense} from 'mattermost-redux/selectors/entities/general';
import {GlobalState} from '@mattermost/types/store';
import {getPrevTrialLicense} from 'mattermost-redux/actions/admin';

import CheckMarkSvg from 'components/widgets/icons/check_mark_icon';
import PlanLabel from 'components/common/plan_label';
import StartTrialBtn from 'components/learn_more_trial_modal/start_trial_btn';

import ContactSalesCTA from './contact_sales_cta';
import StartTrialCaution from './start_trial_caution';
import Card, {ButtonCustomiserClasses} from './card';

import './content.scss';

type ContentProps = {
    onHide: () => void;
}

function SelfHostedContent(props: ContentProps) {
    const {formatMessage} = useIntl();
    const dispatch = useDispatch();

    useEffect(() => {
        dispatch(getPrevTrialLicense());
    }, []);

    const isAdmin = useSelector(isCurrentUserSystemAdmin);

    const license = useSelector(getLicense);
    const prevSelfHostedTrialLicense = useSelector((state: GlobalState) => state.entities.admin.prevTrialLicense);

    const isSelfHostedEnterpriseTrial = license.IsTrial === 'true';

    const isStarter = license.IsLicensed === 'false';
    const isProfessional = license.SkuShortName === LicenseSkus.Professional;
    const isEnterprise = license.SkuShortName === LicenseSkus.Enterprise;
    const isPostSelfHostedEnterpriseTrial = prevSelfHostedTrialLicense.IsLicensed === 'true';

    const closePricingModal = () => {
        dispatch(closeModal(ModalIdentifiers.PRICING_MODAL));
    };

    const starterBriefing = [
        formatMessage({id: 'pricing_modal.briefing.unlimitedWorkspaceTeams', defaultMessage: 'Unlimited workspace teams'}),
        formatMessage({id: 'pricing_modal.briefing.unlimitedPlaybookRuns', defaultMessage: 'Unlimited playbooks and runs'}),
        formatMessage({id: 'pricing_modal.extra_briefing.free.calls', defaultMessage: '1:1 voice calls and screen share'}),
        formatMessage({id: 'pricing_modal.briefing.fullMessageAndHistory', defaultMessage: 'Full message and file history'}),
        formatMessage({id: 'pricing_modal.briefing.ssoWithGitLab', defaultMessage: 'SSO with Gitlab'}),
    ];

    const professionalBriefing = [
        formatMessage({id: 'pricing_modal.briefing.customUserGroups', defaultMessage: 'Custom user groups'}),
        formatMessage({id: 'pricing_modal.briefing.voiceCallsScreenSharingInGroupMessagesAndChannels', defaultMessage: 'Voice calls and screen sharing in group messages and channels'}),
        formatMessage({id: 'pricing_modal.extra_briefing.professional.ssoSaml', defaultMessage: 'SSO with SAML 2.0, including Okta, OneLogin and ADFS'}),
        formatMessage({id: 'pricing_modal.extra_briefing.professional.ssoadLdap', defaultMessage: 'SSO support with AD/LDAP, Google, O365, OpenID'}),
        formatMessage({id: 'pricing_modal.extra_briefing.professional.guestAccess', defaultMessage: 'Guest access with MFA enforcement'}),

    ];

    const enterpriseBriefing = [
        formatMessage({id: 'pricing_modal.briefing.enterprise.groupSync', defaultMessage: 'AD/LDAP group sync'}),
        formatMessage({id: 'pricing_modal.briefing.enterprise.mobileSecurity', defaultMessage: 'Advanced mobile security via ID-only push notifications'}),
        formatMessage({id: 'pricing_modal.briefing.enterprise.rolesAndPermissions', defaultMessage: 'Advanced roles and permissions'}),
        formatMessage({id: 'pricing_modal.briefing.enterprise.advancedComplianceManagement', defaultMessage: 'Advanced compliance management'}),
        formatMessage({id: 'pricing_modal.briefing.enterprise.compliance', defaultMessage: 'Advanced compliance management'}),
        formatMessage({id: 'pricing_modal.extra_briefing.enterprise.playBookAnalytics', defaultMessage: 'Playbook analytics dashboard'}),
    ];

    const renderAlert = () => {
        return (
            <div className='alert-option'>
                <span>
                    {formatMessage({id: 'pricing_modal.lookingForCloudOption', defaultMessage: 'Looking for a cloud option?'})}
                </span>
                <a
                    onClick={() => {
                        trackEvent(
                            TELEMETRY_CATEGORIES.SELF_HOSTED_PURCHASING,
                            'click_looking_for_a_cloud_option',
                        );
                    }
                    }
                    href={CloudLinks.CLOUD_SIGNUP_PAGE}
                    rel='noopener noreferrer'
                    target='_blank'
                >{formatMessage({id: 'pricing_modal.reviewDeploymentOptions', defaultMessage: 'Review deployment options'})}</a>
            </div>
        );
    };

    const trialButton = () => {
        return (
            <StartTrialBtn
                message={formatMessage({id: 'pricing_modal.btn.tryDays', defaultMessage: 'Try free for {days} days'}, {days: '30'})}
                telemetryId='start_trial_from_self_hosted_pricing_modal'
                renderAsButton={true}
                disabled={isSelfHostedEnterpriseTrial}
                btnClass={`plan_action_btn ${isSelfHostedEnterpriseTrial ? ButtonCustomiserClasses.grayed : ButtonCustomiserClasses.special}`}
                onClick={closePricingModal}
            />
        );
    };

    return (
        <div className='Content Content--self-hosted'>
            <Modal.Header className='PricingModal__header'>
                <div className='header_lhs'>
                    <h1 className='title'>
                        {formatMessage({id: 'pricing_modal.title', defaultMessage: 'Select a plan'})}
                    </h1>
                    <div>{formatMessage({id: 'pricing_modal.subtitle', defaultMessage: 'Choose a plan to get started'})}</div>
                </div>
                <button
                    id='closeIcon'
                    className='icon icon-close'
                    aria-label='Close'
                    title='Close'
                    onClick={() => {
                        trackEvent('self_hosted_pricing', 'close_pricing_modal');
                        props.onHide();
                    }}
                />
            </Modal.Header>
            <Modal.Body>
                {renderAlert()}
                <div className='PricingModal__body'>
                    <Card
                        id='free'
                        topColor='#339970'
                        plan='Free'
                        planSummary={formatMessage({id: 'pricing_modal.planSummary.free', defaultMessage: 'Increased productivity for small teams'})}
                        price='$0'
                        rate={formatMessage({id: 'pricing_modal.price.freeForever', defaultMessage: 'Free forever'})}
                        planLabel={
                            isStarter ? (
                                <PlanLabel
                                    text={formatMessage({id: 'pricing_modal.planLabel.currentPlan', defaultMessage: 'CURRENT PLAN'})}
                                    color='var(--denim-status-online)'
                                    bgColor='var(--center-channel-bg)'
                                    firstSvg={<CheckMarkSvg/>}
                                />) : undefined}
                        buttonDetails={{
                            action: () => {},
                            text: formatMessage({id: 'pricing_modal.btn.downgrade', defaultMessage: 'Downgrade'}),
                            disabled: true,
                            customClass: ButtonCustomiserClasses.secondary,
                        }}
                        briefing={{
                            title: formatMessage({id: 'pricing_modal.briefing.title', defaultMessage: 'Top features'}),
                            items: starterBriefing,
                        }}
                    />
                    <Card
                        id='professional'
                        topColor='var(--denim-button-bg)'
                        plan='Professional'
                        planSummary={formatMessage({id: 'pricing_modal.planSummary.professional', defaultMessage: 'Scalable solutions for growing teams'})}
                        price='$10'
                        rate={formatMessage({id: 'pricing_modal.rate.userPerMonth', defaultMessage: 'USD per user/month'})}
                        planLabel={
                            isProfessional ? (
                                <PlanLabel
                                    text={formatMessage({id: 'pricing_modal.planLabel.currentPlan', defaultMessage: 'CURRENT PLAN'})}
                                    color='var(--denim-status-online)'
                                    bgColor='var(--center-channel-bg)'
                                    firstSvg={<CheckMarkSvg/>}
                                />) : undefined}
                        buttonDetails={{
                            action: () => {
                                trackEvent('self_hosted_pricing', 'click_upgrade_button');
                                window.open(CloudLinks.SELF_HOSTED_SIGNUP, '_blank');
                            },
                            text: formatMessage({id: 'pricing_modal.btn.upgrade', defaultMessage: 'Upgrade'}),
                            disabled: !isAdmin || isProfessional,
                            customClass: isPostSelfHostedEnterpriseTrial ? ButtonCustomiserClasses.special : ButtonCustomiserClasses.active,
                        }}

                        briefing={{
                            title: formatMessage({id: 'pricing_modal.briefing.title', defaultMessage: 'Top features'}),
                            items: professionalBriefing,
                        }}
                    />
                    <Card
                        id='enterprise'
                        topColor='#E07315'
                        plan='Enterprise'
                        planSummary={formatMessage({id: 'pricing_modal.planSummary.enterprise', defaultMessage: 'Administration, security, and compliance for large teams'})}
                        planLabel={
                            isEnterprise ? (
                                <PlanLabel
                                    text={formatMessage({id: 'pricing_modal.planLabel.currentPlan', defaultMessage: 'CURRENT PLAN'})}
                                    color='var(--denim-status-online)'
                                    bgColor='var(--center-channel-bg)'
                                    firstSvg={<CheckMarkSvg/>}
                                    renderLastDaysOnTrial={true}
                                />) : undefined}
                        buttonDetails={(isPostSelfHostedEnterpriseTrial || !isAdmin) ? {
                            action: () => {
                                trackEvent('self_hosted_pricing', 'click_enterprise_contact_sales');
                                window.open(LicenseLinks.CONTACT_SALES, '_blank');
                            },
                            text: formatMessage({id: 'pricing_modal.btn.contactSales', defaultMessage: 'Contact Sales'}),
                            customClass: ButtonCustomiserClasses.active,
                        } : undefined}
                        customButtonDetails={(!isPostSelfHostedEnterpriseTrial && isAdmin) ? (
                            trialButton()
                        ) : undefined}
                        planTrialDisclaimer={(!isPostSelfHostedEnterpriseTrial && isAdmin) ? <StartTrialCaution/> : undefined}
                        contactSalesCTA={(isPostSelfHostedEnterpriseTrial || !isAdmin) ? undefined : <ContactSalesCTA/>}
                        briefing={{
                            title: formatMessage({id: 'pricing_modal.briefing.title', defaultMessage: 'Top features'}),
                            items: enterpriseBriefing,
                        }}
                    />
                </div>
            </Modal.Body>
        </div>
    );
}

export default SelfHostedContent;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState} from 'react';
import {Modal} from 'react-bootstrap';
import {useDispatch, useSelector} from 'react-redux';

import {closeModal} from 'actions/views/modals';
import {ModalIdentifiers} from 'utils/constants';
import {isModalOpen} from 'selectors/views/modals';
import {GlobalState} from 'types/store';
import {isCurrentLicenseCloud} from 'mattermost-redux/selectors/entities/cloud';

import Content from './content';
import SelfHostedContent from './self_hosted_content';

import './pricing_modal.scss';

type Props = {

    // callerCTA is information about the cta that opened this modal. This helps us provide a telemetry path
    // showing information about how the modal was opened all the way to more CTAs within the modal itself
    callerCTA?: string;
}

function PricingModal(props: Props) {
    const [showModal, setShowModal] = useState(true);
    const dispatch = useDispatch();
    const isCloud = useSelector(isCurrentLicenseCloud);
    const isCloudPurchaseModalOpen = useSelector((state: GlobalState) => isModalOpen(state, ModalIdentifiers.CLOUD_PURCHASE));

    const onHide = () => {
        // this fixes problem when both pricing modal and purchase modal are open and subsequently, when a user closes the pricing modal,
        // the purchase modal becomes unresponsive for sometime because the pricing modal is still in the DOM.
        if (isCloudPurchaseModalOpen) {
            dispatch(closeModal(ModalIdentifiers.PRICING_MODAL));
        } else {
            setShowModal(false);
        }
    };

    const content = isCloud ? (
        <Content
            onHide={onHide}
            callerCTA={props.callerCTA}
        />
    ) : (
        <SelfHostedContent
            onHide={onHide}
        />
    );

    return (
        <Modal
            className='PricingModal'
            show={showModal}
            id='pricingModal'
            onExited={() => {
                dispatch(closeModal(ModalIdentifiers.PRICING_MODAL));
            }}
            data-testid='pricingModal'
            dialogClassName='a11y__modal'
            onHide={onHide}
            role='dialog'
            aria-modal='true'
            aria-labelledby='pricing_modal_title'
        >
            {content}

        </Modal>
    );
}

export default PricingModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import styled from 'styled-components';
import {useIntl} from 'react-intl';

import {LicenseLinks} from 'utils/constants';

const ContainerSpan = styled.span`
font-style: normal;
display: inline-block;
font-weight: 400;
font-size: 10px;
line-height: 14px;
letter-spacing: 0.02em;
color: rgba(var(--center-channel-text-rgb), 0.56);
`;

const Span = styled.span`
font-weight: 600;
`;

const A = styled.a`
color: var(--denim-button-bg);
`;

function StartTrialCaution() {
    const {formatMessage} = useIntl();

    const message = formatMessage({
        id: 'pricing_modal.start_trial.disclaimer',
        defaultMessage: 'By selecting <span>Try free for 30 days,</span> I agree to the <a>Mattermost Software Evaluation Agreement, Privacy Policy,</a> and receiving product emails.',
    }, {
        span: (chunks: React.ReactNode | React.ReactNodeArray) => (<Span>{chunks}</Span>),
        a: (chunks: React.ReactNode | React.ReactNodeArray) => (
            <A
                href={LicenseLinks.SOFTWARE_EVALUATION_AGREEMENT}
                target='_blank'
            >
                {chunks}
            </A>),
    });
    return (<ContainerSpan>{message}</ContainerSpan>);
}

export default StartTrialCaution;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

type Props = {
    className: string;
    status: string;
}

export default class StatusIconNew extends React.PureComponent<Props> {
    static defaultProps: Props = {
        className: '',
        status: '',
    };

    render() {
        const {status, className} = this.props;

        if (!status) {
            return null;
        }

        let iconName = 'icon-circle-outline';
        if (status === 'online') {
            iconName = 'icon-check-circle';
        } else if (status === 'away') {
            iconName = 'icon-clock';
        } else if (status === 'dnd') {
            iconName = 'icon-minus-circle';
        }

        return <i className={`${iconName} ${className}`}/>;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ComponentProps} from 'react';
import styled from 'styled-components';

import OverlayTrigger, {BaseOverlayTrigger} from 'components/overlay_trigger';
import ProfilePopover from 'components/profile_popover';
import StatusIcon from 'components/status_icon';
import StatusIconNew from 'components/status_icon_new';
import Avatar, {TAvatarSizeToken, getAvatarWidth} from 'components/widgets/users/avatar';

import './profile_picture.scss';

interface MMOverlayTrigger extends BaseOverlayTrigger {
    hide: () => void;
}

type Props = {
    hasMention?: boolean;
    isBusy?: boolean;
    isEmoji?: boolean;
    isRHS?: boolean;
    profileSrc?: string;
    size?: ComponentProps<typeof Avatar>['size'];
    src: string;
    status?: string;
    userId?: string;
    channelId?: string;
    username?: string;
    wrapperClass?: string;
    overwriteIcon?: string;
    overwriteName?: string;
    newStatusIcon?: boolean;
    statusClass?: string;
    isBot?: boolean;
    fromWebhook?: boolean;
    fromAutoResponder?: boolean;
    popoverPlacement?: string;
}

export default class ProfilePicture extends React.PureComponent<Props> {
    public static defaultProps = {
        size: 'md',
        isRHS: false,
        isEmoji: false,
        hasMention: false,
        wrapperClass: '',
        popoverPlacement: 'right',
    };

    overlay = React.createRef<MMOverlayTrigger>();
    buttonRef = React.createRef<HTMLButtonElement>();

    public hideProfilePopover = () => {
        if (this.overlay.current) {
            this.overlay.current.hide();
        }
    }

    public render() {
        // profileSrc will, if possible, be the original user profile picture even if the icon
        // for the post is overriden, so that the popup shows the user identity
        const profileSrc = (typeof this.props.profileSrc === 'string' && this.props.profileSrc !== '') ? this.props.profileSrc : this.props.src;

        const profileIconClass = `profile-icon ${this.props.isEmoji ? 'emoji' : ''}`;

        const hideStatus = this.props.isBot || this.props.fromAutoResponder || this.props.fromWebhook;

        if (this.props.userId) {
            return (
                <OverlayTrigger
                    ref={this.overlay}
                    trigger={['click']}
                    placement={this.props.popoverPlacement}
                    rootClose={true}
                    overlay={
                        <ProfilePopover
                            className='user-profile-popover'
                            userId={this.props.userId}
                            src={profileSrc}
                            isBusy={this.props.isBusy}
                            hide={this.hideProfilePopover}
                            isRHS={this.props.isRHS}
                            channelId={this.props.channelId}
                            hasMention={this.props.hasMention}
                            overwriteIcon={this.props.overwriteIcon}
                            overwriteName={this.props.overwriteName}
                            fromWebhook={this.props.fromWebhook}
                            hideStatus={hideStatus}
                        />
                    }
                >
                    <span className={`status-wrapper  ${this.props.wrapperClass}`}>
                        <RoundButton
                            className='style--none'
                            size={this.props.size ?? 'md'}
                            ref={this.buttonRef}
                        >
                            <span className={profileIconClass}>

                                <Avatar
                                    username={this.props.username}
                                    size={this.props.size}
                                    url={this.props.src}
                                    tabIndex={-1}
                                />
                            </span>
                        </RoundButton>

                        <StatusIcon status={this.props.status}/>
                    </span>
                </OverlayTrigger>
            );
        }
        return (
            <span className={`status-wrapper style--none ${this.props.wrapperClass}`}>
                <span className={profileIconClass}>
                    <Avatar
                        size={this.props.size}
                        url={this.props.src}
                    />
                </span>
                {this.props.newStatusIcon ? (
                    <StatusIconNew
                        className={this.props.statusClass}
                        status={this.props.status}
                    />
                ) : <StatusIcon status={this.props.status}/>}
            </span>
        );
    }
}

const RoundButton = styled.button<{size: TAvatarSizeToken}>`
    border-radius: 50%;

    width: ${(p) => getAvatarWidth(p.size)}px;
    height: ${(p) => getAvatarWidth(p.size)}px;
`;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {getTeamMember} from 'mattermost-redux/actions/teams';
import {getChannelMember} from 'mattermost-redux/actions/channels';

export function getMembershipForEntities(teamId, userId, channelId) {
    return async (dispatch) => {
        return Promise.all([
            dispatch(getTeamMember(teamId, userId)),
            channelId && dispatch(getChannelMember(channelId, userId)),
        ]);
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {
    getChannelsInCurrentTeam,
} from 'mattermost-redux/selectors/entities/channels';
import {getMyChannelMemberships} from 'mattermost-redux/selectors/entities/common';
import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentUserLocale} from 'mattermost-redux/selectors/entities/i18n';
import {haveIChannelPermission} from 'mattermost-redux/selectors/entities/roles';
import {Permissions} from 'mattermost-redux/constants';
import {sortChannelsByTypeAndDisplayName} from 'mattermost-redux/utils/channel_utils';
import {logError} from 'mattermost-redux/actions/errors';

import store from 'stores/redux_store.jsx';
import {Constants} from 'utils/constants';

import Provider from './provider';
import Suggestion from './suggestion.jsx';

class SearchChannelWithPermissionsSuggestion extends Suggestion {
    static get propTypes() {
        return {
            ...super.propTypes,
        };
    }

    render() {
        const {item, isSelection} = this.props;
        const channel = item.channel;
        const channelIsArchived = channel.delete_at && channel.delete_at !== 0;

        let className = 'suggestion-list__item';
        if (isSelection) {
            className += ' suggestion--selected';
        }

        const displayName = channel.display_name;
        let icon = null;
        if (channelIsArchived) {
            icon = (
                <i className='icon icon--no-spacing icon-archive-outline'/>
            );
        } else if (channel.type === Constants.OPEN_CHANNEL) {
            icon = (
                <i className='icon icon--no-spacing icon-globe'/>
            );
        } else if (channel.type === Constants.PRIVATE_CHANNEL) {
            icon = (
                <i className='icon icon--no-spacing icon-lock-outline'/>
            );
        }

        return (
            <div
                onClick={this.handleClick}
                className={className}
                onMouseMove={this.handleMouseMove}
                ref={(node) => {
                    this.node = node;
                }}
                {...Suggestion.baseProps}
            >
                <span className='suggestion-list__icon suggestion-list__icon--large'>{icon}</span>
                <div className='suggestion-list__ellipsis'>
                    <span className='suggestion-list__main'>{displayName}</span>
                </div>
            </div>
        );
    }
}

let prefix = '';

function channelSearchSorter(wrappedA, wrappedB) {
    const aIsArchived = wrappedA.channel.delete_at ? wrappedA.channel.delete_at !== 0 : false;
    const bIsArchived = wrappedB.channel.delete_at ? wrappedB.channel.delete_at !== 0 : false;
    if (aIsArchived && !bIsArchived) {
        return 1;
    } else if (!aIsArchived && bIsArchived) {
        return -1;
    }

    const locale = getCurrentUserLocale(store.getState());

    const a = wrappedA.channel;
    const b = wrappedB.channel;

    const aDisplayName = a.display_name.toLowerCase();
    const bDisplayName = b.display_name.toLowerCase();

    const aStartsWith = aDisplayName.startsWith(prefix);
    const bStartsWith = bDisplayName.startsWith(prefix);
    if (aStartsWith && bStartsWith) {
        return sortChannelsByTypeAndDisplayName(locale, a, b);
    } else if (!aStartsWith && !bStartsWith) {
        return sortChannelsByTypeAndDisplayName(locale, a, b);
    } else if (aStartsWith) {
        return -1;
    }

    return 1;
}

export default class SearchChannelWithPermissionsProvider extends Provider {
    constructor(channelSearchFunc) {
        super();
        this.autocompleteChannelsForSearch = channelSearchFunc;
    }

    makeChannelSearchFilter(channelPrefix) {
        const channelPrefixLower = channelPrefix.toLowerCase();

        return (channel) => {
            const state = store.getState();
            const channelId = channel.id;
            const teamId = getCurrentTeamId(state);

            const searchString = channel.display_name;

            if (channel.type === Constants.OPEN_CHANNEL &&
                haveIChannelPermission(state, teamId, channelId, Permissions.MANAGE_PUBLIC_CHANNEL_MEMBERS)) {
                return searchString.toLowerCase().includes(channelPrefixLower);
            } else if (channel.type === Constants.PRIVATE_CHANNEL &&
                haveIChannelPermission(state, teamId, channelId, Permissions.MANAGE_PRIVATE_CHANNEL_MEMBERS)) {
                return searchString.toLowerCase().includes(channelPrefixLower);
            }

            return false;
        };
    }

    handlePretextChanged(channelPrefix, resultsCallback) {
        if (channelPrefix) {
            prefix = channelPrefix;
            this.startNewRequest(channelPrefix);
            const state = store.getState();

            // Dispatch suggestions for local data
            const channels = getChannelsInCurrentTeam(state);
            this.formatChannelsAndDispatch(channelPrefix, resultsCallback, channels);

            // Fetch data from the server and dispatch
            this.fetchChannels(channelPrefix, resultsCallback);
        }

        return true;
    }

    async fetchChannels(channelPrefix, resultsCallback) {
        const state = store.getState();
        const teamId = getCurrentTeamId(state);
        if (!teamId) {
            return;
        }

        const channelsAsync = this.autocompleteChannelsForSearch(teamId, channelPrefix);

        let channelsFromServer = [];
        try {
            const {data} = await channelsAsync;
            channelsFromServer = data;
        } catch (err) {
            store.dispatch(logError(err));
        }

        if (this.shouldCancelDispatch(channelPrefix)) {
            return;
        }

        const channels = getChannelsInCurrentTeam(state).concat(channelsFromServer);
        this.formatChannelsAndDispatch(channelPrefix, resultsCallback, channels);
    }

    formatChannelsAndDispatch(channelPrefix, resultsCallback, allChannels) {
        const channels = [];

        const state = store.getState();

        const members = getMyChannelMemberships(state);

        if (this.shouldCancelDispatch(channelPrefix)) {
            return;
        }

        const completedChannels = {};

        const channelFilter = this.makeChannelSearchFilter(channelPrefix);

        const config = getConfig(state);
        const viewArchivedChannels = config.ExperimentalViewArchivedChannels === 'true';

        for (const id of Object.keys(allChannels)) {
            const channel = allChannels[id];
            if (!channel) {
                continue;
            }

            if (completedChannels[channel.id]) {
                continue;
            }

            if (channelFilter(channel)) {
                const newChannel = Object.assign({}, channel);
                const channelIsArchived = channel.delete_at !== 0;

                const wrappedChannel = {channel: newChannel, name: newChannel.name, deactivated: false};
                if (!viewArchivedChannels && channelIsArchived) {
                    continue;
                } else if (!members[channel.id]) {
                    continue;
                } else if (channel.type === Constants.OPEN_CHANNEL) {
                    wrappedChannel.type = Constants.OPEN_CHANNEL;
                } else if (channel.type === Constants.PRIVATE_CHANNEL) {
                    wrappedChannel.type = Constants.PRIVATE_CHANNEL;
                } else {
                    continue;
                }
                completedChannels[channel.id] = true;
                channels.push(wrappedChannel);
            }
        }

        const channelNames = channels.
            sort(channelSearchSorter).
            map((wrappedChannel) => wrappedChannel.channel.name);

        resultsCallback({
            matchedPretext: channelPrefix,
            terms: channelNames,
            items: channels,
            component: SearchChannelWithPermissionsSuggestion,
        });
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/* eslint-disable react/no-string-refs */

import React, {ChangeEvent, FormEvent} from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

import {getFullName} from 'mattermost-redux/utils/user_utils';
import {ActionResult} from 'mattermost-redux/types/actions';

import SearchChannelWithPermissionsProvider from 'components/suggestion/search_channel_with_permissions_provider.jsx';
import SuggestionBox from 'components/suggestion/suggestion_box';
import SuggestionBoxComponent from 'components/suggestion/suggestion_box/suggestion_box';
import ModalSuggestionList from 'components/suggestion/modal_suggestion_list';

import {placeCaretAtEnd} from 'utils/utils';

import {UserProfile} from '@mattermost/types/users';
import {Channel, ChannelMembership} from '@mattermost/types/channels';
import {RelationOneToOne} from '@mattermost/types/utilities';

export type Props = {

    /**
    * Function that's called after modal is closed
    */
    onExited: () => void;

    /**
    * The user that is being added to a channel
    */
    user: UserProfile;

    /**
    * Object used to determine if the user
    * is a member of a given channel
    */
    channelMembers: RelationOneToOne<Channel, Record<string, ChannelMembership>>;

    actions: {

        /**
        * Function to add the user to a channel
        */
        addChannelMember: (channelId: string, userId: string) => Promise<ActionResult>;

        /**
        * Function to fetch the user's channel membership
        */
        getChannelMember: (channelId: string, userId: string) => Promise<ActionResult>;

        /**
        * Function passed on to the constructor of the
        * SearchChannelWithPermissionsProvider class to fetch channels
        * based on a search term
        */
        autocompleteChannelsForSearch: (teamId: string, term: string) => Promise<ActionResult>;
    };

}

type State = {

    /**
    * Whether or not the modal is visible
    */
    show: boolean;

    /**
    * Whether or not a request to add the user is in progress
    */
    saving: boolean;

    /**
    * Whether or not a request to check for the user's channel membership
    * is in progress
    */
    checkingForMembership: boolean;

    /**
    * The user input in the channel search box
    */
    text: string;

    /**
    * The id for the channel that is selected
    */
    selectedChannelId: string | null;

    /**
    * An error to display when the add request fails
    */
    submitError: string;
}

export default class AddUserToChannelModal extends React.PureComponent<Props, State> {
    private suggestionProviders: SearchChannelWithPermissionsProvider[];
    private channelSearchBox?: SuggestionBoxComponent;

    constructor(props: Props) {
        super(props);

        this.state = {
            show: true,
            saving: false,
            checkingForMembership: false,
            text: '',
            selectedChannelId: null,
            submitError: '',
        };
        this.suggestionProviders = [new SearchChannelWithPermissionsProvider(props.actions.autocompleteChannelsForSearch)];
        this.enableChannelProvider();
    }

    enableChannelProvider = () => {
        this.suggestionProviders[0].disableDispatches = false;
    }

    focusTextbox = () => {
        if (this.channelSearchBox == null) {
            return;
        }

        const textbox = this.channelSearchBox.getTextbox();
        if (document.activeElement !== textbox) {
            textbox.focus();
            placeCaretAtEnd(textbox);
        }
    }

    onInputChange = (e: ChangeEvent<HTMLInputElement>) => {
        this.setState({text: e.target.value, selectedChannelId: null});
    }

    onHide = () => {
        this.setState({show: false});
    }

    onExited = () => {
        this.props.onExited();
    }

    setSearchBoxRef = (input: SuggestionBoxComponent) => {
        this.channelSearchBox = input;
        this.focusTextbox();
    }

    handleSubmitError = (error: {message: string}) => {
        if (error) {
            this.setState({submitError: error.message, saving: false});
        }
    }

    didSelectChannel = (selection: {channel: Channel}) => {
        const channel = selection.channel;
        const userId = this.props.user.id;

        this.setState({
            text: channel.display_name,
            selectedChannelId: channel.id,
            checkingForMembership: true,
            submitError: '',
        });

        this.props.actions.getChannelMember(channel.id, userId).then(() => {
            this.setState({checkingForMembership: false});
        });
    }

    handleSubmit = (e: FormEvent) => {
        if (e && e.preventDefault) {
            e.preventDefault();
        }

        const channelId = this.state.selectedChannelId;
        const user = this.props.user;

        if (!channelId) {
            return;
        }

        if (this.isUserMemberOfChannel(channelId) || this.state.saving) {
            return;
        }

        this.setState({saving: true});

        this.props.actions.addChannelMember(channelId, user.id).then(({error}) => {
            if (error) {
                this.handleSubmitError(error);
            } else {
                this.onHide();
            }
        });
    }

    isUserMemberOfChannel = (channelId: string | null) => {
        const user = this.props.user;
        const memberships = this.props.channelMembers;

        if (!channelId) {
            return false;
        }

        if (!memberships[channelId]) {
            return false;
        }

        return Boolean(memberships[channelId][user.id]);
    }

    render() {
        const user = this.props.user;
        const channelId = this.state.selectedChannelId;
        const targetUserIsMemberOfSelectedChannel = this.isUserMemberOfChannel(channelId);

        let name = getFullName(user);
        if (!name) {
            name = `@${user.username}`;
        }

        let errorMsg;
        if (!this.state.saving) {
            if (this.state.submitError) {
                errorMsg = (
                    <label
                        id='add-user-to-channel-modal__invite-error'
                        className='modal__error has-error control-label'
                    >
                        {this.state.submitError}
                    </label>
                );
            } else if (targetUserIsMemberOfSelectedChannel) {
                errorMsg = (
                    <label
                        id='add-user-to-channel-modal__user-is-member'
                        className='modal__error has-error control-label'
                    >
                        <FormattedMessage
                            id='add_user_to_channel_modal.membershipExistsError'
                            defaultMessage='{name} is already a member of that channel'
                            values={{
                                name,
                            }}
                        />
                    </label>
                );
            }
        }

        const help = (
            <FormattedMessage
                id='add_user_to_channel_modal.help'
                defaultMessage='Type to find a channel. Use  to browse,  to select, ESC to dismiss.'
            />
        );

        const content = (
            <SuggestionBox
                ref={this.setSearchBoxRef}
                className='form-control focused'
                onChange={this.onInputChange}
                value={this.state.text}
                onItemSelected={this.didSelectChannel}
                listComponent={ModalSuggestionList}
                maxLength='64'
                providers={this.suggestionProviders}
                listPosition='bottom'
                completeOnTab={false}
                delayInputUpdate={true}
                openWhenEmpty={false}
            />
        );

        const shouldDisableAddButton = targetUserIsMemberOfSelectedChannel ||
            this.state.checkingForMembership ||
            Boolean(!this.state.selectedChannelId) ||
            this.state.saving;

        return (
            <Modal
                dialogClassName='a11y__modal modal--overflow'
                show={this.state.show}
                onHide={this.onHide}
                onExited={this.onExited}
                ref='modal'
                enforceFocus={true}
                role='dialog'
                aria-labelledby='addChannelModalLabel'
            >
                <Modal.Header closeButton={true}>
                    <Modal.Title
                        componentClass='h1'
                        id='addChannelModalLabel'
                    >
                        <FormattedMessage
                            id='add_user_to_channel_modal.title'
                            defaultMessage='Add {name} to a Channel'
                            values={{
                                name,
                            }}
                        />
                    </Modal.Title>
                </Modal.Header>
                <form
                    role='form'
                    onSubmit={this.handleSubmit}
                >
                    <Modal.Body>
                        <div className='modal__hint'>
                            {help}
                        </div>
                        <div className='pos-relative'>
                            {content}
                        </div>
                        <div>
                            {errorMsg}
                            <br/>
                        </div>
                    </Modal.Body>
                    <Modal.Footer>
                        <button
                            type='button'
                            className='btn btn-link'
                            onClick={this.onHide}
                        >
                            <FormattedMessage
                                id='add_user_to_channel_modal.cancel'
                                defaultMessage='Cancel'
                            />
                        </button>
                        <button
                            type='button'
                            id='add-user-to-channel-modal__add-button'
                            className='btn btn-primary'
                            onClick={this.handleSubmit}
                            disabled={shouldDisableAddButton}
                        >
                            <FormattedMessage
                                id='add_user_to_channel_modal.add'
                                defaultMessage='Add'
                            />
                        </button>
                    </Modal.Footer>
                </form>
            </Modal>
        );
    }
}
/* eslint-enable react/no-string-refs */

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {addChannelMember, getChannelMember, autocompleteChannelsForSearch} from 'mattermost-redux/actions/channels';
import {getChannelMembersInChannels} from 'mattermost-redux/selectors/entities/channels';

import {GlobalState} from '@mattermost/types/store';

import {ActionFunc} from 'mattermost-redux/types/actions';

import AddUserToChannelModal, {Props} from './add_user_to_channel_modal';

function mapStateToProps(state: GlobalState) {
    const channelMembers = getChannelMembersInChannels(state) || {};
    return {
        channelMembers,
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc>, Props['actions']>({
            addChannelMember,
            getChannelMember,
            autocompleteChannelsForSearch,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(AddUserToChannelModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage, injectIntl, IntlShape} from 'react-intl';

import EventEmitter from 'mattermost-redux/utils/event_emitter';
import StatusIcon from 'components/status_icon';
import Timestamp from 'components/timestamp';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import UserSettingsModal from 'components/user_settings/modal';
import {getHistory} from 'utils/browser_history';
import * as GlobalActions from 'actions/global_actions';
import Constants, {A11yClassNames, A11yCustomEventTypes, A11yFocusEventDetail, ModalIdentifiers, UserStatuses} from 'utils/constants';
import {t} from 'utils/i18n';
import * as Utils from 'utils/utils';
import {shouldFocusMainTextbox} from 'utils/post_utils';
import {displayUsername, isGuest, isSystemAdmin} from 'mattermost-redux/utils/user_utils';
import Pluggable from 'plugins/pluggable';
import AddUserToChannelModal from 'components/add_user_to_channel_modal';
import LocalizedIcon from 'components/localized_icon';
import ToggleModalButton from 'components/toggle_modal_button';
import Avatar from 'components/widgets/users/avatar';
import Popover from 'components/widgets/popover';
import SharedUserIndicator from 'components/shared_user_indicator';
import CustomStatusEmoji from 'components/custom_status/custom_status_emoji';
import CustomStatusModal from 'components/custom_status/custom_status_modal';
import CustomStatusText from 'components/custom_status/custom_status_text';
import ExpiryTime from 'components/custom_status/expiry_time';
import {UserCustomStatus, UserProfile, UserTimezone, CustomStatusDuration} from '@mattermost/types/users';
import {ServerError} from '@mattermost/types/errors';
import {ModalData} from 'types/actions';

import './profile_popover.scss';

interface ProfilePopoverProps extends Omit<React.ComponentProps<typeof Popover>, 'id'>{

    /**
     * Source URL from the image to display in the popover
     */
    src: string;

    /**
     * Source URL from the image that should override default image
     */
    overwriteIcon?: string;

    /**
     * Set to true of the popover was opened from a webhook post
     */
    fromWebhook?: boolean;

    /**
     * User the popover is being opened for
     */
    user?: UserProfile;
    userId: string;
    channelId?: string;

    /**
     * Status for the user, either 'offline', 'away', 'dnd' or 'online'
     */
    status?: string;
    hideStatus?: boolean;

    /**
     * Function to call to hide the popover
     */
    hide?: () => void;

    /**
     * Function to call to return focus to the previously focused element when the popover closes.
     * If not provided, the popover will automatically determine the previously focused element
     * and focus that on close. However, if the previously focused element is not correctly detected
     * by the popover, or the previously focused element will disappear after the popover opens,
     * it is necessary to provide this function to focus the correct element.
     */
    returnFocus?: () => void;

    /**
     * Set to true if the popover was opened from the right-hand
     * sidebar (comment thread, search results, etc.)
     */
    isRHS?: boolean;
    isBusy?: boolean;
    isMobileView: boolean;

    /**
     * Returns state of modals in redux for determing which need to be closed
     */
    modals?: {
        modalState: {
            [modalId: string]: {
                open: boolean;
                dialogProps: Record<string, any>;
                dialogType: React.ComponentType;
            };
        };
    };
    currentTeamId: string;

    /**
     * @internal
     */
    currentUserId: string;
    customStatus?: UserCustomStatus | null;
    isCustomStatusEnabled: boolean;
    isCustomStatusExpired: boolean;
    currentUserTimezone?: string;

    /**
     * @internal
     */
    hasMention?: boolean;

    /**
     * @internal
     */
    isInCurrentTeam: boolean;

    /**
     * @internal
     */
    teamUrl: string;

    /**
     * @internal
     */
    isTeamAdmin: boolean;

    /**
     * @internal
     */
    isChannelAdmin: boolean;

    /**
     * @internal
     */
    canManageAnyChannelMembersInCurrentTeam: boolean;

    /**
     * @internal
     */
    teammateNameDisplay: string;

    /**
     * The overwritten username that should be shown at the top of the popover
     */
    overwriteName?: React.ReactNode;

    /**
     * @internal
     */
    enableTimezone: boolean;
    actions: {
        openModal: <P>(modalData: ModalData<P>) => void;
        closeModal: (modalId: string) => void;
        openDirectChannelToUserId: (userId?: string) => Promise<{error: ServerError}>;
        getMembershipForEntities: (teamId: string, userId: string, channelId?: string) => Promise<void>;
    };
    intl: IntlShape;

    lastActivityTimestamp: number;

    enableLastActiveTime: boolean;

    timestampUnits: string[];
}
type ProfilePopoverState = {
    loadingDMChannel?: string;
};

/**
 * The profile popover, or hovercard, that appears with user information when clicking
 * on the username or profile picture of a user.
 */
class ProfilePopover extends React.PureComponent<
ProfilePopoverProps,
ProfilePopoverState
> {
    titleRef: React.RefObject<HTMLDivElement>;
    returnFocus: () => void;

    static getComponentName() {
        return 'ProfilePopover';
    }
    static defaultProps = {
        isRHS: false,
        hasMention: false,
        status: UserStatuses.OFFLINE,
        customStatus: null,
    };
    constructor(props: ProfilePopoverProps) {
        super(props);
        this.state = {
            loadingDMChannel: undefined,
        };
        this.titleRef = React.createRef();

        if (this.props.returnFocus) {
            this.returnFocus = this.props.returnFocus;
        } else {
            const previouslyFocused = document.activeElement;
            this.returnFocus = () => {
                document.dispatchEvent(new CustomEvent<A11yFocusEventDetail>(
                    A11yCustomEventTypes.FOCUS, {
                        detail: {
                            target: previouslyFocused as HTMLElement,
                            keyboardOnly: true,
                        },
                    },
                ));
            };
        }
    }
    componentDidMount() {
        const {currentTeamId, userId, channelId} = this.props;
        if (currentTeamId && userId) {
            this.props.actions.getMembershipForEntities(
                currentTeamId,
                userId,
                channelId,
            );
        }

        // Focus the title when the popover first opens, to bring the focus into the popover.
        document.dispatchEvent(new CustomEvent<A11yFocusEventDetail>(
            A11yCustomEventTypes.FOCUS, {
                detail: {
                    target: this.titleRef.current,
                    keyboardOnly: true,
                },
            },
        ));
    }
    handleShowDirectChannel = (e: React.MouseEvent<HTMLAnchorElement>) => {
        const {actions} = this.props;
        e.preventDefault();
        if (!this.props.user) {
            return;
        }
        const user = this.props.user;
        if (this.state.loadingDMChannel !== undefined) {
            return;
        }
        this.setState({loadingDMChannel: user.id});
        actions.openDirectChannelToUserId(user.id).then((result: {error: ServerError}) => {
            if (!result.error) {
                if (this.props.isMobileView) {
                    GlobalActions.emitCloseRightHandSide();
                }
                this.setState({loadingDMChannel: undefined});
                if (this.props.hide) {
                    this.props.hide();
                }
                getHistory().push(`${this.props.teamUrl}/messages/@${user.username}`);
            }
        });
        this.handleCloseModals();
    };
    handleMentionKeyClick = () => {
        if (!this.props.user) {
            return;
        }
        if (this.props.hide) {
            this.props.hide();
        }
        EventEmitter.emit(
            'mention_key_click',
            this.props.user.username,
            this.props.isRHS,
        );
        this.handleCloseModals();
    };
    handleEditAccountSettings = () => {
        if (!this.props.user) {
            return;
        }
        if (this.props.hide) {
            this.props.hide();
        }
        this.props.actions.openModal({
            modalId: ModalIdentifiers.USER_SETTINGS,
            dialogType: UserSettingsModal,
            dialogProps: {isContentProductSettings: false, onExited: this.returnFocus},
        });
        this.handleCloseModals();
    };
    showCustomStatusModal = () => {
        if (this.props.hide) {
            this.props.hide();
        }
        const customStatusInputModalData = {
            modalId: ModalIdentifiers.CUSTOM_STATUS,
            dialogType: CustomStatusModal,
            dialogProps: {onExited: this.returnFocus},
        };
        this.props.actions.openModal(customStatusInputModalData);
    };
    handleAddToChannel = () => {
        this.props.hide?.();
        this.handleCloseModals();
    };
    handleCloseModals = () => {
        const {modals} = this.props;
        for (const modal in modals?.modalState) {
            if (!Object.prototype.hasOwnProperty.call(modals, modal)) {
                continue;
            }
            if (modals?.modalState[modal].open) {
                this.props.actions.closeModal(modal);
            }
        }
    };
    handleKeyDown = (e: React.KeyboardEvent) => {
        if (shouldFocusMainTextbox(e, document.activeElement)) {
            this.props.hide?.();
        } else if (Utils.isKeyPressed(e, Constants.KeyCodes.ESCAPE)) {
            this.returnFocus();
        }
    }
    renderCustomStatus() {
        const {
            customStatus,
            isCustomStatusEnabled,
            user,
            currentUserId,
            hideStatus,
            isCustomStatusExpired,
        } = this.props;
        const customStatusSet = (customStatus?.text || customStatus?.emoji) && !isCustomStatusExpired;
        const canSetCustomStatus = user?.id === currentUserId;
        const shouldShowCustomStatus =
      isCustomStatusEnabled &&
      !hideStatus &&
      (customStatusSet || canSetCustomStatus);
        if (!shouldShowCustomStatus) {
            return null;
        }
        let customStatusContent;
        let expiryContent;
        if (customStatusSet) {
            const customStatusEmoji = (
                <span className='d-flex'>
                    <CustomStatusEmoji
                        userID={this.props.user?.id}
                        showTooltip={false}
                        emojiStyle={{
                            marginRight: 4,
                            marginTop: 1,
                        }}
                    />
                </span>
            );
            customStatusContent = (
                <div className='d-flex'>
                    {customStatusEmoji}
                    <CustomStatusText
                        tooltipDirection='top'
                        text={customStatus?.text || ''}
                        className='user-popover__email pb-1'
                    />
                </div>
            );

            expiryContent = customStatusSet && customStatus?.expires_at && customStatus.duration !== CustomStatusDuration.DONT_CLEAR && (
                <ExpiryTime
                    time={customStatus.expires_at}
                    timezone={this.props.currentUserTimezone}
                    className='ml-1'
                    withinBrackets={true}
                />
            );
        } else if (canSetCustomStatus) {
            customStatusContent = (
                <div>
                    <button
                        className='user-popover__set-custom-status-btn'
                        onClick={this.showCustomStatusModal}
                    >
                        <FormattedMessage
                            id='user_profile.custom_status.set_status'
                            defaultMessage='Set a status'
                        />
                    </button>
                </div>
            );
        }

        return {customStatusContent, expiryContent};
    }
    render() {
        if (!this.props.user) {
            return null;
        }

        const keysToBeRemoved: Array<keyof ProfilePopoverProps> = ['user', 'userId', 'channelId', 'src', 'status', 'hideStatus', 'isBusy',
            'hide', 'isRHS', 'hasMention', 'enableTimezone', 'currentUserId', 'currentTeamId', 'teamUrl', 'actions', 'isTeamAdmin',
            'isChannelAdmin', 'canManageAnyChannelMembersInCurrentTeam', 'intl'];
        const popoverProps: React.ComponentProps<typeof Popover> = Utils.deleteKeysFromObject({...this.props},
            keysToBeRemoved);
        const {formatMessage} = this.props.intl;
        const dataContent = [];
        const urlSrc = this.props.overwriteIcon ? this.props.overwriteIcon : this.props.src;
        dataContent.push(
            <div
                className='user-popover-image'
                key='user-popover-image'
            >
                <Avatar
                    size='xxl'
                    username={this.props.user?.username || ''}
                    url={urlSrc}
                    tabIndex={-1}
                />
                <StatusIcon
                    className='status user-popover-status'
                    status={this.props.hideStatus ? undefined : this.props.status}
                    button={true}
                />
            </div>,
        );
        if (this.props.enableLastActiveTime && this.props.lastActivityTimestamp && this.props.timestampUnits) {
            dataContent.push(
                <div
                    className='user-popover-last-active'
                    key='user-popover-last-active'
                >
                    <FormattedMessage
                        id='channel_header.lastActive'
                        defaultMessage='Active {timestamp}'
                        values={{
                            timestamp: (
                                <Timestamp
                                    value={this.props.lastActivityTimestamp}
                                    units={this.props.timestampUnits}
                                    useTime={false}
                                    style={'short'}
                                />
                            ),
                        }}
                    />
                </div>,
            );
        }

        const fullname = Utils.getFullName(this.props.user);
        const haveOverrideProp =
      this.props.overwriteIcon || this.props.overwriteName;
        if ((fullname || this.props.user.position) && !haveOverrideProp) {
            dataContent.push(
                <hr
                    key='user-popover-hr'
                    className='divider divider--expanded'
                />,
            );
        }
        if (fullname && !haveOverrideProp) {
            let sharedIcon;
            if (this.props.user.remote_id) {
                sharedIcon = (
                    <SharedUserIndicator
                        className='shared-user-icon'
                        withTooltip={true}
                    />
                );
            }
            dataContent.push(
                <div
                    data-testId={`popover-fullname-${this.props.user.username}`}
                    className='overflow--ellipsis text-nowrap'
                    key='user-popover-fullname'
                >
                    <OverlayTrigger
                        delayShow={Constants.OVERLAY_TIME_DELAY}
                        placement='top'
                        overlay={<Tooltip id='fullNameTooltip'>{fullname}</Tooltip>}
                    >
                        <span className='user-profile-popover__heading'>{fullname}</span>
                    </OverlayTrigger>
                    {sharedIcon}
                </div>,
            );
        }
        if (this.props.user.is_bot && !haveOverrideProp) {
            dataContent.push(
                <div
                    key='bot-description'
                    className='overflow--ellipsis text-nowrap'
                >
                    {this.props.user.bot_description}
                </div>,
            );
        }
        if (this.props.user.position && !haveOverrideProp) {
            const position = (this.props.user?.position || '').substring(
                0,
                Constants.MAX_POSITION_LENGTH,
            );
            dataContent.push(
                <OverlayTrigger
                    delayShow={Constants.OVERLAY_TIME_DELAY}
                    placement='top'
                    overlay={<Tooltip id='positionTooltip'>{position}</Tooltip>}
                    key='user-popover-position'
                >
                    <div className='overflow--ellipsis text-nowrap pt-1 pb-1'>
                        {position}
                    </div>
                </OverlayTrigger>,
            );
        }
        const email = this.props.user.email || '';
        if (email && !this.props.user.is_bot && !haveOverrideProp) {
            dataContent.push(
                <hr
                    key='user-popover-hr2'
                    className='divider divider--expanded'
                />,
            );
            dataContent.push(
                <div
                    data-toggle='tooltip'
                    title={email}
                    key='user-popover-email'
                >
                    <a
                        href={'mailto:' + email}
                        className='text-nowrap text-lowercase user-popover__email pb-1'
                    >
                        {email}
                    </a>
                </div>,
            );
        }
        dataContent.push(
            <Pluggable
                key='profilePopoverPluggable2'
                pluggableName='PopoverUserAttributes'
                user={this.props.user}
                hide={this.props.hide}
                status={this.props.hideStatus ? null : this.props.status}
                fromWebhook={this.props.fromWebhook}
            />,
        );
        if (
            this.props.enableTimezone &&
            this.props.user.timezone &&
            !haveOverrideProp
        ) {
            dataContent.push(
                <div
                    key='user-popover-local-time'
                    className='pb-1'
                >
                    <span className='user-profile-popover__heading'>
                        <FormattedMessage
                            id='user_profile.account.localTime'
                            defaultMessage='Local Time'
                        />
                    </span>
                    <div>
                        <Timestamp
                            useRelative={false}
                            useDate={false}
                            userTimezone={this.props.user?.timezone as UserTimezone | undefined}
                            useTime={{
                                hour: 'numeric',
                                minute: 'numeric',
                                timeZoneName: 'short',
                            }}
                        />
                    </div>
                </div>,
            );
        }

        const customStatusAndExpiryContent = !haveOverrideProp && this.renderCustomStatus();
        if (customStatusAndExpiryContent) {
            const {customStatusContent, expiryContent} = customStatusAndExpiryContent;
            dataContent.push(
                <div
                    key='user-popover-status'
                    id='user-popover-status'
                    className='pb-1'
                >
                    <span className='user-profile-popover__heading'>
                        <FormattedMessage
                            id='user_profile.custom_status'
                            defaultMessage='Status'
                        />
                        {expiryContent}
                    </span>
                    {customStatusContent}
                </div>,
            );
        }
        if (this.props.user.id === this.props.currentUserId && !haveOverrideProp) {
            dataContent.push(
                <div
                    data-toggle='tooltip'
                    key='user-popover-settings'
                    className='popover__row first'
                >
                    <button
                        className='style--link'
                        onClick={this.handleEditAccountSettings}
                    >
                        <LocalizedIcon
                            className='fa fa-pencil-square-o'
                            title={{
                                id: t('generic_icons.edit'),
                                defaultMessage: 'Edit Icon',
                            }}
                        />
                        <FormattedMessage
                            id='user_profile.account.editProfile'
                            defaultMessage='Edit Profile'
                        />
                    </button>
                </div>,
            );
        }
        if (haveOverrideProp) {
            dataContent.push(
                <div
                    data-toggle='tooltip'
                    key='user-popover-settings'
                    className='popover__row first'
                >
                    <FormattedMessage
                        id='user_profile.account.post_was_created'
                        defaultMessage='This post was created by an integration from'
                    />
                    {' '}
                    <button
                        className='style--link'
                        onClick={this.handleMentionKeyClick}
                    >{`@${this.props.user.username}`}</button>
                </div>,
            );
        }
        if (this.props.user.id !== this.props.currentUserId && !haveOverrideProp) {
            dataContent.push(
                <div
                    data-toggle='tooltip'
                    key='user-popover-dm'
                    className='popover__row first'
                >
                    <a
                        href='#'
                        className='text-nowrap user-popover__email'
                        onClick={this.handleShowDirectChannel}
                    >
                        <LocalizedIcon
                            className='fa fa-paper-plane'
                            title={{
                                id: t('user_profile.send.dm.icon'),
                                defaultMessage: 'Send Message Icon',
                            }}
                        />
                        <FormattedMessage
                            id='user_profile.send.dm'
                            defaultMessage='Send Message'
                        />
                    </a>
                </div>,
            );
            if (
                this.props.canManageAnyChannelMembersInCurrentTeam &&
                this.props.isInCurrentTeam
            ) {
                const addToChannelMessage = formatMessage({
                    id: 'user_profile.add_user_to_channel',
                    defaultMessage: 'Add to a Channel',
                });
                dataContent.push(
                    <div
                        data-toggle='tooltip'
                        className='popover__row first'
                        key='user-popover-add-to-channel'
                    >
                        <ToggleModalButton
                            ariaLabel={addToChannelMessage}
                            modalId={ModalIdentifiers.ADD_USER_TO_CHANNEL}
                            role='menuitem'
                            dialogType={AddUserToChannelModal}
                            dialogProps={{user: this.props.user, onExited: this.returnFocus}}
                            onClick={this.handleAddToChannel}
                            className='style--link'
                        >
                            <LocalizedIcon
                                className='fa fa-user-plus'
                                title={{
                                    id: t('user_profile.add_user_to_channel.icon'),
                                    defaultMessage: 'Add User to Channel Icon',
                                }}
                            />
                            {addToChannelMessage}
                        </ToggleModalButton>
                    </div>,
                );
            }
        }
        dataContent.push(
            <Pluggable
                key='profilePopoverPluggable3'
                pluggableName='PopoverUserActions'
                user={this.props.user}
                hide={this.props.hide}
                status={this.props.hideStatus ? null : this.props.status}
            />,
        );
        let roleTitle;
        if (this.props.user.is_bot) {
            roleTitle = (
                <span className='user-popover__role'>
                    {Utils.localizeMessage('bots.is_bot', 'BOT')}
                </span>
            );
        } else if (isGuest(this.props.user.roles)) {
            roleTitle = (
                <span className='user-popover__role'>
                    {Utils.localizeMessage('post_info.guest', 'GUEST')}
                </span>
            );
        } else if (isSystemAdmin(this.props.user.roles)) {
            roleTitle = (
                <span className='user-popover__role'>
                    {Utils.localizeMessage(
                        'admin.permissions.roles.system_admin.name',
                        'System Admin',
                    )}
                </span>
            );
        } else if (this.props.isTeamAdmin) {
            roleTitle = (
                <span className='user-popover__role'>
                    {Utils.localizeMessage(
                        'admin.permissions.roles.team_admin.name',
                        'Team Admin',
                    )}
                </span>
            );
        } else if (this.props.isChannelAdmin) {
            roleTitle = (
                <span className='user-popover__role'>
                    {Utils.localizeMessage(
                        'admin.permissions.roles.channel_admin.name',
                        'Channel Admin',
                    )}
                </span>
            );
        }
        let title: React.ReactNode = `@${this.props.user.username}`;
        if (this.props.overwriteName) {
            title = this.props.overwriteName;
            roleTitle = '';
        } else if (this.props.hasMention) {
            title = (
                <button
                    className='style--link user-popover__username'
                    onClick={this.handleMentionKeyClick}
                >
                    {title}
                </button>);
        } else {
            title = <span className='user-popover__username'>{title}</span>;
        }
        title = (
            <span data-testid={`profilePopoverTitle_${this.props.user.username}`}>
                {title}
                {roleTitle}
            </span>
        );

        const displayName = displayUsername(this.props.user, this.props.teammateNameDisplay);

        const tabCatcher = (
            <span
                tabIndex={0}
                onFocus={(e) => (e.relatedTarget as HTMLElement).focus()}
            />
        );

        return (
            <Popover
                {...popoverProps}
                id='user-profile-popover'
            >
                {tabCatcher}
                <div
                    role='dialog'
                    aria-label={Utils.localizeAndFormatMessage('profile_popover.profileLabel', 'Profile for {name}', {name: displayName})}
                    onKeyDown={this.handleKeyDown}
                    className={A11yClassNames.POPUP}
                >
                    <div
                        tabIndex={-1}
                        className='popover-title'
                        ref={this.titleRef}
                    >
                        {title}
                    </div>
                    <div className='user-profile-popover__content'>
                        {dataContent}
                    </div>
                </div>
                {tabCatcher}
            </Popover>
        );
    }
}

export default injectIntl(ProfilePopover);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {displayLastActiveLabel, getCurrentUserId, getLastActiveTimestampUnits, getLastActivityForUserId, getStatusForUserId, getUser} from 'mattermost-redux/selectors/entities/users';
import {
    getCurrentTeam,
    getCurrentRelativeTeamUrl,
    getTeamMember,
} from 'mattermost-redux/selectors/entities/teams';
import {
    getChannelMembersInChannels,
    canManageAnyChannelMembersInCurrentTeam,
    getCurrentChannelId,
} from 'mattermost-redux/selectors/entities/channels';
import {getTeammateNameDisplaySetting} from 'mattermost-redux/selectors/entities/preferences';

import {openDirectChannelToUserId} from 'actions/channel_actions';
import {getMembershipForEntities} from 'actions/views/profile_popover';
import {closeModal, openModal} from 'actions/views/modals';

import {areTimezonesEnabledAndSupported, getCurrentUserTimezone} from 'selectors/general';
import {getRhsState, getSelectedPost} from 'selectors/rhs';
import {getIsMobileView} from 'selectors/views/browser';

import {makeGetCustomStatus, isCustomStatusEnabled, isCustomStatusExpired} from 'selectors/views/custom_status';
import {Action} from 'mattermost-redux/types/actions';

import {ModalData} from 'types/actions';
import {GlobalState} from 'types/store';

import {ServerError} from '@mattermost/types/errors';

import ProfilePopover from './profile_popover';

type OwnProps = {
    userId: string;
    channelId?: string;
}

function getDefaultChannelId(state: GlobalState) {
    const selectedPost = getSelectedPost(state);
    return selectedPost.exists ? selectedPost.channel_id : getCurrentChannelId(state);
}

function makeMapStateToProps() {
    const getCustomStatus = makeGetCustomStatus();

    return (state: GlobalState, {userId, channelId = getDefaultChannelId(state)}: OwnProps) => {
        const team = getCurrentTeam(state);
        const teamMember = getTeamMember(state, team.id, userId);

        const isTeamAdmin = Boolean(teamMember && teamMember.scheme_admin);
        const channelMember = getChannelMembersInChannels(state)?.[channelId]?.[userId];

        let isChannelAdmin = false;
        if (getRhsState(state) !== 'search' && channelMember != null && channelMember.scheme_admin) {
            isChannelAdmin = true;
        }

        const customStatus = getCustomStatus(state, userId);
        const status = getStatusForUserId(state, userId);
        const user = getUser(state, userId);

        const lastActivityTimestamp = getLastActivityForUserId(state, userId);
        const timestampUnits = getLastActiveTimestampUnits(state, userId);
        const enableLastActiveTime = displayLastActiveLabel(state, userId);
        return {
            currentTeamId: team.id,
            currentUserId: getCurrentUserId(state),
            enableTimezone: areTimezonesEnabledAndSupported(state),
            isTeamAdmin,
            isChannelAdmin,
            isInCurrentTeam: Boolean(teamMember) && teamMember?.delete_at === 0,
            canManageAnyChannelMembersInCurrentTeam: canManageAnyChannelMembersInCurrentTeam(state),
            status,
            teamUrl: getCurrentRelativeTeamUrl(state),
            user,
            modals: state.views.modals,
            customStatus,
            isCustomStatusEnabled: isCustomStatusEnabled(state),
            isCustomStatusExpired: isCustomStatusExpired(state, customStatus),
            channelId,
            currentUserTimezone: getCurrentUserTimezone(state),
            lastActivityTimestamp,
            enableLastActiveTime,
            timestampUnits,
            isMobileView: getIsMobileView(state),
            teammateNameDisplay: getTeammateNameDisplaySetting(state),
        };
    };
}

type Actions = {
    openModal: <P>(modalData: ModalData<P>) => void;
    closeModal: (modalId: string) => void;
    openDirectChannelToUserId: (userId?: string) => Promise<{error: ServerError}>;
    getMembershipForEntities: (teamId: string, userId: string, channelId?: string) => Promise<void>;
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, Actions>({
            closeModal,
            openDirectChannelToUserId,
            openModal,
            getMembershipForEntities,
        }, dispatch),
    };
}

export default connect(makeMapStateToProps, mapDispatchToProps)(ProfilePopover);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import classNames from 'classnames';
import {FormattedMessage} from 'react-intl';

import './icon_message.scss';

type Props = {
    icon: JSX.Element;
    title?: string;
    subtitle?: string;
    date?: string;
    error?: boolean;
    buttonText?: string;
    tertiaryBtnText?: string;
    formattedButtonText?: JSX.Element;
    formattedTertiaryButonText?: JSX.Element;
    formattedTitle?: JSX.Element;
    formattedSubtitle?: JSX.Element;
    buttonHandler?: () => void;
    tertiaryButtonHandler?: () => void;
    linkText?: string;
    linkURL?: string;
    footer?: JSX.Element;
    className?: string;
}

export default function IconMessage(props: Props) {
    const {
        icon,
        title,
        subtitle,
        date,
        error,
        buttonText,
        tertiaryBtnText,
        formattedButtonText,
        formattedTertiaryButonText,
        formattedTitle,
        formattedSubtitle,
        buttonHandler,
        tertiaryButtonHandler,
        linkText,
        linkURL,
        footer,
        className,
    } = props;

    let button = null;
    if ((buttonText || formattedButtonText) && buttonHandler) {
        button = (
            <div className={classNames('IconMessage-button', error ? 'error' : '')}>
                <button
                    className='btn btn-primary Form-btn'
                    onClick={buttonHandler}
                >
                    {formattedButtonText || <FormattedMessage id={buttonText}/>}
                </button>
            </div>
        );
    }

    let tertiaryBtn = null;
    if ((tertiaryBtnText || formattedTertiaryButonText) && tertiaryButtonHandler) {
        tertiaryBtn = (
            <div className={classNames('IconMessage-tertiary-button', error ? 'error' : '')}>
                <button
                    className='btn Form-btn'
                    onClick={tertiaryButtonHandler}
                >
                    {formattedTertiaryButonText || <FormattedMessage id={tertiaryBtnText}/>}
                </button>
            </div>
        );
    }

    let link = null;
    if (linkText && linkURL) {
        link = (
            <div className='IconMessage-link'>
                <a
                    href={linkURL}
                    target='_blank'
                    rel='noopener noreferrer'
                >
                    <FormattedMessage
                        id={linkText}
                    />
                </a>
            </div>
        );
    }

    return (
        <div
            id='payment_complete_header'
            className='IconMessage'
        >
            <div className={classNames('content', className || '')}>
                <div className='IconMessage__svg-wrapper'>
                    {icon}
                </div>
                <h3 className='IconMessage-h3'>
                    {title ? <FormattedMessage id={title}/> : null}
                    {formattedTitle || null}
                </h3>
                <div className={classNames('IconMessage-sub', error || '')}>
                    {subtitle ? (
                        <FormattedMessage
                            id={subtitle}
                            values={{date}}
                        />
                    ) : null}
                    {formattedSubtitle || null}
                </div>
                <div className='IconMessage-buttons'>
                    {tertiaryBtn}
                    {button}
                </div>
                {link}
                {footer}
            </div>
        </div>
    );
}

IconMessage.defaultProps = {
    error: false,
    subtitle: '',
    date: '',
    className: '',
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {connect} from 'react-redux';
import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';
import {Stripe} from '@stripe/stripe-js';

import {getConfig, getFeatureFlagValue} from 'mattermost-redux/selectors/entities/general';
import {getAdminAnalytics} from 'mattermost-redux/selectors/entities/admin';
import {getClientConfig} from 'mattermost-redux/actions/general';
import {getCloudProducts, getCloudSubscription, getInvoices} from 'mattermost-redux/actions/cloud';
import {Action} from 'mattermost-redux/types/actions';
import {getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';
import {getTheme} from 'mattermost-redux/selectors/entities/preferences';

import {makeAsyncComponent} from 'components/async_load';

import {GlobalState} from 'types/store';
import {BillingDetails} from 'types/cloud/sku';

import {isModalOpen} from 'selectors/views/modals';
import {getCloudContactUsLink, InquiryType, getCloudDelinquentInvoices, isCloudDelinquencyGreaterThan90Days} from 'selectors/cloud';

import {ModalIdentifiers} from 'utils/constants';

import {closeModal, openModal} from 'actions/views/modals';
import {completeStripeAddPaymentMethod, subscribeCloudSubscription} from 'actions/cloud';
import {ModalData} from 'types/actions';
import withGetCloudSubscription from 'components/common/hocs/cloud/with_get_cloud_subscription';

const PurchaseModal = makeAsyncComponent('PurchaseModal', React.lazy(() => import('./purchase_modal')));

function mapStateToProps(state: GlobalState) {
    const subscription = state.entities.cloud.subscription;

    const isDelinquencyModal = Boolean(state.entities.cloud.subscription?.delinquent_since);

    return {
        show: isModalOpen(state, ModalIdentifiers.CLOUD_PURCHASE),
        products: state.entities.cloud!.products,
        isDevMode: getConfig(state).EnableDeveloper === 'true',
        contactSupportLink: getCloudContactUsLink(state)(InquiryType.Technical),
        invoices: getCloudDelinquentInvoices(state),
        isCloudDelinquencyGreaterThan90Days: isCloudDelinquencyGreaterThan90Days(state),
        isFreeTrial: subscription?.is_free_trial === 'true',
        contactSalesLink: getCloudContactUsLink(state)(InquiryType.Sales),
        productId: subscription?.product_id,
        customer: state.entities.cloud.customer,
        currentTeam: getCurrentTeam(state),
        theme: getTheme(state),
        isDelinquencyModal,
        annualSubscription: getFeatureFlagValue(state, 'AnnualSubscription') === 'true',
        usersCount: Number(getAdminAnalytics(state)!.TOTAL_USERS) || 1,
    };
}
type Actions = {
    closeModal: () => void;
    openModal: <P>(modalData: ModalData<P>) => void;
    getCloudProducts: () => void;
    completeStripeAddPaymentMethod: (stripe: Stripe, billingDetails: BillingDetails, isDevMode: boolean) => Promise<boolean | null>;
    subscribeCloudSubscription: (productId: string, seats?: number) => Promise<boolean | null>;
    getClientConfig: () => void;
    getCloudSubscription: () => void;
    getInvoices: () => void;
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, Actions>(
            {
                closeModal: () => closeModal(ModalIdentifiers.CLOUD_PURCHASE),
                openModal,
                getCloudProducts,
                completeStripeAddPaymentMethod,
                subscribeCloudSubscription,
                getClientConfig,
                getInvoices,
                getCloudSubscription,
            },
            dispatch,
        ),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(withGetCloudSubscription(PurchaseModal));

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {Fragment, FC, InputHTMLAttributes, forwardRef} from 'react';

import classNames from 'classnames';

interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
    className: string;
    defaultValue?: string;
    maxLength: number;
}

// An input component that renders a validation message (-{number of exceeding characters})
// when the characters length of the value exceeds maxLength prop
// to be used with QuickInput as an inputComponent
const MaxLengthInput: FC<InputProps> = forwardRef<HTMLInputElement, InputProps>(
    ({className, defaultValue, maxLength, ...props}: InputProps, ref) => {
        const excess: number = defaultValue ? defaultValue.length - maxLength : 0;

        const classes: string = classNames({
            MaxLengthInput: true,
            [className]: Boolean(className),
            'has-error': excess > 0,
        });

        return (
            <Fragment>
                <input
                    className={classes}
                    defaultValue={defaultValue}
                    ref={ref}
                    {...props}
                />
                {excess > 0 && (
                    <span className='MaxLengthInput__validation'>
                        {'-'}
                        {excess}
                    </span>
                )}
            </Fragment>
        );
    },
);

export default MaxLengthInput;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode} from 'react';
import {FormattedMessage} from 'react-intl';
import classNames from 'classnames';

import {ReactComponentLike} from 'prop-types';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import AutosizeTextarea from 'components/autosize_textarea';
import Constants from 'utils/constants';

export type Props = {

    /**
     * Whether to delay updating the value of the textbox from props. Should only be used
     * on textboxes that to properly compose CJK characters as the user types.
     */
    delayInputUpdate?: boolean;

    /**
     * An optional React component that will be used instead of an HTML input when rendering
     */
    inputComponent?: ReactComponentLike;

    /**
     * The string value displayed in this input
     */
    value: string;

    /**
     * When true, and an onClear callback is defined, show an X on the input field that clears
     * the input when clicked.
     */
    clearable?: boolean;

    /**
     * The optional tooltip text to display on the X shown when clearable. Pass a components
     * such as FormattedMessage to localize.
     */
    clearableTooltipText?: string | ReactNode;

    /**
     * Callback to clear the input value, and used in tandem with the clearable prop above.
     */
    onClear?: () => void;

    /**
     * ClassName for the clear button container
     */
    clearClassName?: string;

    /**
     * Position in which the tooltip will be displayed
     */
    tooltipPosition?: 'top' | 'bottom';

    /**
     * Callback to handle the change event of the input
     */
    onChange?: (event: React.ChangeEvent<HTMLInputElement>) => void;

    /**
     * Callback to handle the key up of the input
     */
    onKeyUp?: (event: React.KeyboardEvent) => void;

    /**
     * When true, and an onClear callback is defined, show an X on the input field even if
     * the input is empty.
     */
    clearableWithoutValue?: boolean;

    forwardedRef?: ((instance: HTMLInputElement | HTMLTextAreaElement | null) => void) | React.MutableRefObject<HTMLInputElement | HTMLTextAreaElement | null> | null;

    maxLength?: number;
    className?: string;
    placeholder?: string | { id: string; defaultMessage: string };
    autoFocus?: boolean;
    type?: string;
    id?: string;
    onInput?: (e?: React.FormEvent<HTMLInputElement>) => void;
}

// A component that can be used to make controlled inputs that function properly in certain
// environments (ie. IE11) where typing quickly would sometimes miss inputs
export class QuickInput extends React.PureComponent<Props> {
    private input?: HTMLInputElement | HTMLTextAreaElement;

    static defaultProps = {
        delayInputUpdate: false,
        value: '',
        clearable: false,
        tooltipPosition: 'bottom',
    };

    componentDidUpdate(prevProps: Props) {
        if (prevProps.value !== this.props.value) {
            if (this.props.delayInputUpdate) {
                requestAnimationFrame(this.updateInputFromProps);
            } else {
                this.updateInputFromProps();
            }
        }
    }

    private updateInputFromProps = () => {
        if (!this.input || this.input.value === this.props.value) {
            return;
        }

        this.input.value = this.props.value;
    }

    private setInputRef = (input: HTMLInputElement) => {
        if (this.props.forwardedRef) {
            if (typeof this.props.forwardedRef === 'function') {
                this.props.forwardedRef(input);
            } else {
                this.props.forwardedRef.current = input;
            }
        }

        this.input = input;
    }

    private onClear = (e: React.MouseEvent<HTMLDivElement> | React.TouchEvent) => {
        e.preventDefault();
        e.stopPropagation();

        if (this.props.onClear) {
            this.props.onClear();
        }

        this.input?.focus();
    }

    render() {
        let clearableTooltipText = this.props.clearableTooltipText;
        if (!clearableTooltipText) {
            clearableTooltipText = (
                <FormattedMessage
                    id={'input.clear'}
                    defaultMessage='Clear'
                />
            );
        }

        const clearableTooltip = (
            <Tooltip id={'InputClearTooltip'}>
                {clearableTooltipText}
            </Tooltip>
        );

        const {
            value,
            inputComponent,
            clearable,
            clearClassName,
            tooltipPosition,
            clearableWithoutValue,
            ...props
        } = this.props;

        Reflect.deleteProperty(props, 'delayInputUpdate');
        Reflect.deleteProperty(props, 'onClear');
        Reflect.deleteProperty(props, 'clearableTooltipText');
        Reflect.deleteProperty(props, 'channelId');
        Reflect.deleteProperty(props, 'clearClassName');
        Reflect.deleteProperty(props, 'tooltipPosition');
        Reflect.deleteProperty(props, 'forwardedRef');

        if (inputComponent !== AutosizeTextarea) {
            Reflect.deleteProperty(props, 'onHeightChange');
        }

        const inputElement = React.createElement(
            inputComponent || 'input',
            {
                ...props,
                ref: this.setInputRef,
                defaultValue: value, // Only set the defaultValue since the real one will be updated using componentDidUpdate
            },
        );

        const showClearButton = this.props.onClear && (clearableWithoutValue || (clearable && value));
        return (<div>
            {inputElement}
            {showClearButton &&
            <div
                className={classNames(clearClassName, 'input-clear visible')}
                onMouseDown={this.onClear}
                onTouchEnd={this.onClear}
            >
                <OverlayTrigger
                    delayShow={Constants.OVERLAY_TIME_DELAY}
                    placement={tooltipPosition}
                    overlay={clearableTooltip}
                >
                    <span
                        className='input-clear-x'
                        aria-hidden='true'
                    >
                        <i className='icon icon-close-circle'/>
                    </span>
                </OverlayTrigger>
            </div>
            }
        </div>);
    }
}

type ForwardedProps = Omit<React.ComponentPropsWithoutRef<typeof QuickInput>, 'forwardedRef'>;

const forwarded = React.forwardRef<HTMLInputElement | HTMLTextAreaElement, ForwardedProps>((props, ref) => (
    <QuickInput
        forwardedRef={ref}
        {...props}
    />
));
forwarded.displayName = 'QuickInput';

export default forwarded;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {Preferences} from 'mattermost-redux/constants';

import ConfirmModal from 'components/confirm_modal';
import {toTitleCase} from 'utils/utils';
import {UserStatuses} from 'utils/constants';
import {t} from 'utils/i18n';
import {UserStatus} from '@mattermost/types/users';
import {PreferenceType} from '@mattermost/types/preferences';

t('modal.manual_status.auto_responder.message_');
t('modal.manual_status.auto_responder.message_away');
t('modal.manual_status.auto_responder.message_dnd');
t('modal.manual_status.auto_responder.message_offline');
t('modal.manual_status.auto_responder.message_online');
t('modal.manual_status.button_');
t('modal.manual_status.button_away');
t('modal.manual_status.button_dnd');
t('modal.manual_status.button_offline');
t('modal.manual_status.button_online');
t('modal.manual_status.cancel_');
t('modal.manual_status.cancel_away');
t('modal.manual_status.cancel_dnd');
t('modal.manual_status.cancel_offline');
t('modal.manual_status.cancel_ooo');
t('modal.manual_status.message_');
t('modal.manual_status.message_away');
t('modal.manual_status.message_dnd');
t('modal.manual_status.message_offline');
t('modal.manual_status.message_online');
t('modal.manual_status.title_');
t('modal.manual_status.title_away');
t('modal.manual_status.title_dnd');
t('modal.manual_status.title_offline');
t('modal.manual_status.title_ooo');

type Props = {

    /*
     * The user's preference for whether their status is automatically reset
     */
    autoResetPref?: string;

    /*
     * Props value is used to update currentUserStatus
     */
    currentUserStatus?: string;

    /*
     * Props value is used to reset status from status_dropdown
     */
    newStatus?: string;

    /*
     * Function called when modal is dismissed
     */
    onHide?: () => void;

    /**
         * Function called after the modal has been hidden
         */
    onExited?: () => void;

    actions: {

        /*
         * Function to get and then reset the user's status if needed
         */
        autoResetStatus: () => Promise<{data: UserStatus}>;

        /*
         * Function to set the status for a user
         */
        setStatus: (status: UserStatus) => void;

        /*
         * Function to save user preferences
         */
        savePreferences: (userId: string, preferences: PreferenceType[]) => void;
    };
}

type State = {
    show: boolean;
    currentUserStatus: UserStatus;
    newStatus: string;
}

export default class ResetStatusModal extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            show: false,
            currentUserStatus: {} as UserStatus,
            newStatus: props.newStatus || 'online',
        };
    }

    public componentDidMount(): void {
        this.props.actions.autoResetStatus().then(
            (result: {data: UserStatus}) => {
                const status = result.data;
                const statusIsManual = status.manual;
                const autoResetPrefNotSet = this.props.autoResetPref === '';

                this.setState({
                    currentUserStatus: status, // Set in state until status refactor where we store 'manual' field in redux
                    show: Boolean(status.status === UserStatuses.OUT_OF_OFFICE || (statusIsManual && autoResetPrefNotSet)),
                });
            },
        );
    }

    private hideModal = (): void => this.setState({show: false});

    public onConfirm = (checked: boolean): void => {
        this.hideModal();

        const newStatus = {...this.state.currentUserStatus};
        newStatus.status = this.state.newStatus;
        this.props.actions.setStatus(newStatus);

        if (checked) {
            const pref = {category: Preferences.CATEGORY_AUTO_RESET_MANUAL_STATUS, user_id: newStatus.user_id, name: newStatus.user_id, value: 'true'};
            this.props.actions.savePreferences(pref.user_id, [pref]);
        }
    };

    public onCancel = (checked: boolean): void => {
        this.hideModal();

        if (checked) {
            const status = {...this.state.currentUserStatus};
            const pref = {category: Preferences.CATEGORY_AUTO_RESET_MANUAL_STATUS, user_id: status.user_id, name: status.user_id, value: 'false'};
            this.props.actions.savePreferences(pref.user_id, [pref]);
        }
    };

    private renderModalMessage = () => {
        if (this.props.currentUserStatus === UserStatuses.OUT_OF_OFFICE) {
            return (
                <FormattedMessage
                    id={`modal.manual_status.auto_responder.message_${this.state.newStatus}`}
                    defaultMessage='Would you like to switch your status to "{status}" and disable Automatic Replies?'
                    values={{
                        status: toTitleCase(this.state.newStatus),
                    }}
                />
            );
        }

        return (
            <FormattedMessage
                id={`modal.manual_status.message_${this.state.newStatus}`}
                defaultMessage='Would you like to switch your status to "{status}"?'
                values={{
                    status: toTitleCase(this.state.newStatus),
                }}
            />
        );
    };

    public render(): JSX.Element {
        const userStatus = this.state.currentUserStatus.status || '';
        const userStatusId = 'modal.manual_status.title_' + userStatus;
        const manualStatusTitle = (
            <FormattedMessage
                id={userStatusId}
                defaultMessage='Your Status is Set to "{status}"'
                values={{
                    status: toTitleCase(userStatus),
                }}
            />
        );

        const manualStatusMessage = this.renderModalMessage();

        const manualStatusButton = (
            <FormattedMessage
                id={`modal.manual_status.button_${this.state.newStatus}`}
                defaultMessage='Yes, set my status to "{status}"'
                values={{
                    status: toTitleCase(this.state.newStatus),
                }}
            />
        );
        const manualStatusId = 'modal.manual_status.cancel_' + userStatus;
        const manualStatusCancel = (
            <FormattedMessage
                id={manualStatusId}
                defaultMessage='No, keep it as "{status}"'
                values={{
                    status: toTitleCase(userStatus),
                }}
            />
        );

        const manualStatusCheckbox = (
            <FormattedMessage
                id='modal.manual_status.ask'
                defaultMessage='Do not ask me again'
            />
        );

        const showCheckbox = this.props.currentUserStatus !== UserStatuses.OUT_OF_OFFICE;

        return (
            <ConfirmModal
                show={this.state.show}
                title={manualStatusTitle}
                message={manualStatusMessage}
                confirmButtonText={manualStatusButton}
                onConfirm={this.onConfirm}
                cancelButtonText={manualStatusCancel}
                onCancel={this.onCancel}
                onExited={this.props.onExited}
                showCheckbox={showCheckbox}
                checkboxText={manualStatusCheckbox}
            />
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {GlobalState} from 'types/store/index.js';

import {ActionFunc, GenericAction} from 'mattermost-redux/types/actions.js';

import {UserStatus} from '@mattermost/types/users.js';

import {PreferenceType} from '@mattermost/types/preferences.js';

import {savePreferences} from 'mattermost-redux/actions/preferences';
import {setStatus} from 'mattermost-redux/actions/users';
import {Preferences} from 'mattermost-redux/constants';
import {get} from 'mattermost-redux/selectors/entities/preferences';
import {getStatusForUserId} from 'mattermost-redux/selectors/entities/users';

import {autoResetStatus} from 'actions/user_actions';

import ResetStatusModal from './reset_status_modal';

function mapStateToProps(state: GlobalState) {
    const {currentUserId} = state.entities.users;
    return {
        autoResetPref: get(state, Preferences.CATEGORY_AUTO_RESET_MANUAL_STATUS, currentUserId, ''),
        currentUserStatus: getStatusForUserId(state, currentUserId),
    };
}

type Actions = {
    autoResetStatus: () => Promise<{data: UserStatus}>;
    setStatus: (status: UserStatus) => void;
    savePreferences: (userId: string, preferences: PreferenceType[]) => void;
};

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc>, Actions>({
            autoResetStatus,
            setStatus,
            savePreferences,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(ResetStatusModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {GenericAction} from 'mattermost-redux/types/actions';

import {Constants, ActionTypes, WindowSizes} from 'utils/constants';

export function emitBrowserWindowResized(windowSize?: string): GenericAction {
    let newWindowSize = windowSize;
    if (!windowSize) {
        const width = window.innerWidth;

        switch (true) {
        case width > Constants.TABLET_SCREEN_WIDTH && width <= Constants.DESKTOP_SCREEN_WIDTH: {
            newWindowSize = WindowSizes.SMALL_DESKTOP_VIEW;
            break;
        }
        case width > Constants.MOBILE_SCREEN_WIDTH && width <= Constants.TABLET_SCREEN_WIDTH: {
            newWindowSize = WindowSizes.TABLET_VIEW;
            break;
        }
        case width <= Constants.MOBILE_SCREEN_WIDTH: {
            newWindowSize = WindowSizes.MOBILE_VIEW;
            break;
        }
        default: {
            newWindowSize = WindowSizes.DESKTOP_VIEW; // width > Constants.DESKTOP_SCREEN_WIDTH
        }
        }
    }
    return {
        type: ActionTypes.BROWSER_WINDOW_RESIZED,
        data: newWindowSize,
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {Store} from 'redux';

import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';

import store from 'stores/redux_store';

import PluginRegistry from './registry';

export abstract class ProductPlugin {
    abstract initialize(registry: PluginRegistry, store: Store): void;
    abstract uninitialize(): void;
}

export function initializeProducts() {
    /* eslint-disable no-console */
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const config = getConfig(getState());

        /**
         * products contains a map of product IDs to a function that will load all of their parts. Calling that
         * function will return an object where each field is a Promise that will resolve to that module.
         *
         * Note that these import paths must be statically defined or else they won't be found at runtime. They
         * can't be constructed based on the name of a product at runtime.
         */
        const products = [
            {
                id: 'boards',
                featureFlagEnabled: config.FeatureFlagBoardsProduct === 'true',
                load: () => ({
                    index: import('boards'),
                    manifest: import('boards/manifest'),
                }),
            },
        ];

        await Promise.all(products.map(async (product) => {
            if ('featureFlagEnabled' in product && !product.featureFlagEnabled) {
                console.log(`Feature flag for product ${product.id} not enabled. Not loading it.`);
                return;
            }

            if (!REMOTE_CONTAINERS[product.id]) {
                console.log(`Product ${product.id} not found. Not loading it.`);
                return;
            }

            console.log(`Loading product ${product.id}...`);

            // Start loading the product
            let imports;
            try {
                imports = product.load();
            } catch (e) {
                console.error(`Error loading ${product.id}`, e);
                return;
            }

            // Wait for the individual parts to load
            let index;
            try {
                index = await imports.index;
            } catch (e) {
                console.error(`Error loading index for ${product.id}`, e);
                return;
            }

            // let manifest;
            // try {
            //     manifest = await imports.manifest;
            // } catch (e) {
            //     console.error(`Error loading manifest for ${product.id}`, e);
            //     return;
            // }

            // Initialize the previously loaded data
            console.log(`Initializing product ${product.id}...`);

            try {
                initializeProduct(product.id, index.default);
            } catch (e) {
                console.error(`Error loading and initializing product ${product.id}`, e);
            }

            console.log(`Product ${product.id} initialized!`);
        }));

        return {data: true};
    };

    /* eslint-enable no-console */
}

function initializeProduct(id: string, Product: new () => ProductPlugin) {
    const plugin = new Product();
    const registry = new PluginRegistry(id);

    plugin.initialize(registry, store);
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// As per rudder-sdk-js documentation, import this only once and use like a singleton.
// See https://github.com/rudderlabs/rudder-sdk-js#step-1-install-rudderstack-using-the-code-snippet
import * as rudderAnalytics from 'rudder-sdk-js';
export {rudderAnalytics};

import {TelemetryHandler} from '@mattermost/client';

import {isSystemAdmin} from 'mattermost-redux/utils/user_utils';

export class RudderTelemetryHandler implements TelemetryHandler {
    trackEvent(userId: string, userRoles: string, category: string, event: string, props?: any) {
        const properties = Object.assign({
            category,
            type: event,
            user_actual_role: getActualRoles(userRoles),
            user_actual_id: userId,
        }, props);
        const options = {
            context: {
                ip: '0.0.0.0',
            },
            page: {
                path: '',
                referrer: '',
                search: '',
                title: '',
                url: '',
            },
            anonymousId: '00000000000000000000000000',
        };

        rudderAnalytics.track('event', properties, options);
    }

    pageVisited(userId: string, userRoles: string, category: string, name: string) {
        rudderAnalytics.page(
            category,
            name,
            {
                path: '',
                referrer: '',
                search: '',
                title: '',
                url: '',
                user_actual_role: getActualRoles(userRoles),
                user_actual_id: userId,
            },
            {
                context: {
                    ip: '0.0.0.0',
                },
                anonymousId: '00000000000000000000000000',
            },
        );
    }
}

function getActualRoles(userRoles: string) {
    return userRoles && isSystemAdmin(userRoles) ? 'system_admin, system_user' : 'system_user';
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage, useIntl} from 'react-intl';
import {useDispatch, useSelector} from 'react-redux';

import {Constants, Preferences} from 'utils/constants';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/common';
import {savePreferences} from 'mattermost-redux/actions/preferences';

import {TourTip, useMeasurePunchouts} from '@mattermost/components';

const translate = {x: 2, y: 25};

const CRTThreadsPaneTutorialTip = () => {
    const dispatch = useDispatch();
    const {formatMessage} = useIntl();
    const currentUserId = useSelector(getCurrentUserId);
    const title = (
        <FormattedMessage
            id='tutorial_threads.threads_pane.title'
            defaultMessage={'Viewing a thread in the sidebar'}
        />
    );

    const screen = (
        <p>
            {formatMessage(
                {
                    id: 'tutorial_threads.threads_pane.description',
                    defaultMessage: 'Click the <b>Follow</b> button to be notified about replies and see it in your <b>Threads</b> view. Within a thread, the <b>New Messages</b> line shows you where you left off.',
                },
                {
                    b: (value: string) => <b>{value}</b>,
                },
            )}
        </p>
    );

    const nextBtn = (): JSX.Element => {
        return (
            <FormattedMessage
                id={'tutorial_tip.got_it'}
                defaultMessage={'Got it'}
            />
        );
    };

    const onDismiss = (e: React.MouseEvent) => {
        e.preventDefault();
        const preferences = [
            {
                user_id: currentUserId,
                category: Preferences.CRT_THREAD_PANE_STEP,
                name: currentUserId,
                value: Constants.CrtThreadPaneSteps.FINISHED.toString(),
            },
        ];
        dispatch(savePreferences(currentUserId, preferences));
    };

    const overlayPunchOut = useMeasurePunchouts(['rhsContainer'], []);

    return (
        <TourTip
            show={true}
            screen={screen}
            title={title}
            overlayPunchOut={overlayPunchOut}
            placement='left'
            pulsatingDotPlacement='top-start'
            pulsatingDotTranslate={translate}
            step={1}
            singleTip={true}
            showOptOut={false}
            handleDismiss={onDismiss}
            handleNext={onDismiss}
            interactivePunchOut={true}
            nextBtn={nextBtn()}
        />
    );
};

export default CRTThreadsPaneTutorialTip;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import LocalizedIcon from 'components/localized_icon';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import FollowButton from 'components/threading/common/follow_button';
import KeyboardShortcutSequence, {
    KEYBOARD_SHORTCUTS,
} from 'components/keyboard_shortcuts/keyboard_shortcuts_sequence';

import {getHistory} from 'utils/browser_history';
import Constants, {RHSStates} from 'utils/constants';
import {t} from 'utils/i18n';
import CRTThreadsPaneTutorialTip
    from 'components/tours/crt_tour/crt_threads_pane_tutorial_tip';
import {RhsState} from 'types/store/rhs';

import {Channel} from '@mattermost/types/channels';

interface RhsHeaderPostProps {
    isExpanded: boolean;
    isMobileView: boolean;
    rootPostId: string;
    previousRhsState?: RhsState;
    relativeTeamUrl: string;
    channel: Channel;
    isCollapsedThreadsEnabled: boolean;
    isFollowingThread?: boolean;
    currentTeamId: string;
    showThreadsTutorialTip: boolean;
    currentUserId: string;
    setRhsExpanded: (b: boolean) => void;
    showMentions: () => void;
    showSearchResults: () => void;
    showFlaggedPosts: () => void;
    showPinnedPosts: () => void;
    goBack: () => void;
    closeRightHandSide: (e?: React.MouseEvent) => void;
    toggleRhsExpanded: (e: React.MouseEvent) => void;
    setThreadFollow: (userId: string, teamId: string, threadId: string, newState: boolean) => void;
}

export default class RhsHeaderPost extends React.PureComponent<RhsHeaderPostProps> {
    handleBack = (e: React.MouseEvent) => {
        e.preventDefault();

        switch (this.props.previousRhsState) {
        case RHSStates.SEARCH:
        case RHSStates.MENTION:
        case RHSStates.FLAG:
        case RHSStates.PIN:
            this.props.goBack();
            break;
        default:
            break;
        }
    }

    handleJumpClick = () => {
        if (this.props.isMobileView) {
            this.props.closeRightHandSide();
        }

        this.props.setRhsExpanded(false);
        const teamUrl = this.props.relativeTeamUrl;
        getHistory().push(`${teamUrl}/pl/${this.props.rootPostId}`);
    }

    handleFollowChange = () => {
        const {currentTeamId, currentUserId, rootPostId, isFollowingThread} = this.props;
        this.props.setThreadFollow(currentUserId, currentTeamId, rootPostId, !isFollowingThread);
    }

    render() {
        let back;
        const {isFollowingThread} = this.props;
        const closeSidebarTooltip = (
            <Tooltip id='closeSidebarTooltip'>
                <FormattedMessage
                    id='rhs_header.closeSidebarTooltip'
                    defaultMessage='Close'
                />
            </Tooltip>
        );

        let backToResultsTooltip;

        switch (this.props.previousRhsState) {
        case RHSStates.SEARCH:
        case RHSStates.MENTION:
            backToResultsTooltip = (
                <Tooltip id='backToResultsTooltip'>
                    <FormattedMessage
                        id='rhs_header.backToResultsTooltip'
                        defaultMessage='Back to search results'
                    />
                </Tooltip>
            );
            break;
        case RHSStates.FLAG:
            backToResultsTooltip = (
                <Tooltip id='backToResultsTooltip'>
                    <FormattedMessage
                        id='rhs_header.backToFlaggedTooltip'
                        defaultMessage='Back to saved posts'
                    />
                </Tooltip>
            );
            break;
        case RHSStates.PIN:
            backToResultsTooltip = (
                <Tooltip id='backToResultsTooltip'>
                    <FormattedMessage
                        id='rhs_header.backToPinnedTooltip'
                        defaultMessage='Back to pinned posts'
                    />
                </Tooltip>
            );
            break;
        }

        const expandSidebarTooltip = (
            <Tooltip id='expandSidebarTooltip'>
                <FormattedMessage
                    id='rhs_header.expandSidebarTooltip'
                    defaultMessage='Expand the right sidebar'
                />
                <KeyboardShortcutSequence
                    shortcut={KEYBOARD_SHORTCUTS.navExpandSidebar}
                    hideDescription={true}
                    isInsideTooltip={true}
                />
            </Tooltip>
        );

        const shrinkSidebarTooltip = (
            <Tooltip id='shrinkSidebarTooltip'>
                <FormattedMessage
                    id='rhs_header.collapseSidebarTooltip'
                    defaultMessage='Collapse the right sidebar'
                />
                <KeyboardShortcutSequence
                    shortcut={KEYBOARD_SHORTCUTS.navExpandSidebar}
                    hideDescription={true}
                    isInsideTooltip={true}
                />
            </Tooltip>
        );

        const channelName = this.props.channel.display_name;

        if (backToResultsTooltip) {
            back = (
                <OverlayTrigger
                    delayShow={Constants.OVERLAY_TIME_DELAY}
                    placement='top'
                    overlay={backToResultsTooltip}
                >
                    <a
                        href='#'
                        onClick={this.handleBack}
                        className='sidebar--right__back'
                    >
                        <LocalizedIcon
                            className='icon icon-arrow-back-ios'
                            ariaLabel={{id: t('generic_icons.back'), defaultMessage: 'Back Icon'}}
                        />
                    </a>
                </OverlayTrigger>
            );
        }

        return (
            <div className='sidebar--right__header'>
                <span className='sidebar--right__title'>
                    {back}
                    <FormattedMessage
                        id='rhs_header.details'
                        defaultMessage='Thread'
                    />
                    {channelName &&
                        <button
                            onClick={this.handleJumpClick}
                            className='style--none sidebar--right__title__channel'
                        >
                            {channelName}
                        </button>
                    }
                </span>
                <div className='controls'>
                    {this.props.isCollapsedThreadsEnabled ? (
                        <FollowButton
                            className='sidebar--right__follow__thread'
                            isFollowing={isFollowingThread}
                            onClick={this.handleFollowChange}
                        />
                    ) : null}

                    <OverlayTrigger
                        delayShow={Constants.OVERLAY_TIME_DELAY}
                        placement='bottom'
                        overlay={this.props.isExpanded ? shrinkSidebarTooltip : expandSidebarTooltip}
                    >
                        <button
                            type='button'
                            className='sidebar--right__expand btn-icon'
                            aria-label='Expand'
                            onClick={this.props.toggleRhsExpanded}
                        >
                            <LocalizedIcon
                                className='icon icon-arrow-expand'
                                ariaLabel={{id: t('rhs_header.expandSidebarTooltip.icon'), defaultMessage: 'Expand Sidebar Icon'}}
                            />
                            <LocalizedIcon
                                className='icon icon-arrow-collapse'
                                ariaLabel={{id: t('rhs_header.collapseSidebarTooltip.icon'), defaultMessage: 'Collapse Sidebar Icon'}}
                            />
                        </button>
                    </OverlayTrigger>

                    <OverlayTrigger
                        delayShow={Constants.OVERLAY_TIME_DELAY}
                        placement='top'
                        overlay={closeSidebarTooltip}
                    >
                        <button
                            id='rhsCloseButton'
                            type='button'
                            className='sidebar--right__close btn-icon'
                            aria-label='Close'
                            onClick={this.props.closeRightHandSide}
                        >
                            <LocalizedIcon
                                className='icon icon-close'
                                ariaLabel={{id: t('rhs_header.closeTooltip.icon'), defaultMessage: 'Close Sidebar Icon'}}
                            />
                        </button>
                    </OverlayTrigger>
                </div>
                {this.props.showThreadsTutorialTip && <CRTThreadsPaneTutorialTip/>}
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ComponentProps} from 'react';
import {connect} from 'react-redux';

import {getInt, isCollapsedThreadsEnabled} from 'mattermost-redux/selectors/entities/preferences';

import {getCurrentTeamId, getCurrentRelativeTeamUrl} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentUserId, getCurrentUserMentionKeys} from 'mattermost-redux/selectors/entities/users';

import {setThreadFollow} from 'mattermost-redux/actions/threads';
import {makeGetThreadOrSynthetic} from 'mattermost-redux/selectors/entities/threads';
import {getPost} from 'mattermost-redux/selectors/entities/posts';

import {GlobalState} from 'types/store';

import {
    setRhsExpanded,
    showMentions,
    showSearchResults,
    showFlaggedPosts,
    showPinnedPosts,
    showChannelFiles,
    closeRightHandSide,
    toggleRhsExpanded,
    goBack,
} from 'actions/views/rhs';
import {getIsRhsExpanded} from 'selectors/rhs';
import {CrtThreadPaneSteps, Preferences} from 'utils/constants';
import {getIsMobileView} from 'selectors/views/browser';

import {allAtMentions} from 'utils/text_formatting';
import {matchUserMentionTriggersWithMessageMentions} from 'utils/post_utils';

import RhsHeaderPost from './rhs_header_post';

type OwnProps = Pick<ComponentProps<typeof RhsHeaderPost>, 'rootPostId'>

function mapStateToProps(state: GlobalState, {rootPostId}: OwnProps) {
    let isFollowingThread = false;

    const collapsedThreads = isCollapsedThreadsEnabled(state);
    const root = getPost(state, rootPostId);
    const currentUserId = getCurrentUserId(state);
    const tipStep = getInt(state, Preferences.CRT_THREAD_PANE_STEP, currentUserId);
    const getThreadOrSynthetic = makeGetThreadOrSynthetic();

    if (root && collapsedThreads) {
        const thread = getThreadOrSynthetic(state, root);
        isFollowingThread = thread.is_following;

        if (isFollowingThread === null && thread.reply_count === 0) {
            const currentUserMentionKeys = getCurrentUserMentionKeys(state);
            const rootMessageMentionKeys = allAtMentions(root.message);

            isFollowingThread = matchUserMentionTriggersWithMessageMentions(currentUserMentionKeys, rootMessageMentionKeys);
        }
    }

    const showThreadsTutorialTip = tipStep === CrtThreadPaneSteps.THREADS_PANE_POPOVER && isCollapsedThreadsEnabled(state);

    return {
        isExpanded: getIsRhsExpanded(state),
        isMobileView: getIsMobileView(state),
        relativeTeamUrl: getCurrentRelativeTeamUrl(state),
        currentTeamId: getCurrentTeamId(state),
        currentUserId,
        isCollapsedThreadsEnabled: collapsedThreads,
        isFollowingThread,
        showThreadsTutorialTip,
    };
}

const actions = {
    setRhsExpanded,
    showSearchResults,
    showMentions,
    showFlaggedPosts,
    showPinnedPosts,
    showChannelFiles,
    closeRightHandSide,
    toggleRhsExpanded,
    setThreadFollow,
    goBack,
};

export default connect(mapStateToProps, actions)(RhsHeaderPost);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo, useEffect} from 'react';
import {useDispatch} from 'react-redux';

import {Channel} from '@mattermost/types/channels';
import {Post} from '@mattermost/types/posts';
import {FakePost, RhsState} from 'types/store/rhs';

import RhsHeaderPost from 'components/rhs_header_post';
import ThreadViewer from 'components/threading/thread_viewer';
import {closeRightHandSide} from 'actions/views/rhs';
import {Team} from '@mattermost/types/teams';

type Props = {
    currentTeam: Team;
    posts: Post[];
    channel: Channel | null;
    selected: Post | FakePost;
    previousRhsState?: RhsState;
}

const RhsThread = ({
    currentTeam,
    channel,
    posts,
    selected,
    previousRhsState,
}: Props) => {
    const dispatch = useDispatch();

    useEffect(() => {
        if (channel?.team_id && channel.team_id !== currentTeam.id) {
            // if team-scoped and mismatched team, close rhs
            dispatch(closeRightHandSide());
        }
    }, [currentTeam, channel]);

    if (posts == null || selected == null || !channel) {
        return (
            <div/>
        );
    }

    return (
        <div
            id='rhsContainer'
            className='sidebar-right__body'
        >
            <RhsHeaderPost
                rootPostId={selected.id}
                channel={channel}
                previousRhsState={previousRhsState}
            />
            <ThreadViewer
                rootPostId={selected.id}
                useRelativeTimestamp={false}
                isThreadView={false}
            />
        </div>
    );
};

export default memo(RhsThread);


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';
import {makeGetPostsForThread} from 'mattermost-redux/selectors/entities/posts';

import {Post} from '@mattermost/types/posts';

import {getSelectedChannel, getSelectedPost} from 'selectors/rhs';
import {GlobalState} from 'types/store';

import RhsThread from './rhs_thread';

function makeMapStateToProps() {
    const getPostsForThread = makeGetPostsForThread();

    return function mapStateToProps(state: GlobalState) {
        const selected = getSelectedPost(state);
        const channel = getSelectedChannel(state);
        const currentTeam = getCurrentTeam(state);
        let posts: Post[] = [];
        if (selected) {
            posts = getPostsForThread(state, selected.id);
        }

        return {
            selected,
            channel,
            posts,
            currentTeam,
        };
    };
}
export default connect(makeMapStateToProps)(RhsThread);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import LocalizedIcon from 'components/localized_icon';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import KeyboardShortcutSequence, {
    KEYBOARD_SHORTCUTS,
} from 'components/keyboard_shortcuts/keyboard_shortcuts_sequence';

import {RhsState} from 'types/store/rhs';

import Constants, {RHSStates} from 'utils/constants';
import {t} from 'utils/i18n';

type Props = {
    previousRhsState?: RhsState;
    isExpanded: boolean;
    actions: {
        showMentions: () => void;
        showSearchResults: () => void;
        showFlaggedPosts: () => void;
        showPinnedPosts: () => void;
        closeRightHandSide: () => void;
        toggleRhsExpanded: () => void;
    };
};

export default class RhsCardHeader extends React.PureComponent<Props> {
    handleBack = (e: React.MouseEvent<HTMLAnchorElement>): void => {
        e.preventDefault();

        switch (this.props.previousRhsState) {
        case RHSStates.CHANNEL_FILES:
            this.props.actions.showSearchResults();
            break;
        case RHSStates.SEARCH:
            this.props.actions.showSearchResults();
            break;
        case RHSStates.MENTION:
            this.props.actions.showMentions();
            break;
        case RHSStates.FLAG:
            this.props.actions.showFlaggedPosts();
            break;
        case RHSStates.PIN:
            this.props.actions.showPinnedPosts();
            break;
        default:
            break;
        }
    }

    render(): React.ReactNode {
        let back;
        let backToResultsTooltip;

        switch (this.props.previousRhsState) {
        case RHSStates.SEARCH:
        case RHSStates.MENTION:
            backToResultsTooltip = (
                <Tooltip id='backToResultsTooltip'>
                    <FormattedMessage
                        id='rhs_header.backToResultsTooltip'
                        defaultMessage='Back to search results'
                    />
                </Tooltip>
            );
            break;
        case RHSStates.FLAG:
            backToResultsTooltip = (
                <Tooltip id='backToResultsTooltip'>
                    <FormattedMessage
                        id='rhs_header.backToFlaggedTooltip'
                        defaultMessage='Back to saved posts'
                    />
                </Tooltip>
            );
            break;
        case RHSStates.PIN:
            backToResultsTooltip = (
                <Tooltip id='backToResultsTooltip'>
                    <FormattedMessage
                        id='rhs_header.backToPinnedTooltip'
                        defaultMessage='Back to pinned posts'
                    />
                </Tooltip>
            );
            break;
        }

        const closeSidebarTooltip = (
            <Tooltip id='closeSidebarTooltip'>
                <FormattedMessage
                    id='rhs_header.closeSidebarTooltip'
                    defaultMessage='Close'
                />
            </Tooltip>
        );

        const expandSidebarTooltip = (
            <Tooltip id='expandSidebarTooltip'>
                <FormattedMessage
                    id='rhs_header.expandSidebarTooltip'
                    defaultMessage='Expand the right sidebar'
                />
                <KeyboardShortcutSequence
                    shortcut={KEYBOARD_SHORTCUTS.navExpandSidebar}
                    hideDescription={true}
                    isInsideTooltip={true}
                />
            </Tooltip>
        );

        const shrinkSidebarTooltip = (
            <Tooltip id='shrinkSidebarTooltip'>
                <FormattedMessage
                    id='rhs_header.collapseSidebarTooltip'
                    defaultMessage='Collapse the right sidebar'
                />
                <KeyboardShortcutSequence
                    shortcut={KEYBOARD_SHORTCUTS.navExpandSidebar}
                    hideDescription={true}
                    isInsideTooltip={true}
                />
            </Tooltip>
        );

        if (backToResultsTooltip) {
            back = (
                <OverlayTrigger
                    delayShow={Constants.OVERLAY_TIME_DELAY}
                    placement='top'
                    overlay={backToResultsTooltip}
                >
                    <a
                        href='#'
                        onClick={this.handleBack}
                        className='sidebar--right__back'
                    >
                        <LocalizedIcon
                            className='icon icon-arrow-back-ios'
                            ariaLabel={{id: t('generic_icons.back'), defaultMessage: 'Back Icon'}}
                        />
                    </a>
                </OverlayTrigger>
            );
        }

        return (
            <div className='sidebar--right__header'>
                <span className='sidebar--right__title'>
                    {back}
                    <FormattedMessage
                        id='search_header.title5'
                        defaultMessage='Extra information'
                    />
                </span>
                <div className='pull-right'>
                    <OverlayTrigger
                        delayShow={Constants.OVERLAY_TIME_DELAY}
                        placement='bottom'
                        overlay={this.props.isExpanded ? shrinkSidebarTooltip : expandSidebarTooltip}
                    >
                        <button
                            type='button'
                            className='sidebar--right__expand btn-icon'
                            aria-label='Expand'
                            onClick={this.props.actions.toggleRhsExpanded}
                        >
                            <LocalizedIcon
                                className='icon icon-arrow-expand'
                                ariaLabel={{id: t('rhs_header.expandSidebarTooltip.icon'), defaultMessage: 'Expand Sidebar Icon'}}
                            />
                            <LocalizedIcon
                                className='icon icon-arrow-collapse'
                                ariaLabel={{id: t('rhs_header.collapseSidebarTooltip.icon'), defaultMessage: 'Collapse Sidebar Icon'}}
                            />
                        </button>
                    </OverlayTrigger>
                    <OverlayTrigger
                        delayShow={Constants.OVERLAY_TIME_DELAY}
                        placement='top'
                        overlay={closeSidebarTooltip}
                    >
                        <button
                            type='button'
                            className='sidebar--right__close btn-icon'
                            aria-label='Close'
                            onClick={this.props.actions.closeRightHandSide}
                        >
                            <LocalizedIcon
                                className='icon icon-close'
                                ariaLabel={{id: t('rhs_header.closeTooltip.icon'), defaultMessage: 'Close Sidebar Icon'}}
                            />
                        </button>
                    </OverlayTrigger>
                </div>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {AnyAction, bindActionCreators, Dispatch} from 'redux';

import {GlobalState} from 'types/store';

import {
    showMentions,
    showSearchResults,
    showFlaggedPosts,
    showPinnedPosts,
    closeRightHandSide,
    toggleRhsExpanded,
} from 'actions/views/rhs';
import {getIsRhsExpanded} from 'selectors/rhs';

import RhsCardHeader from './rhs_card_header';

function mapStateToProps(state: GlobalState) {
    return {
        isExpanded: getIsRhsExpanded(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch<AnyAction>) {
    return {
        actions: bindActionCreators({
            showMentions,
            showSearchResults,
            showFlaggedPosts,
            showPinnedPosts,
            closeRightHandSide,
            toggleRhsExpanded,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(RhsCardHeader);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode} from 'react';
import Scrollbars from 'react-custom-scrollbars';
import {FormattedMessage} from 'react-intl';
import {Link} from 'react-router-dom';

import DelayedAction from 'utils/delayed_action';
import Constants from 'utils/constants';

import RhsCardHeader from 'components/rhs_card_header';
import Markdown from 'components/markdown';
import UserProfile from 'components/user_profile';
import PostProfilePicture from 'components/post_profile_picture';

import {Post} from '@mattermost/types/posts';

import {RhsState} from 'types/store/rhs';
import {PostPluginComponent} from 'types/store/plugins';

import {emitCloseRightHandSide} from 'actions/global_actions';

type Props = {
    isMobileView: boolean;
    selected?: Post;
    pluginPostCardTypes?: Record<string, PostPluginComponent>;
    previousRhsState?: RhsState;
    enablePostUsernameOverride?: boolean;
    teamUrl?: string;
};

type State = {
    isScrolling: boolean;
};

export function renderView(props: Props) {
    return (
        <div
            {...props}
            className='scrollbar--view'
        />
    );
}

export function renderThumbHorizontal(props: Props) {
    return (
        <div
            {...props}
            className='scrollbar--horizontal'
        />
    );
}

export function renderThumbVertical(props: Props) {
    return (
        <div
            {...props}
            className='scrollbar--vertical'
        />
    );
}

export default class RhsCard extends React.Component<Props, State> {
    scrollStopAction: DelayedAction;

    static defaultProps = {
        pluginPostCardTypes: {},
    }

    constructor(props: Props) {
        super(props);

        this.scrollStopAction = new DelayedAction(this.handleScrollStop);

        this.state = {
            isScrolling: false,
        };
    }

    shouldComponentUpdate(nextProps: Props, nextState: State) {
        if (nextState.isScrolling !== this.state.isScrolling) {
            return true;
        }
        return false;
    }

    handleScroll = () => {
        if (!this.state.isScrolling) {
            this.setState({
                isScrolling: true,
            });
        }

        this.scrollStopAction.fireAfter(Constants.SCROLL_DELAY);
    }

    handleScrollStop = () => {
        this.setState({
            isScrolling: false,
        });
    }

    handleClick = () => {
        if (this.props.isMobileView) {
            emitCloseRightHandSide();
        }
    };

    render() {
        if (this.props.selected == null) {
            return (<div/>);
        }

        const {selected, pluginPostCardTypes, teamUrl} = this.props;
        const postType = selected.type;
        let content: ReactNode = null;
        if (pluginPostCardTypes?.hasOwnProperty(postType)) {
            const PluginComponent = pluginPostCardTypes[postType].component;
            content = <PluginComponent post={selected}/>;
        }

        if (!content) {
            content = (
                <div className='info-card'>
                    <Markdown message={selected.props && selected.props.card}/>
                </div>
            );
        }

        let user = (
            <UserProfile
                userId={selected.user_id}
                hideStatus={true}
                disablePopover={true}
            />
        );
        if (selected.props.override_username && this.props.enablePostUsernameOverride) {
            user = (
                <UserProfile
                    userId={selected.user_id}
                    hideStatus={true}
                    disablePopover={true}
                    overwriteName={selected.props.override_username}
                />
            );
        }
        const avatar = (
            <PostProfilePicture
                compactDisplay={false}
                post={selected}
                userId={selected.user_id}
            />
        );

        return (
            <div className='sidebar-right__body sidebar-right__card'>
                <RhsCardHeader previousRhsState={this.props.previousRhsState}/>
                <Scrollbars
                    autoHide={true}
                    autoHideTimeout={500}
                    autoHideDuration={500}
                    renderThumbHorizontal={renderThumbHorizontal}
                    renderThumbVertical={renderThumbVertical}
                    renderView={renderView}
                    onScroll={this.handleScroll}
                >
                    <div className='post-right__scroll'>
                        {content}
                        <div className='d-flex post-card--info'>
                            <div className='post-card--post-by overflow--ellipsis'>
                                <FormattedMessage
                                    id='rhs_card.message_by'
                                    defaultMessage='Message by {avatar} {user}'
                                    values={{user, avatar}}
                                />
                            </div>
                            <div className='post-card--view-post'>
                                <Link
                                    to={`${teamUrl}/pl/${selected.id}`}
                                    className='post__permalink'
                                    onClick={this.handleClick}
                                >
                                    <FormattedMessage
                                        id='rhs_card.jump'
                                        defaultMessage='Jump'
                                    />
                                </Link>
                            </div>
                        </div>
                    </div>
                </Scrollbars>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getCurrentRelativeTeamUrl} from 'mattermost-redux/selectors/entities/teams';
import {getConfig} from 'mattermost-redux/selectors/entities/general';

import {getSelectedPostCard} from 'selectors/rhs';
import {getIsMobileView} from 'selectors/views/browser';

import {GlobalState} from 'types/store';

import RhsCard from './rhs_card';

function mapStateToProps(state: GlobalState) {
    const selected = getSelectedPostCard(state);
    const config = getConfig(state);
    const enablePostUsernameOverride = config.EnablePostUsernameOverride === 'true';

    return {
        enablePostUsernameOverride,
        isMobileView: getIsMobileView(state),
        selected,
        pluginPostCardTypes: state.plugins.postCardTypes,
        teamUrl: getCurrentRelativeTeamUrl(state),
    };
}

export default connect(mapStateToProps)(RhsCard);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import styled from 'styled-components';
import {useIntl} from 'react-intl';

import {Channel, ChannelStats} from '@mattermost/types/channels';
import {Constants} from 'utils/constants';

const MenuItemContainer = styled.div`
    padding: 8px 16px;
    flex: 1;
    display: flex;
`;

const Icon = styled.div`
    color: rgba(var(--center-channel-color-rgb), 0.56);
`;

const MenuItemText = styled.div`
    padding-left: 8px;
    flex: 1;
`;

const RightSide = styled.div`
    display: flex;
    color: rgba(var(--center-channel-color-rgb), 0.56);
`;

const Badge = styled.div`
    font-size: 12px;
    line-height: 18px;
`;

interface MenuItemProps {
    className?: string;
    icon: JSX.Element;
    text: string;
    opensSubpanel?: boolean;
    badge?: string|number;
    onClick: () => void;
}

const menuItem = ({icon, text, className, opensSubpanel, badge, onClick}: MenuItemProps) => {
    const hasRightSide = (badge !== undefined) || opensSubpanel;

    return (
        <div className={className}>
            <MenuItemContainer onClick={onClick}>
                <Icon>{icon}</Icon>
                <MenuItemText>
                    {text}
                </MenuItemText>

                {hasRightSide && (
                    <RightSide>
                        {badge !== undefined && (
                            <Badge>{badge}</Badge>
                        )}
                        {opensSubpanel && (
                            <Icon><i className='icon icon-chevron-right'/></Icon>
                        )}
                    </RightSide>
                )}
            </MenuItemContainer>
        </div>
    );
};

const MenuItem = styled(menuItem)`
    display: flex;
    flex-direction: row;
    align-items: center;
    cursor: pointer;
    width: 100%;
    height: 40px;

    &:hover {
       background: rgba(var(--center-channel-color-rgb), 0.08);
    }
`;

interface MenuProps {
    channel: Channel;
    channelStats: ChannelStats;
    isArchived: boolean;

    className?: string;

    actions: {
        openNotificationSettings: () => void;
        showChannelFiles: (channelId: string) => void;
        showPinnedPosts: (channelId: string | undefined) => void;
        showChannelMembers: (channelId: string) => void;
    };
}

const Menu = ({channel, channelStats, isArchived, className, actions}: MenuProps) => {
    const {formatMessage} = useIntl();

    const showNotificationPreferences = channel.type !== Constants.DM_CHANNEL && !isArchived;
    const showMembers = channel.type !== Constants.DM_CHANNEL;

    return (
        <div
            className={className}
            data-testid='channel_info_rhs-menu'
        >
            {showNotificationPreferences && (
                <MenuItem
                    icon={<i className='icon icon-bell-outline'/>}
                    text={formatMessage({id: 'channel_info_rhs.menu.notification_preferences', defaultMessage: 'Notification Preferences'})}
                    onClick={actions.openNotificationSettings}
                />
            )}
            {showMembers && (
                <MenuItem
                    icon={<i className='icon icon-account-outline'/>}
                    text={formatMessage({id: 'channel_info_rhs.menu.members', defaultMessage: 'Members'})}
                    opensSubpanel={true}
                    badge={channelStats.member_count}
                    onClick={() => actions.showChannelMembers(channel.id)}
                />
            )}
            <MenuItem
                icon={<i className='icon icon-pin-outline'/>}
                text={formatMessage({id: 'channel_info_rhs.menu.pinned', defaultMessage: 'Pinned Messages'})}
                opensSubpanel={true}
                badge={channelStats?.pinnedpost_count}
                onClick={() => actions.showPinnedPosts(channel.id)}
            />
            <MenuItem
                icon={<i className='icon icon-file-text-outline'/>}
                text={formatMessage({id: 'channel_info_rhs.menu.files', defaultMessage: 'Files'})}
                opensSubpanel={true}
                badge={channelStats?.files_count}
                onClick={() => actions.showChannelFiles(channel.id)}
            />
        </div>
    );
};

const StyledMenu = styled(Menu)`
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    padding: 16px 0;

    font-size: 14px;
    line-height: 20px;
    color: rgb(var(--center-channel-color-rgb));
`;

export default StyledMenu;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useRef, useState} from 'react';
import styled from 'styled-components';
import {CSSTransition} from 'react-transition-group';

interface LineLimiterProps {
    children: React.ReactNode;
    maxLines: number;
    lineHeight: number;
    moreText: string;
    lessText: string;
    className?: string;
    errorMargin?: number;
}

const LineLimiterBase = ({children, maxLines, lineHeight, moreText, lessText, errorMargin = 0.1, className}: LineLimiterProps) => {
    const maxLineHeight = maxLines * lineHeight;

    const [needLimiter, setNeedLimiter] = useState(false);
    const [open, setOpen] = useState(false);
    const [maxHeight, setMaxHeight] = useState('inherit');
    const ref = useRef<HTMLDivElement>(null);

    useEffect(() => {
        if (ref === null || ref.current === null) {
            return;
        }

        const contentHeight = ref.current.scrollHeight;
        const margin = maxLineHeight * errorMargin;
        if (contentHeight > (maxLineHeight + margin)) {
            setNeedLimiter(true);

            if (open) {
                setMaxHeight(`${contentHeight}px`);
            } else {
                setMaxHeight(`${maxLineHeight}px`);
            }
        } else {
            setNeedLimiter(false);
            setMaxHeight('inherit');
        }
    }, [children, open]);

    return (
        <CSSTransition
            in={open}
            timeout={500}
            classNames='LineLimiter--Transition-'
        >
            <>
                <div
                    className={className}
                    style={{maxHeight}}
                >
                    <div>
                        <div ref={ref}>{children}</div>
                    </div>
                </div>
                {needLimiter && (
                    <ToggleButton
                        className='LineLimiter__toggler'
                        onClick={() => setOpen(!open)}
                    >
                        {open ? lessText : moreText}
                    </ToggleButton>
                )}
            </>
        </CSSTransition>
    );
};

const ToggleButton = styled.button`
    border: 0px;
    background-color: var(--center-channel-bg);
    color: var(--button-bg);
    padding: 0;
    margin: 0;
`;

const LineLimiter = styled(LineLimiterBase)<LineLimiterProps>`
    transition: max-height 0.5s ease;
    line-height: ${(props) => props.lineHeight}px;
    overflow: hidden;

    p {
        margin-bottom: ${(props) => props.lineHeight}px;
    }

    span[data-emoticon] {
        max-height: ${(props) => props.lineHeight}px;
        .emoticon {
            max-height: ${(props) => props.lineHeight}px;
            min-height: ${(props) => props.lineHeight}px;
         }
    }

    .markdown-inline-img__container img.markdown-inline-img {
        max-height: ${(props) => props.lineHeight}px !important;
        margin-top: 0 !important;
        margin-bottom: 0 !important;
    }

    & > * {
       overflow: hidden;
    }
`;

export default LineLimiter;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';
import styled from 'styled-components';

const EditButton = styled.button`
    border: 0;
    margin: 0px;
    padding: 0px;
    border-radius: 4px;
    background: rgba(var(--center-channel-color-rgb), 0.04);
    color: rgba(var(--center-channel-color-rgb), 0.56);
    &:hover {
        background: rgba(var(--center-channel-color-rgb), 0.08);
        color: rgba(var(--center-channel-color-rgb), 0.72);
    }
    width: 24px;
    height: 24px;
    i.icon {
        font-size: 14.4px;
    }
`;

const EmptyPlace = styled.button`
    padding: 0px;
    background: transparent;
    border: 0px;
    color: rgba(var(--center-channel-color-rgb), 0.64);
    i {
        display: none;
        font-size: 14px;
        margin-left: 4px;
    }
    &:hover {
        color: rgba(var(--center-channel-color-rgb), 0.72);
        i {
            display: inline-block;
        }
    }
`;

interface EditableAreaProps {
    editable: boolean;
    content: React.ReactNode;
    emptyLabel: string;
    onEdit: () => void;
    className?: string;
}

const EditableAreaBase = ({editable, content, emptyLabel, onEdit, className}: EditableAreaProps) => {
    const {formatMessage} = useIntl();

    const allowEditArea = editable && content;

    return (
        <div className={className}>
            <div className='EditableArea__content'>
                {content}
                {!content && editable && (
                    <EmptyPlace
                        onClick={onEdit}
                        aria-label={formatMessage({id: 'channel_info_rhs.edit_link', defaultMessage: 'Edit'})}
                    >
                        {emptyLabel}
                        <i className='icon icon-pencil-outline edit-icon'/>
                    </EmptyPlace>
                )}
            </div>
            <div className='EditableArea__edit'>
                {allowEditArea ? (
                    <EditButton
                        onClick={onEdit}
                        aria-label={formatMessage({id: 'channel_info_rhs.edit_link', defaultMessage: 'Edit'})}
                    >
                        <i className='icon icon-pencil-outline'/>
                    </EditButton>
                ) : ''}
            </div>
        </div>
    );
};

const EditableArea = styled(EditableAreaBase)`
    display: flex;
    &>.EditableArea__content {
        flex: 1;
        p:last-child {
            margin-bottom:0;
        }
    }
    &:hover {
        &>.EditableArea__edit {
            visibility: visible;
        }
    }

    &>.EditableArea__edit {
        visibility: hidden;
        width: 24px;
    }
`;

export default EditableArea;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import styled from 'styled-components';
import {useIntl} from 'react-intl';

import {Channel} from '@mattermost/types/channels';
import Markdown from 'components/markdown';
import ProfilePicture from 'components/profile_picture';
import {Client4} from 'mattermost-redux/client';
import BotBadge from 'components/widgets/badges/bot_badge';
import GuestBadge from 'components/widgets/badges/guest_badge';

import {DMUser} from './channel_info_rhs';
import LineLimiter from './components/linelimiter';
import EditableArea from './components/editable_area';

const Username = styled.p`
    font-family: Metropolis, sans-serif;
    font-size: 18px;
    line-height: 24px;
    color: rgb(var(--center-channel-color-rgb));
    font-weight: 600;
    margin: 0;
`;

const ChannelHeader = styled.div`
    margin-bottom: 12px;
`;

const UserInfoContainer = styled.div`
    display: flex;
    align-items: center;
    margin-bottom: 12px;
`;

const UserAvatar = styled.div`
    .status {
        bottom: 0;
        right: 0;
        height: 18px;
        width: 18px;
        & svg {
            min-height: 14.4px;
        }
    }
`;

const UserInfo = styled.div`
    margin-left: 12px;
    display: flex;
    flex-direction: column;
`;

const UsernameContainer = styled.div`
    display: flex;
`;

const UserPosition = styled.div`
    line-height: 20px;
    p {
        margin-bottom: 0px;
    }
`;

const ChannelId = styled.div`
    margin-bottom: 12px;
    font-size: 11px;
    line-height: 16px;
    letter-spacing: 0.02em;
    color: rgba(var(--center-channel-color-rgb), .64);
`;

interface Props {
    channel: Channel;
    dmUser: DMUser;
    actions: {
        editChannelHeader: () => void;
    };
}

const AboutAreaDM = ({channel, dmUser, actions}: Props) => {
    const {formatMessage} = useIntl();

    return (
        <>
            <UserInfoContainer>
                <UserAvatar>
                    <ProfilePicture
                        src={Client4.getProfilePictureUrl(dmUser.user.id, dmUser.user.last_picture_update)}
                        isBot={dmUser.user.is_bot}
                        status={dmUser.status ? dmUser.status : undefined}
                        isRHS={true}
                        username={dmUser.display_name}
                        userId={dmUser.user.id}
                        channelId={channel.id}
                        size='xl'
                        popoverPlacement='left'
                    />
                </UserAvatar>
                <UserInfo>
                    <UsernameContainer>
                        <Username>{dmUser.display_name}</Username>
                        {dmUser.user.is_bot && <BotBadge/>}
                        {dmUser.is_guest && <GuestBadge/>}
                    </UsernameContainer>
                    <UserPosition>
                        <Markdown message={dmUser.user.is_bot ? dmUser.user.bot_description : dmUser.user.position}/>
                    </UserPosition>
                </UserInfo>
            </UserInfoContainer>

            {!dmUser.user.is_bot && (
                <ChannelHeader>
                    <EditableArea
                        content={channel.header && (
                            <LineLimiter
                                maxLines={4}
                                lineHeight={20}
                                moreText={formatMessage({id: 'channel_info_rhs.about_area.channel_header.line_limiter.more', defaultMessage: 'more'})}
                                lessText={formatMessage({id: 'channel_info_rhs.about_area.channel_header.line_limiter.less', defaultMessage: 'less'})}
                            >
                                <Markdown message={channel.header}/>
                            </LineLimiter>
                        )}
                        editable={true}
                        onEdit={actions.editChannelHeader}
                        emptyLabel={formatMessage({id: 'channel_info_rhs.about_area.add_channel_header', defaultMessage: 'Add a channel header'})}
                    />
                </ChannelHeader>
            )}

            <ChannelId>
                {formatMessage({id: 'channel_info_rhs.about_area_id', defaultMessage: 'ID:'})} {channel.id}
            </ChannelId>
        </>
    );
};

export default AboutAreaDM;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import styled from 'styled-components';
import {useIntl} from 'react-intl';

import {Channel} from '@mattermost/types/channels';
import Markdown from 'components/markdown';
import {UserProfile} from '@mattermost/types/users';
import ProfilePicture from 'components/profile_picture';
import {Client4} from 'mattermost-redux/client';
import UserProfileElement from 'components/user_profile';

import EditableArea from './components/editable_area';
import LineLimiter from './components/linelimiter';

const Usernames = styled.p`
    font-family: Metropolis, sans-serif;
    font-size: 18px;
    line-height: 24px;
    color: rgb(var(--center-channel-color-rgb));
    font-weight: 600;
    margin: 0;
`;

const ProfilePictures = styled.div`
    margin-bottom: 10px;
`;

interface ProfilePictureContainerProps {
    position: number;
}

const ProfilePictureContainer = styled.div<ProfilePictureContainerProps>`
    display: inline-block;
    position: relative;
    left: ${(props) => props.position * -15}px;

    & img {
        border: 2px solid white;
    }
`;

const UsersArea = styled.div`
    margin-bottom: 12px;
    &.ChannelPurpose--is-dm {
        margin-bottom: 16px;
    }
`;

const ChannelHeader = styled.div`
    margin-bottom: 12px;
`;

const ChannelId = styled.div`
    margin-bottom: 12px;
    font-size: 11px;
    line-height: 16px;
    letter-spacing: 0.02em;
    color: rgba(var(--center-channel-color-rgb), .64);
`;

interface Props {
    channel: Channel;
    gmUsers: UserProfile[];
    actions: {
        editChannelHeader: () => void;
    };
}

const AboutAreaGM = ({channel, gmUsers, actions}: Props) => {
    const {formatMessage} = useIntl();

    return (
        <>
            <UsersArea>
                <ProfilePictures>
                    {gmUsers.map((user, idx) => (
                        <ProfilePictureContainer
                            key={user.id}
                            position={idx}
                        >
                            <ProfilePicture
                                src={Client4.getProfilePictureUrl(user.id, user.last_picture_update)}
                                size='xl'
                                userId={user.id}
                                username={user.username}
                                channelId={channel.id}
                                popoverPlacement='left'
                            />
                        </ProfilePictureContainer>
                    ))}
                </ProfilePictures>
                <Usernames>
                    {gmUsers.map((user, i, {length}) => (
                        <React.Fragment key={user.id}>
                            <UserProfileElement
                                userId={user.id}
                                isRHS={true}
                                channelId={channel.id}
                            />
                            {(i + 1 !== length) && (<span>{', '}</span>)}
                        </React.Fragment>
                    ))}
                </Usernames>
            </UsersArea>

            <ChannelHeader>
                <EditableArea
                    content={channel.header && (
                        <LineLimiter
                            maxLines={4}
                            lineHeight={20}
                            moreText={formatMessage({id: 'channel_info_rhs.about_area.channel_header.line_limiter.more', defaultMessage: 'more'})}
                            lessText={formatMessage({id: 'channel_info_rhs.about_area.channel_header.line_limiter.less', defaultMessage: 'less'})}
                        >
                            <Markdown message={channel.header}/>
                        </LineLimiter>
                    )}
                    editable={true}
                    onEdit={actions.editChannelHeader}
                    emptyLabel={formatMessage({id: 'channel_info_rhs.about_area.add_channel_header', defaultMessage: 'Add a channel header'})}
                />
            </ChannelHeader>

            <ChannelId>
                {formatMessage({id: 'channel_info_rhs.about_area_id', defaultMessage: 'ID:'})} {channel.id}
            </ChannelId>
        </>
    );
};

export default AboutAreaGM;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import styled from 'styled-components';
import {useIntl} from 'react-intl';

import {Channel} from '@mattermost/types/channels';
import Markdown from 'components/markdown';

import LineLimiter from './components/linelimiter';
import EditableArea from './components/editable_area';

const ChannelId = styled.div`
    margin-bottom: 12px;
    font-size: 11px;
    line-height: 16px;
    letter-spacing: 0.02em;
    color: rgba(var(--center-channel-color-rgb), .64);
`;

const ChannelPurpose = styled.div`
    margin-bottom: 12px;
    &.ChannelPurpose--is-dm {
        margin-bottom: 16px;
    }
`;

const ChannelHeader = styled.div`
    margin-bottom: 12px;
`;

interface Props {
    channel: Channel;
    canEditChannelProperties: boolean;
    actions: {
        editChannelPurpose: () => void;
        editChannelHeader: () => void;
    };
}

const AboutAreaChannel = ({channel, canEditChannelProperties, actions}: Props) => {
    const {formatMessage} = useIntl();

    return (
        <>
            {(channel.purpose || canEditChannelProperties) && (
                <ChannelPurpose>
                    <EditableArea
                        editable={canEditChannelProperties}
                        content={channel.purpose && (
                            <LineLimiter
                                maxLines={4}
                                lineHeight={20}
                                moreText={formatMessage({id: 'channel_info_rhs.about_area.channel_purpose.line_limiter.more', defaultMessage: 'more'})}
                                lessText={formatMessage({id: 'channel_info_rhs.about_area.channel_purpose.line_limiter.less', defaultMessage: 'less'})}
                            >
                                <Markdown message={channel.purpose}/>
                            </LineLimiter>
                        )}
                        onEdit={actions.editChannelPurpose}
                        emptyLabel={formatMessage({id: 'channel_info_rhs.about_area.add_channel_purpose', defaultMessage: 'Add a channel purpose'})}
                    />
                </ChannelPurpose>
            )}

            {(channel.header || canEditChannelProperties) && (
                <ChannelHeader>
                    <EditableArea
                        content={channel.header && (
                            <LineLimiter
                                maxLines={4}
                                lineHeight={20}
                                moreText={formatMessage({id: 'channel_info_rhs.about_area.channel_header.line_limiter.more', defaultMessage: 'more'})}
                                lessText={formatMessage({id: 'channel_info_rhs.about_area.channel_header.line_limiter.less', defaultMessage: 'less'})}
                            >
                                <Markdown message={channel.header}/>
                            </LineLimiter>
                        )}
                        editable={canEditChannelProperties}
                        onEdit={actions.editChannelHeader}
                        emptyLabel={formatMessage({id: 'channel_info_rhs.about_area.add_channel_header', defaultMessage: 'Add a channel header'})}
                    />
                </ChannelHeader>
            )}

            <ChannelId>
                {formatMessage({id: 'channel_info_rhs.about_area_id', defaultMessage: 'ID:'})} {channel.id}
            </ChannelId>
        </>
    );
};

export default AboutAreaChannel;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import styled from 'styled-components';

import Constants from 'utils/constants';
import {Channel} from '@mattermost/types/channels';
import {UserProfile} from '@mattermost/types/users';

import {DMUser} from './channel_info_rhs';
import AboutAreaDM from './about_area_dm';
import AboutAreaGM from './about_area_gm';
import AboutAreaChannel from './about_area_channel';

const Container = styled.div`
    overflow-wrap: anywhere;
    padding: 24px;
    padding-bottom: 12px;

    font-size: 14px;
    line-height: 20px;

    & .status-wrapper {
        height: 50px;
    }

    & .text-empty {
        padding: 0px;
        background: transparent;
        border: 0px;
        color: rgba(var(--center-channel-color-rgb), 0.64);
    }
`;

interface Props {
    channel: Channel;
    dmUser?: DMUser;
    gmUsers?: UserProfile[];
    canEditChannelProperties: boolean;
    actions: {
        editChannelPurpose: () => void;
        editChannelHeader: () => void;
    };
}

const AboutArea = ({channel, dmUser, gmUsers, canEditChannelProperties, actions}: Props) => {
    return (
        <Container>
            {channel.type === Constants.DM_CHANNEL && dmUser && (
                <AboutAreaDM
                    channel={channel}
                    dmUser={dmUser}
                    actions={{editChannelHeader: actions.editChannelHeader}}
                />
            )}
            {channel.type === Constants.GM_CHANNEL && gmUsers && (
                <AboutAreaGM
                    channel={channel}
                    gmUsers={gmUsers!}
                    actions={{editChannelHeader: actions.editChannelHeader}}
                />
            )}
            {[Constants.OPEN_CHANNEL, Constants.PRIVATE_CHANNEL].includes(channel.type) && (
                <AboutAreaChannel
                    channel={channel}
                    canEditChannelProperties={canEditChannelProperties}
                    actions={actions}
                />
            )}
        </Container>
    );
};

export default AboutArea;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import styled from 'styled-components';
import {useIntl, FormattedMessage} from 'react-intl';

import Constants from 'utils/constants';
import useCopyText from 'components/common/hooks/useCopyText';

const ChannelInfoRhsTopButtons = styled.div`
    display: flex;
    color: rgba(var(--center-channel-color-rgb), 0.56);
    margin-top: 24px;
    padding: 0 18px;
`;

const Button = styled.button`
    border-radius: 4px;
    border: 0;
    padding: 12px 0 10px 0;
    background: rgba(var(--center-channel-color-rgb), 0.04);
    flex: 1;
    margin: 0 6px;

    &:hover {
       background: rgba(var(--center-channel-color-rgb), 0.08);
       color: rgba(var(--center-channel-color-rgb), 0.72);
    }

    &:active,
    &.active {
        background: rgba(var(--button-bg-rgb), 0.08);
        color: var(--button-bg);
    }

    & i {
        font-size: 24px;
    }
    & span {
        line-height: 16px;
        font-size: 10px;
        font-weight: 600;
    }
`;

const CopyButton = styled(Button)`
    transition: background-color 0.5s ease;

    &:active,
    &.active {
        background: rgba(var(--center-channel-color-rgb), 0.08);
        color: rgba(var(--center-channel-color-rgb), 0.72);
        transition: none;
    }

    &.success {
        background: var(--denim-status-online);
        color: var(--button-color);
    }
`;

export interface Props {
    channelType: string;
    channelURL?: string;

    isFavorite: boolean;
    isMuted: boolean;
    isInvitingPeople: boolean;

    canAddPeople: boolean;

    actions: {
        toggleFavorite: () => void;
        toggleMute: () => void;
        addPeople: () => void;
    };
}

export default function TopButtons({
    channelType,
    channelURL,
    isFavorite,
    isMuted,
    isInvitingPeople,
    canAddPeople: propsCanAddPeople,
    actions,
}: Props) {
    const {formatMessage} = useIntl();

    const copyLink = useCopyText({
        text: channelURL || '',
        successCopyTimeout: 1000,
    });

    const canAddPeople = ([Constants.OPEN_CHANNEL, Constants.PRIVATE_CHANNEL].includes(channelType) && propsCanAddPeople) || channelType === Constants.GM_CHANNEL;

    const canCopyLink = [Constants.OPEN_CHANNEL, Constants.PRIVATE_CHANNEL].includes(channelType);

    // Favorite Button State
    const favoriteIcon = isFavorite ? 'icon-star' : 'icon-star-outline';
    const favoriteText = isFavorite ? formatMessage({id: 'channel_info_rhs.top_buttons.favorited', defaultMessage: 'Favorited'}) : formatMessage({id: 'channel_info_rhs.top_buttons.favorite', defaultMessage: 'Favorite'});

    // Mute Button State
    const mutedIcon = isMuted ? 'icon-bell-off-outline' : 'icon-bell-outline';
    const mutedText = isMuted ? formatMessage({id: 'channel_info_rhs.top_buttons.muted', defaultMessage: 'Muted'}) : formatMessage({id: 'channel_info_rhs.top_buttons.mute', defaultMessage: 'Mute'});

    // Copy Button State
    const copyIcon = copyLink.copiedRecently ? 'icon-check' : 'icon-link-variant';
    const copyText = copyLink.copiedRecently ? formatMessage({id: 'channel_info_rhs.top_buttons.copied', defaultMessage: 'Copied'}) : formatMessage({id: 'channel_info_rhs.top_buttons.copy', defaultMessage: 'Copy Link'});

    return (
        <ChannelInfoRhsTopButtons>
            <Button
                onClick={actions.toggleFavorite}
                className={isFavorite ? 'active' : ''}
            >
                <div>
                    <i className={'icon ' + favoriteIcon}/>
                </div>
                <span>{favoriteText}</span>
            </Button>
            <Button
                onClick={actions.toggleMute}
                className={isMuted ? 'active' : ''}
            >
                <div>
                    <i className={'icon ' + mutedIcon}/>
                </div>
                <span>{mutedText}</span>
            </Button>
            {canAddPeople && (
                <Button
                    onClick={actions.addPeople}
                    className={isInvitingPeople ? 'active' : ''}
                >
                    <div>
                        <i className='icon icon-account-plus-outline'/>
                    </div>
                    <span>
                        <FormattedMessage
                            id='channel_info_rhs.top_buttons.add_people'
                            defaultMessage='Add People'
                        />
                    </span>
                </Button>
            )}
            {canCopyLink && (
                <CopyButton
                    onClick={copyLink.onClick}
                    className={copyLink.copiedRecently ? 'success' : ''}
                >
                    <div>
                        <i className={'icon ' + copyIcon}/>
                    </div>
                    <span>{copyText}</span>
                </CopyButton>
            )}
        </ChannelInfoRhsTopButtons>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';
import styled from 'styled-components';

import Constants from 'utils/constants';
import {Channel} from '@mattermost/types/channels';
import LocalizedIcon from 'components/localized_icon';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import {t} from 'utils/i18n';

interface Props {
    channel: Channel;
    isArchived: boolean;
    isMobile: boolean;
    onClose: () => void;
}

const Icon = styled.i`
    font-size:12px;
`;

const BackButton = styled.button`
    border: 0px;
    background: transparent;
`;

const HeaderTitle = styled.span`
    line-height: 2.4rem;
`;

const Header = ({channel, isArchived, isMobile, onClose}: Props) => {
    const closeSidebarTooltip = (
        <Tooltip id='closeSidebarTooltip'>
            <FormattedMessage
                id='rhs_header.closeSidebarTooltip'
                defaultMessage='Close'
            />
        </Tooltip>
    );

    return (
        <div className='sidebar--right__header'>
            <span className='sidebar--right__title'>

                {isMobile && (
                    <BackButton
                        className='sidebar--right__back'
                        onClick={onClose}
                    >
                        <i
                            className='icon icon-arrow-back-ios'
                            aria-label='Back Icon'
                        />
                    </BackButton>
                )}

                <HeaderTitle>
                    <FormattedMessage
                        id='channel_info_rhs.header.title'
                        defaultMessage='Info'
                    />
                </HeaderTitle>

                {channel.display_name &&
                <span
                    className='style--none sidebar--right__title__subtitle'
                >
                    {isArchived && (<Icon className='icon icon-archive-outline'/>)}
                    {channel.display_name}
                </span>
                }
            </span>

            <OverlayTrigger
                delayShow={Constants.OVERLAY_TIME_DELAY}
                placement='top'
                overlay={closeSidebarTooltip}
            >
                <button
                    id='rhsCloseButton'
                    type='button'
                    className='sidebar--right__close btn-icon'
                    aria-label='Close'
                    onClick={onClose}
                >
                    <LocalizedIcon
                        className='icon icon-close'
                        ariaLabel={{id: t('rhs_header.closeTooltip.icon'), defaultMessage: 'Close Sidebar Icon'}}
                    />
                </button>
            </OverlayTrigger>
        </div>
    );
};

export default Header;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo} from 'react';

import styled from 'styled-components';

import {UserProfile} from '@mattermost/types/users';
import {Channel, ChannelStats} from '@mattermost/types/channels';
import {getSiteURL} from 'utils/url';
import ChannelInviteModal from 'components/channel_invite_modal';
import {Team} from '@mattermost/types/teams';
import {ModalData} from 'types/actions';
import Constants, {ModalIdentifiers} from 'utils/constants';
import EditChannelPurposeModal from 'components/edit_channel_purpose_modal';
import EditChannelHeaderModal from 'components/edit_channel_header_modal';
import ChannelNotificationsModal from 'components/channel_notifications_modal';
import MoreDirectChannels from 'components/more_direct_channels';

import Menu from './menu';
import AboutArea from './about_area';
import TopButtons from './top_buttons';
import Header from './header';

const Divider = styled.div`
    width: 88%;
    border: 1px solid rgba(var(--center-channel-color-rgb), 0.04);
    margin: 0 auto;
`;

export interface DMUser {
    user: UserProfile;
    display_name: string;
    is_guest: boolean;
    status: string;
}

export interface Props {
    channel: Channel;
    channelStats: ChannelStats;
    currentUser: UserProfile;
    currentTeam: Team;

    isArchived: boolean;
    isFavorite: boolean;
    isMuted: boolean;
    isInvitingPeople: boolean;
    isMobile: boolean;

    canManageMembers: boolean;
    canManageProperties: boolean;

    dmUser?: DMUser;
    channelMembers: UserProfile[];

    actions: {
        closeRightHandSide: () => void;
        unfavoriteChannel: (channelId: string) => void;
        favoriteChannel: (channelId: string) => void;
        unmuteChannel: (userId: string, channelId: string) => void;
        muteChannel: (userId: string, channelId: string) => void;
        openModal: <P>(modalData: ModalData<P>) => void;
        showChannelFiles: (channelId: string) => void;
        showPinnedPosts: (channelId: string | undefined) => void;
        showChannelMembers: (channelId: string) => void;
    };
}

const ChannelInfoRhs = ({
    channel,
    channelStats,
    isArchived,
    isFavorite,
    isMuted,
    isInvitingPeople,
    isMobile,
    currentTeam,
    currentUser,
    dmUser,
    channelMembers,
    canManageMembers,
    canManageProperties,
    actions,
}: Props) => {
    const currentUserId = currentUser.id;
    const channelURL = getSiteURL() + '/' + currentTeam.name + '/channels/' + channel.name;

    const toggleFavorite = () => {
        if (isFavorite) {
            actions.unfavoriteChannel(channel.id);
            return;
        }
        actions.favoriteChannel(channel.id);
    };

    const toggleMute = () => {
        if (isMuted) {
            actions.unmuteChannel(currentUserId, channel.id);
            return;
        }
        actions.muteChannel(currentUserId, channel.id);
    };

    const addPeople = () => {
        if (channel.type === Constants.GM_CHANNEL) {
            return actions.openModal({
                modalId: ModalIdentifiers.CREATE_DM_CHANNEL,
                dialogType: MoreDirectChannels,
                dialogProps: {isExistingChannel: true},
            });
        }

        return actions.openModal({
            modalId: ModalIdentifiers.CHANNEL_INVITE,
            dialogType: ChannelInviteModal,
            dialogProps: {channel},
        });
    };

    const editChannelPurpose = () => actions.openModal({
        modalId: ModalIdentifiers.EDIT_CHANNEL_PURPOSE,
        dialogType: EditChannelPurposeModal,
        dialogProps: {channel},
    });

    const editChannelHeader = () => actions.openModal({
        modalId: ModalIdentifiers.EDIT_CHANNEL_HEADER,
        dialogType: EditChannelHeaderModal,
        dialogProps: {channel},
    });

    const openNotificationSettings = () => actions.openModal({
        modalId: ModalIdentifiers.CHANNEL_NOTIFICATIONS,
        dialogType: ChannelNotificationsModal,
        dialogProps: {channel, currentUser},
    });

    const gmUsers = channelMembers.filter((user) => {
        return user.id !== currentUser.id;
    });

    const canEditChannelProperties = !isArchived && canManageProperties;

    return (
        <div
            id='rhsContainer'
            className='sidebar-right__body'
        >
            <Header
                channel={channel}
                isArchived={isArchived}
                isMobile={isMobile}
                onClose={actions.closeRightHandSide}
            />

            <TopButtons
                channelType={channel.type}
                channelURL={channelURL}

                isFavorite={isFavorite}
                isMuted={isMuted}
                isInvitingPeople={isInvitingPeople}

                canAddPeople={canManageMembers}

                actions={{toggleFavorite, toggleMute, addPeople}}
            />

            <AboutArea
                channel={channel}

                dmUser={dmUser}
                gmUsers={gmUsers}

                canEditChannelProperties={canEditChannelProperties}

                actions={{
                    editChannelHeader,
                    editChannelPurpose,
                }}
            />

            <Divider/>

            <Menu
                channel={channel}
                channelStats={channelStats}
                isArchived={isArchived}
                actions={{
                    openNotificationSettings,
                    showChannelFiles: actions.showChannelFiles,
                    showPinnedPosts: actions.showPinnedPosts,
                    showChannelMembers: actions.showChannelMembers,
                }}
            />
        </div>
    );
};

export default memo(ChannelInfoRhs);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {AnyAction, bindActionCreators, Dispatch} from 'redux';

import {getCurrentChannel, isCurrentChannelFavorite, isCurrentChannelMuted, isCurrentChannelArchived, getCurrentChannelStats} from 'mattermost-redux/selectors/entities/channels';
import {isModalOpen} from 'selectors/views/modals';

import {closeRightHandSide, showChannelFiles, showChannelMembers, showPinnedPosts} from 'actions/views/rhs';

import {GlobalState} from 'types/store';

import {Constants, ModalIdentifiers} from 'utils/constants';

import {getCurrentUser} from 'mattermost-redux/selectors/entities/common';
import {getIsMobileView} from 'selectors/views/browser';
import {getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';
import {unfavoriteChannel, favoriteChannel} from 'mattermost-redux/actions/channels';
import {muteChannel, unmuteChannel} from 'actions/channel_actions';
import {openModal} from 'actions/views/modals';
import {getDisplayNameByUser, getUserIdFromChannelId} from 'utils/utils';
import {getProfilesInCurrentChannel, getStatusForUserId, getUser} from 'mattermost-redux/selectors/entities/users';
import {isGuest} from 'mattermost-redux/utils/user_utils';

import {haveIChannelPermission} from 'mattermost-redux/selectors/entities/roles';
import {Permissions} from 'mattermost-redux/constants';

import RHS, {Props} from './channel_info_rhs';

const EMPTY_CHANNEL_STATS = {
    member_count: 0,
    guest_count: 0,
    pinnedpost_count: 0,
    files_count: 0,
};

function mapStateToProps(state: GlobalState) {
    const channel = getCurrentChannel(state);
    const currentUser = getCurrentUser(state);
    const currentTeam = getCurrentTeam(state);
    const channelStats = getCurrentChannelStats(state) || EMPTY_CHANNEL_STATS;
    const isArchived = isCurrentChannelArchived(state);
    const isFavorite = isCurrentChannelFavorite(state);
    const isMuted = isCurrentChannelMuted(state);
    const isInvitingPeople = isModalOpen(state, ModalIdentifiers.CHANNEL_INVITE) || isModalOpen(state, ModalIdentifiers.CREATE_DM_CHANNEL);
    const isMobile = getIsMobileView(state);

    const isPrivate = channel.type === Constants.PRIVATE_CHANNEL;
    const canManageMembers = haveIChannelPermission(state, currentTeam.id, channel.id, isPrivate ? Permissions.MANAGE_PRIVATE_CHANNEL_MEMBERS : Permissions.MANAGE_PUBLIC_CHANNEL_MEMBERS);
    const canManageProperties = haveIChannelPermission(state, currentTeam.id, channel.id, isPrivate ? Permissions.MANAGE_PRIVATE_CHANNEL_PROPERTIES : Permissions.MANAGE_PUBLIC_CHANNEL_PROPERTIES);

    const channelMembers = getProfilesInCurrentChannel(state);

    const props = {
        channel,
        currentUser,
        currentTeam,
        isArchived,
        isFavorite,
        isMuted,
        isInvitingPeople,
        isMobile,
        canManageMembers,
        canManageProperties,
        channelStats,
        channelMembers,
    } as Props;

    if (channel.type === Constants.DM_CHANNEL) {
        const user = getUser(state, getUserIdFromChannelId(channel.name, currentUser.id));
        props.dmUser = {
            user,
            display_name: getDisplayNameByUser(state, user),
            is_guest: isGuest(user.roles),
            status: getStatusForUserId(state, user.id),
        };
    }

    return props;
}

function mapDispatchToProps(dispatch: Dispatch<AnyAction>) {
    return {
        actions: bindActionCreators({
            closeRightHandSide,
            unfavoriteChannel,
            favoriteChannel,
            unmuteChannel,
            muteChannel,
            openModal,
            showChannelFiles,
            showPinnedPosts,
            showChannelMembers,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(RHS);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {AnyAction, bindActionCreators, Dispatch} from 'redux';

import {createSelector} from 'reselect';

import {
    getCurrentChannel,
    getCurrentChannelStats,
    getMembersInCurrentChannel,
    getMyCurrentChannelMembership,
    isCurrentChannelArchived,
} from 'mattermost-redux/selectors/entities/channels';
import {GlobalState} from 'types/store';
import {Constants, RHSStates} from 'utils/constants';
import {getCurrentRelativeTeamUrl, getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';
import {
    getActiveProfilesInCurrentChannelWithoutSorting,
    getUserStatuses, searchActiveProfilesInCurrentChannel,
} from 'mattermost-redux/selectors/entities/users';
import {haveIChannelPermission} from 'mattermost-redux/selectors/entities/roles';
import {Permissions} from 'mattermost-redux/constants';
import {getTeammateNameDisplaySetting} from 'mattermost-redux/selectors/entities/preferences';
import {displayUsername} from 'mattermost-redux/utils/user_utils';
import {openDirectChannelToUserId} from 'actions/channel_actions';
import {openModal} from 'actions/views/modals';
import {closeRightHandSide, goBack, setEditChannelMembers} from 'actions/views/rhs';
import {getIsEditingMembers, getPreviousRhsState} from 'selectors/rhs';
import {setChannelMembersRhsSearchTerm} from 'actions/views/search';
import {loadProfilesAndReloadChannelMembers, searchProfilesAndChannelMembers} from 'actions/user_actions';
import {Channel, ChannelMembership} from '@mattermost/types/channels';
import {loadMyChannelMemberAndRole} from 'mattermost-redux/actions/channels';

import {UserProfile} from '@mattermost/types/users';
import {RelationOneToOne} from '@mattermost/types/utilities';

import RHS, {Props, ChannelMember} from './channel_members_rhs';

const buildProfileList = (
    profilesInCurrentChannel: UserProfile[],
    userStatuses: RelationOneToOne<UserProfile, string>,
    teammateNameDisplaySetting: string,
    membersInCurrentChannel: Record<string, ChannelMembership>,
) => {
    const channelMembers: ChannelMember[] = [];
    profilesInCurrentChannel.forEach((profile) => {
        if (!membersInCurrentChannel[profile.id]) {
            return;
        }

        channelMembers.push({
            user: profile,
            membership: membersInCurrentChannel[profile.id],
            status: userStatuses[profile.id],
            displayName: displayUsername(profile, teammateNameDisplaySetting),
        });
    });

    channelMembers.sort((a, b) => {
        if (a.membership?.scheme_admin === b.membership?.scheme_admin) {
            return a.displayName.localeCompare(b.displayName);
        }

        if (a.membership?.scheme_admin === true) {
            return -1;
        }
        return 1;
    });

    return channelMembers;
};

const getProfiles = createSelector(
    'getProfiles',
    getActiveProfilesInCurrentChannelWithoutSorting,
    getUserStatuses,
    getTeammateNameDisplaySetting,
    getMembersInCurrentChannel,
    buildProfileList,
);

const searchProfiles = createSelector(
    'searchProfiles',
    (state: GlobalState, search: string) => searchActiveProfilesInCurrentChannel(state, search, false),
    getUserStatuses,
    getTeammateNameDisplaySetting,
    getMembersInCurrentChannel,
    buildProfileList,
);

function mapStateToProps(state: GlobalState) {
    const channel = getCurrentChannel(state);
    const currentTeam = getCurrentTeam(state);
    const currentUser = getMyCurrentChannelMembership(state);
    const {member_count: membersCount} = getCurrentChannelStats(state) || {member_count: 0};

    if (!channel) {
        return {
            channel: {} as Channel,
            currentUserIsChannelAdmin: false,
            channelMembers: [],
            channelAdmins: [],
            searchTerms: '',
            membersCount,
            canManageMembers: false,
            canGoBack: false,
            teamUrl: '',
        } as unknown as Props;
    }

    const isArchived = isCurrentChannelArchived(state);
    const isPrivate = channel.type === Constants.PRIVATE_CHANNEL;
    const canManageMembers = haveIChannelPermission(
        state,
        currentTeam.id,
        channel.id,
        isPrivate ? Permissions.MANAGE_PRIVATE_CHANNEL_MEMBERS : Permissions.MANAGE_PUBLIC_CHANNEL_MEMBERS,
    ) && !isArchived;

    const searchTerms = state.views.search.channelMembersRhsSearch || '';

    let channelMembers: ChannelMember[] = [];
    if (searchTerms === '') {
        channelMembers = getProfiles(state);
    } else {
        channelMembers = searchProfiles(state, searchTerms.trim());
    }

    const teamUrl = getCurrentRelativeTeamUrl(state);
    const prevRhsState = getPreviousRhsState(state);
    const hasInfoPrevState = prevRhsState === RHSStates.CHANNEL_INFO ||
        prevRhsState === RHSStates.CHANNEL_FILES ||
        prevRhsState === RHSStates.PIN;

    const canGoBack = Boolean(hasInfoPrevState);
    const editing = getIsEditingMembers(state);

    const currentUserIsChannelAdmin = currentUser && currentUser.scheme_admin;

    return {
        channel,
        currentUserIsChannelAdmin,
        membersCount,
        searchTerms,
        teamUrl,
        canGoBack,
        canManageMembers,
        channelMembers,
        editing,
    } as Props;
}

function mapDispatchToProps(dispatch: Dispatch<AnyAction>) {
    return {
        actions: bindActionCreators({
            openModal,
            openDirectChannelToUserId,
            closeRightHandSide,
            goBack,
            setChannelMembersRhsSearchTerm,
            loadProfilesAndReloadChannelMembers,
            loadMyChannelMemberAndRole,
            setEditChannelMembers,
            searchProfilesAndChannelMembers,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(RHS);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useSelector} from 'react-redux';

import {FormattedMessage, MessageDescriptor} from 'react-intl';
import classNames from 'classnames';

import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {isFileAttachmentsEnabled} from 'utils/file_utils';

interface SearchTerm {
    searchTerm: string;
    message: MessageDescriptor;
    additionalDisplay?: string;
}

type Props = {
    withTitle?: boolean;
    onOptionSelected: (term: string) => void;
    onMouseDown?: () => void | undefined;
    options: SearchTerm[];
    highlightedIndex?: number;
    onOptionHover?: (index: number) => void;
    onSearchTypeSelected?: (searchType: 'files' | 'messages') => void;
    onElementBlur?: () => void;
    onElementFocus?: () => void;
    searchType?: 'files' | 'messages' | '';
}

const SearchHint = (props: Props): JSX.Element => {
    const handleOnOptionHover = (optionIndex: number) => {
        if (props.onOptionHover) {
            props.onOptionHover(optionIndex);
        }
    };
    const config = useSelector(getConfig);
    const isFileAttachmentEnabled = isFileAttachmentsEnabled(config);

    if (props.onSearchTypeSelected) {
        if (!props.searchType) {
            return (
                <div
                    className='search-hint__search-type-selector'
                    onMouseDown={props.onMouseDown}
                >
                    <div>
                        <FormattedMessage
                            id='search_bar.usage.search_type_question'
                            defaultMessage='What are you searching for?'
                        />
                    </div>
                    <div className='button-container'>
                        <button
                            className={classNames({highlighted: props.highlightedIndex === 0})}
                            onClick={() => props.onSearchTypeSelected && props.onSearchTypeSelected('messages')}
                            onBlur={() => props.onElementBlur && props.onElementBlur()}
                            onFocus={() => props.onElementFocus && props.onElementFocus()}
                        >
                            <i className='icon icon-message-text-outline'/>
                            <FormattedMessage
                                id='search_bar.usage.search_type_messages'
                                defaultMessage='Messages'
                            />
                        </button>
                        { isFileAttachmentEnabled &&
                            <button
                                className={classNames({highlighted: props.highlightedIndex === 1})}
                                onClick={() => props.onSearchTypeSelected && props.onSearchTypeSelected('files')}
                                onBlur={() => props.onElementBlur && props.onElementBlur()}
                                onFocus={() => props.onElementFocus && props.onElementFocus()}
                            >
                                <i className='icon icon-file-text-outline'/>
                                <FormattedMessage
                                    id='search_bar.usage.search_type_files'
                                    defaultMessage='Files'
                                />
                            </button>}
                    </div>
                </div>
            );
        }
    }

    return (
        <React.Fragment>
            {props.withTitle && (!props.searchType) &&
                <h4 className='search-hint__title'>
                    <FormattedMessage
                        id='search_bar.usage.title'
                        defaultMessage='Search options'
                    />
                </h4>
            }
            {props.withTitle && props.searchType === 'files' &&
                <h4 className='search-hint__title'>
                    <FormattedMessage
                        id='search_bar.usage.title_files'
                        defaultMessage='File search options'
                    />
                </h4>
            }
            {props.withTitle && props.searchType === 'messages' &&
                <h4 className='search-hint__title'>
                    <FormattedMessage
                        id='search_bar.usage.title_messages'
                        defaultMessage='Message search options'
                    />
                </h4>
            }
            <ul
                role='list'
                className='search-hint__suggestions-list'
                onMouseDown={props.onMouseDown}
                onTouchEnd={props.onMouseDown}
            >
                {props.options.map((option, optionIndex) => (
                    <li
                        className={classNames('search-hint__suggestions-list__option', {highlighted: optionIndex === props.highlightedIndex})}
                        key={option.searchTerm}
                        onMouseDown={() => props.onOptionSelected(option.searchTerm)}
                        onTouchEnd={() => props.onOptionSelected(option.searchTerm)}
                        onMouseOver={() => handleOnOptionHover(optionIndex)}
                    >
                        <div className='search-hint__suggestion-list__flex-wrap'>
                            <span className='search-hint__suggestion-list__label'>{option.additionalDisplay ? option.additionalDisplay : option.searchTerm}</span>
                        </div>
                        <div className='search-hint__suggestion-list__value'>
                            <FormattedMessage
                                id={option.message.id}
                                defaultMessage={option.message.defaultMessage}
                            />
                        </div>
                    </li>))}
            </ul>
        </React.Fragment>
    );
};

export default SearchHint;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

type Props = React.HTMLAttributes<HTMLSpanElement>;

export default function UserGuideIcon(props: Props): JSX.Element {
    const {formatMessage} = useIntl();

    return (
        <span {...props}>
            <svg
                width='18px'
                height='18px'
                viewBox='1 1 22 22'
                role='img'
                aria-label={formatMessage({id: 'generic_icons.userGuide', defaultMessage: 'Help'})}
                style={{width: '18px', height: '18px'}}
            >
                <path d='M11,18H13V16H11V18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,6A4,4 0 0,0 8,10H10A2,2 0 0,1 12,8A2,2 0 0,1 14,10C14,12 11,11.75 11,15H13C13,12.75 16,12.5 16,10A4,4 0 0,0 12,6Z'/>
            </svg>
        </span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage, injectIntl, WrappedComponentProps} from 'react-intl';
import classNames from 'classnames';

import {trackEvent} from 'actions/telemetry_actions';

import {ModalIdentifiers} from 'utils/constants';

import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import UserGuideIcon from 'components/widgets/icons/user_guide_icon';
import Menu from 'components/widgets/menu/menu';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import KeyboardShortcutsModal from 'components/keyboard_shortcuts/keyboard_shortcuts_modal/keyboard_shortcuts_modal';

import type {PropsFromRedux} from './index';

const askTheCommunityUrl = 'https://mattermost.com/pl/default-ask-mattermost-community/';

type Props = PropsFromRedux & WrappedComponentProps

type State = {
    buttonActive: boolean;
};

class UserGuideDropdown extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);
        this.state = {
            buttonActive: false,
        };
    }

    openKeyboardShortcutsModal = (e: MouseEvent) => {
        e.preventDefault();
        this.props.actions.openModal({
            modalId: ModalIdentifiers.KEYBOARD_SHORTCUTS_MODAL,
            dialogType: KeyboardShortcutsModal,
        });
    }

    buttonToggleState = (menuActive: boolean) => {
        this.setState({
            buttonActive: menuActive,
        });
    }

    askTheCommunityClick = () => {
        trackEvent('ui', 'help_ask_the_community');
    }

    renderDropdownItems = (): React.ReactNode => {
        const {intl} = this.props;

        return (
            <Menu.Group>
                {this.props.enableAskCommunityLink === 'true' && (
                    <Menu.ItemExternalLink
                        id='askTheCommunityLink'
                        url={askTheCommunityUrl}
                        text={intl.formatMessage({id: 'userGuideHelp.askTheCommunity', defaultMessage: 'Ask the community'})}
                        onClick={this.askTheCommunityClick}
                    />
                )}
                <Menu.ItemExternalLink
                    id='helpResourcesLink'
                    url={this.props.helpLink}
                    text={intl.formatMessage({id: 'userGuideHelp.helpResources', defaultMessage: 'Help resources'})}
                />
                <Menu.ItemExternalLink
                    id='reportAProblemLink'
                    url={this.props.reportAProblemLink}
                    text={intl.formatMessage({id: 'userGuideHelp.reportAProblem', defaultMessage: 'Report a problem'})}
                />
                <Menu.ItemAction
                    id='keyboardShortcuts'
                    onClick={this.openKeyboardShortcutsModal}
                    text={intl.formatMessage({id: 'userGuideHelp.keyboardShortcuts', defaultMessage: 'Keyboard shortcuts'})}
                />
            </Menu.Group>
        );
    }

    render() {
        const {intl} = this.props;
        const tooltip = (
            <Tooltip
                id='userGuideHelpTooltip'
                className='hidden-xs'
            >
                <FormattedMessage
                    id={'channel_header.userHelpGuide'}
                    defaultMessage='Help'
                />
            </Tooltip>
        );

        return (
            <MenuWrapper
                className='userGuideHelp'
                onToggle={this.buttonToggleState}
            >
                <OverlayTrigger
                    delayShow={500}
                    placement='bottom'
                    overlay={this.state.buttonActive ? <></> : tooltip}
                >
                    <button
                        id='channelHeaderUserGuideButton'
                        className={classNames('channel-header__icon', {'channel-header__icon--active': this.state.buttonActive})}
                        type='button'
                        aria-expanded='true'
                    >
                        <UserGuideIcon className='icon'/>
                    </button>
                </OverlayTrigger>
                <Menu
                    openLeft={true}
                    openUp={false}
                    id='AddChannelDropdown'
                    ariaLabel={intl.formatMessage({id: 'sidebar_left.add_channel_dropdown.dropdownAriaLabel', defaultMessage: 'Add Channel Dropdown'})}
                >
                    {this.renderDropdownItems()}
                </Menu>
            </MenuWrapper>
        );
    }
}

export default injectIntl(UserGuideDropdown);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {bindActionCreators, Dispatch} from 'redux';
import {connect, ConnectedProps} from 'react-redux';

import {GenericAction} from 'mattermost-redux/types/actions';
import {getConfig} from 'mattermost-redux/selectors/entities/general';

import {GlobalState} from 'types/store';

import {openModal} from 'actions/views/modals';

import UserGuideDropdown from './user_guide_dropdown';

function mapStateToProps(state: GlobalState) {
    const {HelpLink, ReportAProblemLink, EnableAskCommunityLink} = getConfig(state);
    return {
        helpLink: HelpLink!,
        reportAProblemLink: ReportAProblemLink!,
        enableAskCommunityLink: EnableAskCommunityLink!,
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            openModal,
        }, dispatch),
    };
}

const connector = connect(mapStateToProps, mapDispatchToProps);

export type PropsFromRedux = ConnectedProps<typeof connector>;

export default connector(UserGuideDropdown);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import Popover from 'components/widgets/popover';

type SuggestionItem = {
    key: string;
    ref: string;
    item: SuggestionItem;
    term: string;
    matchedPretext: string;
    isSelection: boolean;
    onClick: (term: string, matchedPretext: string[], e?: React.MouseEvent<HTMLDivElement>) => boolean;
}

type Props = {
    onCompleteWord: (term: string, matchedPretext: string[], e?: React.MouseEvent<HTMLDivElement>) => boolean;
    matchedPretext: string[];
    items: SuggestionItem[];
    terms: string[];
    components: Array<React.ComponentType<SuggestionItem>>;
}

export default class SuggestionDate extends React.PureComponent<Props> {
    render() {
        if (this.props.items.length === 0) {
            return null;
        }

        const item = this.props.items[0];
        const term = this.props.terms[0];

        // ReactComponent names need to be upper case when used in JSX
        const Component = this.props.components[0];

        const itemComponent = (
            <Component
                key={term}
                ref={term}
                item={item}
                term={term}
                matchedPretext={this.props.matchedPretext[0]}
                isSelection={false}
                onClick={this.props.onCompleteWord}
            />
        );

        return (
            <Popover
                id='search-autocomplete__popover'
                className='search-help-popover autocomplete visible'
                placement='bottom'
            >
                {itemComponent}
            </Popover>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import Constants from 'utils/constants';

import Popover from 'components/widgets/popover';

import SuggestionList from './suggestion_list';
import {UserProfile} from './command_provider/app_command_parser/app_command_parser_dependencies';

interface Item extends UserProfile {
    type: string;
    display_name: string;
    name: string;
}

interface Props {
    ariaLiveRef?: React.Ref<HTMLDivElement>;
    open: boolean;
    position?: 'top' | 'bottom';
    renderDividers?: string[];
    renderNoResults?: boolean;
    onCompleteWord: (term: string, matchedPretext: string, e?: React.MouseEvent<HTMLDivElement>) => boolean;
    preventClose?: () => void;
    onItemHover: (term: string) => void;
    pretext: string;
    cleared: boolean;
    matchedPretext: string[];
    items: any[];
    terms: string[];
    selection: string;
    components: Array<React.FunctionComponent<any>>;
    wrapperHeight?: number;

    // suggestionBoxAlgn is an optional object that can be passed to align the SuggestionList with the keyboard caret
    // as the user is typing.
    suggestionBoxAlgn?: {
        lineHeight: number;
        pixelsToMoveX: number;
        pixelsToMoveY: number;
    };
}

export default class SearchSuggestionList extends SuggestionList {
    popoverRef: React.RefObject<Popover>;
    itemsContainerRef: React.RefObject<HTMLDivElement>;
    suggestionReadOut: React.RefObject<HTMLDivElement>;
    currentLabel: string;

    constructor(props: Props) {
        super(props);

        this.itemRefs = new Map();
        this.popoverRef = React.createRef();
        this.itemsContainerRef = React.createRef();
        this.suggestionReadOut = React.createRef();
        this.currentLabel = '';
    }

    generateLabel(item: Item) {
        if (item.username) {
            this.currentLabel = item.username;
            if ((item.first_name || item.last_name) && item.nickname) {
                this.currentLabel += ` ${item.first_name} ${item.last_name} ${item.nickname}`;
            } else if (item.nickname) {
                this.currentLabel += ` ${item.nickname}`;
            } else if (item.first_name || item.last_name) {
                this.currentLabel += ` ${item.first_name} ${item.last_name}`;
            }
        } else if (item.type === Constants.DM_CHANNEL || item.type === Constants.GM_CHANNEL) {
            this.currentLabel = item.display_name;
        } else {
            this.currentLabel = item.name;
        }

        if (this.currentLabel) {
            this.currentLabel = this.currentLabel.toLowerCase();
        }

        this.announceLabel();
    }

    getContent = () => {
        return this.itemsContainerRef.current?.parentNode;
    }

    renderChannelDivider(type: string) {
        let text;
        if (type === Constants.OPEN_CHANNEL) {
            text = (
                <FormattedMessage
                    id='suggestion.search.public'
                    defaultMessage='Public Channels'
                />
            );
        } else if (type === Constants.PRIVATE_CHANNEL) {
            text = (
                <FormattedMessage
                    id='suggestion.search.private'
                    defaultMessage='Private Channels'
                />
            );
        } else {
            text = (
                <FormattedMessage
                    id='suggestion.search.direct'
                    defaultMessage='Direct Messages'
                />
            );
        }

        return (
            <div
                key={type + '-divider'}
                className='search-autocomplete__divider'
            >
                <span>{text}</span>
            </div>
        );
    }

    render() {
        if (this.props.items.length === 0) {
            return null;
        }

        const items: JSX.Element[] = [];
        let haveDMDivider = false;
        for (let i = 0; i < this.props.items.length; i++) {
            const item: any = this.props.items[i];
            const term = this.props.terms[i];
            const isSelection = term === this.props.selection;

            // ReactComponent names need to be upper case when used in JSX
            const Component = this.props.components[i];

            // temporary hack to add dividers between public and private channels in the search suggestion list
            if (this.props.renderDividers) {
                if (i === 0 || item.type !== this.props.items[i - 1].type) {
                    if (item.type === Constants.DM_CHANNEL || item.type === Constants.GM_CHANNEL) {
                        if (!haveDMDivider) {
                            items.push(this.renderChannelDivider(Constants.DM_CHANNEL));
                        }
                        haveDMDivider = true;
                    } else if (item.type === Constants.PRIVATE_CHANNEL) {
                        items.push(this.renderChannelDivider(Constants.PRIVATE_CHANNEL));
                    } else if (item.type === Constants.OPEN_CHANNEL) {
                        items.push(this.renderChannelDivider(Constants.OPEN_CHANNEL));
                    }
                }
            }

            if (isSelection) {
                this.currentItem = item;
            }

            items.push(
                <Component
                    key={term}
                    ref={(ref: React.RefObject<HTMLDivElement>) => this.itemRefs.set(term, ref)}
                    item={item}
                    term={term}
                    matchedPretext={this.props.matchedPretext[i]}
                    isSelection={isSelection}
                    onClick={this.props.onCompleteWord}
                    onMouseMove={this.props.onItemHover}
                />,
            );
        }

        return (
            <Popover
                ref={this.popoverRef}
                id='search-autocomplete__popover'
                className='search-help-popover autocomplete visible'
                placement='bottom'
            >
                <div
                    ref={this.suggestionReadOut}
                    aria-live='polite'
                    className='hidden-label'
                />
                <div ref={this.itemsContainerRef}>
                    {items}
                </div>
            </Popover>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ChangeEvent, CSSProperties, FormEvent, useEffect, useRef} from 'react';
import classNames from 'classnames';
import {FormattedMessage, useIntl} from 'react-intl';

import Constants from 'utils/constants';
import * as Utils from 'utils/utils';

import SuggestionDate from 'components/suggestion/suggestion_date';
import SearchSuggestionList from 'components/suggestion/search_suggestion_list';
import SuggestionBox from 'components/suggestion/suggestion_box';
import SuggestionBoxComponent from 'components/suggestion/suggestion_box/suggestion_box';
import LoadingSpinner from 'components/widgets/loading/loading_spinner';
import Provider from 'components/suggestion/provider';

const {KeyCodes} = Constants;

const style: Record<string, CSSProperties> = {
    searchForm: {overflow: 'visible'},
};

type Props = {
    searchTerms: string;
    updateHighlightedSearchHint: (indexDelta: number, changedViaKeyPress?: boolean) => void;
    handleChange: (e: ChangeEvent<HTMLInputElement>) => void;
    handleSubmit: (e: FormEvent<HTMLFormElement>) => void;
    handleEnterKey: (e: ChangeEvent<HTMLInputElement>) => void;
    handleClear: () => void;
    handleFocus: () => void;
    handleBlur: () => void;
    keepFocused: boolean;
    setKeepFocused: (value: boolean) => void;
    isFocused: boolean;
    suggestionProviders: Provider[];
    isSearchingTerm: boolean;
    isSideBarRight?: boolean;
    searchType: string;
    clearSearchType?: () => void;
    getFocus?: (searchBarFocus: () => void) => void;
    children?: React.ReactNode;
}

const defaultProps: Partial<Props> = {
    isSideBarRight: false,
    getFocus: (): void => {},
    children: null,
};

const SearchBar: React.FunctionComponent<Props> = (props: Props): JSX.Element => {
    const {isFocused, keepFocused, searchTerms, suggestionProviders} = props;

    const searchRef = useRef<SuggestionBoxComponent>();
    const intl = useIntl();

    useEffect((): void => {
        const shouldFocus = isFocused || keepFocused;
        if (shouldFocus) {
            // let redux handle changes before focussing the input
            setTimeout(() => searchRef.current?.focus(), 0);
        } else {
            setTimeout(() => searchRef.current?.blur(), 0);
        }
    }, [isFocused, keepFocused]);

    useEffect((): void => {
        if (isFocused && !keepFocused && searchTerms.endsWith('""')) {
            setTimeout(() => searchRef.current?.focus(), 0);
        }
    }, [searchTerms]);

    const handleKeyDown = (e: ChangeEvent<HTMLInputElement>): void => {
        if (Utils.isKeyPressed(e as any, KeyCodes.ESCAPE)) {
            searchRef.current?.blur();
            e.stopPropagation();
            e.preventDefault();
        }

        if (Utils.isKeyPressed(e as any, KeyCodes.DOWN)) {
            e.preventDefault();
            props.updateHighlightedSearchHint(1, true);
        }

        if (Utils.isKeyPressed(e as any, KeyCodes.UP)) {
            e.preventDefault();
            props.updateHighlightedSearchHint(-1, true);
        }

        if (Utils.isKeyPressed(e as any, KeyCodes.ENTER)) {
            props.handleEnterKey(e);
        }

        if (Utils.isKeyPressed(e as any, KeyCodes.BACKSPACE) && !searchTerms) {
            if (props.clearSearchType) {
                props.clearSearchType();
            }
        }
    };

    const getSearch = (node: SuggestionBoxComponent): void => {
        searchRef.current = node;
        if (props.getFocus) {
            props.getFocus(props.handleFocus);
        }
    };

    return (
        <div
            id={props.isSideBarRight ? 'sbrSearchFormContainer' : 'searchFormContainer'}
            className='search-form__container'
        >
            <form
                role='application'
                className={classNames(['search__form', {'search__form--focused': isFocused}])}
                onSubmit={props.handleSubmit}
                style={style.searchForm}
                autoComplete='off'
                aria-labelledby='searchBox'
            >
                <div className='search__font-icon'>
                    <i className='icon icon-magnify icon-16'/>
                </div>

                {props.searchType !== '' && (
                    <div
                        className='searchTypeBadge'
                        onMouseDown={props.handleFocus}
                    >
                        {props.searchType === 'messages' && (
                            <FormattedMessage
                                id='search_bar.search_types.messages'
                                defaultMessage='MESSAGES'
                            />
                        )}
                        {props.searchType === 'files' && (
                            <FormattedMessage
                                id='search_bar.search_types.files'
                                defaultMessage='FILES'
                            />
                        )}
                        <i
                            className='icon icon-close icon-12'
                            onMouseDown={() => {
                                props.setKeepFocused(true);
                            }}
                            onClick={() => props.clearSearchType && props.clearSearchType()}
                        />
                    </div>
                )}
                <SuggestionBox
                    ref={getSearch}
                    id={props.isSideBarRight ? 'sbrSearchBox' : 'searchBox'}
                    tabIndex='0'
                    className={'search-bar form-control a11y__region'}
                    containerClass='w-full'
                    data-a11y-sort-order='9'
                    aria-describedby={props.isSideBarRight ? 'sbr-searchbar-help-popup' : 'searchbar-help-popup'}
                    aria-label={intl.formatMessage({id: 'search_bar.search', defaultMessage: 'Search'})}
                    placeholder={intl.formatMessage({id: 'search_bar.search', defaultMessage: 'Search'})}
                    value={props.searchTerms}
                    onFocus={props.handleFocus}
                    onBlur={props.handleBlur}
                    onChange={props.handleChange}
                    onKeyDown={handleKeyDown}
                    listComponent={SearchSuggestionList}
                    dateComponent={SuggestionDate}
                    providers={suggestionProviders}
                    type='search'
                    delayInputUpdate={true}
                    renderDividers={['all']}
                    clearable={true}
                    onClear={props.handleClear}
                />
                {props.isSearchingTerm && <LoadingSpinner/>}
                {props.children}
            </form>
        </div>
    );
};

SearchBar.defaultProps = defaultProps;

export default SearchBar;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';
import styled from 'styled-components';

import LocalizedIcon from 'components/localized_icon';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import KeyboardShortcutSequence, {
    KEYBOARD_SHORTCUTS,
} from 'components/keyboard_shortcuts/keyboard_shortcuts_sequence';
import Constants, {RHSStates} from 'utils/constants';
import {t} from 'utils/i18n';
import {RhsState} from 'types/store/rhs';

const BackButton = styled.button`
    border: 0px;
    background: transparent;
`;

const BackButtonIcon = styled(LocalizedIcon)`
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
`;

type Props = {
    isExpanded: boolean;
    channelId: string;
    previousRhsState?: RhsState;
    canGoBack: boolean;
    children?: React.ReactNode;
    actions: {
        closeRightHandSide: () => void;
        toggleRhsExpanded: () => void;
        goBack: () => void;
    };
};

export default class SearchResultsHeader extends React.PureComponent<Props> {
    render(): React.ReactNode {
        const closeSidebarTooltip = (
            <Tooltip id='closeSidebarTooltip'>
                <FormattedMessage
                    id='rhs_header.closeSidebarTooltip'
                    defaultMessage='Close'
                />
            </Tooltip>
        );

        const expandSidebarTooltip = (
            <Tooltip id='expandSidebarTooltip'>
                <FormattedMessage
                    id='rhs_header.expandSidebarTooltip'
                    defaultMessage='Expand the right sidebar'
                />
                <KeyboardShortcutSequence
                    shortcut={KEYBOARD_SHORTCUTS.navExpandSidebar}
                    hideDescription={true}
                    isInsideTooltip={true}
                />
            </Tooltip>
        );

        const shrinkSidebarTooltip = (
            <Tooltip id='shrinkSidebarTooltip'>
                <FormattedMessage
                    id='rhs_header.collapseSidebarTooltip'
                    defaultMessage='Collapse the right sidebar'
                />
                <KeyboardShortcutSequence
                    shortcut={KEYBOARD_SHORTCUTS.navExpandSidebar}
                    hideDescription={true}
                    isInsideTooltip={true}
                />
            </Tooltip>
        );

        const showExpand = this.props.previousRhsState !== RHSStates.CHANNEL_INFO;

        return (
            <div className='sidebar--right__header'>
                <span className='sidebar--right__title'>
                    {this.props.canGoBack && (
                        <BackButton
                            className='sidebar--right__back'
                            onClick={() => this.props.actions.goBack()}
                        >
                            <BackButtonIcon
                                className='icon-arrow-back-ios'
                                ariaLabel={{id: t('rhs_header.back.icon'), defaultMessage: 'Back Icon'}}
                            />
                        </BackButton>
                    )}
                    {this.props.children}
                </span>

                <div className='pull-right'>
                    {showExpand && (
                        <OverlayTrigger
                            delayShow={Constants.OVERLAY_TIME_DELAY}
                            placement='bottom'
                            overlay={this.props.isExpanded ? shrinkSidebarTooltip : expandSidebarTooltip}
                        >
                            <button
                                type='button'
                                className='sidebar--right__expand btn-icon'
                                onClick={this.props.actions.toggleRhsExpanded}
                            >
                                <LocalizedIcon
                                    className='icon icon-arrow-expand'
                                    ariaLabel={{id: t('rhs_header.expandSidebarTooltip.icon'), defaultMessage: 'Expand Sidebar Icon'}}
                                />
                                <LocalizedIcon
                                    className='icon icon-arrow-collapse'
                                    ariaLabel={{id: t('rhs_header.collapseSidebarTooltip.icon'), defaultMessage: 'Collapse Sidebar Icon'}}
                                />
                            </button>
                        </OverlayTrigger>
                    )}
                    <OverlayTrigger
                        delayShow={Constants.OVERLAY_TIME_DELAY}
                        placement='top'
                        overlay={closeSidebarTooltip}
                    >
                        <button
                            id='searchResultsCloseButton'
                            type='button'
                            className='sidebar--right__close btn-icon'
                            aria-label='Close'
                            onClick={this.props.actions.closeRightHandSide}
                        >
                            <LocalizedIcon
                                className='icon icon-close'
                                ariaLabel={{id: t('rhs_header.closeTooltip.icon'), defaultMessage: 'Close Sidebar Icon'}}
                            />
                        </button>
                    </OverlayTrigger>
                </div>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {AnyAction, bindActionCreators, Dispatch} from 'redux';

import {GlobalState} from 'types/store/index.js';

import {
    closeRightHandSide,
    toggleRhsExpanded,
    goBack,
} from 'actions/views/rhs';
import {getIsRhsExpanded, getPreviousRhsState} from 'selectors/rhs';
import {getCurrentChannelId} from 'mattermost-redux/selectors/entities/common';

import {RHSStates} from 'utils/constants';

import SearchResultsHeader from './search_results_header';

function mapStateToProps(state: GlobalState) {
    const previousRhsState = getPreviousRhsState(state);
    const canGoBack = previousRhsState === RHSStates.CHANNEL_INFO ||
        previousRhsState === RHSStates.CHANNEL_MEMBERS ||
        previousRhsState === RHSStates.CHANNEL_FILES ||
        previousRhsState === RHSStates.PIN;

    return {
        isExpanded: getIsRhsExpanded(state),
        channelId: getCurrentChannelId(state),
        previousRhsState,
        canGoBack,
    };
}

function mapDispatchToProps(dispatch: Dispatch<AnyAction>) {
    return {
        actions: bindActionCreators({
            closeRightHandSide,
            toggleRhsExpanded,
            goBack,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(SearchResultsHeader);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {Posts} from 'mattermost-redux/constants/index';
import * as ReduxPostUtils from 'mattermost-redux/utils/post_utils';

import AutoHeightSwitcher, {AutoHeightSlots} from 'components/common/auto_height_switcher';
import PostMessageContainer from 'components/post_view/post_message_view';
import FileAttachmentListContainer from 'components/file_attachment_list';
import CommentIcon from 'components/common/comment_icon';
import DotMenu from 'components/dot_menu';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import PostProfilePicture from 'components/post_profile_picture';
import UserProfile from 'components/user_profile';
import DateSeparator from 'components/post_view/date_separator';
import PostAriaLabelDiv from 'components/post_view/post_aria_label_div';
import PostBodyAdditionalContent from 'components/post_view/post_body_additional_content';
import PostFlagIcon from 'components/post_view/post_flag_icon';
import ArchiveIcon from 'components/widgets/icons/archive_icon';
import PostTime from 'components/post_view/post_time';
import {getHistory} from 'utils/browser_history';
import BotBadge from 'components/widgets/badges/bot_badge';
import InfoSmallIcon from 'components/widgets/icons/info_small_icon';
import PostPreHeader from 'components/post_view/post_pre_header';
import ThreadFooter from 'components/threading/channel_threads/thread_footer';
import EditPost from 'components/edit_post';
import PriorityLabel from 'components/post_priority/post_priority_label';

import Constants, {AppEvents, Locations} from 'utils/constants';
import * as PostUtils from 'utils/post_utils';
import * as Utils from 'utils/utils';

import {Post} from '@mattermost/types/posts';

type Props = {

    /**
     *  Data used for rendering post
     */
    post: Post;

    /**
     * An array of strings in this post that were matched by the search
     */
    matches?: string[];

    channelDisplayName?: string;
    channelType?: string;
    channelIsArchived?: boolean;

    /**
     *  Flag for determining result display setting
     */
    compactDisplay?: boolean;

    /**
     *  Flag for highlighting mentions
     */
    isMentionSearch?: boolean;

    /**
     *  Flag for highlighting search term
     */
    term?: string;

    /**
     *  Flag for determining result flag state
     */
    isFlagged: boolean;

    /**
     * Whether post username overrides are to be respected.
     */
    enablePostUsernameOverride: boolean;

    /**
     * Is the search results item from a bot.
     */
    isBot: boolean;

    a11yIndex?: number;

    isMobileView: boolean;

    isPostPriorityEnabled: boolean;

    /**
     *  Function used for closing LHS
     */
    actions: {
        closeRightHandSide: () => void;
        selectPost: (post: Post) => void;
        selectPostCard: (post: Post) => void;
        setRhsExpanded: (rhsExpanded: boolean) => void;
    };

    displayName: string;

    /**
     * The number of replies in the same thread as this post
     */
    replyCount?: number;

    /**
     * Is the search results item from the flagged posts list.
     */
    isFlaggedPosts?: boolean;

    /**
     * Is the search results item from the pinned posts list.
     */
    isPinnedPosts?: boolean;

    /**
     * is the current post being edited in RHS?
     */
    isPostBeingEditedInRHS?: boolean;

    teamDisplayName?: string;
    teamName?: string;

    /**
     * Is this a post that we can directly reply to?
     */
    canReply?: boolean;

    isCollapsedThreadsEnabled?: boolean;
};

type State = {
    dropdownOpened: boolean;
    fileDropdownOpened: boolean;
    showPreview: boolean;
}

export default class SearchResultsItem extends React.PureComponent<Props, State> {
    static defaultProps = {
        isBot: false,
        channelIsArchived: false,
    };

    constructor(props: Props) {
        super(props);

        this.state = {
            dropdownOpened: false,
            fileDropdownOpened: false,
            showPreview: false,
        };
    }

    handleFocusRHSClick = (e: React.MouseEvent) => {
        e.preventDefault();
        this.props.actions.selectPost(this.props.post);
    };

    handleJumpClick = (e: React.MouseEvent) => {
        e.preventDefault();
        if (this.props.isMobileView) {
            this.props.actions.closeRightHandSide();
        }

        this.props.actions.setRhsExpanded(false);
        getHistory().push(`/${this.props.teamName}/pl/${this.props.post.id}`);
    };

    handleCardClick = (post: Post) => {
        if (!post) {
            return;
        }

        this.props.actions.selectPostCard(post);
    }

    handleDropdownOpened = (isOpened: boolean) => {
        this.setState({
            dropdownOpened: isOpened,
        });
    };

    handleFileDropdownOpened = (isOpened: boolean) => {
        this.setState({
            fileDropdownOpened: isOpened,
        });
    };

    renderPostTime = () => {
        const post = this.props.post;

        const isPermalink = !(Posts.POST_DELETED === post.state ||
            ReduxPostUtils.isPostPendingOrFailed(post));

        return (
            <PostTime
                isPermalink={isPermalink}
                eventTime={post.create_at}
                postId={post.id}
                location={Locations.SEARCH}
                teamName={this.props.teamName}
            />
        );
    };

    getClassName = () => {
        const {compactDisplay, isPostBeingEditedInRHS} = this.props;

        let className = 'post post--thread';

        if (compactDisplay) {
            className += ' post--compact';
        }

        if ((this.state.dropdownOpened || this.state.fileDropdownOpened) && !isPostBeingEditedInRHS) {
            className += ' post--hovered';
        }

        if (isPostBeingEditedInRHS) {
            className += ' post--editing';
        }

        return className;
    };

    getChannelName = () => {
        const {post, channelType, isCollapsedThreadsEnabled} = this.props;
        const {channelDisplayName} = this.props;
        let channelName: React.ReactNode = channelDisplayName;

        const isDirectMessage = channelType === Constants.DM_CHANNEL;
        const isPartOfThread = isCollapsedThreadsEnabled && (post.reply_count > 0 || post.is_following);

        if (isDirectMessage && isPartOfThread) {
            channelName = (
                <FormattedMessage
                    id='search_item.thread_direct'
                    defaultMessage='Thread in Direct Message with {username}'
                    values={{
                        username: this.props.displayName,
                    }}
                />
            );
        } else if (isPartOfThread) {
            channelName = (
                <FormattedMessage
                    id='search_item.thread'
                    defaultMessage='Thread in {channel}'
                    values={{
                        channel: channelDisplayName,
                    }}
                />
            );
        } else if (isDirectMessage) {
            channelName = (
                <FormattedMessage
                    id='search_item.direct'
                    defaultMessage='Direct Message (with {username})'
                    values={{
                        username: this.props.displayName,
                    }}
                />
            );
        }

        return channelName;
    }

    render() {
        const {post, channelIsArchived, teamDisplayName, canReply, isPostBeingEditedInRHS, isPostPriorityEnabled} = this.props;
        const channelName = this.getChannelName();

        let overrideUsername;
        let disableProfilePopover = false;
        if (post.props &&
            post.props.from_webhook &&
            post.props.override_username &&
            this.props.enablePostUsernameOverride) {
            overrideUsername = post.props.override_username;
            disableProfilePopover = true;
        }

        const profilePic = (
            <PostProfilePicture
                compactDisplay={this.props.compactDisplay}
                post={post}
                userId={post.user_id}
            />
        );

        const profilePicContainer = (<div className='post__img'>{profilePic}</div>);

        let postClass = '';
        if (PostUtils.isEdited(this.props.post)) {
            postClass += ' post--edited';
        }

        let fileAttachment = null;
        if (post.file_ids && post.file_ids.length > 0) {
            fileAttachment = (
                <FileAttachmentListContainer
                    post={post}
                    compactDisplay={this.props.compactDisplay}
                    handleFileDropdownOpened={this.handleFileDropdownOpened}
                />
            );
        }

        const hasCRTFooter = this.props.isCollapsedThreadsEnabled && !post.root_id && (post.reply_count > 0 || post.is_following);

        let message;
        let flagContent;
        let postInfoIcon;
        let rhsControls;
        if (post.state === Constants.POST_DELETED || post.state === Posts.POST_DELETED) {
            message = (
                <p>
                    <FormattedMessage
                        id='post_body.deleted'
                        defaultMessage='(message deleted)'
                    />
                </p>
            );
        } else {
            if (!this.props.isMobileView) {
                flagContent = (
                    <PostFlagIcon
                        location={Locations.SEARCH}
                        postId={post.id}
                        isFlagged={this.props.isFlagged}
                    />
                );
            }

            if (post.props && post.props.card) {
                postInfoIcon = (
                    <OverlayTrigger
                        delayShow={Constants.OVERLAY_TIME_DELAY}
                        placement='top'
                        overlay={
                            <Tooltip>
                                <FormattedMessage
                                    id='post_info.info.view_additional_info'
                                    defaultMessage='View additional info'
                                />
                            </Tooltip>
                        }
                    >
                        <button
                            className='card-icon__container icon--show style--none'
                            onClick={(e) => {
                                e.preventDefault();
                                this.handleCardClick(this.props.post);
                            }}
                        >
                            <InfoSmallIcon
                                className='icon icon__info'
                                aria-hidden='true'
                            />
                        </button>
                    </OverlayTrigger>
                );
            }

            rhsControls = (
                <div className='col__controls post-menu'>
                    <DotMenu
                        post={post}
                        location={Locations.SEARCH}
                        isFlagged={this.props.isFlagged}
                        handleDropdownOpened={this.handleDropdownOpened}
                        isMenuOpen={this.state.dropdownOpened}
                        isReadOnly={channelIsArchived}
                    />
                    {flagContent}
                    {canReply && !hasCRTFooter &&
                        <CommentIcon
                            location={Locations.SEARCH}
                            handleCommentClick={this.handleFocusRHSClick}
                            commentCount={this.props.replyCount}
                            postId={post.id}
                            searchStyle={'search-item__comment'}
                            extraClass={this.props.replyCount ? 'icon--visible' : ''}
                        />
                    }
                    <a
                        href='#'
                        onClick={this.handleJumpClick}
                        className='search-item__jump'
                    >
                        <FormattedMessage
                            id='search_item.jump'
                            defaultMessage='Jump'
                        />
                    </a>
                </div>
            );

            message = (
                <PostBodyAdditionalContent
                    post={post}
                    options={{
                        searchTerm: this.props.term,
                        searchMatches: this.props.matches,
                    }}
                >
                    <PostMessageContainer
                        post={post}
                        options={{
                            searchTerm: this.props.term,
                            searchMatches: this.props.matches,
                            mentionHighlight: this.props.isMentionSearch,
                        }}
                        isRHS={true}
                    />
                </PostBodyAdditionalContent>
            );
        }

        const currentPostDay = Utils.getDateForUnixTicks(post.create_at);
        const showSlot = isPostBeingEditedInRHS ? AutoHeightSlots.SLOT2 : AutoHeightSlots.SLOT1;

        return (
            <div
                data-testid='search-item-container'
                className='search-item__container'
            >
                <DateSeparator date={currentPostDay}/>
                <PostAriaLabelDiv
                    className={`a11y__section ${this.getClassName()}`}
                    id={'searchResult_' + post.id}
                    post={post}
                    data-a11y-sort-order={this.props.a11yIndex}
                >
                    <div
                        className='search-channel__name__container'
                        aria-hidden='true'
                    >
                        <span className='search-channel__name'>
                            {channelName}
                        </span>
                        {channelIsArchived &&
                            <span className='search-channel__archived'>
                                <ArchiveIcon className='icon icon__archive channel-header-archived-icon svg-text-color'/>
                                <FormattedMessage
                                    id='search_item.channelArchived'
                                    defaultMessage='Archived'
                                />
                            </span>
                        }
                        {Boolean(teamDisplayName) &&
                            <span className='search-team__name'>
                                {teamDisplayName}
                            </span>
                        }
                    </div>
                    <PostPreHeader
                        isFlagged={this.props.isFlagged}
                        isPinned={post.is_pinned}
                        skipPinned={this.props.isPinnedPosts}
                        skipFlagged={this.props.isFlaggedPosts}
                        channelId={post.channel_id}
                    />
                    <div
                        role='application'
                        className='post__content'
                    >
                        {profilePicContainer}
                        <div>
                            <div className='post__header'>
                                <div className='col col__name'>
                                    <UserProfile
                                        userId={post.user_id}
                                        overwriteName={overrideUsername}
                                        disablePopover={disableProfilePopover}
                                        isRHS={true}
                                    />
                                    <BotBadge show={Boolean(post.props && post.props.from_webhook && !this.props.isBot)}/>
                                </div>
                                <div className='col d-flex align-items-center'>
                                    {this.renderPostTime()}
                                    {post.metadata?.priority && isPostPriorityEnabled && (
                                        <span className='d-flex mr-2 ml-1'>
                                            <PriorityLabel priority={post.metadata.priority.priority}/>
                                        </span>
                                    )}
                                    {postInfoIcon}
                                </div>
                                {!isPostBeingEditedInRHS && rhsControls}
                            </div>
                            <div className='search-item-snippet post__body'>
                                <div className={postClass}>
                                    <AutoHeightSwitcher
                                        showSlot={showSlot}
                                        shouldScrollIntoView={isPostBeingEditedInRHS}
                                        slot1={message}
                                        slot2={<EditPost/>}
                                        onTransitionEnd={() => document.dispatchEvent(new Event(AppEvents.FOCUS_EDIT_TEXTBOX))}
                                    />
                                </div>
                                {fileAttachment}
                            </div>
                            {hasCRTFooter ? (
                                <ThreadFooter
                                    threadId={post.id}
                                    replyClick={this.handleFocusRHSClick}
                                />
                            ) : null}
                        </div>
                    </div>
                </PostAriaLabelDiv>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {getChannel, getDirectTeammate} from 'mattermost-redux/selectors/entities/channels';
import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {isPostPriorityEnabled, makeGetCommentCountForPost} from 'mattermost-redux/selectors/entities/posts';

import {
    getMyPreferences,
    isCollapsedThreadsEnabled,
} from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentTeam, getTeam, getTeamMemberships} from 'mattermost-redux/selectors/entities/teams';
import {getUser} from 'mattermost-redux/selectors/entities/users';

import {GenericAction} from 'mattermost-redux/types/actions';

import {isPostFlagged} from 'mattermost-redux/utils/post_utils';

import {
    closeRightHandSide,
    selectPostFromRightHandSideSearch,
    selectPostCardFromRightHandSideSearch,
    setRhsExpanded,
} from 'actions/views/rhs';

import {getRhsState} from 'selectors/rhs';
import {getIsMobileView} from 'selectors/views/browser';

import {GlobalState} from 'types/store';

import {getDisplayNameByUser} from 'utils/utils';

import {General} from 'mattermost-redux/constants';

import {RHSStates} from 'utils/constants';

import {Post} from '@mattermost/types/posts';
import {getIsPostBeingEditedInRHS} from '../../selectors/posts';

import SearchResultsItem from './search_results_item';

export interface OwnProps {
    post: Post;
}

// Exported for testing
export function mapStateToProps() {
    const getReplyCount = makeGetCommentCountForPost();

    return (state: GlobalState, ownProps: OwnProps) => {
        const {post} = ownProps;
        const config = getConfig(state);
        const preferences = getMyPreferences(state);
        const enablePostUsernameOverride = config.EnablePostUsernameOverride === 'true';
        const user = getUser(state, post.user_id);
        const channel = getChannel(state, post.channel_id) || {delete_at: 0};

        const currentTeam = getCurrentTeam(state);
        const teamId = currentTeam?.id ?? '';
        let teamName = currentTeam?.name ?? '';
        let teamDisplayName = '';

        const memberships = getTeamMemberships(state);
        const isDMorGM = channel.type === General.DM_CHANNEL || channel.type === General.GM_CHANNEL;
        const rhsState = getRhsState(state);
        if (
            rhsState !== RHSStates.PIN && // Not show in pinned posts since they are all for the same channel
            !isDMorGM && // Not show for DM or GMs since they don't belong to a team
            memberships && Object.values(memberships).length > 1 // Not show if the user only belongs to one team
        ) {
            const team = getTeam(state, channel.team_id);
            teamDisplayName = team?.display_name;
            teamName = team?.name || currentTeam.name;
        }

        const canReply = isDMorGM || (channel.team_id === teamId);
        const directTeammate = getDirectTeammate(state, channel.id);

        return {
            teamDisplayName,
            teamName,
            channelId: channel.id,
            channelDisplayName: channel.display_name,
            channelType: channel.type,
            channelIsArchived: channel.delete_at !== 0,
            enablePostUsernameOverride,
            isFlagged: isPostFlagged(post.id, preferences),
            isBot: user ? user.is_bot : false,
            isCollapsedThreadsEnabled: isCollapsedThreadsEnabled(state),

            isPostBeingEditedInRHS: getIsPostBeingEditedInRHS(state, post.id),
            displayName: getDisplayNameByUser(state, directTeammate),
            replyCount: getReplyCount(state, post),
            canReply,
            isMobileView: getIsMobileView(state),
            isPostPriorityEnabled: isPostPriorityEnabled(state),
        };
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            closeRightHandSide,
            selectPost: selectPostFromRightHandSideSearch,
            selectPostCard: selectPostCardFromRightHandSideSearch,
            setRhsExpanded,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(SearchResultsItem);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {fileSizeToString, copyToClipboard, localizeMessage} from 'utils/utils';
import {getHistory} from 'utils/browser_history';
import {getSiteURL} from 'utils/url';
import Constants, {ModalIdentifiers} from 'utils/constants';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import Menu from 'components/widgets/menu/menu';
import Badge from 'components/widgets/badges/badge';
import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import FileThumbnail from 'components/file_attachment/file_thumbnail';
import Timestamp, {RelativeRanges} from 'components/timestamp';

import FilePreviewModal from 'components/file_preview_modal';

import type {PropsFromRedux, OwnProps} from './index';

import './file_search_result_item.scss';

type Props = OwnProps & PropsFromRedux;

type State = {
    keepOpen: boolean;
}

const FILE_TOOLTIP_RANGES = [
    RelativeRanges.TODAY_TITLE_CASE,
    RelativeRanges.YESTERDAY_TITLE_CASE,
];

export default class FileSearchResultItem extends React.PureComponent<Props, State> {
    public constructor(props: Props) {
        super(props);
        this.state = {keepOpen: false};
    }

    private jumpToConv = (e: MouseEvent) => {
        e.stopPropagation();
        getHistory().push(`/${this.props.teamName}/pl/${this.props.fileInfo.post_id}`);
    }

    private copyLink = () => {
        copyToClipboard(`${getSiteURL()}/${this.props.teamName}/pl/${this.props.fileInfo.post_id}`);
    }

    private stopPropagation = (e: React.MouseEvent<HTMLElement, MouseEvent>) => {
        e.stopPropagation();
    }

    private keepOpen = (open: boolean) => {
        this.setState({keepOpen: open});
    }

    private renderPluginItems = () => {
        const {fileInfo} = this.props;
        const pluginItems = this.props.pluginMenuItems?.filter((item) => item?.match(fileInfo)).map((item) => {
            return (
                <Menu.ItemAction
                    id={item.id + '_pluginmenuitem'}
                    key={item.id + '_pluginmenuitem'}
                    onClick={() => item.action?.(fileInfo)}
                    text={item.text}
                />
            );
        });

        if (!pluginItems?.length) {
            return null;
        }

        return (
            <>
                <li
                    id={`divider_file_${this.props.fileInfo.id}_plugins`}
                    className='MenuItem__divider'
                    role='menuitem'
                />
                {pluginItems}
            </>
        );
    }

    private showPreview = () => {
        this.props.actions.openModal({
            modalId: ModalIdentifiers.FILE_PREVIEW_MODAL,
            dialogType: FilePreviewModal,
            dialogProps: {
                fileInfos: [this.props.fileInfo],
                postId: this.props.fileInfo.post_id,
                startIndex: 0,
            },
        });
    }

    public render(): React.ReactNode {
        const {fileInfo, channelDisplayName, channelType} = this.props;
        let channelName: React.ReactNode = channelDisplayName;
        if (channelType === Constants.DM_CHANNEL) {
            channelName = (
                <FormattedMessage
                    id='search_item.file_badge.direct_message'
                    defaultMessage='Direct Message'
                />
            );
        } else if (channelType === Constants.GM_CHANNEL) {
            channelName = (
                <FormattedMessage
                    id='search_item.file_badge.group_message'
                    defaultMessage='Group Message'
                />
            );
        }

        return (
            <div
                data-testid='search-item-container'
                className='search-item__container'
            >
                <button
                    className={'FileSearchResultItem' + (this.state.keepOpen ? ' keep-open' : '')}
                    onClick={this.showPreview}
                >
                    <FileThumbnail fileInfo={fileInfo}/>
                    <div className='fileData'>
                        <div className='fileDataName'>{fileInfo.name}</div>
                        <div className='fileMetadata'>
                            {channelName && <Badge className='file-search-channel-name'>{channelName}</Badge>}
                            <span>{fileSizeToString(fileInfo.size)}</span>
                            <span>{'  '}</span>
                            <Timestamp
                                value={fileInfo.create_at}
                                ranges={FILE_TOOLTIP_RANGES}
                            />
                        </div>
                    </div>
                    <OverlayTrigger
                        delayShow={1000}
                        placement='top'
                        overlay={
                            <Tooltip id='file-name__tooltip'>
                                {localizeMessage('file_search_result_item.more_actions', 'More Actions')}
                            </Tooltip>
                        }
                    >
                        <MenuWrapper
                            onToggle={this.keepOpen}
                            stopPropagationOnToggle={true}
                        >
                            <a
                                href='#'
                                className='action-icon dots-icon'
                            >
                                <i className='icon icon-dots-vertical'/>
                            </a>
                            <Menu
                                ariaLabel={'file menu'}
                                openLeft={true}
                            >
                                <Menu.ItemAction
                                    onClick={this.jumpToConv}
                                    ariaLabel={localizeMessage('file_search_result_item.open_in_channel', 'Open in channel')}
                                    text={localizeMessage('file_search_result_item.open_in_channel', 'Open in channel')}
                                />
                                <Menu.ItemAction
                                    onClick={this.copyLink}
                                    ariaLabel={localizeMessage('file_search_result_item.copy_link', 'Copy link')}
                                    text={localizeMessage('file_search_result_item.copy_link', 'Copy link')}
                                />
                                {this.renderPluginItems()}
                            </Menu>
                        </MenuWrapper>
                    </OverlayTrigger>
                    <OverlayTrigger
                        delayShow={1000}
                        placement='top'
                        overlay={
                            <Tooltip id='file-name__tooltip'>
                                {localizeMessage('file_search_result_item.download', 'Download')}
                            </Tooltip>
                        }
                    >
                        <a
                            className='action-icon download-icon'
                            href={`/api/v4/files/${fileInfo.id}?download=1`}
                            onClick={this.stopPropagation}
                        >
                            <i className='icon icon-download-outline'/>
                        </a>
                    </OverlayTrigger>
                </button>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {bindActionCreators, Dispatch} from 'redux';
import {connect, ConnectedProps} from 'react-redux';

import {GenericAction} from 'mattermost-redux/types/actions';
import {getChannel} from 'mattermost-redux/selectors/entities/channels';
import {FileInfo} from '@mattermost/types/files';

import {GlobalState} from 'types/store';
import {FileDropdownPluginComponent} from 'types/store/plugins';

import {openModal} from 'actions/views/modals';

import FileSearchResultItem from './file_search_result_item';

export type OwnProps = {
    channelId: string;
    fileInfo: FileInfo;
    teamName: string;
    pluginMenuItems?: FileDropdownPluginComponent[];
};

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const channel = getChannel(state, ownProps.channelId);

    return {
        channelDisplayName: '',
        channelType: channel.type,
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            openModal,
        }, dispatch),
    };
}

const connector = connect(mapStateToProps, mapDispatchToProps);

export type PropsFromRedux = ConnectedProps<typeof connector>;

export default connector(FileSearchResultItem);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {FilterVariantIcon} from '@mattermost/compass-icons/components';

import Menu from 'components/widgets/menu/menu';
import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import Tooltip from 'components/tooltip';
import OverlayTrigger from 'components/overlay_trigger';

import {SearchFilterType} from '../search/types';
import {IconContainer} from '../advanced_text_editor/formatting_bar/formatting_icon';

import './files_filter_menu.scss';

type Props = {
    selectedFilter: string;
    onFilter: (filter: SearchFilterType) => void;
};

export default function FilesFilterMenu(props: Props): JSX.Element {
    const toolTip = (
        <Tooltip
            id='files-filter-tooltip'
            className='hidden-xs'
        >
            <FormattedMessage
                id='channel_info_rhs.menu.files.filter'
                defaultMessage='Filter'
            />
        </Tooltip>
    );
    return (
        <div className='FilesFilterMenu'>
            <MenuWrapper>
                <OverlayTrigger
                    className='hidden-xs'
                    delayShow={500}
                    placement='top'
                    overlay={toolTip}
                    rootClose={true}
                >
                    <IconContainer
                        id='filesFilterButton'
                        className='action-icon dots-icon'
                        type='button'
                    >
                        {props.selectedFilter !== 'all' && <i className='icon-dot'/>}
                        <FilterVariantIcon
                            size={18}
                            color='currentColor'
                        />
                    </IconContainer>
                </OverlayTrigger>
                <Menu
                    ariaLabel={'file menu'}
                    openLeft={true}
                >
                    <Menu.ItemAction
                        ariaLabel={'All file types'}
                        text={'All file types'}
                        onClick={() => props.onFilter('all')}
                        icon={props.selectedFilter === 'all' ? <i className='icon icon-check'/> : null}
                    />
                    <Menu.ItemAction
                        ariaLabel={'Documents'}
                        text={'Documents'}
                        onClick={() => props.onFilter('documents')}
                        icon={props.selectedFilter === 'documents' ? <i className='icon icon-check'/> : null}
                    />
                    <Menu.ItemAction
                        ariaLabel={'Spreadsheets'}
                        text={'Spreadsheets'}
                        onClick={() => props.onFilter('spreadsheets')}
                        icon={props.selectedFilter === 'spreadsheets' ? <i className='icon icon-check'/> : null}
                    />
                    <Menu.ItemAction
                        ariaLabel={'Presentations'}
                        text={'Presentations'}
                        onClick={() => props.onFilter('presentations')}
                        icon={props.selectedFilter === 'presentations' ? <i className='icon icon-check'/> : null}
                    />
                    <Menu.ItemAction
                        ariaLabel={'Code'}
                        text={'Code'}
                        onClick={() => props.onFilter('code')}
                        icon={props.selectedFilter === 'code' ? <i className='icon icon-check'/> : null}
                    />
                    <Menu.ItemAction
                        ariaLabel={'Images'}
                        text={'Images'}
                        onClick={() => props.onFilter('images')}
                        icon={props.selectedFilter === 'images' ? <i className='icon icon-check'/> : null}
                    />
                    <Menu.ItemAction
                        ariaLabel={'Audio'}
                        text={'Audio'}
                        onClick={() => props.onFilter('audio')}
                        icon={props.selectedFilter === 'audio' ? <i className='icon icon-check'/> : null}
                    />
                    <Menu.ItemAction
                        ariaLabel={'Videos'}
                        text={'Videos'}
                        onClick={() => props.onFilter('video')}
                        icon={props.selectedFilter === 'video' ? <i className='icon icon-check'/> : null}
                    />
                </Menu>
            </MenuWrapper>
        </div>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {SearchFilterType} from '../search/types';
import {SearchType} from 'types/store/rhs';

import * as Utils from 'utils/utils';
import Constants from 'utils/constants';

import FilesFilterMenu from './files_filter_menu';

const {KeyCodes} = Constants;

import './messages_or_files_selector.scss';

type Props = {
    selected: string;
    selectedFilter: SearchFilterType;
    messagesCounter: string;
    filesCounter: string;
    isFileAttachmentsEnabled: boolean;
    onChange: (value: SearchType) => void;
    onFilter: (filter: SearchFilterType) => void;
};

export default function MessagesOrFilesSelector(props: Props): JSX.Element {
    return (
        <div className='MessagesOrFilesSelector'>
            <div className='buttons-container'>
                <button
                    onClick={() => props.onChange('messages')}
                    onKeyDown={(e: React.KeyboardEvent<HTMLSpanElement>) => Utils.isKeyPressed(e, KeyCodes.ENTER) && props.onChange('messages')}
                    className={props.selected === 'messages' ? 'active tab messages-tab' : 'tab messages-tab'}
                >
                    <FormattedMessage
                        id='search_bar.messages_tab'
                        defaultMessage='Messages'
                    />
                    <span className='counter'>{props.messagesCounter}</span>
                </button>
                {props.isFileAttachmentsEnabled &&
                    <button
                        onClick={() => props.onChange('files')}
                        onKeyDown={(e: React.KeyboardEvent<HTMLSpanElement>) => Utils.isKeyPressed(e, KeyCodes.ENTER) && props.onChange('files')}
                        className={props.selected === 'files' ? 'active tab files-tab' : 'tab files-tab'}
                    >
                        <FormattedMessage
                            id='search_bar.files_tab'
                            defaultMessage='Files'
                        />
                        <span className='counter'>{props.filesCounter}</span>
                    </button>
                }
            </div>
            {props.selected === 'files' &&
                <FilesFilterMenu
                    selectedFilter={props.selectedFilter}
                    onFilter={props.onFilter}
                />}
        </div>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import styled from 'styled-components';
import {useIntl} from 'react-intl';
import {useSelector} from 'react-redux';

import useOpenPricingModal from 'components/common/hooks/useOpenPricingModal';
import {getCurrentUser} from 'mattermost-redux/selectors/entities/users';
import {isAdmin} from 'mattermost-redux/utils/user_utils';
import {isCurrentLicenseCloud} from 'mattermost-redux/selectors/entities/cloud';
import {DataSearchTypes} from 'utils/constants';
import useGetUsage from 'components/common/hooks/useGetUsage';
import useGetLimits from 'components/common/hooks/useGetLimits';
import {asGBString} from 'utils/limits';

const StyledDiv = styled.div`
width: 100%;
`;

const StyledA = styled.a`
color: var(--denim-button-bg) !important;
`;

const InnerDiv = styled.div`
display: flex;
gap: 8px;
border: 1px solid rgba(var(--center-channel-text-rgb), 0.08);
border-radius: 4px;
background-color: rgba(var(--center-channel-text-rgb), 0.04);
padding: 10px;
margin: 10px;
color: rgba(var(--center-channel-text-rgb), 0.72);
font-weight: 400;
font-size: 11px;
line-height: 16px;
letter-spacing: 0.02em;
`;

type Props = {
    searchType: string;
}

function SearchLimitsBanner(props: Props) {
    const {formatMessage, formatNumber} = useIntl();
    const openPricingModal = useOpenPricingModal();
    const usage = useGetUsage();
    const [cloudLimits] = useGetLimits();
    const isAdminUser = isAdmin(useSelector(getCurrentUser).roles);
    const isCloud = useSelector(isCurrentLicenseCloud);

    if (!isCloud) {
        return null;
    }

    const currentFileStorageUsage = usage.files.totalStorage;
    const fileStorageLimit = cloudLimits?.files?.total_storage;
    const currentMessagesUsage = usage.messages.history;
    const messagesLimit = cloudLimits?.messages?.history;

    let ctaAction = formatMessage({
        id: 'workspace_limits.search_limit.view_plans',
        defaultMessage: 'View plans',
    });

    if (isAdminUser) {
        ctaAction = formatMessage({
            id: 'workspace_limits.search_limit.upgrade_now',
            defaultMessage: 'Upgrade now',
        });
    }

    const renderBanner = (bannerText: React.ReactNode, id: string) => {
        return (<StyledDiv id={id}>
            <InnerDiv>
                <i className='icon-eye-off-outline'/>
                <span>{bannerText}</span>
            </InnerDiv>
        </StyledDiv>);
    };

    switch (props.searchType) {
    case DataSearchTypes.FILES_SEARCH_TYPE:
        if ((fileStorageLimit === undefined) || !(currentFileStorageUsage > fileStorageLimit)) {
            return null;
        }
        return renderBanner(formatMessage({
            id: 'workspace_limits.search_files_limit.banner_text',
            defaultMessage: 'Some older files may not be shown because your workspace has met its file storage limit of {storage}. <a>{ctaAction}</a>',
        }, {
            ctaAction,
            storage: asGBString(fileStorageLimit, formatNumber),
            a: (chunks: React.ReactNode | React.ReactNodeArray) => (
                <StyledA
                    onClick={() => openPricingModal({trackingLocation: 'file_search_limits_banner'})}
                >
                    {chunks}
                </StyledA>
            ),
        }), `${DataSearchTypes.FILES_SEARCH_TYPE}_search_limits_banner`);

    case DataSearchTypes.MESSAGES_SEARCH_TYPE:
        if ((messagesLimit === undefined) || !(currentMessagesUsage > messagesLimit)) {
            return null;
        }
        return renderBanner(formatMessage({
            id: 'workspace_limits.search_message_limit.banner_text',
            defaultMessage: 'Some older messages may not be shown because your workspace has over {messages} messages. <a>{ctaAction}</a>',
        }, {
            ctaAction,
            messages: formatNumber(messagesLimit),
            a: (chunks: React.ReactNode | React.ReactNodeArray) => (
                <StyledA
                    onClick={() => openPricingModal({trackingLocation: 'messages_search_limits_banner'})}
                >
                    {chunks}
                </StyledA>
            ),
        }), `${DataSearchTypes.MESSAGES_SEARCH_TYPE}_search_limits_banner`);
    default:
        return null;
    }
}

export default SearchLimitsBanner;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useRef, useState} from 'react';
import {MessageDescriptor, useIntl, FormattedMessage} from 'react-intl';
import {useSelector} from 'react-redux';
import Scrollbars from 'react-custom-scrollbars';
import classNames from 'classnames';

import {debounce} from 'mattermost-redux/actions/helpers';
import {getConfig} from 'mattermost-redux/selectors/entities/general';

import {getFilesDropdownPluginMenuItems} from 'selectors/plugins';

import SearchResultsHeader from 'components/search_results_header';
import SearchResultsItem from 'components/search_results_item';
import SearchHint from 'components/search_hint/search_hint';
import LoadingSpinner from 'components/widgets/loading/loading_wrapper';
import NoResultsIndicator from 'components/no_results_indicator/no_results_indicator';
import FlagIcon from 'components/widgets/icons/flag_icon';
import FileSearchResultItem from 'components/file_search_results';
import {NoResultsVariant} from 'components/no_results_indicator/types';

import * as Utils from 'utils/utils';
import {searchHintOptions, DataSearchTypes} from 'utils/constants';
import {isFileAttachmentsEnabled} from 'utils/file_utils';
import {t} from 'utils/i18n';

import {Post} from '@mattermost/types/posts';
import {FileSearchResultItem as FileSearchResultItemType} from '@mattermost/types/files';

import MessageOrFileSelector from './messages_or_files_selector';
import FilesFilterMenu from './files_filter_menu';
import SearchLimitsBanner from './search_limits_banner';

import type {Props} from './types';

import './search_results.scss';

const GET_MORE_BUFFER = 30;

const renderView = (props: Record<string, unknown>): JSX.Element => (
    <div
        {...props}
        className='scrollbar--view'
    />
);

const renderThumbHorizontal = (props: Record<string, unknown>): JSX.Element => (
    <div
        {...props}
        className='scrollbar--horizontal scrollbar--thumb--RHS'
    />
);

const renderThumbVertical = (props: Record<string, unknown>): JSX.Element => (
    <div
        {...props}
        className='scrollbar--vertical scrollbar--thumb--RHS'
    />
);

const renderTrackVertical = (props: Record<string, unknown>): JSX.Element => (
    <div
        {...props}
        className='scrollbar--vertical--RHS'
    />
);

interface NoResultsProps {
    variant: NoResultsVariant;
    titleValues?: Record<string, React.ReactNode>;
    subtitleValues?: Record<string, React.ReactNode>;
}

const defaultProps: Partial<Props> = {
    isCard: false,
    isOpened: false,
    channelDisplayName: '',
    children: null,
};

const SearchResults: React.FC<Props> = (props: Props): JSX.Element => {
    const scrollbars = useRef<Scrollbars|null>(null);
    const [searchType, setSearchType] = useState<string>(props.searchType);
    const filesDropdownPluginMenuItems = useSelector(getFilesDropdownPluginMenuItems);
    const config = useSelector(getConfig);
    const intl = useIntl();

    useEffect(() => {
        if (props.searchFilterType !== 'all') {
            props.setSearchFilterType('all');
        }
        setSearchType(props.searchType);
        scrollbars.current?.scrollToTop();
    }, [props.searchTerms]);

    useEffect(() => {
        // reset search type when switching views
        setSearchType(props.searchType);
    }, [props.isFlaggedPosts, props.isPinnedPosts, props.isMentionSearch]);

    useEffect(() => {
        // after the first page of search results, there is no way to
        // know if the search has more results to return, so we search
        // for the second page and stop if it yields no results
        if (props.searchPage === 0 && !props.isChannelFiles && !props.isSearchingTerm) {
            setTimeout(() => {
                props.getMorePostsForSearch();
                props.getMoreFilesForSearch();
            }, 100);
        }
    }, [props.searchPage, props.searchTerms, props.isSearchingTerm]);

    const handleScroll = (): void => {
        if (!props.isFlaggedPosts && !props.isPinnedPosts && !props.isSearchingTerm && !props.isSearchGettingMore && !props.isChannelFiles) {
            const scrollHeight = scrollbars.current?.getScrollHeight() || 0;
            const scrollTop = scrollbars.current?.getScrollTop() || 0;
            const clientHeight = scrollbars.current?.getClientHeight() || 0;
            if ((scrollTop + clientHeight + GET_MORE_BUFFER) >= scrollHeight) {
                if (searchType === DataSearchTypes.FILES_SEARCH_TYPE) {
                    loadMoreFiles();
                } else {
                    loadMorePosts();
                }
            }
        }
    };

    const loadMorePosts = debounce(
        () => {
            props.getMorePostsForSearch();
        },
        100,
        false,
        (): void => {},
    );

    const loadMoreFiles = debounce(
        () => {
            props.getMoreFilesForSearch();
        },
        100,
        false,
        (): void => {},
    );

    const {
        results,
        fileResults,
        searchTerms,
        isCard,
        isSearchAtEnd,
        isSearchFilesAtEnd,
        isSearchingTerm,
        isFlaggedPosts,
        isSearchingFlaggedPost,
        isPinnedPosts,
        isChannelFiles,
        isSearchingPinnedPost,
        isSideBarExpanded,
        isMentionSearch,
        isOpened,
        updateSearchTerms,
        handleSearchHintSelection,
        searchFilterType,
        setSearchFilterType,
    } = props;

    const noResults = (!results || !Array.isArray(results) || results.length === 0);
    const noFileResults = (!fileResults || !Array.isArray(fileResults) || fileResults.length === 0);
    const isLoading = isSearchingTerm || isSearchingFlaggedPost || isSearchingPinnedPost || !isOpened;
    const isAtEnd = (searchType === DataSearchTypes.MESSAGES_SEARCH_TYPE && isSearchAtEnd) || (searchType === DataSearchTypes.FILES_SEARCH_TYPE && isSearchFilesAtEnd);
    const showLoadMore = !isAtEnd && !isChannelFiles && !isFlaggedPosts && !isPinnedPosts;
    const isMessagesSearch = (!isFlaggedPosts && !isMentionSearch && !isCard && !isPinnedPosts && !isChannelFiles);

    let contentItems;
    let loadingMorePostsComponent;

    let sortedResults: any = results;

    const titleDescriptor: MessageDescriptor = {};
    const noResultsProps: NoResultsProps = {
        variant: NoResultsVariant.ChannelSearch,
    };

    if (isMentionSearch) {
        noResultsProps.variant = NoResultsVariant.Mentions;

        titleDescriptor.id = t('search_header.title2');
        titleDescriptor.defaultMessage = 'Recent Mentions';
    } else if (isFlaggedPosts) {
        noResultsProps.variant = NoResultsVariant.FlaggedPosts;
        noResultsProps.subtitleValues = {icon: <FlagIcon className='icon  no-results__mini_icon'/>};

        titleDescriptor.id = t('search_header.title3');
        titleDescriptor.defaultMessage = 'Saved Posts';
    } else if (isPinnedPosts) {
        noResultsProps.variant = NoResultsVariant.PinnedPosts;
        noResultsProps.subtitleValues = {text: <strong>{'Pin to Channel'}</strong>};

        sortedResults = [...results];
        sortedResults.sort((postA: Post|FileSearchResultItemType, postB: Post|FileSearchResultItemType) => postB.create_at - postA.create_at);

        titleDescriptor.id = t('search_header.pinnedPosts');
        titleDescriptor.defaultMessage = 'Pinned Posts';
    } else if (isChannelFiles) {
        if (searchFilterType === 'all') {
            noResultsProps.variant = NoResultsVariant.ChannelFiles;
        } else {
            noResultsProps.variant = NoResultsVariant.ChannelFilesFiltered;
        }

        titleDescriptor.id = t('search_header.channelFiles');
        titleDescriptor.defaultMessage = 'Files';
    } else if (isCard) {
        titleDescriptor.id = t('search_header.title5');
        titleDescriptor.defaultMessage = 'Extra information';
    } else if (!searchTerms && noResults && noFileResults) {
        titleDescriptor.id = t('search_header.search');
        titleDescriptor.defaultMessage = 'Search';
    } else {
        noResultsProps.titleValues = {channelName: `"${searchTerms}"`};

        titleDescriptor.id = t('search_header.results');
        titleDescriptor.defaultMessage = 'Search Results';
    }

    const formattedTitle = intl.formatMessage(titleDescriptor);

    const handleOptionSelection = (term: string): void => {
        handleSearchHintSelection();
        updateSearchTerms(term);
    };

    switch (true) {
    case isLoading:
        contentItems = (
            <div className='sidebar--right__subheader a11y__section'>
                <div className='sidebar--right__loading'>
                    <LoadingSpinner text={Utils.localizeMessage('search_header.loading', 'Searching')}/>
                </div>
            </div>
        );
        break;
    case (noResults && !searchTerms && !isMentionSearch && !isPinnedPosts && !isFlaggedPosts && !isChannelFiles):
        contentItems = (
            <div className='sidebar--right__subheader search__hints a11y__section'>
                <SearchHint
                    onOptionSelected={handleOptionSelection}
                    options={searchHintOptions}
                />
            </div>
        );
        break;
    case noResults && (searchType === DataSearchTypes.MESSAGES_SEARCH_TYPE && !isChannelFiles):
        contentItems = (
            <div
                className={classNames([
                    'sidebar--right__subheader a11y__section',
                    {'sidebar-expanded': isSideBarExpanded},
                ])}
            >
                <NoResultsIndicator {...noResultsProps}/>
            </div>
        );
        break;
    case noFileResults && (searchType === DataSearchTypes.FILES_SEARCH_TYPE || isChannelFiles):
        contentItems = (
            <div
                className={classNames([
                    'sidebar--right__subheader a11y__section',
                    {'sidebar-expanded': isSideBarExpanded},
                ])}
            >
                <NoResultsIndicator {...noResultsProps}/>
            </div>
        );
        break;
    default:
        if (searchType === DataSearchTypes.FILES_SEARCH_TYPE || isChannelFiles) {
            sortedResults = fileResults;
        }

        contentItems = sortedResults.map((item: Post|FileSearchResultItemType, index: number) => {
            if (searchType === DataSearchTypes.MESSAGES_SEARCH_TYPE && !props.isChannelFiles) {
                return (
                    <SearchResultsItem
                        key={item.id}
                        compactDisplay={props.compactDisplay}
                        post={item as Post}
                        matches={props.matches[item.id]}
                        term={(!props.isFlaggedPosts && !props.isPinnedPosts && !props.isMentionSearch) ? searchTerms : ''}
                        isMentionSearch={props.isMentionSearch}
                        a11yIndex={index}
                        isFlaggedPosts={props.isFlaggedPosts}
                        isPinnedPosts={props.isPinnedPosts}
                    />
                );
            }
            return (
                <FileSearchResultItem
                    key={item.id}
                    channelId={item.channel_id}
                    fileInfo={item as FileSearchResultItemType}
                    teamName={props.currentTeamName}
                    pluginMenuItems={filesDropdownPluginMenuItems}
                />
            );
        });

        loadingMorePostsComponent = (showLoadMore) ? (
            <div className='loading-screen'>
                <div className='loading__content'>
                    <div className='round round-1'/>
                    <div className='round round-2'/>
                    <div className='round round-3'/>
                </div>
            </div>
        ) : null;
    }

    return (
        <div
            id='searchContainer'
            className='SearchResults sidebar-right__body'
        >
            <SearchResultsHeader>
                {formattedTitle}
                {props.channelDisplayName && <div className='sidebar--right__title__channel'>{props.channelDisplayName}</div>}
            </SearchResultsHeader>
            {isMessagesSearch &&
                <MessageOrFileSelector
                    selected={searchType}
                    selectedFilter={searchFilterType}
                    isFileAttachmentsEnabled={isFileAttachmentsEnabled(config)}
                    messagesCounter={isSearchAtEnd || props.searchPage === 0 ? `${results.length}` : `${results.length}+`}
                    filesCounter={isSearchFilesAtEnd || props.searchPage === 0 ? `${fileResults.length}` : `${fileResults.length}+`}
                    onChange={setSearchType}
                    onFilter={setSearchFilterType}
                />}
            {isChannelFiles &&
                <div className='channel-files__header'>
                    <div className='channel-files__title'>
                        <FormattedMessage
                            id='search_results.channel-files-header'
                            defaultMessage='Recent files'
                        />
                    </div>
                    <FilesFilterMenu
                        selectedFilter={searchFilterType}
                        onFilter={setSearchFilterType}
                    />
                </div>
            }
            <SearchLimitsBanner searchType={searchType}/>
            <Scrollbars
                ref={scrollbars}
                autoHide={true}
                autoHideTimeout={500}
                autoHideDuration={500}
                renderTrackVertical={renderTrackVertical}
                renderThumbHorizontal={renderThumbHorizontal}
                renderThumbVertical={renderThumbVertical}
                renderView={renderView}
                onScroll={handleScroll}
            >
                <div
                    id='search-items-container'
                    role='application'
                    className={classNames([
                        'search-items-container post-list__table a11y__region',
                        {
                            'no-results': (noResults && searchType === DataSearchTypes.MESSAGES_SEARCH_TYPE) || (noFileResults && (searchType === DataSearchTypes.FILES_SEARCH_TYPE || isChannelFiles)),
                            'channel-files-container': isChannelFiles,
                        },
                    ])}
                    data-a11y-sort-order='3'
                    data-a11y-focus-child={true}
                    data-a11y-loop-navigation={false}
                    aria-label={intl.formatMessage({
                        id: 'accessibility.sections.rhs',
                        defaultMessage: '{regionTitle} complimentary region',
                    }, {
                        regionTitle: formattedTitle,
                    })}
                >
                    {contentItems}
                    {loadingMorePostsComponent}
                </div>
            </Scrollbars>
        </div>
    );
};

SearchResults.defaultProps = defaultProps;

export const arePropsEqual = (props: Props, nextProps: Props): boolean => {
    // Shallow compare for all props except 'results' and 'fileResults'
    for (const key in nextProps) {
        if (!Object.prototype.hasOwnProperty.call(nextProps, key) || key === 'results') {
            continue;
        }

        if (!Object.prototype.hasOwnProperty.call(nextProps, key) || key === 'fileResults') {
            continue;
        }

        if (nextProps[key] !== props[key]) {
            return false;
        }
    }

    // Here we do a slightly deeper compare on 'results' because it is frequently a new
    // array but without any actual changes
    const {results} = props;
    const {results: nextResults} = nextProps;

    if (results.length !== nextResults.length) {
        return false;
    }

    for (let i = 0; i < results.length; i++) {
        // Only need a shallow compare on each post
        if (results[i] !== nextResults[i]) {
            return false;
        }
    }

    // Here we do a slightly deeper compare on 'fileResults' because it is frequently a new
    // array but without any actual changes
    const {fileResults} = props;
    const {fileResults: nextFileResults} = nextProps;

    if (fileResults.length !== nextFileResults.length) {
        return false;
    }

    for (let i = 0; i < fileResults.length; i++) {
        // Only need a shallow compare on each file
        if (fileResults[i] !== nextFileResults[i]) {
            return false;
        }
    }

    return true;
};

export default React.memo(SearchResults, arePropsEqual);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getChannel} from 'mattermost-redux/selectors/entities/channels';
import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getSearchMatches, getSearchResults} from 'mattermost-redux/selectors/entities/posts';
import {getSearchFilesResults} from 'mattermost-redux/selectors/entities/files';
import * as PreferenceSelectors from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentSearchForCurrentTeam} from 'mattermost-redux/selectors/entities/search';

import {getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';

import {
    getSearchResultsTerms,
    getIsSearchingTerm,
    getIsSearchingFlaggedPost,
    getIsSearchingPinnedPost,
    getIsSearchGettingMore,
} from 'selectors/rhs';
import {GlobalState} from 'types/store';
import {Preferences} from 'utils/constants';

import {FileSearchResultItem} from '@mattermost/types/files';
import {Post} from '@mattermost/types/posts';

import SearchResults from './search_results';
import {StateProps, OwnProps} from './types';

function makeMapStateToProps() {
    let results: Post[];
    let fileResults: FileSearchResultItem[];
    let files: FileSearchResultItem[] = [];
    let posts: Post[];

    return function mapStateToProps(state: GlobalState) {
        const config = getConfig(state);

        const viewArchivedChannels = config.ExperimentalViewArchivedChannels === 'true';

        const newResults = getSearchResults(state);

        // Cache posts and channels
        if (newResults && newResults !== results) {
            results = newResults;

            posts = [];
            results.forEach((post) => {
                if (!post) {
                    return;
                }

                posts.push(post);
            });
        }

        const newFilesResults = getSearchFilesResults(state);

        // Cache files and channels
        if (newFilesResults && newFilesResults !== fileResults) {
            fileResults = newFilesResults;

            files = [];
            fileResults.forEach((file) => {
                if (!file) {
                    return;
                }

                const channel = getChannel(state, file.channel_id);
                if (channel && channel.delete_at !== 0 && !viewArchivedChannels) {
                    return;
                }

                files.push(file);
            });
        }

        // this is basically a hack to make ts compiler happy
        // add correct type when it is known what exactly is returned from the function
        const currentSearch = getCurrentSearchForCurrentTeam(state) as unknown as Record<string, any> || {};
        const currentTeamName = getCurrentTeam(state)?.name ?? '';

        return {
            results: posts,
            fileResults: files,
            matches: getSearchMatches(state),
            searchTerms: getSearchResultsTerms(state),
            isSearchingTerm: getIsSearchingTerm(state),
            isSearchingFlaggedPost: getIsSearchingFlaggedPost(state),
            isSearchingPinnedPost: getIsSearchingPinnedPost(state),
            isSearchGettingMore: getIsSearchGettingMore(state),
            isSearchAtEnd: currentSearch.isEnd,
            isSearchFilesAtEnd: currentSearch.isFilesEnd,
            searchPage: currentSearch.params?.page,
            compactDisplay: PreferenceSelectors.get(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.MESSAGE_DISPLAY, Preferences.MESSAGE_DISPLAY_DEFAULT) === Preferences.MESSAGE_DISPLAY_COMPACT,
            currentTeamName,
        };
    };
}

// eslint-disable-next-line @typescript-eslint/ban-types
export default connect<StateProps, {}, OwnProps, GlobalState>(makeMapStateToProps)(SearchResults);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import DayPicker from 'react-day-picker';

import MomentLocaleUtils from 'react-day-picker/moment';

import Suggestion from '../suggestion.jsx';

import 'react-day-picker/lib/style.css';

import 'moment';

const loadedLocales: Record<string, moment.Locale> = {};

type Props = {
    locale: string;
}

export default class SearchDateSuggestion extends Suggestion {
    handleDayClick = (day: Date) => {
        const dayString = day.toISOString().split('T')[0];
        this.props.onClick(dayString, this.props.matchedPretext);
    }

    componentDidMount() {
        //the naming scheme of momentjs packages are all lowercases
        const locale = this.props.locale.toLowerCase();

        // Momentjs use en as defualt, no need to import en
        if (locale && locale !== 'en' && !loadedLocales[locale]) {
            /* eslint-disable global-require */
            loadedLocales[locale] = require(`moment/locale/${locale}`);
            /* eslint-disable global-require */
        }
    }

    componentDidUpdate(prevProps: Props) {
        const locale = this.props.locale.toLowerCase();

        if (locale && locale !== 'en' && locale !== prevProps.locale && !loadedLocales[locale]) {
            /* eslint-disable global-require */
            loadedLocales[locale] = require(`moment/locale/${locale}`);
            /* eslint-disable global-require */
        }
    }

    render() {
        let modifiers;
        if (this.props.currentDate) {
            modifiers = {
                today: this.props.currentDate,
            };
        }

        const locale = this.props.locale.toLowerCase();

        return (
            <DayPicker
                onDayClick={this.handleDayClick}
                showOutsideDays={true}
                modifiers={modifiers}
                localeUtils={MomentLocaleUtils}
                locale={locale}
            />
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {makeGetUserTimezone} from 'mattermost-redux/selectors/entities/timezone';

import {getCurrentDateForTimezone} from 'utils/timezone';
import {areTimezonesEnabledAndSupported} from 'selectors/general';
import {getCurrentLocale} from 'selectors/i18n';

import {GlobalState} from 'types/store';

import SearchDateSuggestion from './search_date_suggestion';

function makeMapStateToProps() {
    const getUserTimezone = makeGetUserTimezone();

    return (state: GlobalState) => {
        const currentUserId = getCurrentUserId(state);
        const userTimezone = getUserTimezone(state, currentUserId);
        const locale = getCurrentLocale(state);

        const enableTimezone = areTimezonesEnabledAndSupported(state);

        let currentDate;
        if (enableTimezone) {
            if (userTimezone.useAutomaticTimezone) {
                currentDate = getCurrentDateForTimezone(userTimezone.automaticTimezone);
            } else {
                currentDate = getCurrentDateForTimezone(userTimezone.manualTimezone);
            }
        }

        return {
            currentDate,
            locale,
        };
    };
}

export default connect(makeMapStateToProps)(SearchDateSuggestion);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import Provider from './provider';
import SearchDateSuggestion from './search_date_suggestion';

type DateItem = {label: string; date: string};

type ResultsCallback = (results: {matchedPretext: string; terms: string[]; items: DateItem[]; component: typeof SearchDateSuggestion}) => void;

export default class SearchDateProvider extends Provider {
    handlePretextChanged(pretext: string, resultsCallback: ResultsCallback) {
        const captured = (/\b(?:on|before|after):\s*(\S*)$/i).exec(pretext.toLowerCase());
        if (captured) {
            const datePrefix = captured[1];

            this.startNewRequest(datePrefix);

            const dates: DateItem[] = Object.assign([], [{label: 'Selected Date', date: datePrefix}]);
            const terms = dates.map((date) => date.date);

            resultsCallback({
                matchedPretext: datePrefix,
                terms,
                items: dates,
                component: SearchDateSuggestion,
            });
        }

        return Boolean(captured);
    }

    allowDividers() {
        return false;
    }

    presentationType() {
        return 'date';
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {getUserIdFromChannelName} from 'mattermost-redux/utils/channel_utils';
import {imageURLForUser} from 'utils/utils';
import Constants from 'utils/constants';
import Avatar from 'components/widgets/users/avatar';
import BotBadge from 'components/widgets/badges/bot_badge';
import Suggestion from '../suggestion';

import {Channel} from '@mattermost/types/channels';

function itemToName(item: Channel, currentUser: string): {icon: React.ReactElement; name: string; description: string} | null {
    if (item.type === Constants.DM_CHANNEL) {
        const profilePicture = (
            <Avatar
                url={imageURLForUser(getUserIdFromChannelName(currentUser, item.name))}
                size='sm'
            />
        );

        return {
            icon: profilePicture,
            name: '@' + item.display_name,
            description: '',
        };
    }

    if (item.type === Constants.GM_CHANNEL) {
        return {
            icon: (
                <span className='suggestion-list__icon suggestion-list__icon--large'>
                    <div className='status status--group'>{'G'}</div>
                </span>
            ),
            name: '@' + item.display_name.replace(/ /g, ''),
            description: '',
        };
    }

    if (item.type === Constants.OPEN_CHANNEL) {
        return {
            icon: (
                <span className='suggestion-list__icon suggestion-list__icon--large'>
                    <i className='icon icon--standard icon--no-spacing icon-globe'/>
                </span>
            ),
            name: item.display_name,
            description: '~' + item.name,
        };
    }

    if (item.type === Constants.PRIVATE_CHANNEL) {
        return {
            icon: (
                <span className='suggestion-list__icon suggestion-list__icon--large'>
                    <i className='icon icon--standard icon--no-spacing icon-lock-outline'/>
                </span>
            ),
            name: item.display_name,
            description: '~' + item.name,
        };
    }

    return null;
}

export default class SearchChannelSuggestion extends Suggestion {
    render(): JSX.Element {
        const {item, isSelection, teammate, currentUser} = this.props;

        let className = 'suggestion-list__item';
        if (isSelection) {
            className += ' suggestion--selected';
        }

        const nameObject = itemToName(item, currentUser);
        if (!nameObject) {
            return (<></>);
        }

        const {icon, name, description} = nameObject;

        let tag = null;
        if (item.type === Constants.DM_CHANNEL) {
            tag = (
                <BotBadge
                    show={Boolean(teammate && teammate.is_bot)}
                    className='badge-popoverlist'
                />
            );
        }

        return (
            <div
                onClick={this.handleClick}
                onMouseMove={this.handleMouseMove}
                className={className}
                {...Suggestion.baseProps}
            >
                {icon}
                <div className={'suggestion-list__ellipsis'}>
                    <span className='suggestion-list__main'>
                        {name}
                    </span>
                    <span className='ml-2'>
                        {description}
                    </span>
                </div>
                {tag}
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getDirectTeammate} from 'mattermost-redux/selectors/entities/channels';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {Channel} from '@mattermost/types/channels';

import {GlobalState} from 'types/store';

import SearchChannelSuggestion from './search_channel_suggestion';

type OwnProps = {
    item: Channel;
}

const mapStateToProps = (state: GlobalState, ownProps: OwnProps) => {
    return {
        teammate: getDirectTeammate(state, ownProps.item.id),
        currentUser: getCurrentUserId(state),
    };
};

export default connect(mapStateToProps, null, null, {forwardRef: true})(SearchChannelSuggestion);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ServerError} from '@mattermost/types/errors.js';
import {ActionFunc} from 'mattermost-redux/types/actions.js';

import {isDirectChannel, isGroupChannel, sortChannelsByTypeListAndDisplayName} from 'mattermost-redux/utils/channel_utils';

import store from 'stores/redux_store.jsx';

import Constants from 'utils/constants';
import {getCurrentLocale} from 'selectors/i18n';

import Provider from './provider';
import SearchChannelSuggestion from './search_channel_suggestion';

import {Channel} from './command_provider/app_command_parser/app_command_parser_dependencies.js';

const getState = store.getState;

export type Results = {
    matchedPretext: string;
    terms: string[];
    items: Channel[];
    component: React.ElementType;
}

type ResultsCallback = (results: Results) => void;

function itemToTerm(isAtSearch: boolean, item: { type: string; display_name: string; name: string }) {
    const prefix = isAtSearch ? '' : '@';
    if (item.type === Constants.DM_CHANNEL) {
        return prefix + item.display_name;
    }
    if (item.type === Constants.GM_CHANNEL) {
        return prefix + item.display_name.replace(/ /g, '');
    }
    if (item.type === Constants.OPEN_CHANNEL || item.type === Constants.PRIVATE_CHANNEL) {
        return item.name;
    }
    return item.name;
}

export default class SearchChannelProvider extends Provider {
    autocompleteChannelsForSearch: any;
    constructor(channelSearchFunc: (term: string, success: (channels: Channel[]) => void, error: (err: ServerError) => void) => ActionFunc) {
        super();
        this.autocompleteChannelsForSearch = channelSearchFunc;
    }

    handlePretextChanged(pretext: string, resultsCallback: ResultsCallback) {
        const captured = (/\b(?:in|channel):\s*(\S*)$/i).exec(pretext.toLowerCase());
        if (captured) {
            let channelPrefix = captured[1];
            const isAtSearch = channelPrefix.startsWith('@');
            if (isAtSearch) {
                channelPrefix = channelPrefix.replace(/^@/, '');
            }

            this.startNewRequest(channelPrefix);

            this.autocompleteChannelsForSearch(
                channelPrefix,
                (data: Channel[]) => {
                    if (this.shouldCancelDispatch(channelPrefix)) {
                        return;
                    }

                    let channels = data;
                    if (isAtSearch) {
                        channels = channels.filter((ch: Channel) => isDirectChannel(ch) || isGroupChannel(ch));
                    }

                    const locale = getCurrentLocale(getState());

                    channels = channels.sort(sortChannelsByTypeListAndDisplayName.bind(null, locale, [Constants.OPEN_CHANNEL, Constants.PRIVATE_CHANNEL, Constants.DM_CHANNEL, Constants.GM_CHANNEL]));
                    const channelNames = channels.map(itemToTerm.bind(null, isAtSearch));

                    resultsCallback({
                        matchedPretext: channelPrefix,
                        terms: channelNames,
                        items: channels,
                        component: SearchChannelSuggestion,
                    });
                },
            );
        }

        return Boolean(captured);
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import * as Utils from 'utils/utils';
import BotBadge from 'components/widgets/badges/bot_badge';
import Avatar from 'components/widgets/users/avatar';
import SharedUserIndicator from 'components/shared_user_indicator';

import {UserProfile} from '@mattermost/types/users';
import {UserAutocomplete} from '@mattermost/types/autocomplete';

import Provider from './provider';
import Suggestion from './suggestion.jsx';
import {ProviderResults} from './generic_user_provider';

class SearchUserSuggestion extends Suggestion {
    private node?: HTMLDivElement | null;
    render() {
        const {item, isSelection} = this.props;

        let className = 'suggestion-list__item';
        if (isSelection) {
            className += ' suggestion--selected';
        }

        const username = item.username;
        let description = '';

        if ((item.first_name || item.last_name) && item.nickname) {
            description = `${Utils.getFullName(item)} (${item.nickname})`;
        } else if (item.nickname) {
            description = `(${item.nickname})`;
        } else if (item.first_name || item.last_name) {
            description = `${Utils.getFullName(item)}`;
        }

        let sharedIcon;
        if (item.remote_id) {
            sharedIcon = (
                <SharedUserIndicator
                    className='mention__shared-user-icon'
                    withTooltip={true}
                />
            );
        }

        return (
            <div
                className={className}
                ref={(node) => {
                    this.node = node;
                }}
                onClick={this.handleClick}
                onMouseMove={this.handleMouseMove}
                {...Suggestion.baseProps}
            >
                <Avatar
                    size='sm'
                    username={username}
                    url={Utils.imageURLForUser(item.id, item.last_picture_update)}
                />
                <div className='suggestion-list__ellipsis'>
                    <span className='suggestion-list__main'>
                        {'@'}{username}
                    </span>
                    <BotBadge
                        show={Boolean(item.is_bot)}
                        className='badge-autocomplete'
                    />
                    <span className='ml-2'>
                        {description}
                    </span>
                </div>
                {sharedIcon}
            </div>
        );
    }
}

export default class SearchUserProvider extends Provider {
    private autocompleteUsersInTeam: (username: string) => Promise<UserAutocomplete>;
    constructor(userSearchFunc: (username: string) => Promise<UserAutocomplete>) {
        super();
        this.autocompleteUsersInTeam = userSearchFunc;
    }

    handlePretextChanged(pretext: string, resultsCallback: (res: ProviderResults) => void) {
        const captured = (/\bfrom:\s*(\S*)$/i).exec(pretext.toLowerCase());

        this.doAutocomplete(captured, resultsCallback);

        return Boolean(captured);
    }

    async doAutocomplete(captured: RegExpExecArray | null, resultsCallback: (res: ProviderResults) => void) {
        if (!captured) {
            return;
        }

        const usernamePrefix = captured[1];

        this.startNewRequest(usernamePrefix);

        const data = await this.autocompleteUsersInTeam(usernamePrefix);

        if (this.shouldCancelDispatch(usernamePrefix)) {
            return;
        }

        const users = Object.assign([], data.users);
        const mentions = users.map((user: UserProfile) => user.username);

        resultsCallback({
            matchedPretext: usernamePrefix,
            terms: mentions,
            items: users,
            component: SearchUserSuggestion,
        });
    }

    allowDividers() {
        return true;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ChangeEvent, MouseEvent, FormEvent, useEffect, useState, useRef} from 'react';
import {useIntl} from 'react-intl';
import classNames from 'classnames';

import {useSelector} from 'react-redux';

import {getCurrentChannelNameForSearchShortcut} from 'mattermost-redux/selectors/entities/channels';
import {isServerVersionGreaterThanOrEqualTo} from 'utils/server_version';
import {isDesktopApp, getDesktopVersion, isMacApp} from 'utils/user_agent';
import Constants, {searchHintOptions, RHSStates, searchFilesHintOptions} from 'utils/constants';
import * as Utils from 'utils/utils';

import HeaderIconWrapper from 'components/channel_header/components/header_icon_wrapper';
import SearchHint from 'components/search_hint/search_hint';
import FlagIcon from 'components/widgets/icons/flag_icon';
import MentionsIcon from 'components/widgets/icons/mentions_icon';
import SearchIcon from 'components/widgets/icons/search_icon';
import Popover from 'components/widgets/popover';

import UserGuideDropdown from 'components/search/user_guide_dropdown';
import SearchBar from 'components/search_bar/search_bar';
import SearchResults from 'components/search_results';
import Provider from 'components/suggestion/provider';
import SearchDateProvider from 'components/suggestion/search_date_provider';
import SearchChannelProvider from 'components/suggestion/search_channel_provider';
import SearchUserProvider from 'components/suggestion/search_user_provider';
import type {SearchType} from 'types/store/rhs';

import type {Props, SearchFilterType} from './types';

interface SearchHintOption {
    searchTerm: string;
    message: {
        id: string;
        defaultMessage: string;
    };
}

const determineVisibleSearchHintOptions = (searchTerms: string, searchType: SearchType): SearchHintOption[] => {
    let newVisibleSearchHintOptions: SearchHintOption[] = [];
    let options = searchHintOptions;
    if (searchType === 'files') {
        options = searchFilesHintOptions;
    }

    if (searchTerms.trim() === '') {
        return options;
    }

    const pretextArray = searchTerms.split(/\s+/g);
    const pretext = pretextArray[pretextArray.length - 1];
    const penultimatePretext = pretextArray[pretextArray.length - 2];

    const shouldShowHintOptions = penultimatePretext ? !options.some(({searchTerm}) => penultimatePretext.toLowerCase().endsWith(searchTerm.toLowerCase())) : !options.some(({searchTerm}) => searchTerms.toLowerCase().endsWith(searchTerm.toLowerCase()));

    if (shouldShowHintOptions) {
        try {
            newVisibleSearchHintOptions = options.filter((option) => {
                return new RegExp(pretext, 'ig').
                    test(option.searchTerm) && option.searchTerm.toLowerCase() !== pretext.toLowerCase();
            });
        } catch {
            newVisibleSearchHintOptions = [];
        }
    }

    return newVisibleSearchHintOptions;
};

const Search: React.FC<Props> = (props: Props): JSX.Element => {
    const {
        actions,
        currentChannel,
        enableFindShortcut,
        hideSearchBar,
        isMobileView,
        searchTerms,
        searchType,
        hideMobileSearchBarInRHS,
    } = props;

    const intl = useIntl();
    const currentChannelName = useSelector(getCurrentChannelNameForSearchShortcut);

    // generate intial component state and setters
    const [focused, setFocused] = useState<boolean>(false);
    const [dropdownFocused, setDropdownFocused] = useState<boolean>(false);
    const [keepInputFocused, setKeepInputFocused] = useState<boolean>(false);
    const [indexChangedViaKeyPress, setIndexChangedViaKeyPress] = useState<boolean>(false);
    const [highlightedSearchHintIndex, setHighlightedSearchHintIndex] = useState<number>(-1);
    const [visibleSearchHintOptions, setVisibleSearchHintOptions] = useState<SearchHintOption[]>(
        determineVisibleSearchHintOptions(searchTerms, searchType),
    );
    const [searchFilterType, setSearchFilterType] = useState<SearchFilterType>('all');

    const suggestionProviders = useRef<Provider[]>([
        new SearchDateProvider(),
        new SearchChannelProvider(actions.autocompleteChannelsForSearch),
        new SearchUserProvider(actions.autocompleteUsersInTeam),
    ]);

    const isDesktop = isDesktopApp() && isServerVersionGreaterThanOrEqualTo(getDesktopVersion(), '4.7.0');
    useEffect(() => {
        if (!enableFindShortcut) {
            return undefined;
        }

        const handleKeyDown = (e: KeyboardEvent) => {
            if (Utils.cmdOrCtrlPressed(e) && Utils.isKeyPressed(e, Constants.KeyCodes.F)) {
                if (!isDesktop && !e.shiftKey) {
                    return;
                }

                // Special case for Mac Desktop xApp where Ctrl+Cmd+F triggers full screen view
                if (isMacApp() && e.ctrlKey) {
                    return;
                }

                e.preventDefault();
                if (hideSearchBar) {
                    actions.openRHSSearch();
                    setKeepInputFocused(true);
                }
                if (currentChannelName) {
                    actions.updateSearchTermsForShortcut();
                }
                handleFocus();
            }
        };

        document.addEventListener('keydown', handleKeyDown);
        return () => {
            document.removeEventListener('keydown', handleKeyDown);
        };
    }, [hideSearchBar, currentChannelName]);

    useEffect((): void => {
        if (!isMobileView) {
            setVisibleSearchHintOptions(determineVisibleSearchHintOptions(searchTerms, searchType));
        }
    }, [isMobileView, searchTerms, searchType]);

    useEffect((): void => {
        if (!isMobileView && focused && keepInputFocused) {
            handleBlur();
        }
    }, [isMobileView, searchTerms]);

    // handle cloding of rhs-flyout
    const handleClose = (): void => actions.closeRightHandSide();

    // focus the search input
    const handleFocus = (): void => setFocused(true);

    // release focus from the search input or unset `keepInputFocused` value
    // `keepInputFocused` is used to keep the search input focused when a
    // user selects a suggestion from `SearchHint` with a click
    const handleBlur = (): void => {
        // add time out so that the pinned and member buttons are clickable
        // when focus is released from the search box.
        setTimeout((): void => {
            if (keepInputFocused) {
                setKeepInputFocused(false);
            } else {
                setFocused(false);
            }
        }, 0);
        updateHighlightedSearchHint();
    };

    const handleDropdownBlur = () => setDropdownFocused(false);

    const handleDropdownFocus = () => setDropdownFocused(true);

    const handleSearchHintSelection = (): void => {
        if (focused) {
            setKeepInputFocused(true);
        } else {
            setFocused(true);
        }
    };

    const handleAddSearchTerm = (term: string): void => {
        const pretextArray = searchTerms?.split(' ') || [];
        pretextArray.pop();
        pretextArray.push(term.toLowerCase());
        handleUpdateSearchTerms(pretextArray.join(' '));
    };

    const handleUpdateSearchTerms = (terms: string): void => {
        actions.updateSearchTerms(terms);
        updateHighlightedSearchHint();
    };

    const handleOnSearchTypeSelected = (searchType || searchTerms) ? undefined : (value: SearchType) => {
        actions.updateSearchType(value);
        if (!searchType) {
            setDropdownFocused(false);
        }
        setFocused(true);
    };

    const handleChange = (e: ChangeEvent<HTMLInputElement>): void => {
        const term = e.target.value;
        actions.updateSearchTerms(term);
    };

    // call this function without parameters to reset `SearchHint`
    const updateHighlightedSearchHint = (indexDelta = 0, changedViaKeyPress = false): void => {
        if (Math.abs(indexDelta) > 1) {
            return;
        }

        let newIndex = highlightedSearchHintIndex + indexDelta;

        switch (indexDelta) {
        case 1:
            // KEY.DOWN
            // is it at the end of the list?
            newIndex = newIndex === visibleSearchHintOptions.length ? 0 : newIndex;
            break;
        case -1:
            // KEY.UP
            // is it at the start of the list (or initial value)?
            newIndex = newIndex < 0 ? visibleSearchHintOptions.length - 1 : newIndex;
            break;
        case 0:
        default:
            // reset the index (e.g. on blur)
            newIndex = -1;
        }

        setHighlightedSearchHintIndex(newIndex);
        setIndexChangedViaKeyPress(changedViaKeyPress);
    };

    const handleEnterKey = (e: ChangeEvent<HTMLInputElement>): void => {
        // only prevent default-behaviour, when one of the conditions is true
        // when both are false just submit the form (default behaviour) with
        // `handleSubmit` function called from the `form`
        if (indexChangedViaKeyPress && !searchType && !searchTerms) {
            e.preventDefault();
            setKeepInputFocused(true);
            actions.updateSearchType(highlightedSearchHintIndex === 0 ? 'messages' : 'files');
            setHighlightedSearchHintIndex(-1);
        } else if (indexChangedViaKeyPress) {
            e.preventDefault();
            setKeepInputFocused(true);
            handleAddSearchTerm(visibleSearchHintOptions[highlightedSearchHintIndex].searchTerm);
        }

        if (props.isMentionSearch) {
            e.preventDefault();
            actions.updateRhsState(RHSStates.SEARCH);
        }
    };

    const handleSubmit = (e: FormEvent<HTMLFormElement>): void => {
        e.preventDefault();

        handleSearch().then(() => {
            setKeepInputFocused(false);
            setFocused(false);
        });
    };

    const handleSearch = async (): Promise<void> => {
        const terms = searchTerms.trim();

        if (terms.length === 0) {
            return;
        }

        const {error} = await actions.showSearchResults(Boolean(props.isMentionSearch));

        if (!error) {
            handleSearchOnSuccess();
        }
    };

    const handleSearchOnSuccess = (): void => {
        if (isMobileView) {
            handleClear();
        }
    };

    const handleClear = (): void => {
        if (props.isMentionSearch) {
            setFocused(false);
            actions.updateRhsState(RHSStates.SEARCH);
        }
        actions.updateSearchTerms('');
        actions.updateSearchType('');
    };

    const handleShrink = (): void => {
        props.actions.setRhsExpanded(false);
    };

    const handleSetSearchFilter = (filterType: SearchFilterType): void => {
        switch (filterType) {
        case 'documents':
            props.actions.filterFilesSearchByExt(['doc', 'pdf', 'docx', 'odt', 'rtf', 'txt']);
            break;
        case 'spreadsheets':
            props.actions.filterFilesSearchByExt(['xls', 'xlsx', 'ods']);
            break;
        case 'presentations':
            props.actions.filterFilesSearchByExt(['ppt', 'pptx', 'odp']);
            break;
        case 'code':
            props.actions.filterFilesSearchByExt(['py', 'go', 'java', 'kt', 'c', 'cpp', 'h', 'html', 'js', 'ts', 'cs', 'vb', 'php', 'pl', 'r', 'rb', 'sql', 'swift', 'json']);
            break;
        case 'images':
            props.actions.filterFilesSearchByExt(['png', 'jpg', 'jpeg', 'bmp', 'tiff', 'svg', 'psd', 'xcf']);
            break;
        case 'audio':
            props.actions.filterFilesSearchByExt(['ogg', 'mp3', 'wav', 'flac']);
            break;
        case 'video':
            props.actions.filterFilesSearchByExt(['ogm', 'mp4', 'avi', 'webm', 'mov', 'mkv', 'mpeg', 'mpg']);
            break;
        default:
            props.actions.filterFilesSearchByExt([]);
        }
        setSearchFilterType(filterType);
        if (props.isChannelFiles && currentChannel) {
            props.actions.showChannelFiles(currentChannel.id);
        } else {
            props.actions.showSearchResults(false);
        }
    };

    const setHoverHintIndex = (_highlightedSearchHintIndex: number): void => {
        setHighlightedSearchHintIndex(_highlightedSearchHintIndex);
        setIndexChangedViaKeyPress(false);
    };

    const searchMentions = (e: MouseEvent<HTMLButtonElement>): void => {
        e.preventDefault();
        if (props.isMentionSearch) {
            actions.closeRightHandSide();
            return;
        }
        actions.showMentions();
    };

    const getFlagged = (e: MouseEvent<HTMLButtonElement>): void => {
        e.preventDefault();
        if (props.isFlaggedPosts) {
            actions.closeRightHandSide();
            return;
        }
        actions.showFlaggedPosts();
    };

    const searchButtonClick = (e: React.MouseEvent) => {
        e.preventDefault();

        actions.openRHSSearch();
    };

    const renderMentionButton = (): JSX.Element => (
        <HeaderIconWrapper
            iconComponent={
                <MentionsIcon
                    className='icon icon--standard'
                    aria-hidden='true'
                />
            }
            ariaLabel={true}
            buttonClass={classNames(
                'channel-header__icon',
                {'channel-header__icon--active': props.isMentionSearch},
            )}
            buttonId={props.isSideBarRight ? 'sbrChannelHeaderMentionButton' : 'channelHeaderMentionButton'}
            onClick={searchMentions}
            tooltipKey={'recentMentions'}
            isRhsOpen={props.isRhsOpen}
        />
    );

    const renderFlagBtn = (): JSX.Element => (
        <HeaderIconWrapper
            iconComponent={
                <FlagIcon className='icon icon--standard'/>
            }
            ariaLabel={true}
            buttonClass={classNames(
                'channel-header__icon ',
                {'channel-header__icon--active': props.isFlaggedPosts},
            )}
            buttonId={props.isSideBarRight ? 'sbrChannelHeaderFlagButton' : 'channelHeaderFlagButton'}
            onClick={getFlagged}
            tooltipKey={'flaggedPosts'}
            isRhsOpen={props.isRhsOpen}
        />
    );

    const renderHintPopover = (): JSX.Element => {
        let termsUsed = 0;

        searchTerms?.split(/[: ]/g).forEach((word: string): void => {
            let options = searchHintOptions;
            if (searchType === 'files') {
                options = searchFilesHintOptions;
            }
            if (options.some(({searchTerm}) => searchTerm.toLowerCase() === word.toLowerCase())) {
                termsUsed++;
            }
        });

        if (visibleSearchHintOptions.length === 0 || props.isMentionSearch) {
            return <></>;
        }

        const helpClass = `search-help-popover${((dropdownFocused || focused) && termsUsed <= 2) ? ' visible' : ''}`;

        return (
            <Popover
                id={`${props.isSideBarRight ? 'sbr-' : ''}searchbar-help-popup`}
                placement='bottom'
                className={helpClass}
            >
                <SearchHint
                    options={visibleSearchHintOptions}
                    withTitle={true}
                    onOptionSelected={handleAddSearchTerm}
                    onMouseDown={handleSearchHintSelection}
                    highlightedIndex={highlightedSearchHintIndex}
                    onOptionHover={setHoverHintIndex}
                    onSearchTypeSelected={handleOnSearchTypeSelected}
                    onElementBlur={handleDropdownBlur}
                    onElementFocus={handleDropdownFocus}
                    searchType={searchType}
                />
            </Popover>
        );
    };

    const renderSearchBar = (): JSX.Element => (
        <>
            <div className='sidebar-collapse__container'>
                <div
                    id={props.isSideBarRight ? 'sbrSidebarCollapse' : 'sidebarCollapse'}
                    className='sidebar-collapse'
                    onClick={handleClose}
                >
                    <span
                        className='fa fa-2x fa-angle-left'
                        title={intl.formatMessage({id: 'generic_icons.back', defaultMessage: 'Back Icon'})}
                    />
                </div>
            </div>
            <SearchBar
                updateHighlightedSearchHint={updateHighlightedSearchHint}
                handleEnterKey={handleEnterKey}
                handleClear={handleClear}
                handleChange={handleChange}
                handleSubmit={handleSubmit}
                handleFocus={handleFocus}
                handleBlur={handleBlur}
                keepFocused={keepInputFocused}
                setKeepFocused={setKeepInputFocused}
                isFocused={focused}
                suggestionProviders={suggestionProviders.current}
                isSideBarRight={props.isSideBarRight}
                isSearchingTerm={props.isSearchingTerm}
                getFocus={props.getFocus}
                searchTerms={searchTerms}
                searchType={searchType}
                clearSearchType={() => actions.updateSearchType('')}
            >
                {!props.isMobileView && renderHintPopover()}
            </SearchBar>
        </>
    );

    // when inserted in RHSSearchNav component, just return SearchBar
    if (!props.isSideBarRight) {
        if (hideSearchBar) {
            return (
                <HeaderIconWrapper
                    iconComponent={
                        <SearchIcon
                            className='icon icon--standard'
                            aria-hidden='true'
                        />
                    }
                    ariaLabel={true}
                    buttonId={'channelHeaderSearchButton'}
                    onClick={searchButtonClick}
                    tooltipKey={'search'}
                />
            );
        }

        return (
            <div
                id='searchbarContainer'
                className={'search-bar-container--global'}
            >
                <div className='sidebar-right__table'>
                    {renderSearchBar()}
                </div>
            </div>
        );
    }

    return (
        <div className='sidebar--right__content'>
            {!hideMobileSearchBarInRHS && (
                <div className='search-bar__container channel-header alt'>
                    <div className='sidebar-right__table'>
                        {renderSearchBar()}
                        {renderMentionButton()}
                        {renderFlagBtn()}
                        <UserGuideDropdown/>
                    </div>
                </div>
            )}
            {props.searchVisible ? (
                <SearchResults
                    isMentionSearch={props.isMentionSearch}
                    isFlaggedPosts={props.isFlaggedPosts}
                    isPinnedPosts={props.isPinnedPosts}
                    isChannelFiles={props.isChannelFiles}
                    shrink={handleShrink}
                    channelDisplayName={props.channelDisplayName}
                    isOpened={props.isSideBarRightOpen}
                    updateSearchTerms={handleAddSearchTerm}
                    handleSearchHintSelection={handleSearchHintSelection}
                    isSideBarExpanded={props.isRhsExpanded}
                    getMorePostsForSearch={props.actions.getMorePostsForSearch}
                    getMoreFilesForSearch={props.actions.getMoreFilesForSearch}
                    setSearchFilterType={handleSetSearchFilter}
                    searchFilterType={searchFilterType}
                    setSearchType={(value: SearchType) => actions.updateSearchType(value)}
                    searchType={searchType || 'messages'}
                />
            ) : props.children}
        </div>
    );
};

const defaultProps: Partial<Props> = {
    searchTerms: '',
    channelDisplayName: '',
    isSideBarRight: false,
    hideMobileSearchBarInRHS: false,
    getFocus: () => {},
};

Search.defaultProps = defaultProps;

export default React.memo(Search);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {Action} from 'mattermost-redux/types/actions';
import {getMorePostsForSearch, getMoreFilesForSearch} from 'mattermost-redux/actions/search';
import {getCurrentChannel} from 'mattermost-redux/selectors/entities/channels';

import {
    updateSearchTerms,
    updateSearchTermsForShortcut,
    showSearchResults,
    showChannelFiles,
    showMentions,
    showFlaggedPosts,
    closeRightHandSide,
    updateRhsState,
    setRhsExpanded,
    openRHSSearch,
    filterFilesSearchByExt,
    updateSearchType,
} from 'actions/views/rhs';
import {autocompleteChannelsForSearch} from 'actions/channel_actions';
import {autocompleteUsersInTeam} from 'actions/user_actions';

import {getRhsState, getSearchTerms, getSearchType, getIsSearchingTerm, getIsRhsOpen, getIsRhsExpanded} from 'selectors/rhs';
import {getIsMobileView} from 'selectors/views/browser';

import {GlobalState} from 'types/store';

import {RHSStates} from 'utils/constants';

import Search from './search';
import type {StateProps, DispatchProps, OwnProps} from './types';

function mapStateToProps(state: GlobalState) {
    const rhsState = getRhsState(state);
    const currentChannel = getCurrentChannel(state);
    const isMobileView = getIsMobileView(state);
    const isRhsOpen = getIsRhsOpen(state);

    return {
        currentChannel,
        isRhsExpanded: getIsRhsExpanded(state),
        isRhsOpen,
        isSearchingTerm: getIsSearchingTerm(state),
        searchTerms: getSearchTerms(state),
        searchType: getSearchType(state),
        searchVisible: rhsState !== null && (![
            RHSStates.PLUGIN,
            RHSStates.CHANNEL_INFO,
            RHSStates.CHANNEL_MEMBERS,
        ].includes(rhsState)),
        hideMobileSearchBarInRHS: isMobileView && isRhsOpen && rhsState === RHSStates.CHANNEL_INFO,
        isMentionSearch: rhsState === RHSStates.MENTION,
        isFlaggedPosts: rhsState === RHSStates.FLAG,
        isPinnedPosts: rhsState === RHSStates.PIN,
        isChannelFiles: rhsState === RHSStates.CHANNEL_FILES,
        isMobileView,
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, DispatchProps['actions']>({
            updateSearchTerms,
            updateSearchTermsForShortcut,
            updateSearchType,
            showSearchResults,
            showChannelFiles,
            showMentions,
            showFlaggedPosts,
            setRhsExpanded,
            closeRightHandSide,
            autocompleteChannelsForSearch,
            autocompleteUsersInTeam,
            updateRhsState,
            getMorePostsForSearch,
            openRHSSearch,
            getMoreFilesForSearch,
            filterFilesSearchByExt,
        }, dispatch),
    };
}
export default connect<StateProps, DispatchProps, OwnProps, GlobalState>(mapStateToProps, mapDispatchToProps)(Search);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import PropTypes from 'prop-types';
import React from 'react';

import SearchResultsHeader from 'components/search_results_header';

import Pluggable from 'plugins/pluggable';

export default class RhsPlugin extends React.PureComponent {
    static propTypes = {
        showPluggable: PropTypes.bool.isRequired,
        pluggableId: PropTypes.string.isRequired,
        title: PropTypes.oneOfType([
            PropTypes.string,
            PropTypes.object,
        ]),
    }

    render() {
        return (
            <div
                id='rhsContainer'
                className='sidebar-right__body'
            >
                <SearchResultsHeader>
                    {this.props.title}
                </SearchResultsHeader>
                {
                    this.props.showPluggable &&
                    <Pluggable
                        pluggableName='RightHandSidebarComponent'
                        pluggableId={this.props.pluggableId}
                    />
                }
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getPluggableId} from 'selectors/rhs';

import RHSPlugin from './rhs_plugin.jsx';

function mapStateToProps(state) {
    const rhsPlugins = state.plugins.components.RightHandSidebarComponent;
    const pluggableId = getPluggableId(state);

    const pluginComponent = rhsPlugins.find((element) => element.id === pluggableId);
    const pluginTitle = pluginComponent ? pluginComponent.title : '';

    return {
        showPluggable: Boolean(pluginComponent),
        pluggableId,
        title: pluginTitle,
    };
}

export default connect(mapStateToProps)(RHSPlugin);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import classNames from 'classnames';

import {ProductIdentifier} from '@mattermost/types/products';
import {Team} from '@mattermost/types/teams';
import {Channel} from '@mattermost/types/channels';

import {RhsState} from 'types/store/rhs';

import {trackEvent} from 'actions/telemetry_actions.jsx';

import Constants from 'utils/constants';
import {isMac, cmdOrCtrlPressed, isKeyPressed} from 'utils/utils';

import FileUploadOverlay from 'components/file_upload_overlay';
import RhsThread from 'components/rhs_thread';
import RhsCard from 'components/rhs_card';
import ChannelInfoRhs from 'components/channel_info_rhs';
import ChannelMembersRhs from 'components/channel_members_rhs';
import Search from 'components/search/index';
import LoadingScreen from 'components/loading_screen';

import RhsPlugin from 'plugins/rhs_plugin';

type Props = {
    isExpanded: boolean;
    isOpen: boolean;
    channel: Channel;
    team: Team;
    teamId: Team['id'];
    productId: ProductIdentifier;
    postRightVisible: boolean;
    postCardVisible: boolean;
    searchVisible: boolean;
    isPinnedPosts: boolean;
    isChannelFiles: boolean;
    isChannelInfo: boolean;
    isChannelMembers: boolean;
    isPluginView: boolean;
    previousRhsState: RhsState;
    rhsChannel: Channel;
    selectedPostId: string;
    selectedPostCardId: string;
    actions: {
        setRhsExpanded: (expanded: boolean) => void;
        showPinnedPosts: (channelId: string) => void;
        openRHSSearch: () => void;
        closeRightHandSide: () => void;
        openAtPrevious: (previous: Partial<Props> | undefined) => void;
        updateSearchTerms: (terms: string) => void;
        showChannelFiles: (channelId: string) => void;
        showChannelInfo: (channelId: string) => void;
    };
}

type State = {
    isOpened: boolean;
}

export default class SidebarRight extends React.PureComponent<Props, State> {
    sidebarRight: React.RefObject<HTMLDivElement>;
    previous: Partial<Props> | undefined = undefined;
    focusSearchBar?: () => void;

    constructor(props: Props) {
        super(props);

        this.sidebarRight = React.createRef();
        this.state = {
            isOpened: false,
        };
    }

    setPrevious = () => {
        if (!this.props.isOpen) {
            return;
        }

        this.previous = {
            searchVisible: this.props.searchVisible,
            isPinnedPosts: this.props.isPinnedPosts,
            isChannelFiles: this.props.isChannelFiles,
            isChannelInfo: this.props.isChannelInfo,
            isChannelMembers: this.props.isChannelMembers,
            selectedPostId: this.props.selectedPostId,
            selectedPostCardId: this.props.selectedPostCardId,
            previousRhsState: this.props.previousRhsState,
        };
    }

    handleShortcut = (e: KeyboardEvent) => {
        const channelInfoShortcutMac = isMac() && e.shiftKey;
        const channelInfoShortcut = !isMac() && e.altKey;

        if (cmdOrCtrlPressed(e, true)) {
            if (e.shiftKey && isKeyPressed(e, Constants.KeyCodes.PERIOD)) {
                e.preventDefault();
                if (this.props.isOpen) {
                    if (this.props.isExpanded) {
                        this.props.actions.setRhsExpanded(false);
                    } else {
                        this.props.actions.setRhsExpanded(true);
                    }
                } else {
                    this.props.actions.openAtPrevious(this.previous);
                }
            } else if (isKeyPressed(e, Constants.KeyCodes.PERIOD)) {
                e.preventDefault();
                if (this.props.isOpen) {
                    this.props.actions.closeRightHandSide();
                } else {
                    this.props.actions.openAtPrevious(this.previous);
                }
            } else if (isKeyPressed(e, Constants.KeyCodes.I) && (channelInfoShortcutMac || channelInfoShortcut)) {
                e.preventDefault();
                if (this.props.isOpen && this.props.isChannelInfo) {
                    this.props.actions.closeRightHandSide();
                } else if (this.props.channel) {
                    this.props.actions.showChannelInfo(this.props.channel.id);
                }
            }
        }
    }

    componentDidMount() {
        document.addEventListener('keydown', this.handleShortcut);
        document.addEventListener('mousedown', this.handleClickOutside);
    }

    componentWillUnmount() {
        document.removeEventListener('keydown', this.handleShortcut);
        document.removeEventListener('mousedown', this.handleClickOutside);
    }

    componentDidUpdate(prevProps: Props) {
        const wasOpen = prevProps.searchVisible || prevProps.postRightVisible;
        const isOpen = this.props.searchVisible || this.props.postRightVisible;

        if (!wasOpen && isOpen) {
            trackEvent('ui', 'ui_rhs_opened');
        }

        const {actions, isChannelFiles, isPinnedPosts, rhsChannel, channel} = this.props;
        if (isPinnedPosts && prevProps.isPinnedPosts === isPinnedPosts && rhsChannel.id !== prevProps.rhsChannel.id) {
            actions.showPinnedPosts(rhsChannel.id);
        }

        if (isChannelFiles && prevProps.isChannelFiles === isChannelFiles && rhsChannel.id !== prevProps.rhsChannel.id) {
            actions.showChannelFiles(rhsChannel.id);
        }

        // in the case of navigating to another channel
        // or from global threads to a channel
        // we shrink the sidebar
        if (
            (channel && prevProps.channel && (channel.id !== prevProps.channel.id)) ||
            (channel && !prevProps.channel)
        ) {
            this.props.actions.setRhsExpanded(false);
        }

        // close when changing products or teams
        if (
            (prevProps.teamId && this.props.teamId !== prevProps.teamId) ||
            this.props.productId !== prevProps.productId
        ) {
            this.props.actions.closeRightHandSide();
        }

        this.setPrevious();
    }

    handleClickOutside = (e: MouseEvent) => {
        if (
            (this.props.isOpen && this.props.isExpanded) && // can be collapsed
            e.target && // has target
            document.getElementById('root')?.contains(e.target as Element) &&//  within Root
            !this.sidebarRight.current?.contains(e.target as Element) && // not within RHS
            !document.getElementById('global-header')?.contains(e.target as Element) && // not within Global Header
            !document.querySelector('.app-bar')?.contains(e.target as Element) // not within App Bar
        ) {
            this.props.actions.setRhsExpanded(false);
        }
    }

    handleUpdateSearchTerms = (term: string) => {
        this.props.actions.updateSearchTerms(term);
        this.focusSearchBar?.();
    }

    getSearchBarFocus = (focusSearchBar: () => void) => {
        this.focusSearchBar = focusSearchBar;
    }

    render() {
        const {
            rhsChannel,
            postRightVisible,
            postCardVisible,
            previousRhsState,
            searchVisible,
            isPinnedPosts,
            isChannelFiles,
            isPluginView,
            isOpen,
            isChannelInfo,
            isChannelMembers,
            isExpanded,
            channel,
            team,
        } = this.props;

        if (!isOpen) {
            return null;
        }

        let content = null;
        if (postRightVisible) {
            content = (
                <div className='post-right__container'>
                    <FileUploadOverlay overlayType='right'/>
                    <RhsThread previousRhsState={previousRhsState}/>
                </div>
            );
        } else if (postCardVisible) {
            content = <RhsCard previousRhsState={previousRhsState}/>;
        } else if (isPluginView) {
            content = <RhsPlugin/>;
        } else if (isChannelInfo) {
            content = (
                <ChannelInfoRhs/>
            );
        } else if (isChannelMembers) {
            content = (
                <ChannelMembersRhs/>
            );
        }

        // Sometimes the channel/team is not loaded yet, so we need to wait for it
        const isChannelSpecificRHS = postRightVisible || postCardVisible || isPinnedPosts || isChannelFiles || isChannelInfo || isChannelMembers;

        const isRHSLoading = postRightVisible ? !(team || channel) : (!team || !channel) && isChannelSpecificRHS;

        const channelDisplayName = rhsChannel ? rhsChannel.display_name : '';

        const isSidebarRightExpanded = (postRightVisible || postCardVisible || isPluginView || searchVisible) && isExpanded;
        const containerClassName = classNames('sidebar--right', 'move--left is-open', {
            'sidebar--right--expanded expanded': isSidebarRightExpanded,
        });

        return (
            <>
                <div className={'sidebar--right sidebar--right--width-holder'}/>
                <div
                    className={containerClassName}
                    id='sidebar-right'
                    role='complementary'
                    ref={this.sidebarRight}
                >
                    <div className='sidebar-right-container'>
                        {isRHSLoading ? (
                            <div className='sidebar-right__body'>
                                <LoadingScreen centered={true}/>
                            </div>
                        ) : (
                            <Search
                                isSideBarRight={true}
                                isSideBarRightOpen={true}
                                getFocus={this.getSearchBarFocus}
                                channelDisplayName={channelDisplayName}
                            >
                                {content}
                            </Search>
                        )}
                    </div>
                </div>
            </>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {withRouter, RouteComponentProps} from 'react-router-dom';

import {memo} from 'react';

import {getCurrentChannel} from 'mattermost-redux/selectors/entities/channels';
import {getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';

import {setRhsExpanded, showChannelInfo, showPinnedPosts, showChannelFiles, openRHSSearch, closeRightHandSide, openAtPrevious, updateSearchTerms} from 'actions/views/rhs';
import {
    getIsRhsExpanded,
    getIsRhsOpen,
    getRhsState,
    getSelectedChannel,
    getSelectedPostId,
    getSelectedPostCardId,
    getPreviousRhsState,
} from 'selectors/rhs';
import {RHSStates} from 'utils/constants';

import {GlobalState} from 'types/store';

import {selectCurrentProductId} from 'selectors/products';

import SidebarRight from './sidebar_right';

function mapStateToProps(state: GlobalState, props: RouteComponentProps) {
    const rhsState = getRhsState(state);
    const channel = getCurrentChannel(state);
    const team = getCurrentTeam(state);
    const teamId = team?.id ?? '';
    const productId = selectCurrentProductId(state, props.location.pathname);

    const selectedPostId = getSelectedPostId(state);
    const selectedPostCardId = getSelectedPostCardId(state);

    return {
        isExpanded: getIsRhsExpanded(state),
        isOpen: getIsRhsOpen(state),
        channel,
        postRightVisible: Boolean(selectedPostId),
        postCardVisible: Boolean(selectedPostCardId),
        searchVisible: Boolean(rhsState) && rhsState !== RHSStates.PLUGIN,
        previousRhsState: getPreviousRhsState(state),
        isPinnedPosts: rhsState === RHSStates.PIN,
        isChannelFiles: rhsState === RHSStates.CHANNEL_FILES,
        isChannelInfo: rhsState === RHSStates.CHANNEL_INFO,
        isChannelMembers: rhsState === RHSStates.CHANNEL_MEMBERS,
        isPluginView: rhsState === RHSStates.PLUGIN,
        rhsChannel: getSelectedChannel(state),
        selectedPostId,
        selectedPostCardId,
        team,
        teamId,
        productId,
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators({
            setRhsExpanded,
            showPinnedPosts,
            openRHSSearch,
            closeRightHandSide,
            openAtPrevious,
            updateSearchTerms,
            showChannelFiles,
            showChannelInfo,
        }, dispatch),
    };
}

export default withRouter(connect(mapStateToProps, mapDispatchToProps)(memo(SidebarRight)));

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState, useEffect} from 'react';
import {useSelector} from 'react-redux';
import classNames from 'classnames';

import {Tooltip} from 'react-bootstrap';

import {getCurrentChannel, getMyCurrentChannelMembership} from 'mattermost-redux/selectors/entities/channels';

import {getActiveRhsComponent} from 'selectors/rhs';

import {PluginComponent, AppBarComponent} from 'types/store/plugins';
import Constants, {suitePluginIds} from 'utils/constants';

import OverlayTrigger from 'components/overlay_trigger';
import PluginIcon from 'components/widgets/icons/plugin_icon';

import NewChannelWithBoardTourTip from './new_channel_with_board_tour_tip';

type PluginComponentProps = {
    component: AppBarComponent;
}

enum ImageLoadState {
    LOADING = 'loading',
    LOADED = 'loaded',
    ERROR = 'error',
}

export const isAppBarPluginComponent = (x: Record<string, any> | undefined): x is PluginComponent => {
    return Boolean(x?.id && x?.pluginId);
};

const AppBarPluginComponent = (props: PluginComponentProps) => {
    const {component} = props;

    const channel = useSelector(getCurrentChannel);
    const channelMember = useSelector(getMyCurrentChannelMembership);
    const activeRhsComponent = useSelector(getActiveRhsComponent);

    const [imageLoadState, setImageLoadState] = useState<ImageLoadState>(ImageLoadState.LOADING);

    useEffect(() => {
        setImageLoadState(ImageLoadState.LOADING);
    }, [component.iconUrl]);

    const onImageLoadComplete = () => {
        setImageLoadState(ImageLoadState.LOADED);
    };

    const onImageLoadError = () => {
        setImageLoadState(ImageLoadState.ERROR);
    };

    const buttonId = `app-bar-icon-${component.pluginId}`;
    const tooltipText = component.tooltipText || component.dropdownText || component.pluginId;
    const tooltip = (
        <Tooltip id={'pluginTooltip-' + buttonId}>
            <span>{tooltipText}</span>
        </Tooltip>
    );

    const iconUrl = component.iconUrl;
    let content: React.ReactNode = (
        <div className='app-bar__icon-inner'>
            <img
                src={iconUrl}
                onLoad={onImageLoadComplete}
                onError={onImageLoadError}
            />
        </div>
    );

    const isButtonActive = component.rhsComponentId ? activeRhsComponent?.id === component.rhsComponentId : component.pluginId === activeRhsComponent?.pluginId;

    if (!iconUrl) {
        content = (
            <div className={classNames('app-bar__old-icon app-bar__icon-inner app-bar__icon-inner--centered', {'app-bar__old-icon--active': isButtonActive})}>
                {component.icon}
            </div>
        );
    }

    if (imageLoadState === ImageLoadState.ERROR) {
        content = (
            <PluginIcon className='icon__plugin'/>
        );
    }

    return (
        <OverlayTrigger
            trigger={['hover', 'focus']}
            delayShow={Constants.OVERLAY_TIME_DELAY}
            placement='left'
            overlay={tooltip}
        >
            <div
                id={buttonId}
                className={classNames('app-bar__icon', {'app-bar__icon--active': isButtonActive})}
                onClick={() => {
                    component.action?.(channel, channelMember);
                }}
            >
                {content}
                {component.pluginId === suitePluginIds.focalboard && <NewChannelWithBoardTourTip/>}
            </div>
        </OverlayTrigger>
    );
};

export default AppBarPluginComponent;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useDispatch, useSelector} from 'react-redux';
import {useIntl} from 'react-intl';
import {Tooltip} from 'react-bootstrap';

import {AppCallResponseTypes} from 'mattermost-redux/constants/apps';
import {getCurrentChannelId} from 'mattermost-redux/selectors/entities/common';
import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {AppBinding, AppCallResponse} from '@mattermost/types/apps';

import {handleBindingClick, openAppsModal, postEphemeralCallResponseForContext} from 'actions/apps';

import {createCallContext} from 'utils/apps';
import Constants from 'utils/constants';
import {DoAppCallResult} from 'types/apps';

import OverlayTrigger from 'components/overlay_trigger';

export const isAppBinding = (x: Record<string, any> | undefined): x is AppBinding => {
    return Boolean(x?.app_id);
};

type BindingComponentProps = {
    binding: AppBinding;
}

const AppBarBinding = (props: BindingComponentProps) => {
    const {binding} = props;

    const dispatch = useDispatch();
    const intl = useIntl();

    const channelId = useSelector(getCurrentChannelId);
    const teamId = useSelector(getCurrentTeamId);

    const submitAppCall = async () => {
        const context = createCallContext(
            binding.app_id,
            binding.location,
            channelId,
            teamId,
        );

        const result = await dispatch(handleBindingClick(binding, context, intl)) as DoAppCallResult;

        if (result.error) {
            const errMsg = result.error.text || 'An error occurred';
            dispatch(postEphemeralCallResponseForContext(result.error, errMsg, context));
            return;
        }

        const callResp = result.data as AppCallResponse;

        switch (callResp.type) {
        case AppCallResponseTypes.OK:
            if (callResp.text) {
                dispatch(postEphemeralCallResponseForContext(callResp, callResp.text, context));
            }
            return;
        case AppCallResponseTypes.FORM:
            if (callResp.form) {
                dispatch(openAppsModal(callResp.form, context));
            }
            return;
        case AppCallResponseTypes.NAVIGATE:
            return;
        default: {
            const errorMessage = intl.formatMessage({
                id: 'apps.error.responses.unknown_type',
                defaultMessage: 'App response type not supported. Response type: {type}.',
            }, {
                type: callResp.type,
            });
            dispatch(postEphemeralCallResponseForContext(callResp, errorMessage, context));
        }
        }
    };

    const id = `app-bar-icon-${binding.app_id}`;
    const label = binding.label || binding.app_id;

    const tooltip = (
        <Tooltip id={'tooltip-' + id}>
            <span>{label}</span>
        </Tooltip>
    );

    return (
        <OverlayTrigger
            trigger={['hover', 'focus']}
            delayShow={Constants.OVERLAY_TIME_DELAY}
            placement='left'
            overlay={tooltip}
        >
            <div
                id={id}
                aria-label={label}
                className={'app-bar__icon'}
                onClick={submitAppCall}
            >
                <div className={'app-bar__icon-inner'}>
                    <img src={binding.icon}/>
                </div>
            </div>
        </OverlayTrigger>
    );
};

export default AppBarBinding;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode} from 'react';
import {useSelector} from 'react-redux';

import {partition} from 'lodash';

import {useCurrentProduct, useCurrentProductId, inScope} from 'utils/products';

import {getAppBarAppBindings} from 'mattermost-redux/selectors/entities/apps';
import {getAppBarPluginComponents, getChannelHeaderPluginComponents, shouldShowAppBar} from 'selectors/plugins';
import {suitePluginIds} from 'utils/constants';

import AppBarPluginComponent, {isAppBarPluginComponent} from './app_bar_plugin_component';
import AppBarBinding, {isAppBinding} from './app_bar_binding';

import './app_bar.scss';

export default function AppBar() {
    const channelHeaderComponents = useSelector(getChannelHeaderPluginComponents);
    const appBarPluginComponents = useSelector(getAppBarPluginComponents);
    const appBarBindings = useSelector(getAppBarAppBindings);
    const currentProduct = useCurrentProduct();
    const currentProductId = useCurrentProductId();
    const enabled = useSelector(shouldShowAppBar);

    if (
        !enabled ||
        (currentProduct && !currentProduct.showAppBar)
    ) {
        return null;
    }

    const coreProductsPluginIds = [suitePluginIds.focalboard, suitePluginIds.playbooks];

    const [coreProductComponents, pluginComponents] = partition(appBarPluginComponents, ({pluginId}) => {
        return coreProductsPluginIds.includes(pluginId);
    });

    const items: ReactNode[] = [
        ...coreProductComponents,
        divider,
        ...pluginComponents,
        ...channelHeaderComponents,
        ...appBarBindings,
    ].map((x) => {
        if (isAppBarPluginComponent(x)) {
            if (!inScope(x.supportedProductIds ?? null, currentProductId, currentProduct?.pluginId)) {
                return null;
            }
            return (
                <AppBarPluginComponent
                    key={x.id}
                    component={x}
                />
            );
        } else if (isAppBinding(x)) {
            if (!inScope(x.supported_product_ids ?? null, currentProductId, currentProduct?.pluginId)) {
                return null;
            }
            return (
                <AppBarBinding
                    key={`${x.app_id}_${x.label}`}
                    binding={x}
                />
            );
        }
        return x;
    });

    if (!items.some((x) => Boolean(x) && x !== divider)) {
        return null;
    }

    return (
        <div className={'app-bar'}>
            <div
                // eslint-disable-next-line react/no-unknown-property
                css={`
                    height: 100%;
                    padding-top: 16px;
                    border-left: solid 1px rgba(var(--center-channel-color-rgb), 0.12);
                    background-color: rgba(var(--center-channel-color-rgb), 0.04);
                `}
            >
                {items}
            </div>
        </div>
    );
}

const divider = (
    <hr
        key='divider'
        className={'app-bar__divider'}
        // eslint-disable-next-line react/no-unknown-property
        css={`
            :last-child, :first-child {
                display: none;
            }
        `}
    />
);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Link} from 'react-router-dom';
import classNames from 'classnames';
import {CSSTransition} from 'react-transition-group';

import * as GlobalActions from 'actions/global_actions';
import {Constants} from 'utils/constants';
import * as Utils from 'utils/utils';

import MainMenu from 'components/main_menu';

type Action = {
    openRhsMenu: () => void;
}

type Props = {
    isOpen: boolean;
    teamDisplayName?: string;
    siteName?: string;
    actions: Action;
};

const ANIMATION_DURATION = 500;

export default class SidebarRightMenu extends React.PureComponent<Props> {
    handleEmitUserLoggedOutEvent = () => {
        GlobalActions.emitUserLoggedOutEvent();
    }

    render() {
        let siteName = '';
        if (this.props.siteName != null) {
            siteName = this.props.siteName;
        }
        let teamDisplayName = siteName;
        if (this.props.teamDisplayName) {
            teamDisplayName = this.props.teamDisplayName;
        }

        return (
            <div
                className={classNames('sidebar--menu', {'move--left': this.props.isOpen && Utils.isMobile()})}
                id='sidebar-menu'
            >
                <div className='team__header theme'>
                    <Link
                        className='team__name'
                        to={`/channels/${Constants.DEFAULT_CHANNEL}`}
                    >
                        {teamDisplayName}
                    </Link>
                </div>

                <div className='nav-pills__container mobile-main-menu'>
                    <CSSTransition
                        in={this.props.isOpen && Utils.isMobile()}
                        classNames='MobileRightSidebarMenu'
                        enter={true}
                        exit={true}
                        mountOnEnter={true}
                        unmountOnExit={true}
                        timeout={{
                            enter: ANIMATION_DURATION,
                            exit: ANIMATION_DURATION,
                        }}
                    >
                        <MainMenu mobile={true}/>
                    </CSSTransition>
                </div>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';
import {openMenu as openRhsMenu} from 'actions/views/rhs';
import {getIsRhsMenuOpen} from 'selectors/rhs';

import {GlobalState} from 'types/store';

import {GenericAction} from 'mattermost-redux/types/actions';

import SidebarRightMenu from './sidebar_right_menu';

function mapStateToProps(state: GlobalState) {
    const config = getConfig(state);
    const currentTeam = getCurrentTeam(state);

    const siteName = config.SiteName;

    return {
        teamDisplayName: currentTeam && currentTeam.display_name,
        isOpen: getIsRhsMenuOpen(state),
        siteName,
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            openRhsMenu,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(SidebarRightMenu);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect} from 'react';
import {useDispatch, useSelector} from 'react-redux';

import Flex from '@mattermost/compass-components/utilities/layout/Flex';

import {closeRightHandSide, showMentions} from 'actions/views/rhs';
import Search from 'components/search';

import {getRhsState} from 'selectors/rhs';

import {GlobalState} from 'types/store';

import {
    Constants,
    RHSStates,
} from 'utils/constants';
import * as Utils from 'utils/utils';

const GlobalSearchNav = (): JSX.Element => {
    const dispatch = useDispatch();
    const rhsState = useSelector((state: GlobalState) => getRhsState(state));

    useEffect(() => {
        const handleShortcut = (e: KeyboardEvent) => {
            if (Utils.cmdOrCtrlPressed(e) && e.shiftKey) {
                if (Utils.isKeyPressed(e, Constants.KeyCodes.M)) {
                    e.preventDefault();
                    if (rhsState === RHSStates.MENTION) {
                        dispatch(closeRightHandSide());
                    } else {
                        dispatch(showMentions());
                    }
                }
            }
        };

        document.addEventListener('keydown', handleShortcut);
        return () => {
            document.removeEventListener('keydown', handleShortcut);
        };
    }, [rhsState, dispatch]);

    return (
        <Flex
            row={true}
            width={432}
            flex={1}
            alignment='center'
        >
            <Search
                enableFindShortcut={true}
            />
        </Flex>
    );
};

export default GlobalSearchNav;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage, injectIntl, WrappedComponentProps} from 'react-intl';
import IconButton from '@mattermost/compass-components/components/icon-button';

import {trackEvent} from 'actions/telemetry_actions';

import {ModalIdentifiers} from 'utils/constants';

import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import Menu from 'components/widgets/menu/menu';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import KeyboardShortcutsModal from 'components/keyboard_shortcuts/keyboard_shortcuts_modal/keyboard_shortcuts_modal';

import type {PropsFromRedux} from './index';

const askTheCommunityUrl = 'https://mattermost.com/pl/default-ask-mattermost-community/';

type Props = WrappedComponentProps & PropsFromRedux & {
    location: {
        pathname: string;
    };
}

type State = {
    buttonActive: boolean;
};

class UserGuideDropdown extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);
        this.state = {
            buttonActive: false,
        };
    }

    openKeyboardShortcutsModal = (e: MouseEvent) => {
        e.preventDefault();
        this.props.actions.openModal({
            modalId: ModalIdentifiers.KEYBOARD_SHORTCUTS_MODAL,
            dialogType: KeyboardShortcutsModal,
        });
    }

    buttonToggleState = (menuActive: boolean) => {
        this.setState({
            buttonActive: menuActive,
        });
    }

    askTheCommunityClick = () => {
        trackEvent('ui', 'help_ask_the_community');
    }

    renderDropdownItems = (): React.ReactNode => {
        const {
            intl,
            pluginMenuItems,
        } = this.props;

        const pluginItems = pluginMenuItems?.map((item) => {
            return (
                <Menu.ItemAction
                    id={item.id + '_pluginmenuitem'}
                    key={item.id + '_pluginmenuitem'}
                    onClick={item.action}
                    text={item.text}
                />
            );
        });

        return (
            <Menu.Group>
                {this.props.enableAskCommunityLink === 'true' && (
                    <Menu.ItemExternalLink
                        id='askTheCommunityLink'
                        url={askTheCommunityUrl}
                        text={intl.formatMessage({id: 'userGuideHelp.askTheCommunity', defaultMessage: 'Ask the community'})}
                        onClick={this.askTheCommunityClick}
                    />
                )}
                <Menu.ItemExternalLink
                    id='helpResourcesLink'
                    url={this.props.helpLink}
                    text={intl.formatMessage({id: 'userGuideHelp.helpResources', defaultMessage: 'Help resources'})}
                />
                {this.props.reportAProblemLink && (
                    <Menu.ItemExternalLink
                        id='reportAProblemLink'
                        url={this.props.reportAProblemLink}
                        text={intl.formatMessage({id: 'userGuideHelp.reportAProblem', defaultMessage: 'Report a problem'})}
                    />
                )}
                <Menu.ItemAction
                    id='keyboardShortcuts'
                    onClick={this.openKeyboardShortcutsModal}
                    text={intl.formatMessage({id: 'userGuideHelp.keyboardShortcuts', defaultMessage: 'Keyboard shortcuts'})}
                />
                {pluginItems}
            </Menu.Group>
        );
    }

    render() {
        const {intl} = this.props;
        const tooltip = (
            <Tooltip
                id='userGuideHelpTooltip'
                className='hidden-xs'
            >
                <FormattedMessage
                    id={'channel_header.userHelpGuide'}
                    defaultMessage='Help'
                />
            </Tooltip>
        );

        return (
            <MenuWrapper
                id='helpMenuPortal'
                className='userGuideHelp'
                onToggle={this.buttonToggleState}
            >
                <OverlayTrigger
                    delayShow={500}
                    placement='bottom'
                    overlay={this.state.buttonActive ? <></> : tooltip}
                >
                    <IconButton
                        size={'sm'}
                        icon={'help-circle-outline'}
                        onClick={() => {}} // icon button currently requires onclick ... needs to revisit
                        active={this.state.buttonActive}
                        inverted={true}
                        compact={true}
                        aria-label='Select to toggle the help menu.' // proper wording and translation needed
                    />
                </OverlayTrigger>
                <Menu
                    openLeft={true}
                    openUp={false}
                    id='AddChannelDropdown'
                    ariaLabel={intl.formatMessage({id: 'sidebar_left.add_channel_dropdown.dropdownAriaLabel', defaultMessage: 'Add Channel Dropdown'})}
                >
                    {this.renderDropdownItems()}
                </Menu>
            </MenuWrapper>
        );
    }
}

export default injectIntl(UserGuideDropdown);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect, ConnectedProps} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';
import {withRouter} from 'react-router-dom';

import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {GenericAction} from 'mattermost-redux/types/actions';
import {getCurrentRelativeTeamUrl} from 'mattermost-redux/selectors/entities/teams';
import {getUseCaseOnboarding} from 'mattermost-redux/selectors/entities/preferences';
import {isFirstAdmin} from 'mattermost-redux/selectors/entities/users';

import {getUserGuideDropdownPluginMenuItems} from 'selectors/plugins';

import {GlobalState} from 'types/store';

import {openModal} from 'actions/views/modals';

import {getIsMobileView} from 'selectors/views/browser';

import UserGuideDropdown from './user_guide_dropdown';

function mapStateToProps(state: GlobalState) {
    const {HelpLink, ReportAProblemLink, EnableAskCommunityLink} = getConfig(state);

    return {
        helpLink: HelpLink || '',
        isMobileView: getIsMobileView(state),
        reportAProblemLink: ReportAProblemLink || '',
        enableAskCommunityLink: EnableAskCommunityLink || '',
        teamUrl: getCurrentRelativeTeamUrl(state),
        pluginMenuItems: getUserGuideDropdownPluginMenuItems(state),
        isFirstAdmin: isFirstAdmin(state),
        useCaseOnboarding: getUseCaseOnboarding(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            openModal,
        }, dispatch),
    };
}

const connector = connect(mapStateToProps, mapDispatchToProps);

export type PropsFromRedux = ConnectedProps<typeof connector>;

export default withRouter(connector(UserGuideDropdown));

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import styled from 'styled-components';

import {ProductIdentifier} from '@mattermost/types/products';

import Pluggable from 'plugins/pluggable';

import {isChannels} from 'utils/products';

import GlobalSearchNav from './global_search_nav/global_search_nav';
import UserGuideDropdown from './user_guide_dropdown';

const CenterControlsContainer = styled.div`
    display: flex;
    align-items: center;
    height: 40px;
    justify-content: center;
    flex-grow: 1;

    > * + * {
        margin-left: 8px;
    }
`;

export type Props = {
    productId?: ProductIdentifier;
}

const CenterControls = ({productId = null}: Props): JSX.Element => {
    return (
        <CenterControlsContainer>
            {isChannels(productId) ? (
                <>
                    <GlobalSearchNav/>
                    <UserGuideDropdown/>
                </>
            ) : (
                <Pluggable
                    pluggableName={'Product'}
                    subComponentName={'headerCentreComponent'}
                    pluggableId={productId}
                />
            )}
        </CenterControlsContainer>
    );
};

export default CenterControls;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useState, useCallback} from 'react';
import {useHistory} from 'react-router-dom';
import styled from 'styled-components';

import IconButton from '@mattermost/compass-components/components/icon-button';

import {trackEvent} from 'actions/telemetry_actions';
import * as Utils from 'utils/utils';
import Constants from 'utils/constants';
import KeyboardShortcutSequence, {
    KEYBOARD_SHORTCUTS,
    KeyboardShortcutDescriptor,
} from 'components/keyboard_shortcuts/keyboard_shortcuts_sequence';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';

const HistoryButtonsContainer = styled.nav`
    display: flex;
    align-items: center;

    > :first-child {
           margin-right: 1px;
    }
`;

const HistoryButtons = (): JSX.Element => {
    const history = useHistory();

    const [canGoBack, setCanGoBack] = useState(true);
    const [canGoForward, setCanGoForward] = useState(true);

    const getTooltip = (shortcut: KeyboardShortcutDescriptor) => (
        <Tooltip
            id='upload-tooltip'
        >
            <KeyboardShortcutSequence
                shortcut={shortcut}
                hoistDescription={true}
                isInsideTooltip={true}
            />
        </Tooltip>
    );
    const goBack = () => {
        trackEvent('ui', 'ui_history_back');
        history.goBack();
        window.postMessage(
            {
                type: 'history-button',
            },
            window.location.origin,
        );
    };

    const goForward = () => {
        trackEvent('ui', 'ui_history_forward');
        history.goForward();
        window.postMessage(
            {
                type: 'history-button',
            },
            window.location.origin,
        );
    };

    const handleButtonMessage = useCallback((message: {origin: string; data: {type: string; message: {enableBack: boolean; enableForward: boolean}}}) => {
        if (message.origin !== window.location.origin) {
            return;
        }

        switch (message.data.type) {
        case 'history-button-return': {
            setCanGoBack(message.data.message.enableBack);
            setCanGoForward(message.data.message.enableForward);
            break;
        }
        }
    }, []);

    useEffect(() => {
        window.addEventListener('message', handleButtonMessage);
        return () => {
            window.removeEventListener('message', handleButtonMessage);
        };
    }, [handleButtonMessage]);

    return (
        <HistoryButtonsContainer>
            <OverlayTrigger
                trigger={['hover', 'focus']}
                delayShow={Constants.OVERLAY_TIME_DELAY}
                placement='bottom'
                overlay={getTooltip(KEYBOARD_SHORTCUTS.browserChannelPrev)}
            >
                <IconButton
                    icon={'arrow-left'}
                    onClick={goBack}
                    size={'sm'}
                    compact={true}
                    inverted={true}
                    disabled={!canGoBack}
                    aria-label={Utils.localizeMessage('sidebar_left.channel_navigator.goBackLabel', 'Back')}
                />
            </OverlayTrigger>
            <OverlayTrigger
                trigger={['hover', 'focus']}
                delayShow={Constants.OVERLAY_TIME_DELAY}
                placement='bottom'
                overlay={getTooltip(KEYBOARD_SHORTCUTS.browserChannelNext)}
            >
                <IconButton
                    icon={'arrow-right'}
                    onClick={goForward}
                    size={'sm'}
                    compact={true}
                    inverted={true}
                    disabled={!canGoForward}
                    aria-label={Utils.localizeMessage('sidebar_left.channel_navigator.goForwardLabel', 'Forward')}
                />
            </OverlayTrigger>
        </HistoryButtonsContainer>
    );
};

export default HistoryButtons;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import HistoryButtons from './history_buttons';

export default HistoryButtons;

export default __webpack_public_path__ + "files/bf7df14bc351bc131de2771126a3cb37.svg";
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {ChannelsTourTip, ChannelsTourTipProps, TutorialTourName} from 'components/tours';

const OnboardingExploreToolsTourTip = (props: Omit<ChannelsTourTipProps, 'tourCategory'>) => {
    return (
        <ChannelsTourTip
            {...props}
            tourCategory={TutorialTourName.EXPLORE_OTHER_TOOLS}
        />
    );
};

export default OnboardingExploreToolsTourTip;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import PlaybooksImg from 'images/playbooks_tour_tip.svg';

import {useMeasurePunchouts} from '@mattermost/components';

import OnboardingExploreToolsTourTip from './onboarding_explore_tools_tour_tip';

interface PlaybooksTourTipProps {
    singleTip: boolean;
}

export const PlaybooksTourTip = ({singleTip}: PlaybooksTourTipProps) => {
    const title = (
        <FormattedMessage
            id='onboardingTour.Playbooks.title'
            defaultMessage={'Build workflows with Playbooks'}
        />
    );
    const screen = (
        <p>
            <FormattedMessage
                id='onboardingTour.Playbooks.Description'
                defaultMessage={'With checklists, automations and integrations, you can define processes that ensure best practices are followed every time.'}
            />
        </p>
    );

    const overlayPunchOut = useMeasurePunchouts(['product-menu-item-playbooks'], []);

    return (
        <OnboardingExploreToolsTourTip
            title={title}
            screen={screen}
            overlayPunchOut={overlayPunchOut}
            singleTip={singleTip}
            imageURL={PlaybooksImg}
            placement='right-start'
            pulsatingDotPlacement='right'
        />
    );
};


export default __webpack_public_path__ + "files/3a942d4e6c0dfced4569da4e013b867e.svg";
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import BoardsImg from 'images/boards_tour_tip.svg';

import {useMeasurePunchouts} from '@mattermost/components';

import OnboardingExploreToolsTourTip from './onboarding_explore_tools_tour_tip';

interface BoardsTourTipProps {
    singleTip: boolean;
}

export const BoardsTourTip = ({singleTip}: BoardsTourTipProps) => {
    const title = (
        <FormattedMessage
            id='onboardingTour.BoardsTourTip.title'
            defaultMessage={'Manage tasks with Boards'}
        />
    );
    const screen = (
        <p>
            <FormattedMessage
                id='onboardingTour.BoardsTourTip.Boards'
                defaultMessage={'Keep every project organized with kanban-style boards that integrate tightly with channel-based collaboration.'}
            />
        </p>
    );

    const overlayPunchOut = useMeasurePunchouts(['product-menu-item-focalboard'], []);

    return (
        <OnboardingExploreToolsTourTip
            title={title}
            screen={screen}
            overlayPunchOut={overlayPunchOut}
            singleTip={singleTip}
            imageURL={BoardsImg}
            placement='right-start'
            pulsatingDotPlacement='right'
        />
    );
};


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import type {GlobalState} from 'types/store';

export function isSwitcherOpen(state: GlobalState): boolean {
    return state.views.productMenu.switcherOpen;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import styled from 'styled-components';
import Icon from '@mattermost/compass-components/foundations/icon';
import Heading from '@mattermost/compass-components/components/heading';

import {useCurrentProduct} from 'utils/products';

const ProductBrandingContainer = styled.div`
    display: flex;
    align-items: center;

    > * + * {
        margin-left: 8px;
    }
`;

const ProductBranding = (): JSX.Element => {
    const currentProduct = useCurrentProduct();

    return (
        <ProductBrandingContainer tabIndex={0}>
            <Icon
                size={20}
                glyph={currentProduct && typeof currentProduct.switcherIcon === 'string' ? currentProduct.switcherIcon : 'product-channels'}
            />
            <Heading
                element='h1'
                size={200}
                margin='none'
            >
                {currentProduct ? currentProduct.switcherText : 'Channels'}
            </Heading>
        </ProductBrandingContainer>
    );
};

export default ProductBranding;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {Link} from 'react-router-dom';

import styled from 'styled-components';

import Icon, {TIconGlyph} from '@mattermost/compass-components/foundations/icon';

export interface ProductMenuItemProps {
    destination: string;
    icon: TIconGlyph;
    text: React.ReactNode;
    active: boolean;
    onClick: () => void;

    tourTip?: React.ReactNode;
    id?: string;
}

const MenuItem = styled(Link)`
    && {
        text-decoration: none;
        color: inherit;
    }

    height: 40px;
    width: 270px;
    padding-left: 16px;
    padding-right: 20px;
    display: flex;
    align-items: center;
    cursor: pointer;
    position: relative;

    &:hover {
        background: rgba(var(--center-channel-color-rgb), 0.08);
        text-decoration: none;
        color: inherit;
    }

    button {
        padding: 0 6px;
    }
`;

const StyledIcon = styled(Icon)`
    color: var(--button-bg);
`;

const MenuItemTextContainer = styled.div`
    margin-left: 8px;
    flex-grow: 1;
    font-weight: 600;
    font-size: 14px;
    line-height: 20px;
`;

const ProductMenuItem = ({icon, destination, text, active, onClick, tourTip, id}: ProductMenuItemProps): JSX.Element => (
    <MenuItem
        to={destination}
        onClick={onClick}
        id={id}
    >
        <StyledIcon
            size={20}
            glyph={icon || 'none'}
        />
        <MenuItemTextContainer>
            {text}
        </MenuItemTextContainer>
        {active && (
            <StyledIcon
                size={16}
                glyph='check'
            />
        )}
        {tourTip || null}
    </MenuItem>
);

export default ProductMenuItem;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect} from 'react';
import {useIntl} from 'react-intl';

import Icon from '@mattermost/compass-components/foundations/icon';

import {Permissions} from 'mattermost-redux/constants';

import AboutBuildModal from 'components/about_build_modal';
import SystemPermissionGate from 'components/permissions_gates/system_permission_gate';
import TeamPermissionGate from 'components/permissions_gates/team_permission_gate';
import MarketplaceModal from 'components/plugin_marketplace';
import Menu from 'components/widgets/menu/menu';
import RestrictedIndicator from 'components/widgets/menu/menu_items/restricted_indicator';
import {VisitSystemConsoleTour} from 'components/onboarding_tasks';
import UserGroupsModal from 'components/user_groups_modal';

import {FREEMIUM_TO_ENTERPRISE_TRIAL_LENGTH_DAYS} from 'utils/cloud_utils';
import {LicenseSkus, ModalIdentifiers, PaidFeatures} from 'utils/constants';
import {makeUrlSafe} from 'utils/url';
import * as UserAgent from 'utils/user_agent';

import {ModalData} from 'types/actions';

import {UserProfile} from '@mattermost/types/users';

import './product_menu_list.scss';

export type Props = {
    isMobile: boolean;
    teamId: string;
    teamName: string;
    siteName: string;
    currentUser: UserProfile;
    appDownloadLink: string;
    isMessaging: boolean;
    enableCommands: boolean;
    enableIncomingWebhooks: boolean;
    enableOAuthServiceProvider: boolean;
    enableOutgoingWebhooks: boolean;
    canManageSystemBots: boolean;
    canManageIntegrations: boolean;
    enablePluginMarketplace: boolean;
    showVisitSystemConsoleTour: boolean;
    isStarterFree: boolean;
    isFreeTrial: boolean;
    onClick?: React.MouseEventHandler<HTMLElement>;
    handleVisitConsoleClick: React.MouseEventHandler<HTMLElement>;
    enableCustomUserGroups?: boolean;
    actions: {
        openModal: <P>(modalData: ModalData<P>) => void;
        getPrevTrialLicense: () => void;
    };
};

const ProductMenuList = (props: Props): JSX.Element | null => {
    const {
        teamId,
        teamName,
        siteName,
        currentUser,
        appDownloadLink,
        isMessaging,
        enableCommands,
        enableIncomingWebhooks,
        enableOAuthServiceProvider,
        enableOutgoingWebhooks,
        canManageSystemBots,
        canManageIntegrations,
        enablePluginMarketplace,
        showVisitSystemConsoleTour,
        isStarterFree,
        isFreeTrial,
        onClick,
        handleVisitConsoleClick,
        isMobile = false,
        enableCustomUserGroups,
    } = props;
    const {formatMessage} = useIntl();

    useEffect(() => {
        props.actions.getPrevTrialLicense();
    }, []);

    if (!currentUser) {
        return null;
    }

    const openGroupsModal = () => {
        props.actions.openModal({
            modalId: ModalIdentifiers.USER_GROUPS,
            dialogType: UserGroupsModal,
            dialogProps: {
                backButtonAction: openGroupsModal,
            },
        });
    };

    const someIntegrationEnabled = enableIncomingWebhooks || enableOutgoingWebhooks || enableCommands || enableOAuthServiceProvider || canManageSystemBots;
    const showIntegrations = !isMobile && someIntegrationEnabled && canManageIntegrations;

    return (
        <Menu.Group>
            <div onClick={onClick}>
                <Menu.CloudTrial id='menuCloudTrial'/>
                <Menu.ItemCloudLimit id='menuItemCloudLimit'/>
                <SystemPermissionGate
                    permissions={[Permissions.SYSCONSOLE_WRITE_ABOUT_EDITION_AND_LICENSE]}
                >
                    <Menu.StartTrial
                        id='startTrial'
                    />
                </SystemPermissionGate>
                <SystemPermissionGate permissions={Permissions.SYSCONSOLE_READ_PERMISSIONS}>
                    <Menu.ItemLink
                        id='systemConsole'
                        show={!isMobile}
                        to='/admin_console'
                        text={(
                            <>
                                {formatMessage({id: 'navbar_dropdown.console', defaultMessage: 'System Console'})}
                                {showVisitSystemConsoleTour && (
                                    <div
                                        onClick={handleVisitConsoleClick}
                                        className={'system-console-visit'}
                                    >
                                        <VisitSystemConsoleTour/>
                                    </div>
                                )}
                            </>
                        )}
                        icon={
                            <Icon
                                size={16}
                                glyph={'application-cog'}
                            />
                        }
                    />
                </SystemPermissionGate>
                <Menu.ItemLink
                    id='integrations'
                    show={isMessaging && showIntegrations}
                    to={'/' + teamName + '/integrations'}
                    text={formatMessage({id: 'navbar_dropdown.integrations', defaultMessage: 'Integrations'})}
                    icon={
                        <Icon
                            size={16}
                            glyph={'webhook-incoming'}
                        />
                    }
                />
                <Menu.ItemToggleModalRedux
                    id='userGroups'
                    modalId={ModalIdentifiers.USER_GROUPS}
                    show={enableCustomUserGroups || isStarterFree || isFreeTrial}
                    dialogType={UserGroupsModal}
                    dialogProps={{
                        backButtonAction: openGroupsModal,
                    }}
                    text={formatMessage({id: 'navbar_dropdown.userGroups', defaultMessage: 'User Groups'})}
                    icon={
                        <Icon
                            size={16}
                            glyph={'account-multiple-outline'}
                        />
                    }
                    disabled={isStarterFree}
                    sibling={(isStarterFree || isFreeTrial) && (
                        <RestrictedIndicator
                            blocked={isStarterFree}
                            feature={PaidFeatures.CUSTOM_USER_GROUPS}
                            minimumPlanRequiredForFeature={LicenseSkus.Professional}
                            tooltipMessage={formatMessage({
                                id: 'navbar_dropdown.userGroups.tooltip.cloudFreeTrial',
                                defaultMessage: 'During your trial you are able to create user groups. These user groups will be archived after your trial.',
                            })}
                            titleAdminPreTrial={formatMessage({
                                id: 'navbar_dropdown.userGroups.modal.titleAdminPreTrial',
                                defaultMessage: 'Try unlimited user groups with a free trial',
                            })}
                            messageAdminPreTrial={formatMessage({
                                id: 'navbar_dropdown.userGroups.modal.messageAdminPreTrial',
                                defaultMessage: 'Create unlimited user groups with one of our paid plans. Get the full experience of Enterprise when you start a free, {trialLength} day trial.',
                            },
                            {
                                trialLength: FREEMIUM_TO_ENTERPRISE_TRIAL_LENGTH_DAYS,
                            },
                            )}
                            titleAdminPostTrial={formatMessage({
                                id: 'navbar_dropdown.userGroups.modal.titleAdminPostTrial',
                                defaultMessage: 'Upgrade to create unlimited user groups',
                            })}
                            messageAdminPostTrial={formatMessage({
                                id: 'navbar_dropdown.userGroups.modal.messageAdminPostTrial',
                                defaultMessage: 'User groups are a way to organize users and apply actions to all users within that group. Upgrade to the Professional plan to create unlimited user groups.',
                            })}
                            titleEndUser={formatMessage({
                                id: 'navbar_dropdown.userGroups.modal.titleEndUser',
                                defaultMessage: 'User groups available in paid plans',
                            })}
                            messageEndUser={formatMessage({
                                id: 'navbar_dropdown.userGroups.modal.messageEndUser',
                                defaultMessage: 'User groups are a way to organize users and apply actions to all users within that group.',
                            })}
                        />
                    )}
                />
                <TeamPermissionGate
                    teamId={teamId}
                    permissions={[Permissions.SYSCONSOLE_WRITE_PLUGINS]}
                >
                    <Menu.ItemToggleModalRedux
                        id='marketplaceModal'
                        modalId={ModalIdentifiers.PLUGIN_MARKETPLACE}
                        show={isMessaging && !isMobile && enablePluginMarketplace}
                        dialogType={MarketplaceModal}
                        text={formatMessage({id: 'navbar_dropdown.marketplace', defaultMessage: 'Marketplace'})}
                        icon={
                            <Icon
                                size={16}
                                glyph={'apps'}
                            />
                        }
                    />
                </TeamPermissionGate>
                <Menu.ItemExternalLink
                    id='nativeAppLink'
                    show={appDownloadLink && !UserAgent.isMobileApp()}
                    url={makeUrlSafe(appDownloadLink)}
                    text={formatMessage({id: 'navbar_dropdown.nativeApps', defaultMessage: 'Download Apps'})}
                    icon={
                        <Icon
                            size={16}
                            glyph={'download-outline'}
                        />
                    }
                />
                <Menu.ItemToggleModalRedux
                    id='about'
                    modalId={ModalIdentifiers.ABOUT}
                    dialogType={AboutBuildModal}
                    text={formatMessage({id: 'navbar_dropdown.about', defaultMessage: 'About {appTitle}'}, {appTitle: siteName})}
                    icon={
                        <Icon
                            size={16}
                            glyph={'information-outline'}
                        />
                    }
                />
            </div>
        </Menu.Group>
    );
};

export default ProductMenuList;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {Action} from 'mattermost-redux/types/actions';

import {getCloudSubscription, getSubscriptionProduct} from 'mattermost-redux/selectors/entities/cloud';
import {
    getInt,
    isCustomGroupsEnabled,
} from 'mattermost-redux/selectors/entities/preferences';
import {
    getConfig,
    getFirstAdminVisitMarketplaceStatus,
    getLicense,
    isMarketplaceEnabled,
} from 'mattermost-redux/selectors/entities/general';
import {getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentUser} from 'mattermost-redux/selectors/entities/users';
import {haveICurrentTeamPermission, haveISystemPermission} from 'mattermost-redux/selectors/entities/roles';
import {Permissions} from 'mattermost-redux/constants';
import {getPrevTrialLicense} from 'mattermost-redux/actions/admin';
import {GlobalState} from 'types/store';
import {OnboardingTaskCategory, OnboardingTasksName, TaskNameMapToSteps} from 'components/onboarding_tasks';
import {openModal} from 'actions/views/modals';
import {ModalData} from 'types/actions';
import {CloudProducts} from 'utils/constants';
import {isCloudLicense} from 'utils/license_utils';

import ProductMenuList from './product_menu_list';

type Actions = {
    openModal: <P>(modalData: ModalData<P>) => void;
    getPrevTrialLicense: () => void;
}

function mapStateToProps(state: GlobalState) {
    const config = getConfig(state);
    const currentTeam = getCurrentTeam(state) || {};
    const currentUser = getCurrentUser(state);

    const appDownloadLink = config.AppDownloadLink || '';
    const enableCommands = config.EnableCommands === 'true';
    const siteName = config.SiteName || 'Mattermost';
    const enableIncomingWebhooks = config.EnableIncomingWebhooks === 'true';
    const enableOAuthServiceProvider = config.EnableOAuthServiceProvider === 'true';
    const enableOutgoingWebhooks = config.EnableOutgoingWebhooks === 'true';
    const enablePluginMarketplace = isMarketplaceEnabled(state);
    const canManageTeamIntegrations = (haveICurrentTeamPermission(state, Permissions.MANAGE_SLASH_COMMANDS) || haveICurrentTeamPermission(state, Permissions.MANAGE_OAUTH) || haveICurrentTeamPermission(state, Permissions.MANAGE_INCOMING_WEBHOOKS) || haveICurrentTeamPermission(state, Permissions.MANAGE_OUTGOING_WEBHOOKS));
    const canManageSystemBots = (haveISystemPermission(state, {permission: Permissions.MANAGE_BOTS}) || haveISystemPermission(state, {permission: Permissions.MANAGE_OTHERS_BOTS}));
    const canManageIntegrations = canManageTeamIntegrations || canManageSystemBots;
    const step = getInt(state, OnboardingTaskCategory, OnboardingTasksName.VISIT_SYSTEM_CONSOLE, 0);
    const showVisitSystemConsoleTour = step === TaskNameMapToSteps[OnboardingTasksName.VISIT_SYSTEM_CONSOLE].STARTED;
    const enableCustomUserGroups = isCustomGroupsEnabled(state);

    const subscription = getCloudSubscription(state);
    const license = getLicense(state);
    const subscriptionProduct = getSubscriptionProduct(state);

    const isCloud = isCloudLicense(license);
    const isCloudStarterFree = isCloud && subscriptionProduct?.sku === CloudProducts.STARTER;
    const isCloudFreeTrial = isCloud && subscription?.is_free_trial === 'true';

    const isEnterpriseReady = config.BuildEnterpriseReady === 'true';
    const isSelfHostedStarter = isEnterpriseReady && (license.IsLicensed === 'false');
    const isSelfHostedFreeTrial = license.IsTrial === 'true';

    const isStarterFree = isCloudStarterFree || isSelfHostedStarter;
    const isFreeTrial = isCloudFreeTrial || isSelfHostedFreeTrial;

    return {
        isMobile: state.views.channel.mobileView,
        appDownloadLink,
        enableCommands,
        canManageIntegrations,
        enableIncomingWebhooks,
        enableOAuthServiceProvider,
        enableOutgoingWebhooks,
        canManageSystemBots,
        enablePluginMarketplace,
        pluginMenuItems: state.plugins.components.MainMenu,
        siteName,
        teamId: currentTeam.id,
        teamName: currentTeam.name,
        currentUser,
        firstAdminVisitMarketplaceStatus: getFirstAdminVisitMarketplaceStatus(state),
        showVisitSystemConsoleTour,
        enableCustomUserGroups,
        isStarterFree,
        isFreeTrial,
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, Actions>({
            openModal,
            getPrevTrialLicense,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(ProductMenuList);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useRef} from 'react';
import styled from 'styled-components';
import {useDispatch, useSelector} from 'react-redux';

import IconButton from '@mattermost/compass-components/components/icon-button';

import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {getInt} from 'mattermost-redux/selectors/entities/preferences';

import Menu from 'components/widgets/menu/menu';
import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import {BoardsTourTip, PlaybooksTourTip} from 'components/tours/onboarding_explore_tools_tour';
import {FINISHED, TutorialTourName} from 'components/tours';

import {isSwitcherOpen} from 'selectors/views/product_menu';

import {setProductMenuSwitcherOpen} from 'actions/views/product_menu';
import {
    GenericTaskSteps,
    OnboardingTaskCategory,
    OnboardingTasksName,
    TaskNameMapToSteps,
    useHandleOnBoardingTaskData,
} from 'components/onboarding_tasks';
import {ExploreOtherToolsTourSteps, suitePluginIds} from 'utils/constants';
import {useCurrentProductId, useProducts, isChannels} from 'utils/products';
import {GlobalState} from 'types/store';

import {useClickOutsideRef} from '../../hooks';

import ProductBranding from './product_branding';
import ProductMenuItem from './product_menu_item';
import ProductMenuList from './product_menu_list';

export const ProductMenuContainer = styled.nav`
    display: flex;
    align-items: center;
    cursor: pointer;

    > * + * {
        margin-left: 12px;
    }
`;

export const ProductMenuButton = styled(IconButton).attrs(() => ({
    id: 'product_switch_menu',
    icon: 'products',
    size: 'sm',

    // we currently need this, since not passing a onClick handler is disabling the IconButton
    // this is a known issue and is being tracked by UI platform team
    // TODO@UI: remove the onClick, when it is not a mandatory prop anymore
    onClick: () => {},
    inverted: true,
    compact: true,
}))`
    > i::before {
        font-size: 20px;
        letter-spacing: 20px;
    }
`;

const ProductMenu = (): JSX.Element => {
    const products = useProducts();
    const dispatch = useDispatch();
    const switcherOpen = useSelector(isSwitcherOpen);
    const menuRef = useRef<HTMLDivElement>(null);
    const currentProductID = useCurrentProductId();

    const enableTutorial = useSelector(getConfig).EnableTutorial === 'true';
    const currentUserId = useSelector(getCurrentUserId);
    const tutorialStep = useSelector((state: GlobalState) => getInt(state, TutorialTourName.EXPLORE_OTHER_TOOLS, currentUserId, 0));
    const triggerStep = useSelector((state: GlobalState) => getInt(state, OnboardingTaskCategory, OnboardingTasksName.EXPLORE_OTHER_TOOLS, FINISHED));
    const exploreToolsTourTriggered = triggerStep === GenericTaskSteps.STARTED;

    const pluginsList = useSelector((state: GlobalState) => state.plugins.plugins);
    const boards = pluginsList.focalboard;
    const playbooks = pluginsList.playbooks;

    const showBoardsTour = enableTutorial && tutorialStep === ExploreOtherToolsTourSteps.BOARDS_TOUR && exploreToolsTourTriggered && boards;
    const showPlaybooksTour = enableTutorial && tutorialStep === ExploreOtherToolsTourSteps.PLAYBOOKS_TOUR && exploreToolsTourTriggered && playbooks;

    const handleClick = () => dispatch(setProductMenuSwitcherOpen(!switcherOpen));

    const handleOnBoardingTaskData = useHandleOnBoardingTaskData();

    const visitSystemConsoleTaskName = OnboardingTasksName.VISIT_SYSTEM_CONSOLE;
    const handleVisitConsoleClick = () => {
        const steps = TaskNameMapToSteps[visitSystemConsoleTaskName];
        handleOnBoardingTaskData(visitSystemConsoleTaskName, steps.FINISHED, true, 'finish');
        localStorage.setItem(OnboardingTaskCategory, 'true');
    };

    useClickOutsideRef(menuRef, () => {
        if (exploreToolsTourTriggered || !switcherOpen) {
            return;
        }
        dispatch(setProductMenuSwitcherOpen(false));
    });

    const productItems = products?.map((product) => {
        let tourTip;

        // focalboard
        if (product.pluginId === suitePluginIds.focalboard && showBoardsTour) {
            tourTip = (<BoardsTourTip singleTip={!playbooks}/>);
        }

        // playbooks
        if (product.pluginId === suitePluginIds.playbooks && showPlaybooksTour) {
            tourTip = (<PlaybooksTourTip singleTip={!boards}/>);
        }

        return (
            <ProductMenuItem
                key={product.id}
                destination={product.switcherLinkURL}
                icon={product.switcherIcon}
                text={product.switcherText}
                active={product.id === currentProductID}
                onClick={handleClick}
                tourTip={tourTip}
                id={`product-menu-item-${product.pluginId || product.id}`}
            />
        );
    });

    return (
        <div ref={menuRef}>
            <MenuWrapper
                open={switcherOpen}
            >
                <ProductMenuContainer onClick={handleClick}>
                    <ProductMenuButton
                        active={switcherOpen}
                        aria-label='Select to open product switch menu.'
                    />
                    <ProductBranding/>
                </ProductMenuContainer>
                <Menu
                    listId={'product-switcher-menu-dropdown'}
                    className={'product-switcher-menu'}
                    ariaLabel={'switcherOpen'}
                >
                    <ProductMenuItem
                        destination={'/'}
                        icon={'product-channels'}
                        text={'Channels'}
                        active={isChannels(currentProductID)}
                        onClick={handleClick}
                    />
                    {productItems}
                    <ProductMenuList
                        isMessaging={isChannels(currentProductID)}
                        onClick={handleClick}
                        handleVisitConsoleClick={handleVisitConsoleClick}
                    />
                </Menu>
            </MenuWrapper>
        </div>
    );
};

export default ProductMenu;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import styled from 'styled-components';

import {isDesktopApp} from 'utils/user_agent';

import HistoryButtons from './history_buttons';
import ProductMenu from './product_menu';

const LeftControlsContainer = styled.div`
    display: flex;
    align-items: center;
    height: 40px;
    flex-shrink: 0;

    > * + * {
        margin-left: 12px;
    }
`;

const LeftControls = (): JSX.Element => (
    <LeftControlsContainer>
        <ProductMenu/>
        {isDesktopApp() && <HistoryButtons/>}
    </LeftControlsContainer>
);

export default LeftControls;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {GlobalState} from 'types/store';

export function isStatusDropdownOpen(state: GlobalState) {
    return state.views.statusDropdown.isOpen;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {connect} from 'react-redux';

import {bindActionCreators, Dispatch} from 'redux';

import {setStatus} from 'mattermost-redux/actions/users';

import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';

import {GlobalState} from 'types/store';
import {makeAsyncComponent} from 'components/async_load';

const DndCustomTimePicker = makeAsyncComponent('DndCustomTimePicker', React.lazy(() => import('./dnd_custom_time_picker_modal')));

function mapStateToProps(state: GlobalState) {
    const userId = getCurrentUserId(state);

    return {
        userId,
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators({
            setStatus,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(DndCustomTimePicker);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode} from 'react';
import {IntlShape, injectIntl, FormattedDate, FormattedMessage, FormattedTime} from 'react-intl';
import classNames from 'classnames';

import StatusIcon from '@mattermost/compass-components/components/status-icon';
import Text from '@mattermost/compass-components/components/text';
import Icon from '@mattermost/compass-components/foundations/icon/Icon';
import {TUserStatus} from '@mattermost/compass-components/shared';

import {PreferenceType} from '@mattermost/types/preferences';
import {PulsatingDot} from '@mattermost/components';
import {ActionFunc} from 'mattermost-redux/types/actions';
import {CustomStatusDuration, UserCustomStatus, UserProfile, UserStatus} from '@mattermost/types/users';

import * as GlobalActions from 'actions/global_actions';
import CustomStatusEmoji from 'components/custom_status/custom_status_emoji';
import CustomStatusModal from 'components/custom_status/custom_status_modal';
import CustomStatusText from 'components/custom_status/custom_status_text';
import ExpiryTime from 'components/custom_status/expiry_time';
import DndCustomTimePicker from 'components/dnd_custom_time_picker_modal';
import OverlayTrigger from 'components/overlay_trigger';
import ResetStatusModal from 'components/reset_status_modal';
import UserSettingsModal from 'components/user_settings/modal';
import EmojiIcon from 'components/widgets/icons/emoji_icon';
import Menu from 'components/widgets/menu/menu';
import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import Avatar, {TAvatarSizeToken} from 'components/widgets/users/avatar/avatar';
import {OnboardingTaskCategory, OnboardingTasksName, TaskNameMapToSteps, CompleteYourProfileTour} from 'components/onboarding_tasks';
import Tooltip from 'components/tooltip';

import {ModalData} from 'types/actions';

import {Constants, ModalIdentifiers, UserStatuses} from 'utils/constants';
import {t} from 'utils/i18n';
import {getCurrentDateTimeForTimezone, getCurrentMomentForTimezone} from 'utils/timezone';
import {localizeMessage} from 'utils/utils';

import './status_dropdown.scss';

type Props = {
    intl: IntlShape;
    status?: string;
    userId: string;
    profilePicture?: string;
    autoResetPref?: string;
    actions: {
        openModal: <P>(modalData: ModalData<P>) => void;
        setStatus: (status: UserStatus) => ActionFunc;
        unsetCustomStatus: () => ActionFunc;
        savePreferences: (userId: string, preferences: PreferenceType[]) => void;
        setStatusDropdown: (open: boolean) => void;
    };
    customStatus?: UserCustomStatus;
    currentUser: UserProfile;
    isCustomStatusEnabled: boolean;
    isCustomStatusExpired: boolean;
    isMilitaryTime: boolean;
    isStatusDropdownOpen: boolean;
    showCompleteYourProfileTour: boolean;
    showCustomStatusPulsatingDot: boolean;
    timezone?: string;
}

type State = {
    openUp: boolean;
    width: number;
    isStatusSet: boolean;
};

export class StatusDropdown extends React.PureComponent<Props, State> {
    dndTimes = [
        {id: 'thirty_minutes', label: t('status_dropdown.dnd_sub_menu_item.thirty_minutes'), labelDefault: '30 mins'},
        {id: 'one_hour', label: t('status_dropdown.dnd_sub_menu_item.one_hour'), labelDefault: '1 hour'},
        {id: 'two_hours', label: t('status_dropdown.dnd_sub_menu_item.two_hours'), labelDefault: '2 hours'},
        {id: 'tomorrow', label: t('status_dropdown.dnd_sub_menu_item.tomorrow'), labelDefault: 'Tomorrow'},
        {id: 'custom', label: t('status_dropdown.dnd_sub_menu_item.custom'), labelDefault: 'Custom'},
    ];
    static defaultProps = {
        userId: '',
        profilePicture: '',
    }

    constructor(props: Props) {
        super(props);

        this.state = {
            openUp: false,
            width: 0,
            isStatusSet: false,
        };
    }

    openProfileModal = (): void => {
        this.props.actions.openModal({
            modalId: ModalIdentifiers.USER_SETTINGS,
            dialogType: UserSettingsModal,
            dialogProps: {isContentProductSettings: false},
        });
    }

    setStatus = (status: string, dndEndTime?: number): void => {
        this.props.actions.setStatus({
            user_id: this.props.userId,
            status,
            dnd_end_time: dndEndTime,
        });
    }

    isUserOutOfOffice = (): boolean => {
        return this.props.status === UserStatuses.OUT_OF_OFFICE;
    }

    setOnline = (event: Event): void => {
        event.preventDefault();
        this.setStatus(UserStatuses.ONLINE);
    }

    setOffline = (event: Event): void => {
        event.preventDefault();
        this.setStatus(UserStatuses.OFFLINE);
    }

    setAway = (event: Event): void => {
        event.preventDefault();
        this.setStatus(UserStatuses.AWAY);
    }

    setDnd = (index: number): void => {
        const currentDate = getCurrentMomentForTimezone(this.props.timezone);
        let endTime = currentDate;
        switch (index) {
        case 0:
            // add 30 minutes in current time
            endTime = currentDate.add(30, 'minutes');
            break;
        case 1:
            // add 1 hour in current time
            endTime = currentDate.add(1, 'hour');
            break;
        case 2:
            // add 2 hours in current time
            endTime = currentDate.add(2, 'hours');
            break;
        case 3:
            // add one day in current date
            endTime = currentDate.add(1, 'day');
            break;
        }

        this.setStatus(UserStatuses.DND, endTime.utc().unix());
    }

    setCustomTimedDnd = (): void => {
        const dndCustomTimePicker = {
            modalId: ModalIdentifiers.DND_CUSTOM_TIME_PICKER,
            dialogType: DndCustomTimePicker,
            dialogProps: {
                currentDate: this.props.timezone ? getCurrentDateTimeForTimezone(this.props.timezone) : new Date(),
            },
        };

        this.props.actions.openModal(dndCustomTimePicker);
    }

    showStatusChangeConfirmation = (status: string): void => {
        const resetStatusModalData = {
            modalId: ModalIdentifiers.RESET_STATUS,
            dialogType: ResetStatusModal,
            dialogProps: {newStatus: status},
        };

        this.props.actions.openModal(resetStatusModalData);
    };

    renderProfilePicture = (size: TAvatarSizeToken): ReactNode => {
        if (!this.props.profilePicture) {
            return null;
        }
        return (
            <Avatar
                size={size}
                url={this.props.profilePicture}
                tabIndex={undefined}
            />
        );
    }

    handleClearStatus = (e: React.MouseEvent<HTMLButtonElement> | React.MouseEvent<HTMLDivElement> | React.TouchEvent): void => {
        e.stopPropagation();
        e.preventDefault();
        this.props.actions.unsetCustomStatus();
    };

    handleEmitUserLoggedOutEvent = (): void => {
        GlobalActions.emitUserLoggedOutEvent();
    }

    onToggle = (open: boolean): void => {
        this.props.actions.setStatusDropdown(open);
    }

    handleCompleteYourProfileTask = (): void => {
        const taskName = OnboardingTasksName.COMPLETE_YOUR_PROFILE;
        const steps = TaskNameMapToSteps[taskName];
        const currentUserId = this.props.currentUser.id;
        const preferences = [
            {
                user_id: currentUserId,
                category: OnboardingTaskCategory,
                name: taskName,
                value: steps.FINISHED.toString(),
            },
        ];
        this.props.actions.savePreferences(currentUserId, preferences);
    }

    handleCustomStatusEmojiClick = (event: React.MouseEvent): void => {
        event.stopPropagation();
        const customStatusInputModalData = {
            modalId: ModalIdentifiers.CUSTOM_STATUS,
            dialogType: CustomStatusModal,
        };
        this.props.actions.openModal(customStatusInputModalData);
    }

    renderCustomStatus = (isStatusSet: boolean | undefined): ReactNode => {
        if (!this.props.isCustomStatusEnabled) {
            return null;
        }
        const {customStatus} = this.props;

        let customStatusText;
        let customStatusHelpText;
        switch (true) {
        case isStatusSet && customStatus?.text && customStatus.text.length > 0:
            customStatusText = customStatus?.text;
            break;
        case isStatusSet && !customStatus?.text && customStatus?.duration === CustomStatusDuration.DONT_CLEAR:
            customStatusHelpText = localizeMessage('status_dropdown.set_custom_text', 'Set Custom Status Text...');
            break;
        case isStatusSet && !customStatus?.text && customStatus?.duration !== CustomStatusDuration.DONT_CLEAR:
            customStatusText = '';
            break;
        case !isStatusSet:
            customStatusHelpText = localizeMessage('status_dropdown.set_custom', 'Set a Custom Status');
        }

        const customStatusEmoji = isStatusSet ? (
            <span className='d-flex'>
                <CustomStatusEmoji
                    showTooltip={false}
                    emojiStyle={{marginLeft: 0}}
                />
            </span>
        ) : (
            <EmojiIcon className={'custom-status-emoji'}/>
        );

        const pulsatingDot = !isStatusSet && this.props.showCustomStatusPulsatingDot && (
            <PulsatingDot/>
        );

        const clearableTooltip = (
            <Tooltip id={'InputClearTooltip'}>
                <FormattedMessage
                    id={'input.clear'}
                    defaultMessage='Clear'
                />
            </Tooltip>
        );

        const clearButton = isStatusSet && !pulsatingDot && (
            <div
                className={classNames('status-dropdown-menu__clear-container', 'input-clear visible')}
                onClick={this.handleClearStatus}
                onTouchEnd={this.handleClearStatus}
            >
                <OverlayTrigger
                    delayShow={Constants.OVERLAY_TIME_DELAY}
                    placement={'left'}
                    overlay={clearableTooltip}
                >
                    <span
                        className='input-clear-x'
                        aria-hidden='true'
                    >
                        <i className='icon icon-close-circle'/>
                    </span>
                </OverlayTrigger>
            </div>
        );

        const expiryTime = isStatusSet && customStatus?.expires_at && customStatus.duration !== CustomStatusDuration.DONT_CLEAR &&
            (
                <ExpiryTime
                    time={customStatus.expires_at}
                    timezone={this.props.timezone}
                    className={classNames('custom_status__expiry', {
                        padded: customStatus?.text.length > 0,
                    })}
                    withinBrackets={true}
                />
            );

        return (
            <Menu.Group>
                <Menu.ItemToggleModalRedux
                    ariaLabel={customStatusText || customStatusHelpText}
                    modalId={ModalIdentifiers.CUSTOM_STATUS}
                    dialogType={CustomStatusModal}
                    className={classNames('MenuItem__primary-text custom_status__row', {
                        flex: customStatus?.text.length === 0,
                    })}
                    id={'status-menu-custom-status'}
                >
                    <span className='custom_status__container'>
                        <span className='custom_status__icon'>
                            {customStatusEmoji}
                        </span>
                        <CustomStatusText
                            text={customStatusText}
                            className='custom_status__text'
                        />
                        <Text
                            margin='none'
                            color='disabled'
                        >
                            {customStatusHelpText}
                        </Text>
                        {clearButton}
                        {pulsatingDot}
                    </span>
                    {expiryTime}
                </Menu.ItemToggleModalRedux>
            </Menu.Group>
        );
    }

    render = (): JSX.Element => {
        const {intl} = this.props;
        const needsConfirm = this.isUserOutOfOffice() && this.props.autoResetPref === '';
        const {status, customStatus, isCustomStatusExpired, currentUser} = this.props;
        const isStatusSet = customStatus && (customStatus.text.length > 0 || customStatus.emoji.length > 0) && !isCustomStatusExpired;

        const setOnline = needsConfirm ? () => this.showStatusChangeConfirmation('online') : this.setOnline;
        const setDnd = needsConfirm ? () => this.showStatusChangeConfirmation('dnd') : this.setDnd;
        const setAway = needsConfirm ? () => this.showStatusChangeConfirmation('away') : this.setAway;
        const setOffline = needsConfirm ? () => this.showStatusChangeConfirmation('offline') : this.setOffline;
        const setCustomTimedDnd = needsConfirm ? () => this.showStatusChangeConfirmation('dnd') : this.setCustomTimedDnd;

        const selectedIndicator = (
            <Icon
                glyph={'check'}
                size={16}
                color={'success'}
            />
        );

        const dndSubMenuItems = [
            {
                id: 'dndSubMenu-header',
                direction: 'right',
                text: localizeMessage('status_dropdown.dnd_sub_menu_header', 'Disable notifications until:'),
                isHeader: true,
            } as any,
        ].concat(
            this.dndTimes.map(({id, label, labelDefault}, index) => {
                let text: React.ReactNode = localizeMessage(label, labelDefault);
                if (index === 3) {
                    const tomorrow = getCurrentMomentForTimezone(this.props.timezone).add(1, 'day').toDate();
                    text = (
                        <>
                            {text}
                            <span className={`dndTime-${id}_timestamp`}>
                                <FormattedDate
                                    value={tomorrow}
                                    weekday='short'
                                />
                                {', '}
                                <FormattedTime
                                    value={tomorrow}
                                    timeStyle='short'
                                    hour12={!this.props.isMilitaryTime}
                                />
                            </span>
                        </>
                    );
                }
                return {
                    id: `dndTime-${id}`,
                    direction: 'right',
                    text,
                    action:
                        index === 4 ? () => setCustomTimedDnd() : () => setDnd(index),
                } as any;
            }),
        );

        const customStatusComponent = this.renderCustomStatus(isStatusSet);

        const menuAriaLabeltext = intl.formatMessage({
            id: 'status_dropdown.menuAriaLabel.text',
            defaultMessage: 'user status is set to {menuAriaLabelValue} you can change status by selecting your profile picture',
        }, {
            menuAriaLabelValue: this.props.status,
        });

        return (
            <MenuWrapper
                onToggle={this.onToggle}
                open={this.props.isStatusDropdownOpen}
                className={classNames('status-dropdown-menu status-dropdown-menu-global-header', {
                    active: this.props.isStatusDropdownOpen || isStatusSet,
                })}
            >
                <button
                    className='status-wrapper style--none'
                    aria-label={localizeMessage('status_dropdown.menuAriaLabel', 'Set a status')}
                >
                    <CustomStatusEmoji
                        showTooltip={true}
                        tooltipDirection={'bottom'}
                        emojiStyle={{marginRight: '6px'}}
                        onClick={this.handleCustomStatusEmojiClick as () => void}
                    />
                    {this.renderProfilePicture('sm')}
                    <button
                        className='status style--none'
                        aria-label={menuAriaLabeltext}
                    >
                        <StatusIcon
                            size={'sm'}
                            status={(this.props.status || 'offline') as TUserStatus}
                        />
                    </button>
                </button>
                <Menu
                    ariaLabel={localizeMessage('status_dropdown.menuAriaLabel', 'Set a status')}
                    id={'statusDropdownMenu'}
                    listId={'status-drop-down-menu-list'}
                >
                    {currentUser && (
                        <Menu.Header onClick={this.openProfileModal}>
                            {this.renderProfilePicture('lg')}
                            <div className={'username-wrapper'}>
                                <Text
                                    className={'bold'}
                                    margin={'none'}
                                >{`${currentUser.first_name} ${currentUser.last_name}`}</Text>
                                <Text
                                    margin={'none'}
                                    className={!currentUser.first_name && !currentUser.last_name ? 'bold' : ''}
                                    color={!currentUser.first_name && !currentUser.last_name ? undefined : 'disabled'}
                                >
                                    {'@' + currentUser.username}
                                </Text>
                            </div>
                        </Menu.Header>
                    )}
                    <Menu.Group>
                        <Menu.ItemAction
                            show={this.isUserOutOfOffice()}
                            onClick={() => null}
                            ariaLabel={localizeMessage('status_dropdown.set_ooo', 'Out of office').toLowerCase()}
                            text={localizeMessage('status_dropdown.set_ooo', 'Out of office')}
                            extraText={localizeMessage('status_dropdown.set_ooo.extra', 'Automatic Replies are enabled')}
                        />
                    </Menu.Group>
                    {customStatusComponent}
                    <Menu.Group>
                        <Menu.ItemAction
                            onClick={setOnline}
                            ariaLabel={localizeMessage('status_dropdown.set_online', 'Online').toLowerCase()}
                            text={localizeMessage('status_dropdown.set_online', 'Online')}
                            icon={(
                                <StatusIcon
                                    status={'online'}
                                    className={'status-icon'}
                                />
                            )}
                            rightDecorator={status === 'online' && selectedIndicator}
                            id={'status-menu-online'}
                        />
                        <Menu.ItemAction
                            onClick={setAway}
                            ariaLabel={localizeMessage('status_dropdown.set_away', 'Away').toLowerCase()}
                            text={localizeMessage('status_dropdown.set_away', 'Away')}
                            icon={(
                                <StatusIcon
                                    status={'away'}
                                    className={'status-icon'}
                                />
                            )}
                            rightDecorator={status === 'away' && selectedIndicator}
                            id={'status-menu-away'}
                        />
                        <Menu.ItemSubMenu
                            subMenu={dndSubMenuItems}
                            ariaLabel={`${localizeMessage('status_dropdown.set_dnd', 'Do not disturb').toLowerCase()}. ${localizeMessage('status_dropdown.set_dnd.extra', 'Disables desktop, email and push notifications').toLowerCase()}`}
                            text={localizeMessage('status_dropdown.set_dnd', 'Do not disturb')}
                            extraText={localizeMessage('status_dropdown.set_dnd.extra', 'Disables all notifications')}
                            icon={(
                                <StatusIcon
                                    status={'dnd'}
                                    className={'status-icon'}
                                />
                            )}
                            rightDecorator={status === 'dnd' && selectedIndicator}
                            direction={'left'}
                            openUp={this.state.openUp}
                            id={'status-menu-dnd'}
                        />
                        <Menu.ItemAction
                            onClick={setOffline}
                            ariaLabel={localizeMessage('status_dropdown.set_offline', 'Offline').toLowerCase()}
                            text={localizeMessage('status_dropdown.set_offline', 'Offline')}
                            icon={(
                                <StatusIcon
                                    status={'offline'}
                                    className={'status-icon'}
                                />
                            )}
                            rightDecorator={status === 'offline' && selectedIndicator}
                            id={'status-menu-offline'}
                        />
                    </Menu.Group>
                    <Menu.Group>
                        <Menu.ItemToggleModalRedux
                            id='accountSettings'
                            ariaLabel='Profile'
                            modalId={ModalIdentifiers.USER_SETTINGS}
                            dialogType={UserSettingsModal}
                            dialogProps={{isContentProductSettings: false}}
                            text={localizeMessage('navbar_dropdown.profileSettings', 'Profile')}
                            icon={(
                                <Icon
                                    size={16}
                                    glyph={'account-outline'}
                                />
                            )}
                        >
                            {this.props.showCompleteYourProfileTour && (
                                <div
                                    onClick={this.handleCompleteYourProfileTask}
                                    className={'account-settings-complete'}
                                >
                                    <CompleteYourProfileTour/>
                                </div>
                            )}
                        </Menu.ItemToggleModalRedux>
                    </Menu.Group>
                    <Menu.Group>
                        <Menu.ItemAction
                            id='logout'
                            onClick={this.handleEmitUserLoggedOutEvent}
                            text={localizeMessage('navbar_dropdown.logout', 'Log Out')}
                            icon={(
                                <Icon
                                    size={16}
                                    glyph={'exit-to-app'}
                                />
                            )}
                        />
                    </Menu.Group>
                </Menu>
            </MenuWrapper>
        );
    }
}
export default injectIntl(StatusDropdown);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {savePreferences} from 'mattermost-redux/actions/preferences';

import {setStatus, unsetCustomStatus} from 'mattermost-redux/actions/users';
import {Client4} from 'mattermost-redux/client';
import {Preferences} from 'mattermost-redux/constants';

import {get, getBool, getInt} from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentUser, getStatusForUserId} from 'mattermost-redux/selectors/entities/users';

import {openModal} from 'actions/views/modals';
import {setStatusDropdown} from 'actions/views/status_dropdown';

import {getCurrentUserTimezone} from 'selectors/general';
import {makeGetCustomStatus, isCustomStatusEnabled, showStatusDropdownPulsatingDot, isCustomStatusExpired} from 'selectors/views/custom_status';
import {isStatusDropdownOpen} from 'selectors/views/status_dropdown';
import {GenericAction} from 'mattermost-redux/types/actions';
import {GlobalState} from 'types/store';
import {
    OnboardingTaskCategory,
    OnboardingTasksName,
    TaskNameMapToSteps,
} from 'components/onboarding_tasks';

import StatusDropdown from './status_dropdown';

function makeMapStateToProps() {
    const getCustomStatus = makeGetCustomStatus();

    return function mapStateToProps(state: GlobalState) {
        const currentUser = getCurrentUser(state);

        const userId = currentUser?.id;
        const customStatus = getCustomStatus(state, userId);
        const isMilitaryTime = getBool(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.USE_MILITARY_TIME, false);
        const step = getInt(state, OnboardingTaskCategory, OnboardingTasksName.COMPLETE_YOUR_PROFILE, 0);
        const showCompleteYourProfileTour = step === TaskNameMapToSteps[OnboardingTasksName.COMPLETE_YOUR_PROFILE].STARTED;
        return {
            userId,
            profilePicture: Client4.getProfilePictureUrl(userId, currentUser?.last_picture_update),
            autoResetPref: get(state, Preferences.CATEGORY_AUTO_RESET_MANUAL_STATUS, userId, ''),
            status: getStatusForUserId(state, userId),
            customStatus,
            currentUser,
            isCustomStatusEnabled: isCustomStatusEnabled(state),
            isCustomStatusExpired: isCustomStatusExpired(state, customStatus),
            isMilitaryTime,
            isStatusDropdownOpen: isStatusDropdownOpen(state),
            showCustomStatusPulsatingDot: showStatusDropdownPulsatingDot(state),
            showCompleteYourProfileTour,
            timezone: getCurrentUserTimezone(state),
        };
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            openModal,
            setStatus,
            unsetCustomStatus,
            setStatusDropdown,
            savePreferences,
        }, dispatch),
    };
}

export default connect(makeMapStateToProps, mapDispatchToProps)(StatusDropdown);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';
import {useDispatch, useSelector} from 'react-redux';
import IconButton from '@mattermost/compass-components/components/icon-button';

import {closeRightHandSide, showMentions} from 'actions/views/rhs';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import {getRhsState} from 'selectors/rhs';
import {GlobalState} from 'types/store';
import Constants, {RHSStates} from 'utils/constants';
import KeyboardShortcutSequence, {KEYBOARD_SHORTCUTS} from 'components/keyboard_shortcuts/keyboard_shortcuts_sequence';

const AtMentionsButton = (): JSX.Element => {
    const dispatch = useDispatch();
    const rhsState = useSelector((state: GlobalState) => getRhsState(state));

    const mentionButtonClick = (e: React.MouseEvent<HTMLButtonElement>) => {
        e.preventDefault();
        if (rhsState === RHSStates.MENTION) {
            dispatch(closeRightHandSide());
        } else {
            dispatch(showMentions());
        }
    };

    const tooltip = (
        <Tooltip id='recentMentions'>
            <FormattedMessage
                id='channel_header.recentMentions'
                defaultMessage='Recent mentions'
            />
            <KeyboardShortcutSequence
                shortcut={KEYBOARD_SHORTCUTS.navMentions}
                hideDescription={true}
                isInsideTooltip={true}
            />
        </Tooltip>
    );

    return (
        <OverlayTrigger
            trigger={['hover', 'focus']}
            delayShow={Constants.OVERLAY_TIME_DELAY}
            placement='bottom'
            overlay={tooltip}
        >
            <IconButton
                size={'sm'}
                icon={'at'}
                toggled={rhsState === RHSStates.MENTION}
                onClick={mentionButtonClick}
                inverted={true}
                compact={true}
                aria-label='Select to toggle a list of recent mentions.' // proper wording and translation needed
            />
        </OverlayTrigger>
    );
};

export default AtMentionsButton;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';
import {useDispatch, useSelector} from 'react-redux';

import IconButton from '@mattermost/compass-components/components/icon-button';

import {closeRightHandSide, showFlaggedPosts} from 'actions/views/rhs';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import {getRhsState} from 'selectors/rhs';
import {GlobalState} from 'types/store';
import Constants, {RHSStates} from 'utils/constants';

const SavedPostsButton = (): JSX.Element | null => {
    const dispatch = useDispatch();
    const rhsState = useSelector((state: GlobalState) => getRhsState(state));

    const savedPostsButtonClick = (e: React.MouseEvent<HTMLButtonElement>) => {
        e.preventDefault();
        if (rhsState === RHSStates.FLAG) {
            dispatch(closeRightHandSide());
        } else {
            dispatch(showFlaggedPosts());
        }
    };

    const tooltip = (
        <Tooltip id='recentMentions'>
            <FormattedMessage
                id='channel_header.flagged'
                defaultMessage='Saved posts'
            />
        </Tooltip>
    );

    return (
        <OverlayTrigger
            trigger={['hover', 'focus']}
            delayShow={Constants.OVERLAY_TIME_DELAY}
            placement='bottom'
            overlay={tooltip}
        >
            <IconButton
                size={'sm'}
                icon={'bookmark-outline'}
                toggled={rhsState === RHSStates.FLAG}
                onClick={savedPostsButtonClick}
                inverted={true}
                compact={true}
                aria-label='Select to toggle a list of saved posts.' // proper wording and translation needed
            />
        </OverlayTrigger>
    );
};

export default SavedPostsButton;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import IconButton from '@mattermost/compass-components/components/icon-button';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import UserSettingsModal from 'components/user_settings/modal';

import {ModalData} from 'types/actions';

import Constants, {ModalIdentifiers} from 'utils/constants';

type Props = {
    actions: {
        openModal: <P>(modalData: ModalData<P>) => void;
    };
};

const SettingsButton = (props: Props): JSX.Element | null => {
    const tooltip = (
        <Tooltip id='productSettings'>
            <FormattedMessage
                id='global_header.productSettings'
                defaultMessage='Settings'
            />
        </Tooltip>
    );

    return (
        <OverlayTrigger
            trigger={['hover', 'focus']}
            delayShow={Constants.OVERLAY_TIME_DELAY}
            placement='bottom'
            overlay={tooltip}
        >
            <IconButton
                size={'sm'}
                icon={'settings-outline'}
                onClick={(): void => {
                    props.actions.openModal({modalId: ModalIdentifiers.USER_SETTINGS, dialogType: UserSettingsModal, dialogProps: {isContentProductSettings: true}});
                }}
                inverted={true}
                compact={true}
                aria-label='Select to open the settings modal.' // proper wording and translation needed
            />
        </OverlayTrigger>
    );
};

export default SettingsButton;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {bindActionCreators, Dispatch} from 'redux';
import {connect} from 'react-redux';

import {GenericAction} from 'mattermost-redux/types/actions';
import {openModal} from 'actions/views/modals';

import SettingsButton from './settings_button';

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            openModal,
        }, dispatch),
    };
}

export default connect(null, mapDispatchToProps)(SettingsButton);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect} from 'react';
import {useIntl} from 'react-intl';
import {useDispatch, useSelector} from 'react-redux';
import styled from 'styled-components';

import Constants, {CloudProducts} from 'utils/constants';
import {isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';
import {getCloudProducts, getCloudSubscription} from 'mattermost-redux/actions/cloud';
import {getCloudSubscription as selectCloudSubscription, getSubscriptionProduct as selectSubscriptionProduct, isCurrentLicenseCloud} from 'mattermost-redux/selectors/entities/cloud';
import {getConfig, getLicense} from 'mattermost-redux/selectors/entities/general';

import useOpenPricingModal, {TelemetryProps} from 'components/common/hooks/useOpenPricingModal';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';

const UpgradeButton = styled.button`
background: var(--denim-button-bg);
border-radius: 4px;
border: none;
box-shadow: none;
height: 24px;
width: auto;
font-family: 'Open Sans';
font-style: normal;
font-weight: 600;
font-size: 11px !important;
line-height: 10px;
letter-spacing: 0.02em;
color: var(--button-color);
`;

let openPricingModal: (telemetryProps?: TelemetryProps) => void;

const PlanUpgradeButton = (): JSX.Element | null => {
    const dispatch = useDispatch();
    const {formatMessage} = useIntl();

    openPricingModal = useOpenPricingModal();
    const isCloud = useSelector(isCurrentLicenseCloud);

    useEffect(() => {
        if (isCloud) {
            dispatch(getCloudSubscription());
            dispatch(getCloudProducts());
        }
    }, [isCloud]);

    const isAdmin = useSelector(isCurrentUserSystemAdmin);
    const subscription = useSelector(selectCloudSubscription);
    const product = useSelector(selectSubscriptionProduct);
    const config = useSelector(getConfig);
    const license = useSelector(getLicense);

    const isEnterpriseTrial = subscription?.is_free_trial === 'true';

    const isCloudFree = product?.sku === CloudProducts.STARTER;

    const isSelfHostedEnterpriseTrial = !isCloud && license.IsTrial === 'true';
    const isSelfHostedStarter = license.IsLicensed === 'false';
    const isEnterpriseReady = config.BuildEnterpriseReady === 'true';

    if (!isAdmin) {
        return null;
    }

    // If not on Enterprise edition, don't show
    if (!isEnterpriseReady) {
        return null;
    }

    // for cloud, only show when subscribed to free or enterprise trial plans
    if (isCloud && !(isCloudFree || isEnterpriseTrial)) {
        return null;
    }

    // for non cloud, only show when subscribed to self hosted starter or self hosted enterprise trial plans
    if (!isCloud && !(isSelfHostedStarter || isSelfHostedEnterpriseTrial)) {
        return null;
    }

    const tooltip = (
        <Tooltip id='upgrade_button_tooltip'>
            {formatMessage({id: 'pricing_modal.btn.tooltip', defaultMessage: 'Only visible to system admins'})}
        </Tooltip>
    );

    return (
        <OverlayTrigger
            trigger={['hover', 'focus']}
            delayShow={Constants.OVERLAY_TIME_DELAY}
            placement='bottom'
            overlay={tooltip}
        >
            <UpgradeButton
                id='UpgradeButton'
                onClick={() => openPricingModal({trackingLocation: 'global_header_plan_upgrade_button'})}
            >
                {formatMessage({id: 'pricing_modal.btn.viewPlans', defaultMessage: 'View plans'})}
            </UpgradeButton>
        </OverlayTrigger>);
};

export default PlanUpgradeButton;
export {openPricingModal};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useRef, useState} from 'react';
import {useSelector, useDispatch} from 'react-redux';

import {Elements} from '@stripe/react-stripe-js';

import {SelfHostedSignupProgress} from '@mattermost/types/cloud';
import {ValueOf} from '@mattermost/types/utilities';
import {getSelfHostedSignupProgress} from 'mattermost-redux/selectors/entities/cloud';
import {DispatchFunc} from 'mattermost-redux/types/actions';

import {trackEvent, pageVisited} from 'actions/telemetry_actions';
import {closeModal} from 'actions/views/modals';

import {GlobalState} from 'types/store';

import {isModalOpen} from 'selectors/views/modals';

import {STRIPE_CSS_SRC} from 'components/payment_form/stripe';

import {
    ModalIdentifiers,
    TELEMETRY_CATEGORIES,
} from 'utils/constants';

import FullScreenModal from 'components/widgets/modals/full_screen_modal';
import RootPortal from 'components/root_portal';
import useLoadStripe from 'components/common/hooks/useLoadStripe';

export default function SelfHostedPurchaseModal() {
    const show = useSelector((state: GlobalState) => isModalOpen(state, ModalIdentifiers.SELF_HOSTED_PURCHASE));
    const progress: ValueOf<typeof SelfHostedSignupProgress> = useSelector(getSelfHostedSignupProgress);

    const reduxDispatch = useDispatch<DispatchFunc>();

    const modalRef = useRef();
    const [stripeLoadHint] = useState(Math.random());

    const stripeRef = useLoadStripe(stripeLoadHint);

    useEffect(() => {
        pageVisited(
            TELEMETRY_CATEGORIES.CLOUD_PURCHASING,
            'pageview_self_hosted_purchase',
        );
    }, []);

    return (
        <Elements
            options={{fonts: [{cssSrc: STRIPE_CSS_SRC}]}}
            stripe={stripeRef.current}
        >
            <RootPortal>
                <FullScreenModal
                    show={show}
                    ref={modalRef}
                    ariaLabelledBy='self_hosted_purchase_modal_title'
                    onClose={() => {
                        trackEvent(
                            TELEMETRY_CATEGORIES.CLOUD_PURCHASING,
                            'click_close_purchasing_screen',
                        );
                        reduxDispatch(closeModal(ModalIdentifiers.SELF_HOSTED_PURCHASE));
                    }}
                >
                    {progress}
                    {'TODO: form goes here next'}
                </FullScreenModal>
            </RootPortal>
        </Elements>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useEffect, useRef, useState} from 'react';
import {Stripe} from '@stripe/stripe-js';

import {loadStripe} from '@stripe/stripe-js/pure'; // https://github.com/stripe/stripe-js#importing-loadstripe-without-side-effects

import {STRIPE_PUBLIC_KEY} from 'components/payment_form/stripe';

// reloadHint
export default function useLoadStripe(reloadHint?: number) {
    const stripeRef = useRef<Stripe | null>(null);
    const [, setDone] = useState(false);

    useEffect(() => {
        if (stripeRef.current) {
            return;
        }
        loadStripe(STRIPE_PUBLIC_KEY).then((stripe: Stripe | null) => {
            stripeRef.current = stripe;

            // deliberately cause a rerender so that the input can render.
            // otherwise, the input does not show up.
            setDone(true);
        });
    }, [reloadHint]);
    return stripeRef;
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useSelector} from 'react-redux';

import {isCurrentLicenseCloud} from 'mattermost-redux/selectors/entities/cloud';
import {isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';
import {getConfig} from 'mattermost-redux/selectors/entities/admin';

import useOpenSelfHostedPurchaseModal from 'components/common/hooks/useOpenSelfHostedPurchaseModal';

export default function SelfHostedPurchaseButton() {
    const openSelfHostedPurchaseModal = useOpenSelfHostedPurchaseModal({});
    const isAdmin = useSelector(isCurrentUserSystemAdmin);
    const isCloud = useSelector(isCurrentLicenseCloud);
    const selfHostedPurchaseEnabled = useSelector(getConfig)?.ServiceSettings?.SelfHostedFirstTimePurchase;

    if (!selfHostedPurchaseEnabled || isCloud || !isAdmin) {
        return null;
    }

    return (
        <button
            style={{
                background: 'black',
                color: 'white',
            }}
            onClick={() => {
                openSelfHostedPurchaseModal({});
            }}
        >
            {'Self-Hosted signup'}
        </button>

    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useDispatch} from 'react-redux';

import {trackEvent} from 'actions/telemetry_actions';
import {openModal} from 'actions/views/modals';
import {ModalIdentifiers, TELEMETRY_CATEGORIES} from 'utils/constants';
import SelfHostedPurchaseModal from 'components/self_hosted_purchase_modal';
import {Client4} from 'mattermost-redux/client';
import CloudTypes from 'mattermost-redux/action_types/cloud';

interface OpenPurchaseModalOptions{
    onClick?: () => void;
    trackingLocation?: string;
}
type TelemetryProps = Pick<OpenPurchaseModalOptions, 'trackingLocation'>

export default function useOpenCloudPurchaseModal(options: OpenPurchaseModalOptions) {
    const dispatch = useDispatch();
    return async (telemetryProps: TelemetryProps) => {
        if (options.onClick) {
            options.onClick();
        }
        const result = await Client4.bootstrapSelfHostedSignup();
        trackEvent(TELEMETRY_CATEGORIES.SELF_HOSTED_PURCHASING, 'click_open_purchase_modal', {
            callerInfo: telemetryProps.trackingLocation,
        });
        dispatch({
            type: CloudTypes.RECEIVED_SELF_HOSTED_SIGNUP_PROGRESS,
            data: result.progress,
        });
        dispatch(openModal({
            modalId: ModalIdentifiers.SELF_HOSTED_PURCHASE,
            dialogType: SelfHostedPurchaseModal,
            dialogProps: {
            },
        }));
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useSelector} from 'react-redux';

import styled from 'styled-components';

import {ProductIdentifier} from '@mattermost/types/products';

import {GlobalState} from 'types/store';

import Pluggable from 'plugins/pluggable';
import {
    CustomizeYourExperienceTour,
    useShowOnboardingTutorialStep,
} from 'components/tours/onboarding_tour';
import StatusDropdown from 'components/status_dropdown';
import {OnboardingTourSteps, OnboardingTourStepsForGuestUsers} from 'components/tours';

import {isChannels} from 'utils/products';

import {isCurrentUserGuestUser} from 'mattermost-redux/selectors/entities/users';

import AtMentionsButton from './at_mentions_button/at_mentions_button';
import SavedPostsButton from './saved_posts_button/saved_posts_button';
import SettingsButton from './settings_button';
import PlanUpgradeButton from './plan_upgrade_button';
import SelfHostedPurchaseButton from './self_hosted_purchase_button';

const RightControlsContainer = styled.div`
    display: flex;
    align-items: center;
    height: 40px;
    flex-shrink: 0;
    position: relative;

    > * + * {
        margin-left: 8px;
    }
`;

export type Props = {
    productId?: ProductIdentifier;
}

const RightControls = ({productId = null}: Props): JSX.Element => {
    // guest validation to see which point the messaging tour tip starts
    const isGuestUser = useSelector((state: GlobalState) => isCurrentUserGuestUser(state));
    const tourStep = isGuestUser ? OnboardingTourStepsForGuestUsers.CUSTOMIZE_EXPERIENCE : OnboardingTourSteps.CUSTOMIZE_EXPERIENCE;

    const showCustomizeTip = useShowOnboardingTutorialStep(tourStep);

    return (
        <RightControlsContainer
            id={'RightControlsContainer'}
        >
            <PlanUpgradeButton/>
            <SelfHostedPurchaseButton/>
            {isChannels(productId) ? (
                <>
                    <AtMentionsButton/>
                    <SavedPostsButton/>
                    <SettingsButton/>
                    {showCustomizeTip && <CustomizeYourExperienceTour/>}
                </>
            ) : (
                <Pluggable
                    pluggableName={'Product'}
                    subComponentName={'headerRightComponent'}
                    pluggableId={productId}
                />
            )}
            <StatusDropdown/>
        </RightControlsContainer>
    );
};

export default RightControls;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import styled from 'styled-components';

import {useCurrentProductId} from 'utils/products';

import CenterControls from './center_controls/center_controls';
import LeftControls from './left_controls/left_controls';
import RightControls from './right_controls/right_controls';

import {useIsLoggedIn} from './hooks';

const GlobalHeaderContainer = styled.header`
    position: relative;
    display: flex;
    flex-shrink: 0;
    align-items: center;
    justify-content: space-between;
    height: 40px;
    background: var(--global-header-background);
    border-bottom: solid 1px rgba(var(--center-channel-color-rgb), 0.08);
    color: rgba(var(--global-header-text-rgb), 0.64);
    padding: 0 12px;
    z-index: 99;

    > * + * {
        margin-left: 12px;
    }

    @media screen and (max-width: 768px) {
        display: none;
    }
`;

const GlobalHeader = (): JSX.Element | null => {
    const isLoggedIn = useIsLoggedIn();
    const currentProductID = useCurrentProductId();

    if (!isLoggedIn) {
        return null;
    }

    return (
        <GlobalHeaderContainer id='global-header'>
            <LeftControls/>
            <CenterControls productId={currentProductID}/>
            <RightControls productId={currentProductID}/>
        </GlobalHeaderContainer>
    );
};

export default GlobalHeader;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import useShowAdminLimitReached from 'components/common/hooks/useShowAdminLimitReached';

export default function AdminCloudEffects() {
    useShowAdminLimitReached();

    return null;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// import React from 'react';
import {useIntl} from 'react-intl';
import {useDispatch, useSelector} from 'react-redux';

import {getNeedsLoggedInLimitReachedCheck} from 'selectors/views/admin';
import {setNeedsLoggedInLimitReachedCheck} from 'actions/views/admin';
import {closeModal, openModal} from 'actions/views/modals';

import {ModalIdentifiers, Preferences} from 'utils/constants';

import CloudUsageModal from 'components/cloud_usage_modal';
import useOpenPricingModal from 'components/common/hooks/useOpenPricingModal';

import {t} from 'utils/i18n';

import useGetUsage from './useGetUsage';
import useGetLimits from './useGetLimits';
import usePreference from './usePreference';

// intended to only be run for admins of cloud instances.
export default function useShowAdminLimitReached() {
    const usage = useGetUsage();
    const dispatch = useDispatch();
    const intl = useIntl();
    const [limits, limitsLoaded] = useGetLimits();
    const needsLoggedInLimitReachedCheck = useSelector(getNeedsLoggedInLimitReachedCheck);
    const messageLimit = limits?.messages?.history;
    const [shownLimitsReachedOnLogin, setShownLimitsReachedOnLogin] = usePreference(
        Preferences.CATEGORY_CLOUD_LIMITS,
        Preferences.SHOWN_LIMITS_REACHED_ON_LOGIN,
    );
    const openPricingModal = useOpenPricingModal();

    if (!limitsLoaded || !usage.messages.historyLoaded || messageLimit === undefined || !needsLoggedInLimitReachedCheck || shownLimitsReachedOnLogin === 'true') {
        return;
    }

    if (usage.messages.history > messageLimit) {
        setShownLimitsReachedOnLogin('true');
        dispatch(openModal({
            modalId: ModalIdentifiers.CLOUD_LIMITS,
            dialogType: CloudUsageModal,
            dialogProps: {
                title: {
                    id: t('workspace_limits.modals.limits_reached.title'),
                    defaultMessage: '{limitName} limit reached',
                    values: {
                        limitName: intl.formatMessage({
                            id: t('workspace_limits.modals.limits_reached.title.message_history'),
                            defaultMessage: 'Message history',
                        }),
                    },
                },
                description: {
                    id: t('workspace_limits.modals.limits_reached.description.message_history'),
                    defaultMessage: 'Your sent message history is no longer available but you can still send messages. Upgrade to a paid plan and get unlimited access to your message history.',
                },
                secondaryAction: {
                    message: {
                        id: t('workspace_limits.modals.close'),
                        defaultMessage: 'Close',
                    },
                    onClick: () => {
                        dispatch(closeModal(ModalIdentifiers.CLOUD_LIMITS));
                    },
                },
                primaryAction: {
                    message: {
                        id: t('workspace_limits.modals.view_plan_options'),
                        defaultMessage: 'View plan options',
                    },
                    onClick: () => {
                        dispatch(closeModal(ModalIdentifiers.CLOUD_LIMITS));
                        openPricingModal({trackingLocation: 'admin_login_limit_reached_dashboard'});
                    },
                },
                onClose: () => {
                    dispatch(closeModal(ModalIdentifiers.CLOUD_LIMITS));
                },
                needsTheme: true,
            },
        }));
    }
    dispatch(setNeedsLoggedInLimitReachedCheck(false));
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useCallback, useMemo} from 'react';
import {useDispatch, useSelector} from 'react-redux';

import {PreferenceType} from '@mattermost/types/preferences';

import {savePreferences} from 'mattermost-redux/actions/preferences';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/common';
import {getMyPreferences} from 'mattermost-redux/selectors/entities/preferences';
import {getPreferenceKey} from 'mattermost-redux/utils/preference_utils';
import {ActionFunc} from 'mattermost-redux/types/actions';

export default function usePreference(category: string, name: string): [string | undefined, (value: string) => ActionFunc] {
    const dispatch = useDispatch();

    const userId = useSelector(getCurrentUserId);
    const preferences = useSelector(getMyPreferences);

    const key = getPreferenceKey(category, name);
    const preference = preferences[key];

    const setPreference = useCallback((value: string) => {
        const preference: PreferenceType = {
            category,
            name,
            user_id: userId,
            value,
        };
        return dispatch(savePreferences(userId, [preference]));
    }, [category, name, userId]);

    return useMemo(() => ([preference?.value, setPreference]), [preference?.value, setPreference]);
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useSelector} from 'react-redux';

import {isCurrentLicenseCloud} from 'mattermost-redux/selectors/entities/cloud';
import {isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';

import AdminCloudEffects from './admin_cloud_effects';

export default function CloudEffectsWrapper() {
    const isCloud = useSelector(isCurrentLicenseCloud);

    const isAdmin = useSelector(isCurrentUserSystemAdmin);

    if (!isCloud || !isAdmin) {
        return null;
    }

    // This render can become more complex if need be, rendering multiple
    // effect components according to conditions.
    return <AdminCloudEffects/>;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Route} from 'react-router-dom';

const HeaderFooterTemplate = React.lazy(() => import('components/header_footer_template'));
const LoggedIn = React.lazy(() => import('components/logged_in'));

export const HFTRoute = ({component: Component, ...rest}) => (
    <Route
        {...rest}
        render={(props) => (
            <React.Suspense fallback={null}>
                <HeaderFooterTemplate {...props}>
                    <Component {...props}/>
                </HeaderFooterTemplate>
            </React.Suspense>
        )}
    />
);

export const LoggedInHFTRoute = ({component: Component, ...rest}) => (
    <Route
        {...rest}
        render={(props) => (
            <React.Suspense fallback={null}>
                <LoggedIn {...props}>
                    <React.Suspense fallback={null}>
                        <HeaderFooterTemplate {...props}>
                            <Component {...props}/>
                        </HeaderFooterTemplate>
                    </React.Suspense>
                </LoggedIn>
            </React.Suspense>
        )}
    />
);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState, useCallback} from 'react';
import {Route} from 'react-router-dom';

import AnnouncementBar from 'components/announcement_bar';

import {HeaderProps} from './header';

import './header_footer_route.scss';

const Header = React.lazy(() => import('./header'));
const Footer = React.lazy(() => import('./footer'));

export type CustomizeHeaderType = (props: HeaderProps) => void;

export type HFRouteProps = {
    path: string;
    component: React.ComponentType<{onCustomizeHeader?: CustomizeHeaderType}>;
};

export const HFRoute = ({path, component: Component}: HFRouteProps) => {
    const [headerProps, setHeaderProps] = useState<HeaderProps>({});

    const customizeHeader: CustomizeHeaderType = useCallback((props) => {
        setHeaderProps(props);
    }, []);

    return (
        <Route
            path={path}
            render={() => (
                <>
                    <React.Suspense fallback={null}>
                        <AnnouncementBar/>
                    </React.Suspense>
                    <div className='header-footer-route'>
                        <div className='header-footer-route-container'>
                            <React.Suspense fallback={null}>
                                <Header {...headerProps}/>
                            </React.Suspense>
                            <React.Suspense fallback={null}>
                                <Component onCustomizeHeader={customizeHeader}/>
                            </React.Suspense>
                            <React.Suspense fallback={null}>
                                <Footer/>
                            </React.Suspense>
                        </div>
                    </div>
                </>
            )}
        />
    );
};

export default __webpack_public_path__ + "files/db2d7e134da4eb88e4c06772eb014385.svg";
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useState} from 'react';
import {Modal} from 'react-bootstrap';
import {useDispatch, useSelector} from 'react-redux';

import {getCurrentUserId} from 'mattermost-redux/selectors/entities/common';
import {savePreferences} from 'mattermost-redux/actions/preferences';

import {OnboardingTaskCategory, OnboardingTaskList} from '../constants';
import './onboarding_video_modal.scss';

type Props = {
    onExited: () => void;
}

const OnBoardingVideoModal = ({onExited}: Props) => {
    const [show, setShow] = useState(true);
    const dispatch = useDispatch();
    const currentUserId = useSelector(getCurrentUserId);

    const handleHide = useCallback(() => {
        setShow(false);
        const preferences = [{
            user_id: currentUserId,
            category: OnboardingTaskCategory,
            name: OnboardingTaskList.ONBOARDING_TASK_LIST_OPEN,
            value: 'true',
        }];
        dispatch(savePreferences(currentUserId, preferences));
    }, [currentUserId]);

    return (
        <Modal
            id={OnboardingTaskList.ONBOARDING_VIDEO_MODAL}
            dialogClassName='a11y__modal on-boarding-video_modal'
            show={show}
            onHide={handleHide}
            onExited={onExited}
            enforceFocus={false}
            role='dialog'
            aria-labelledby='onBoardingVideoModal'
        >
            <Modal.Header
                closeButton={true}
            />
            <Modal.Body>
                <iframe
                    src='//fast.wistia.net/embed/iframe/3t4dpc0k6b'
                    // eslint-disable-next-line react/no-unknown-property
                    allowTransparency={true}
                    frameBorder='0'
                    scrolling='no'
                    className='wistia_embed'
                    name='wistia_embed'
                    allowFullScreen={true}
                />
            </Modal.Body>
        </Modal>
    );
};

export default OnBoardingVideoModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {RefObject} from 'react';
import {usePopper} from 'react-popper';
import {CSSTransition} from 'react-transition-group';
import styled from 'styled-components';
import {Placement} from 'popper.js';

const Overlay = styled.div`
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: flex-end;
    justify-content: center;
    height: 100%;
    min-height: 100%;
    left: 0;
    right: 0;
    top: 0;
    position: fixed;
    overflow: auto;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
    pointer-events: auto;
    -ms-scroll-chaining: none;
    transition: 150ms;
    transition-property: background-color;
    transition-timing-function: ease-in-out;
    z-index: 100;
    &.fade-enter {
        background-color: rgba(0, 0, 0, 0);
    }
    &.fade-enter-active {
        background-color: rgba(0, 0, 0, 0.5);
    }
    &.fade-enter-done {
        background-color: rgba(0, 0, 0, 0.5);
    }
    &.fade-exit {
        background-color: rgba(0, 0, 0, 0.5);
    }
    &.fade-exit-active {
        background-color: rgba(0, 0, 0, 0);
    }
    &.fade-exit-done {
        background-color: rgba(0, 0, 0, 0);
    }
`;

interface TaskListPopoverProps {
    trigger: RefObject<HTMLButtonElement>;
    isVisible: boolean;
    placement?: Placement;
    offset?: [number | null | undefined, number | null | undefined];
    children?: React.ReactNode;
    onClick?: () => void;
}

export const TaskListPopover = ({
    trigger,
    placement = 'top-start',
    isVisible,
    offset = [0, 5],
    children,
    onClick,
}: TaskListPopoverProps): JSX.Element | null => {
    const [popperElement, setPopperElement] =
        React.useState<HTMLDivElement | null>(null);

    const {
        styles: {popper},
        attributes,
    } = usePopper(trigger.current, popperElement, {
        placement,
        modifiers: [
            {
                name: 'offset',
                options: {
                    offset,
                },
            },
        ],
    });
    const style = {
        ...popper,
        zIndex: isVisible ? 100 : -1,
    };
    return (
        <>
            <CSSTransition
                timeout={150}
                classNames='fade'
                in={isVisible}
                unmountOnExit={true}
            >
                <Overlay
                    onClick={onClick}
                    data-cy='onboarding-task-list-overlay'
                />
            </CSSTransition>
            <div
                ref={setPopperElement}
                style={style}
                {...attributes.popper}
            >
                {children}
            </div>
        </>
    );
};


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import styled from 'styled-components';
import StatusIcon from '@mattermost/compass-components/components/status-icon';

const Animation = styled.div`
    position: absolute;
    z-index: 30;
    flex-direction: column;
    left: 15px;
    bottom: 0;
    display: none;

    &.completed {
        display: flex;
    }

    &:before {
        content: '';
        background-color: var(--denim-status-online);
        opacity: 0;
        border-radius: 50%;
        width: 1rem;
        bottom: 15%;
        position: absolute;
        height: 1rem;
        margin-left: auto;
        margin-right: auto;
        left: 0;
        right: 0;
    }

    .x1 {
        opacity: 0;
        animation-delay: 150ms;
    }

    .x2 {
        transform: scale(0.6);
        margin-left: 6px;
        animation-delay: 250ms;
        opacity: 0;
    }
    .x3 {
        transform: scale(0.6);
        margin-left: -6px;
        animation-delay: 300ms;
        opacity: 0;
    }
    .x4 {
        transform: scale(0.2);
        opacity: 0;
    }

    &.completed {
        &:before {
            animation: opacity 800ms ease-in-out, scale 800ms linear;
        }
        .x1, .x2, .x3, .x4 {
            animation: opacity 900ms ease-in-out, moveUp 900ms linear;
        }
    }
    @keyframes moveUp {
        0% { 
            top: 0;
        }
        100% { 
            top: -50px;
        }
    }

    @keyframes opacity {
        0% { 
            opacity:0;
        }
        50% { 
            opacity: 1;
        }
        100% { 
            opacity: 0;
        }
    }

    @keyframes scale {
        0% { 
            transform: scale(0);
        }
        50% { 
            transform: scale(2);
        }
        100% { 
            transform: scale(4);
        }
    }

`;

export const CompletedAnimation = (props: {completed: boolean}) => {
    return (
        <Animation className={props.completed ? 'completed' : ''}>
            <StatusIcon
                status={'online'}
                className={'x1'}
            />
            <StatusIcon
                status={'online'}
                className={'x2'}
            />
            <StatusIcon
                status={'online'}
                className={'x3'}
            />
            <StatusIcon
                status={'online'}
                className={'x4'}
            />
        </Animation>
    );
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import styled from 'styled-components';

import {CompletedAnimation} from './onboarding_tasklist_animations';

export interface TaskProps {
    label: React.ReactElement | string;
    icon?: React.ReactNode;
    onClick?: () => void;
    completedStatus: boolean;
}

const StyledTask = styled.div`
    display: flex;
    background-color: var(--center-channel-bg);
    cursor: pointer;
    width: 100%;
    padding: 8px 20px;
    font-size: 14px;
    align-items: flex-start;
    color: var(--center-channel-color);
    position: relative;

    &.completed {
        color: var(--denim-status-online);

        span {
            text-decoration: line-through;
        }
    }

    i.play {
        margin: 3px 10px 0 0;
        color: rgba(var(--center-channel-color-rgb), 0.56);
        &.completed {
            color: var(--denim-status-online);
        }
    }
    :hover {
        background: rgba(var(--center-channel-color-rgb), 0.08);
    }
    :active {
        background-color: rgba(var(--button-bg-rgb), 0.08);
    }
    :focus {
        box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.32),
            inset 0 0 0 2px blue;
    }
    transition: background 250ms ease-in-out, color 250ms ease-in-out,
        box-shadow 250ms ease-in-out;
`;

export const Task = (props: TaskProps): JSX.Element => {
    const {label, completedStatus, onClick} = props;

    const handleOnClick = () => {
        if (onClick) {
            onClick();
        }
    };

    return (
        <StyledTask
            className={completedStatus ? 'completed' : ''}
            onClick={handleOnClick}
        >
            {completedStatus && <CompletedAnimation completed={completedStatus}/>}
            <span>{label}</span>
        </StyledTask>
    );
};

export default __webpack_public_path__ + "files/2a8c0b1b24fe26f9bfcfc0cfbaddb838.svg";
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect} from 'react';
import {CSSTransition} from 'react-transition-group';
import styled from 'styled-components';
import {FormattedMessage, useIntl} from 'react-intl';
import {useSelector, useDispatch} from 'react-redux';

import {GlobalState} from '@mattermost/types/store';

import {getLicense} from 'mattermost-redux/selectors/entities/general';
import {getPrevTrialLicense} from 'mattermost-redux/actions/admin';

import {LicenseSkus} from 'utils/constants';

import StartTrialBtn from 'components/learn_more_trial_modal/start_trial_btn';
import CloudStartTrialButton from 'components/cloud_start_trial/cloud_start_trial_btn';

import completedImg from 'images/completed.svg';

const CompletedWrapper = styled.div`
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 26px 24px 0 24px;
    margin: auto;
    text-align: center;
    word-break: break-word;
    width: 100%;
    height: 500px;

    &.fade-enter {
        transform: scale(0);
    }
    &.fade-enter-active {
        transform: scale(1);
    }
    &.fade-enter-done {
        transform: scale(1);
    }
    &.fade-exit {
        transform: scale(1);
    }
    &.fade-exit-active {
        transform: scale(1);
    }
    &.fade-exit-done {
        transform: scale(1);
    }
    .start-trial-btn, button {
        padding: 13px 20px;
        background: var(--button-bg);
        border-radius: 4px;
        color: var(--sidebar-text);
        border: none;
        font-weight: bold;
        margin-top: 15px;
        min-height: 40px;
        &:hover {
            background: var(--button-bg) !important;
            color: var(--sidebar-text) !important;
        }
    }

    h2 {
        font-size: 20px;
        margin: 0 0 10px;
        font-weight: 600;
    }

    .start-trial-text, .completed-subtitle {
        font-size: 14px !important;
        color: rgba(var(--center-channel-color-rgb), 0.72);
        line-height: 20px;
    }

    .completed-subtitle {
        margin-top: 5px;
    }

    .disclaimer, .download-apps {
        width: 90%;
        margin-top: 15px;
        color: rgba(var(--center-channel-color-rgb), 0.72);
        font-family: "Open Sans";
        font-style: normal;
        font-weight: normal;
        line-height: 16px;
    }

    .disclaimer {
        text-align: left;
        margin-top: auto;
        font-size: 11px;
    }

    .download-apps {
        margin-top: 24px;
        width: 200px;
        font-size: 12px;
    }
`;

interface Props {
    dismissAction: () => void;
    isCurrentUserSystemAdmin: boolean;
    isFirstAdmin: boolean;
}

const Completed = (props: Props): JSX.Element => {
    const {dismissAction} = props;

    const dispatch = useDispatch();

    useEffect(() => {
        dispatch(getPrevTrialLicense());
    }, []);

    const prevTrialLicense = useSelector((state: GlobalState) => state.entities.admin.prevTrialLicense);
    const license = useSelector(getLicense);
    const isPrevLicensed = prevTrialLicense?.IsLicensed;
    const isCurrentLicensed = license?.IsLicensed;

    // Cloud conditions
    const subscription = useSelector((state: GlobalState) => state.entities.cloud.subscription);
    const isCloud = license?.Cloud === 'true';
    const isFreeTrial = subscription?.is_free_trial === 'true';
    const hadPrevCloudTrial = subscription?.is_free_trial === 'false' && subscription?.trial_end_at > 0;
    const isPaidSubscription = isCloud && license?.SkuShortName !== LicenseSkus.Starter && !isFreeTrial;

    // Show this CTA if the instance is currently not licensed and has never had a trial license loaded before
    // also check that the user is a system admin (this after the onboarding task list is shown to all users)
    const selfHostedTrialCondition = (isCurrentLicensed === 'false' && isPrevLicensed === 'false') &&
    (props.isCurrentUserSystemAdmin || props.isFirstAdmin);

    // if Cloud, show if not in trial and had never been on trial
    const cloudTrialCondition = isCloud && !isFreeTrial && !hadPrevCloudTrial && !isPaidSubscription;

    const showStartTrialBtn = selfHostedTrialCondition || cloudTrialCondition;

    const {formatMessage} = useIntl();

    return (
        <>
            <CSSTransition
                in={true}
                timeout={150}
                classNames='fade'
            >
                <CompletedWrapper>
                    <img
                        src={completedImg}
                        alt={'completed tasks image'}
                    />
                    <h2>
                        <FormattedMessage
                            id={'onboardingTask.checklist.completed_title'}
                            defaultMessage='Well done. Youve completed all of the tasks!'
                        />
                    </h2>
                    <span className='completed-subtitle'>
                        <FormattedMessage
                            id={'onboardingTask.checklist.completed_subtitle'}
                            defaultMessage='We hope Mattermost is more familiar now.'
                        />
                    </span>

                    {showStartTrialBtn ? (
                        <>
                            <span className='start-trial-text'>
                                <FormattedMessage
                                    id='onboardingTask.checklist.higher_security_features'
                                    defaultMessage='Interested in our higher-security features?'
                                /> <br/>
                                <FormattedMessage
                                    id='onboardingTask.checklist.start_enterprise_now'
                                    defaultMessage='Start your free Enterprise trial now!'
                                />
                            </span>
                            {isCloud ? (
                                <CloudStartTrialButton
                                    message={formatMessage({id: 'trial_btn.free.tryFreeFor30Days', defaultMessage: 'Try free for 30 days'})}
                                    telemetryId={'start_cloud_trial_after_completing_steps'}
                                    extraClass={'btn btn-primary'}
                                    afterTrialRequest={dismissAction}
                                />
                            ) : (
                                <StartTrialBtn
                                    message={formatMessage({id: 'start_trial.modal_btn.start_free_trial', defaultMessage: 'Start free 30-day trial'})}
                                    telemetryId='start_trial_from_onboarding_completed_task'
                                    onClick={dismissAction}
                                />
                            )}
                        </>

                    ) : (
                        <button onClick={dismissAction}>
                            <FormattedMessage
                                id={'collapsed_reply_threads_modal.confirm'}
                                defaultMessage='Got it'
                            />
                        </button>
                    )}
                    <div className='download-apps'>
                        <span>
                            <FormattedMessage
                                id='onboardingTask.checklist.downloads'
                                defaultMessage='Now that youre all set up, <link>download our apps.</link>!'
                                values={{
                                    link: (msg: React.ReactNode) => (
                                        <a
                                            href='https://mattermost.com/download'
                                            target='_blank'
                                            rel='noreferrer'
                                        >
                                            {msg}
                                        </a>
                                    ),
                                }}
                            />
                        </span>
                    </div>
                    {showStartTrialBtn && <div className='disclaimer'>
                        <span>
                            <FormattedMessage
                                id='onboardingTask.checklist.disclaimer'
                                defaultMessage='By clicking Start trial, I agree to the <linkEvaluation>Mattermost Software Evaluation Agreement</linkEvaluation>, <linkPrivacy>privacy policy</linkPrivacy> and receiving product emails.'
                                values={{
                                    linkEvaluation: (msg: React.ReactNode) => (
                                        <a
                                            href='https://mattermost.com/software-evaluation-agreement'
                                            target='_blank'
                                            rel='noreferrer'
                                        >
                                            {msg}
                                        </a>
                                    ),
                                    linkPrivacy: (msg: React.ReactNode) => (
                                        <a
                                            href='https://mattermost.com/privacy-policy'
                                            target='_blank'
                                            rel='noreferrer'
                                        >
                                            {msg}
                                        </a>
                                    ),
                                }}
                            />
                        </span>
                    </div>}
                </CompletedWrapper>
            </CSSTransition>
        </>
    );
};

export default Completed;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useRef, useCallback, useEffect, useState} from 'react';
import {useDispatch, useSelector} from 'react-redux';
import styled, {css} from 'styled-components';

import Icon from '@mattermost/compass-components/foundations/icon/Icon';
import {FormattedMessage} from 'react-intl';

import {useFirstAdminUser, useIsCurrentUserSystemAdmin} from 'components/global_header/hooks';

import {getPrevTrialLicense} from 'mattermost-redux/actions/admin';
import {getShowTaskListBool} from 'selectors/onboarding';
import {getBool, getMyPreferences as getMyPreferencesSelector} from 'mattermost-redux/selectors/entities/preferences';
import {getMyPreferences, savePreferences} from 'mattermost-redux/actions/preferences';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {trackEvent} from 'actions/telemetry_actions';
import checklistImg from 'images/onboarding-checklist.svg';
import {
    useTasksListWithStatus,
    OnboardingTaskCategory,
    OnboardingTaskList,
} from 'components/onboarding_tasks';
import {useHandleOnBoardingTaskTrigger} from 'components/onboarding_tasks/onboarding_tasks_manager';
import {openModal} from 'actions/views/modals';
import {GlobalState} from 'types/store';
import OnBoardingVideoModal from 'components/onboarding_tasks/onboarding_video_modal/onboarding_video_modal';

import {Preferences, RecommendedNextStepsLegacy} from 'utils/constants';

import {TaskListPopover} from './onboarding_tasklist_popover';
import {Task} from './onboarding_tasklist_task';
import Completed from './onboarding_tasklist_completed';
import {CompletedAnimation} from './onboarding_tasklist_animations';

const TaskItems = styled.div`
    border-radius: 4px;
    border: solid 1px rgba(var(--center-channel-color-rgb), 0.16);
    background-color: var(--center-channel-bg);
    width: 352px;
    padding: 24px 0;
    transform: scale(0);
    opacity: 0;
    box-shadow: var(--elevation-6);
    transition: opacity 250ms ease-in-out 0ms, transform 250ms ease-in-out 0ms;
    transform-origin: left bottom;
    max-height: ${document.documentElement.clientHeight}px;
    overflow-y: auto;

    &.open {
        transform: scale(1);
        opacity: 1;
    }

    h1 {
        font-size: 20px;
        padding: 0 24px;
        margin: 0;
    }

    p {
        font-size: 12px;
        color: rgba(var(--center-channel-color-rgb), 0.72);
        padding: 4px 24px;
    }

    .link {
        font-size: 12px;
        color: var(--link-color);
        padding: 12px 24px 0;
        font-weight: bold;
        cursor: pointer;
        display: block;
        :hover{
          text-decoration: underline
        }
    }
`;

const Button = styled.button<{open: boolean}>(({open}) => {
    return css`
        width: 36px;
        height: 36px;
        padding: 7px;
        border-radius: 50%;
        left: 20px;
        bottom: 20px;
        position: fixed;
        z-index: 101;
        display: flex;
        align-items: center;
        background: var(--center-channel-bg);
        border: solid 1px rgba(var(--center-channel-color-rgb), 0.16);
        box-shadow: var(--elevation-3);
        
        i {
            color: rgba(var(--center-channel-color-rgb), 0.56);
        }
        
        &:hover {
            border-color: rgba(var(--center-channel-color-rgb), 0.24);
            box-shadow: var(--elevation-4);
            
            i {
                color: rgba(var(--center-channel-color-rgb), 0.72)
            }
        }

        span {
            width: 20px;
            height: 16px;
            background: var(--button-bg);
            position: fixed;
            display: ${open ? 'none' : 'block'};
            border-radius: 12px;
            color: var(--button-color);
            font-weight: bold;
            font-size: 11px;
            line-height: 16px;
            bottom: 47px;
            left: 41px;
        }
    `;
});

const PlayButton = styled.button`
    padding: 10px 20px;
    max-width: 175px;
    background: var(--button-bg);
    border-radius: 4px;
    color: var(--button-color);
    border: none;
    font-weight: bold;
    position: absolute;
    z-index: 1;
    margin-left: auto;
    margin-right: auto;
    left: 0;
    right: 0;
    top: 48px;
  
    &:hover {
        border-color: rgba(var(--center-channel-color-rgb), 0.24);
        box-shadow: var(--elevation-4);
    }

    i {
        margin-right: 10px;
        vertical-align: middle;
    }
`;

const Skeleton = styled.div`
    height: auto;
    margin: 0 auto;
    padding: 0 20px;
    position: relative;
`;

const OnBoardingTaskList = (): JSX.Element | null => {
    const myPreferences = useSelector((state: GlobalState) => getMyPreferencesSelector(state));

    useEffect(() => {
        dispatch(getPrevTrialLicense());
        if (Object.keys(myPreferences).length === 0) {
            dispatch(getMyPreferences());
        }
    }, []);

    const open = useSelector(((state: GlobalState) => getBool(state, OnboardingTaskCategory, OnboardingTaskList.ONBOARDING_TASK_LIST_OPEN)));
    const trigger = useRef<HTMLButtonElement>(null);
    const dispatch = useDispatch();
    const currentUserId = useSelector(getCurrentUserId);
    const handleTaskTrigger = useHandleOnBoardingTaskTrigger();
    const tasksList = useTasksListWithStatus();
    const [completedCount, setCompletedCount] = useState(tasksList.filter((task) => task.status).length);
    const [showAnimation, setShowAnimation] = useState(false);
    const itemsLeft = tasksList.length - completedCount;
    const isCurrentUserSystemAdmin = useIsCurrentUserSystemAdmin();
    const isFirstAdmin = useFirstAdminUser();
    const isEnableOnboardingFlow = useSelector((state: GlobalState) => getConfig(state).EnableOnboardingFlow === 'true');
    const [showTaskList, firstTimeOnboarding] = useSelector(getShowTaskListBool);

    const startTask = (taskName: string) => {
        toggleTaskList();
        handleTaskTrigger(taskName);
    };

    const initOnboardingPrefs = async () => {
        // save to preferences the show/open-task-list to true
        // also save the recomendedNextSteps-hide to true to avoid asserting to true
        // the logic to firstTimeOnboarding
        await dispatch(savePreferences(currentUserId, [
            {
                category: OnboardingTaskCategory,
                user_id: currentUserId,
                name: OnboardingTaskList.ONBOARDING_TASK_LIST_SHOW,
                value: 'true',
            },
            {
                user_id: currentUserId,
                category: OnboardingTaskCategory,
                name: OnboardingTaskList.ONBOARDING_TASK_LIST_OPEN,
                value: 'true',
            },
            {
                user_id: currentUserId,
                category: Preferences.RECOMMENDED_NEXT_STEPS,
                name: RecommendedNextStepsLegacy.HIDE,
                value: 'true',
            },
        ]));
    };

    useEffect(() => {
        if (firstTimeOnboarding) {
            initOnboardingPrefs();
        }
    }, [firstTimeOnboarding]);

    useEffect(() => {
        if (firstTimeOnboarding && showTaskList && isEnableOnboardingFlow) {
            trackEvent(OnboardingTaskCategory, OnboardingTaskList.ONBOARDING_TASK_LIST_SHOW);
        }
    }, [firstTimeOnboarding, showTaskList, isEnableOnboardingFlow]);

    // Done to show task done animation in closed state as well
    useEffect(() => {
        const newCCount = tasksList.filter((task) => task.status).length;
        const show = localStorage.getItem(OnboardingTaskCategory);
        if (show || ((completedCount + 1) === newCCount && !open)) {
            setTimeout(() => {
                setShowAnimation(true);
                setCompletedCount(newCCount);
            }, 100);
            setTimeout(() => {
                setShowAnimation(false);
                setCompletedCount(newCCount);
            }, 500);
            localStorage.removeItem(OnboardingTaskCategory);
        } else {
            setCompletedCount(newCCount);
        }
    }, [tasksList, completedCount]);

    const dismissChecklist = useCallback(() => {
        const preferences = [{
            user_id: currentUserId,
            category: OnboardingTaskCategory,
            name: OnboardingTaskList.ONBOARDING_TASK_LIST_SHOW,
            value: 'false',
        },
        {
            user_id: currentUserId,
            category: OnboardingTaskCategory,
            name: OnboardingTaskList.ONBOARDING_TASK_LIST_OPEN,
            value: 'false',
        }];
        dispatch(savePreferences(currentUserId, preferences));
        trackEvent(OnboardingTaskCategory, OnboardingTaskList.DECLINED_ONBOARDING_TASK_LIST);
    }, [currentUserId]);

    const toggleTaskList = useCallback(() => {
        const preferences = [{
            user_id: currentUserId,
            category: OnboardingTaskCategory,
            name: OnboardingTaskList.ONBOARDING_TASK_LIST_OPEN,
            value: String(!open),
        }];
        dispatch(savePreferences(currentUserId, preferences));
        trackEvent(OnboardingTaskCategory, open ? OnboardingTaskList.ONBOARDING_TASK_LIST_CLOSE : OnboardingTaskList.ONBOARDING_TASK_LIST_OPEN);
    }, [open, currentUserId]);

    const openVideoModal = useCallback(() => {
        toggleTaskList();
        dispatch(openModal({
            modalId: OnboardingTaskList.ONBOARDING_VIDEO_MODAL,
            dialogType: OnBoardingVideoModal,
            dialogProps: {},
        }));
    }, []);

    if (Object.keys(myPreferences).length === 0 || !showTaskList || !isEnableOnboardingFlow) {
        return null;
    }

    return (
        <>
            <CompletedAnimation completed={showAnimation}/>
            <Button
                onClick={toggleTaskList}
                ref={trigger}
                open={open}
                data-cy='onboarding-task-list-action-button'
            >
                <Icon glyph={open ? 'close' : 'playlist-check'}/>
                {itemsLeft !== 0 && (<span>{itemsLeft}</span>)}
            </Button>
            <TaskListPopover
                isVisible={open}
                trigger={trigger}
                onClick={toggleTaskList}
            >
                <TaskItems className={open ? 'open' : ''}>
                    {completedCount === tasksList.length ?
                        <Completed
                            dismissAction={dismissChecklist}
                            isFirstAdmin={isFirstAdmin}
                            isCurrentUserSystemAdmin={isCurrentUserSystemAdmin}
                        /> : (
                            <>
                                <h1>
                                    <FormattedMessage
                                        id='next_steps_view.welcomeToMattermost'
                                        defaultMessage='Welcome to Mattermost'
                                    />
                                </h1>
                                <p>
                                    <FormattedMessage
                                        id='onboardingTask.checklist.main_subtitle'
                                        defaultMessage="Let's get up and running."
                                    />
                                </p>
                                <Skeleton>
                                    <img
                                        src={checklistImg}
                                        alt={'On Boarding video'}
                                        style={{display: 'block', margin: '1rem auto', borderRadius: '4px'}}
                                    />
                                    <PlayButton
                                        onClick={openVideoModal}
                                    >
                                        <Icon
                                            glyph={'play'}
                                            size={16}
                                        />
                                        <FormattedMessage
                                            id='onboardingTask.checklist.video_title'
                                            defaultMessage='Watch overview'
                                        />
                                    </PlayButton>
                                </Skeleton>
                                {tasksList.map((task) => (
                                    <Task
                                        key={OnboardingTaskCategory + task.name}
                                        label={task.label}
                                        onClick={() => {
                                            startTask(task.name);
                                        }}
                                        completedStatus={task.status}
                                    />
                                ))}
                                <span
                                    className='link'
                                    onClick={dismissChecklist}
                                >
                                    <FormattedMessage
                                        id='onboardingTask.checklist.dismiss_link'
                                        defaultMessage='No thanks, Ill figure it out myself'
                                    />
                                </span>
                            </>
                        )}
                </TaskItems>
            </TaskListPopover>
        </>
    );
};

export default OnBoardingTaskList;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect} from 'react';
import {useIntl} from 'react-intl';
import {useSelector, useDispatch} from 'react-redux';

import Markdown from 'components/markdown';

import useOpenPricingModal from 'components/common/hooks/useOpenPricingModal';

import {getUsers} from 'mattermost-redux/selectors/entities/users';
import useOpenCloudPurchaseModal from 'components/common/hooks/useOpenCloudPurchaseModal';
import {openModal} from 'actions/views/modals';
import LearnMoreTrialModal from 'components/learn_more_trial_modal/learn_more_trial_modal';
import {ModalIdentifiers, PaidFeatures} from 'utils/constants';
import {trackEvent} from 'actions/telemetry_actions';
import {mapFeatureIdToTranslation} from 'utils/notify_admin_utils';
import {getMissingProfilesByIds} from 'mattermost-redux/actions/users';

import {Post} from '@mattermost/types/posts';

const MinimumPlansForFeature = {
    Professional: 'Professional plan',
    Enterprise: 'Enterprise plan',
};

type FeatureRequest = {
    user_id: string;
    required_feature: string;
    required_plan: string;
    create_at: string;
    trial: string;
}

type RequestedFeature = Record<string, FeatureRequest[]>

type CustomPostProps = {
    requested_features: RequestedFeature;
    trial: boolean;
}

const style = {
    display: 'flex',
    gap: '10px',
    padding: '12px',
    borderRadius: '4px',
    border: '1px solid rgba(var(--center-channel-text-rgb), 0.16)',
    width: 'max-content',
    margin: '10px 0',
};

const btnStyle = {
    background: 'var(--button-bg)',
    color: 'var(--button-color)',
    border: 'none',
    borderRadius: '4px',
    padding: '8px 20px',
    fontWeight: 600,
};

const messageStyle = {
    marginBottom: '16px',
};

export default function OpenPricingModalPost(props: {post: Post}) {
    let allProfessional = true;

    const dispatch = useDispatch();
    const userProfiles = useSelector(getUsers);

    const openPurchaseModal = useOpenCloudPurchaseModal({});
    const {formatMessage} = useIntl();

    const openPricingModal = useOpenPricingModal();

    const getUserIdsForUsersThatRequestedFeature = (requests: FeatureRequest[]): string[] => requests.map((request: FeatureRequest) => request.user_id);
    const postProps = props.post.props as Partial<CustomPostProps>;
    const requestFeatures = postProps?.requested_features;
    const wasTrialRequest = postProps?.trial;

    useEffect(() => {
        if (requestFeatures) {
            for (const featureId of Object.keys(requestFeatures)) {
                dispatch(getMissingProfilesByIds(getUserIdsForUsersThatRequestedFeature(requestFeatures[featureId])));
            }
        }
    }, [dispatch, requestFeatures]);

    const isDowngradeNotification = (featureId: string) => featureId === PaidFeatures.UPGRADE_DOWNGRADED_WORKSPACE;

    const customMessageBody = [];

    const getUserNamesForUsersThatRequestedFeature = (requests: FeatureRequest[]): string[] => {
        const unknownName = formatMessage({id: 'postypes.custom_open_pricing_modal_post_renderer.unknown', defaultMessage: '@unknown'});
        const userNames = requests.map((req: FeatureRequest) => {
            const username = userProfiles[req.user_id]?.username;
            return username ? '@' + username : unknownName;
        });

        return userNames;
    };

    const renderUsersThatRequestedFeature = (requests: FeatureRequest[]) => {
        if (requests.length >= 5) {
            return formatMessage({
                id: 'postypes.custom_open_pricing_modal_post_renderer.members',
                defaultMessage: '{members} members'},
            {members: requests.length});
        }

        let renderedUsers;

        const users = getUserNamesForUsersThatRequestedFeature(requests);

        if (users.length === 1) {
            renderedUsers = users[0];
        } else {
            const lastUser = users.splice(-1, 1)[0];
            users.push(formatMessage({id: 'postypes.custom_open_pricing_modal_post_renderer.and', defaultMessage: 'and '}) + lastUser);
            renderedUsers = users.join(', ').replace(/,([^,]*)$/, '$1');
        }

        return renderedUsers;
    };

    const markDownOptions = {
        atSumOfMembersMentions: true,
        atPlanMentions: true,
        markdown: false,
    };

    const mapFeatureToPlan = (feature: string) => {
        switch (feature) {
        case PaidFeatures.ALL_ENTERPRISE_FEATURES:
        case PaidFeatures.CUSTOM_USER_GROUPS:
            allProfessional = false;
            return MinimumPlansForFeature.Enterprise;
        default:
            return MinimumPlansForFeature.Professional;
        }
    };

    if (requestFeatures) {
        for (const featureId of Object.keys(requestFeatures)) {
            let title = (
                <div id={`${featureId}-title`.replaceAll('.', '_')}>
                    <span>
                        <b>
                            {mapFeatureIdToTranslation(featureId, formatMessage)}
                        </b>
                    </span>
                    <span>
                        <Markdown
                            message={formatMessage({id: 'postypes.custom_open_pricing_modal_post_renderer.availableOn', defaultMessage: ' - available on the {feature}'}, {feature: mapFeatureToPlan(featureId)})}
                            options={{...markDownOptions, atSumOfMembersMentions: false}}
                        />
                    </span>
                </div>);
            let subTitle = (
                <ul id={`${featureId}-subtitle`.replaceAll('.', '_')}>
                    <li>
                        <Markdown
                            postId={props.post.id}
                            message={formatMessage({id: 'postypes.custom_open_pricing_modal_post_renderer.userRequests', defaultMessage: '{userRequests} requested access to this feature'}, {userRequests: renderUsersThatRequestedFeature(requestFeatures[featureId])})}
                            options={markDownOptions}
                            userIds={getUserIdsForUsersThatRequestedFeature(requestFeatures[featureId])}
                            messageMetadata={{requestedFeature: featureId}}
                        />
                    </li>
                </ul>);

            if (isDowngradeNotification(featureId)) {
                title = (
                    <div id={`${featureId}-title`.replaceAll('.', '_')}>
                        <span>
                            <b>
                                {mapFeatureIdToTranslation(featureId, formatMessage)}
                            </b>
                        </span>
                    </div>);
                subTitle = (
                    <ul id={`${featureId}-subtitle`.replaceAll('.', '_')}>
                        <li>
                            <Markdown
                                postId={props.post.id}
                                message={formatMessage({id: 'postypes.custom_open_pricing_modal_post_renderer.downgradeNotfication', defaultMessage: '{userRequests} requested to revert the workspace to a paid plan'}, {userRequests: renderUsersThatRequestedFeature(requestFeatures[featureId])})}
                                options={markDownOptions}
                                userIds={getUserIdsForUsersThatRequestedFeature(requestFeatures[featureId])}
                                messageMetadata={{requestedFeature: featureId}}
                            />
                        </li>
                    </ul>);
            }

            const featureMessage = (
                <div style={messageStyle}>
                    {title}
                    {subTitle}
                </div>
            );

            customMessageBody.push(featureMessage);
        }
    }

    const openLearnMoreTrialModal = () => {
        dispatch(openModal({
            modalId: ModalIdentifiers.LEARN_MORE_TRIAL_MODAL,
            dialogType: LearnMoreTrialModal,
        }));
    };

    const renderButtons = () => {
        if (wasTrialRequest) {
            return (
                <>
                    <button
                        id='learn_more_about_trial'
                        onClick={() => {
                            trackEvent('cloud_admin', 'click_learn_more_trial_modal', {
                                callerInfo: 'notify_admin_learn_more_about_trial',
                            });
                            openLearnMoreTrialModal();
                        }}
                        style={btnStyle}
                    >
                        {formatMessage({id: 'postypes.custom_open_pricing_modal_post_renderer.learn_trial', defaultMessage: 'Learn more about trial'})}
                    </button>
                    <button
                        onClick={() => openPricingModal({trackingLocation: 'notify_admin_message_view_upgrade_options'})}
                        style={{...btnStyle, color: 'var(--button-bg)', background: 'rgba(var(--denim-button-bg-rgb), 0.08)'}}
                    >
                        {formatMessage({id: 'postypes.custom_open_pricing_modal_post_renderer.view_options', defaultMessage: 'View upgrade options'})}
                    </button>
                </>
            );
        }

        if (allProfessional) {
            return (
                <>
                    <button
                        id='upgrade_to_professional'
                        onClick={() => openPurchaseModal({trackingLocation: 'notify_admin_message_view'})}
                        style={btnStyle}
                    >
                        {formatMessage({id: 'postypes.custom_open_pricing_modal_post_renderer.upgrade_professional', defaultMessage: 'Upgrade to Professional'})}
                    </button>
                    <button
                        id='view_upgrade_options'
                        onClick={() => openPricingModal({trackingLocation: 'notify_admin_message_view_upgrade_options'})}
                        style={{...btnStyle, color: 'var(--button-bg)', background: 'rgba(var(--denim-button-bg-rgb), 0.08)'}}
                    >
                        {formatMessage({id: 'postypes.custom_open_pricing_modal_post_renderer.view_options', defaultMessage: 'View upgrade options'})}
                    </button>
                </>
            );
        }
        return (
            <button
                id='view_upgrade_options'
                onClick={() => openPricingModal({trackingLocation: 'notify_admin_message_view_upgrade_options'})}
                style={{...btnStyle, border: '1px solid var(--button-bg)', color: 'var(--button-bg)', background: 'var(--sidebar-text)'}}
            >
                {formatMessage({id: 'postypes.custom_open_pricing_modal_post_renderer.view_options', defaultMessage: 'View upgrade options'})}
            </button>
        );
    };

    return (
        <div>
            <div style={messageStyle}>
                <Markdown
                    message={props.post.message}
                    options={{...markDownOptions, atSumOfMembersMentions: false}}
                />
            </div>
            {customMessageBody}
            <div style={{display: 'flex'}}>
                <div
                    style={style}
                >
                    {renderButtons()}
                </div>
            </div>
        </div>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import * as React from 'react';

const SvgComponent = (props: React.SVGProps<SVGSVGElement>) => (
    <svg
        width={322}
        height={246}
        fill='none'
        xmlns='http://www.w3.org/2000/svg'
        xmlnsXlink='http://www.w3.org/1999/xlink'
        {...props}
    >
        <g clipPath='url(#a)'>
            <path
                d='M28.985 202.376H293.15a7.321 7.321 0 0 0 5.214-2.175 7.305 7.305 0 0 0 1.578-2.403c.36-.898.538-1.858.523-2.824V18.865a7.283 7.283 0 0 0-4.489-6.837 7.335 7.335 0 0 0-2.826-.565H28.986a7.338 7.338 0 0 0-5.214 2.175 7.286 7.286 0 0 0-2.101 5.227v176.13a7.262 7.262 0 0 0 2.109 5.214 7.326 7.326 0 0 0 5.205 2.167ZM.5 228.238C.5 237.119 7.72 246 16.53 246h288.94c8.36 0 16.02-8.86 16.02-17.762H.5Z'
                fill='#24262E'
            />
            <path
                d='M294.749 202.376H27.251L.5 228.238h321l-26.751-25.862Z'
                fill='#DDDFE4'
            />
            <path
                d='M285.909 204.438H36.238l-8.904 10.869h267.488l-8.913-10.869Z'
                fill='#BABEC9'
            />
            <path
                d='M188.519 220.097h-54.881l-4.117 5.424h63.115l-4.117-5.424Z'
                fill='#2D3039'
            />
            <path
                d='M161.068 15.596a4.189 4.189 0 0 1 3.862 2.571 4.155 4.155 0 0 1-.906 4.539 4.188 4.188 0 0 1-6.431-.631 4.149 4.149 0 0 1 .519-5.259 4.188 4.188 0 0 1 2.956-1.22Z'
                fill='#DDDFE4'
            />
            <path
                d='M184.088 239.764h-46.187c-1.588 0-5.799 0-5.799-5.373h57.796c0 5.373-4.253 5.373-5.81 5.373Z'
                fill='#3F4350'
            />
            <path
                d='M284.122 27.549H38.035V186.3h246.087V27.549Z'
                fill='#DDDFE4'
            />
            <path
                d='M62.34 171.049c5.225-8.61 29.99-26.841 38.831-31.703 28.015-15.388 59.563-27.403 91.34-23.946 4.065.437 8.203 1.156 11.766 3.175-3.25 6.778-.481 14.722.136 22.218a4.158 4.158 0 0 1-.251 2.176 4.31 4.31 0 0 1-2.184 1.697c-30.022 14.181-60.304 28.163-87.923 46.57-6.269 4.165-12.006 9.443-19.175 11.609-7.168 2.166-22.81 0-28.38-4.945-4.828-4.321-12.3-13.4-4.16-26.851Z'
                fill='#CB8E00'
            />
            <path
                d='M62.34 171.049c5.225-8.61 29.99-26.841 38.831-31.703 28.015-15.388 59.563-27.403 91.34-23.946 4.065.437 8.203 1.156 11.766 3.175-3.25 6.778-.481 14.722.136 22.218a4.158 4.158 0 0 1-.251 2.176 4.31 4.31 0 0 1-2.184 1.697c-30.022 14.181-60.304 28.163-87.923 46.57-6.269 4.165-12.006 9.443-19.175 11.609-7.168 2.166-22.81 0-28.38-4.945-4.828-4.321-12.3-13.4-4.16-26.851Z'
                fill='#CB8E00'
            />
            <path
                d='M62.34 171.049c5.225-8.61 29.99-26.841 38.831-31.703 28.015-15.388 59.563-27.403 91.34-23.946 4.065.437 8.203 1.156 11.766 3.175-3.25 6.778-.481 14.722.136 22.218a4.158 4.158 0 0 1-.251 2.176 4.31 4.31 0 0 1-2.184 1.697c-30.022 14.181-60.304 28.163-87.923 46.57-6.269 4.165-12.006 9.443-19.175 11.609-7.168 2.166-22.81 0-28.38-4.945-4.828-4.321-12.3-13.4-4.16-26.851Z'
                fill='#CB8E00'
            />
            <path
                d='M62.34 171.049c5.225-8.61 29.99-26.841 38.831-31.703 28.015-15.388 59.563-27.403 91.34-23.946 4.065.437 8.203 1.156 11.766 3.175-3.25 6.778-.481 14.722.136 22.218a4.158 4.158 0 0 1-.251 2.176 4.31 4.31 0 0 1-2.184 1.697c-30.022 14.181-60.304 28.163-87.923 46.57-6.269 4.165-12.006 9.443-19.175 11.609-7.168 2.166-22.81 0-28.38-4.945-4.828-4.321-12.3-13.4-4.16-26.851Z'
                fill='#CB8E00'
            />
            <path
                d='M201.205 116.045c-19.718 19.428-38.381 46.237-39.771 69.954-9.823.854-21.944 1.218-30.105-.156 10.648-32.411-11.673-56.523-12.31-55.722 47.013-22.894 82.186-14.076 82.186-14.076Z'
                fill='#fff'
            />
            <path
                d='M119.04 130.715a57.9 57.9 0 0 1 14.107 31.473c.084.687 1.139.427 1.045-.26a58.846 58.846 0 0 0-14.379-31.963c-.459-.52-1.254.229-.783.75h.01Z'
                fill='#14213E'
            />
            <path
                d='M157.181 162.386a33.363 33.363 0 0 0 2.424-9.203c.084-.688-1.045-.708-1.045 0a30.789 30.789 0 0 1-2.247 8.651c-.282.635.638 1.208.92.573l-.052-.021Z'
                fill='#fff'
            />
            <path
                d='M179.48 65.716c-8.308 3.124-12.832 13.223-10.805 21.864 2.027 8.642 9.666 15.336 18.276 17.554 2.72.844 5.63.862 8.36.052a15.28 15.28 0 0 0 5.664-4.06 41.708 41.708 0 0 0 5.642-7.288 21.943 21.943 0 0 0 3.428-9.173c.554-5.789-2.466-11.577-7.022-15.21-4.556-3.635-10.45-5.29-16.291-5.571-.637-.073-7.252 1.832-7.252 1.832Z'
                fill='#1A0C00'
            />
            <mask
                id='b'
                style={{
                    maskType: 'alpha',
                }}
                maskUnits='userSpaceOnUse'
                x={38}
                y={27}
                width={247}
                height={160}
            >
                <path
                    d='M284.122 27.549H38.035v158.753h246.087V27.549Z'
                    fill='#DDDFE4'
                />
            </mask>
            <g mask='url(#b)'>
                <path
                    fill='url(#c)'
                    d='M200.5 115.5h84v71h-84z'
                />
                <path
                    d='M256.514 186.364c14.629-5.727 4.483-53.869 3.908-54.337-8.224-6.684-18.673-10.006-29.029-12.327-26.981-6.039-83.596 10.817-84.641 12.306-1.798 2.436-.847 39.272 13.626 52.796 22.989 3.644 96.136-1.041 96.136 1.562Z'
                    fill='#fff'
                />
                <path
                    d='M258.144 166.27c-1.327 6.028-2.09 12.16-3.406 18.199-.147.676.898 1.041 1.045.312 1.264-6.049 2.09-12.181 3.406-18.209.146-.677-.899-1.042-1.045-.302Z'
                    fill='#14213E'
                />
            </g>
            <path
                d='m195.05 120.699-.533-17.283a12.846 12.846 0 0 0-.648-4.414 15.555 15.555 0 0 0-2.288-3.477 48.617 48.617 0 0 1-9.844-34.723 24.673 24.673 0 0 1 2.247-8.464c2.999-5.976 9.269-9.568 15.476-12.108 4.472-1.822 9.331-3.311 14.075-2.437 5.789 1.042 10.533 5.591 12.905 10.953 2.372 5.362 2.634 11.453 1.923 17.262a28.042 28.042 0 0 1-3.542 11.453c-1.965 3.186-4.859 5.736-6.845 8.922-3.344 5.362 1.348 12.098 1.286 18.418-.063 6.32 6.708 14.972 4.409 20.823-2.299 5.851-14.734 17.887-24.713 14.576-7.764-2.572-6.207-13.67-4.796-16.773l.888-2.728Z'
                fill='#CB8E00'
            />
            <path
                d='M206.941 99.096c-3.814.916-10.815 1.041-14.629-2.593a10.65 10.65 0 0 1 1.536 2.499c.472 1.423.691 2.916.648 4.414.073 2.291.136 4.581.209 6.872 1.641-9.725 8.673-7.955 12.466-10.089l-.23-1.103Z'
                fill='#814B23'
            />
            <path
                d='M96.96 205.594c22.466 1.822 39.854 2.956 58.705 3.415 18.047.447 34.369 2.55 43.972-6.768 9.029-8.766 21.359-10.765 34.097-10.536 1.045 0 1.693-1.25.857-1.843a13.68 13.68 0 0 0-5.988-1.801c-4.315-.344-8.014-.427-8.025-.448a6.513 6.513 0 0 0-3.762-3.05 19.23 19.23 0 0 0-6.541-.583c-1.975.208-1.223-.937-4.671-1.375a32.575 32.575 0 0 0-10.042.75c-4.065 1.041-10.084 3.55-15.131 5.747-7.618 3.321-24.149-1.676-31.955-4.602-7.544-2.821-17.534-7.808-24.912-10.921-9.206-3.873-13.657-7.559-22.069-9.162-9.74-1.864-17.367-2.905-26.94.302-9.57 3.206-17.763 12.025-16.259 20.822a19.973 19.973 0 0 0 4.807 9.256c7.628 9.068 16.542 9.703 29.447 10.474l4.41.323Z'
                fill='#CB8E00'
            />
            <mask
                id='d'
                style={{
                    maskType: 'alpha',
                }}
                maskUnits='userSpaceOnUse'
                x={58}
                y={162}
                width={177}
                height={48}
            >
                <path
                    d='M96.96 205.594c22.466 1.822 39.854 2.956 58.705 3.415 18.047.447 34.369 2.55 43.972-6.768 9.029-8.766 21.359-10.765 34.097-10.536 1.045 0 1.693-1.25.857-1.843a13.68 13.68 0 0 0-5.988-1.801c-4.315-.344-8.014-.427-8.025-.448a6.513 6.513 0 0 0-3.762-3.05 19.23 19.23 0 0 0-6.541-.583c-1.975.208-1.223-.937-4.671-1.375a32.575 32.575 0 0 0-10.042.75c-4.065 1.041-10.084 3.55-15.131 5.747-7.618 3.321-24.149-1.676-31.955-4.602-7.544-2.821-17.534-7.808-24.912-10.921-9.206-3.873-13.657-7.559-22.069-9.162-9.74-1.864-17.367-2.905-26.94.302-9.57 3.206-17.763 12.025-16.259 20.822a19.973 19.973 0 0 0 4.807 9.256c7.628 9.068 16.542 9.703 29.447 10.474l4.41.323Z'
                    fill='#CB8E00'
                />
            </mask>
            <g mask='url(#d)'>
                <path
                    fill='url(#e)'
                    d='M58 162.5h145.5V210H58z'
                />
            </g>
            <mask
                id='f'
                style={{
                    maskType: 'alpha',
                }}
                maskUnits='userSpaceOnUse'
                x={119}
                y={114}
                width={83}
                height={73}
            >
                <path
                    d='M201.205 116.045c-19.718 19.427-38.381 46.237-39.771 69.954-9.823.854-21.944 1.218-30.105-.156 10.648-32.411-11.673-56.524-12.31-55.722 47.013-22.895 82.186-14.076 82.186-14.076Z'
                    fill='#fff'
                />
            </mask>
            <g mask='url(#f)'>
                <path
                    fill='url(#g)'
                    d='M.5 0H279v215.5H.5z'
                />
            </g>
            <path
                d='M202.197 87.56a13.785 13.785 0 0 0-7.91 3.644c-.501.479.188 1.322.7.843a12.677 12.677 0 0 1 7.398-3.415c.69-.083.502-1.145-.188-1.041v-.031ZM190.473 77.846a7.835 7.835 0 0 1 0 2.832 3.843 3.843 0 0 0 0 1.79c.439 1.292 1.776 1.042 2.686.438.564-.396 0-1.343-.523-.947-.522.395-1.17.447-1.181-.282.025-.437.081-.872.167-1.301a8.629 8.629 0 0 0-.114-2.79c-.136-.687-1.192-.427-1.045.26h.01Z'
                fill='#24262E'
            />
            <path
                d='M208.237 188.529a28.025 28.025 0 0 1 7.639-1.53 43.343 43.343 0 0 1 8.13-.396.542.542 0 0 1 0 1.041 42.12 42.12 0 0 0-7.848.365 27.584 27.584 0 0 0-7.315 1.436c-.637.271-1.16-.687-.512-.957l-.094.041ZM205.854 183.959a8.67 8.67 0 0 1 2.644-.813c.641-.036 1.28-.109 1.912-.218a.548.548 0 0 1 .564.419.54.54 0 0 1-.323.622c-1.474.354-2.884.219-4.285.927-.627.312-1.139-.646-.512-.958v.021Z'
                fill='#14213E'
            />
            <path
                d='M268.949 61.323c-11.724-11.453-27.9-8.798-36.385-4.165-2.09-5.528-4.629-18.74-22.989-21.593-5.047-.791-13.877 1.5-19.854 4.925-5.977 3.425-11.369 9.037-10.659 16.48.241 2.5 2.477 4.936 2.592 4.457l.543-3.935c2.874 1.311 6.573-.99 7.085-2.718 1.818 4.05 16.395 7.163 20.899 7.142 2.801 0 6.124-.874 8.036 1.166 2.361 2.51.083 6.518-2.236 9.058-2.32 2.54-4.839 6.247-2.801 9.058 1.16 1.562 3.563 2.239 3.992 4.165.324 1.426-.669 2.79-1.411 4.05-3.605 6.153-.063 15.752 2.863 19.781 6.375 8.86 20.994 22.104 42.844 11.609 18.903-9.1 25.664-41.697 7.481-59.48Z'
                fill='#1A0C00'
            />
            <mask
                id='h'
                style={{
                    maskType: 'alpha',
                }}
                maskUnits='userSpaceOnUse'
                x={178}
                y={35}
                width={102}
                height={90}
            >
                <path
                    d='M268.949 61.323c-11.724-11.453-27.9-8.798-36.385-4.165-2.09-5.528-4.629-18.74-22.989-21.593-5.047-.791-13.877 1.5-19.854 4.925-5.977 3.425-11.369 9.037-10.659 16.48.241 2.5 2.477 4.936 2.592 4.457l.543-3.935c2.874 1.311 6.573-.99 7.085-2.718 1.818 4.05 16.395 7.163 20.899 7.142 2.801 0 6.124-.874 8.036 1.166 2.361 2.51.083 6.518-2.236 9.058-2.32 2.54-4.839 6.247-2.801 9.058 1.16 1.562 3.563 2.239 3.992 4.165.324 1.426-.669 2.79-1.411 4.05-3.605 6.153-.063 15.752 2.863 19.781 6.375 8.86 20.994 22.104 42.844 11.609 18.903-9.1 25.664-41.697 7.481-59.48Z'
                    fill='#1A0C00'
                />
            </mask>
            <g mask='url(#h)'>
                <path
                    fill='url(#i)'
                    d='M178.5 35H280v90H178.5z'
                />
            </g>
            <path
                d='M99.855 170.371a58.339 58.339 0 0 1 33.616 8.173c.595.365 1.045-.635.439-1.041a59.295 59.295 0 0 0-34.16-8.256c-.7 0-.596 1.125.105 1.041v.083Z'
                fill='#14213E'
            />
            <path
                d='M210.724 66.498a40.36 40.36 0 0 0-11.494.833c-.523.114-.303 1.228.209 1.114a40.017 40.017 0 0 1 11.233-.792c.617.042.627-1.114.052-1.155Z'
                fill='#fff'
            />
            <path
                d='M198.801 67.976c.512 1.5 1.39 4.102.565 5.653-1.724 3.218-5.037-1.04-5.539-2.415-.501-1.374-1.045-3.56 0-4.966 1.704-2.405 4.274-.292 4.839 1.447.24.708 1.494.417 1.254-.302-.69-2.082-2.749-3.925-5.319-3.123-3.208 1.04-2.863 4.903-2.007 7.225.857 2.322 3.208 5.206 6.27 4.165 3.26-1.125 1.965-5.768 1.223-7.944-.241-.708-1.495-.417-1.254.302l-.032-.042ZM182.375 72.494c-.084-1.572-.22-4.32 1.045-5.58 2.581-2.613 4.618 2.436 4.733 3.873.115 1.437 0 3.706-1.358 4.768-2.341 1.843-4.264-.905-4.326-2.738 0-.75-1.338-.822-1.306-.062a4.327 4.327 0 0 0 1.216 3.147 4.358 4.358 0 0 0 3.11 1.33c3.406-.073 4.179-3.905 3.971-6.383-.209-2.478-1.704-5.861-4.974-5.705-3.491.167-3.512 4.987-3.397 7.288 0 .76 1.338.822 1.307.062h-.021Z'
                fill='#fff'
            />
            <path
                d='M189.407 70.943a2.39 2.39 0 0 1 1.954-.406c.156.045.307.108.449.187.115.063.178.125.147.094.554.49 1.389-.323.825-.812a3.309 3.309 0 0 0-3.95-.073c-.637.396-.062 1.406.575 1.041v-.031Z'
                fill='#fff'
            />
            <path
                d='m197.192 69.35-1.4.146a.542.542 0 0 0 .104 1.041l1.401-.156a.547.547 0 0 0 .331-.554.539.539 0 0 0-.436-.477ZM185.854 70.63l-1.4.157a.542.542 0 0 0 .104 1.041l1.401-.146a.542.542 0 0 0-.105-1.051Z'
                fill='#24262E'
            />
            <g clipPath='url(#j)'>
                <path
                    d='M65.955 110.345c-3.227 0-4.689-2.317-3.249-5.149l26.08-51.043c1.477-2.825 3.803-2.825 5.25 0l26.073 51.043c1.476 2.825 0 5.149-3.249 5.149H65.955Z'
                    fill='#FFBC1F'
                />
                <path
                    d='m87.317 73.031 2.68 17.944c.026.356.186.69.448.932a1.42 1.42 0 0 0 2.38-.932l2.68-17.944c.488-6.996-8.683-6.996-8.188 0ZM91.407 94.22a4.116 4.116 0 0 1 2.279.692c.674.45 1.2 1.09 1.509 1.838a4.077 4.077 0 0 1-.895 4.455 4.111 4.111 0 0 1-6.314-.623 4.08 4.08 0 0 1 1.848-6.053 4.117 4.117 0 0 1 1.573-.31Z'
                    fill='#1B1D22'
                />
            </g>
        </g>
        <defs>
            <pattern
                id='c'
                patternContentUnits='objectBoundingBox'
                width={1}
                height={1}
            >
                <use
                    xlinkHref='#k'
                    transform='scale(.00595 .00704)'
                />
            </pattern>
            <pattern
                id='e'
                patternContentUnits='objectBoundingBox'
                width={1}
                height={1}
            >
                <use
                    xlinkHref='#l'
                    transform='scale(.00344 .01053)'
                />
            </pattern>
            <pattern
                id='g'
                patternContentUnits='objectBoundingBox'
                width={1}
                height={1}
            >
                <use
                    xlinkHref='#m'
                    transform='scale(.0018 .00232)'
                />
            </pattern>
            <pattern
                id='i'
                patternContentUnits='objectBoundingBox'
                width={1}
                height={1}
            >
                <use
                    xlinkHref='#n'
                    transform='scale(.00493 .00556)'
                />
            </pattern>
            <image
                id='k'
                width={168}
                height={142}
                xlinkHref='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKgAAACOCAYAAAClvkOfAAATeElEQVR4Xu2dC5IcNRKG1bwN2NjGPIIgCLjB7g1gT8ANYE8ANwD2AuyegOUCu3ABHgcAdi+wg3kZzGPGBoY32via+o0sVCVVlaqrqjsrYsKeaUmlyvo7lflnKrVxzjnv/fnNZnPC/+0yCSxJApsGoM86515wzp13zgHU95tJ8u+14G98tv18s9mozZKex+ayZxLYAlSX915AfbzwOQVm/XvZOXfsnONfAAyQTTMXCtOa/VECNwF0BFBzsv1Po3n/2/yr3/9jAM6J7rA/TwK0WfbRotKoU0pJ2heNi+Y9cs4BZDMjppT6SsZuBWigTQHqi865Z2Z6JrQt4AW0pnlneglz3TYL0AUBNZZRaDa8JdPBTIa5oDTNfYsBGgD1SefcK865Ukdqmpm3jxprXEwF/mbXCiXQG6ATOlJTig87F5BiJqBtDbRTSrvi2IMBGgBV9ulSNWqXuACrgbYioGoPNRqggcc/pyNVSy7StG83Gvcts2lriXbYOFUAumBHaphUbu6FacDPVtuaPVtDpOVjVAXoihypcgn9sSVaFrAKsPxr10QSmASgK3WkhopYZsFrjYY1wA6VZKLfpACNHCmSUQ7hkoYVYI3iGvHWdwLQPXOk+oqbKBha9XX+Naern/h2BtDIkfq3c+5P/aa6N60BK9r1bXO48u905wA9MPs09wakXV/dbDZmu85lg3a9Je89/Omh2Kddoght19fNFPhNVLNp0PBNee/nzpjKabo5Pkej/rMxBQ5298IiABos+9il2KdrDJtOCWKB9eA066IAavZpEcZxsF7bbDavFrVeeaNFAjSgpZ53zj23chlPNX1sVsC61w7WYgEa0VIvO+eenupN78G42KjYq4B1r+zVxQPUlv3eX5+tvbovJsBqABoA1WipMsyKY31pzVp1dQAN7NN9yD8tg9r4Vtiq/1hjMGCVALVlfzBi0aovrmn5XzVAbdkfBVRs1cUv/3sB0GDZN2+/P2bx/hcL1L0BqC37/ZEZ9VgkUPcOoOZE7RdQ9xKgEcn/psX2B4F2ERp1rwFqTtQgYMadZgXqQQDUlv31AvVgAGpOVBWQwqNC+P+9ymgFgxwcQE2bFqAi32RnhP9BAtS0aR6BhS0mt08PGqCNNuXgCOL6lndaiMpEM8KnLw3v3t7z4AEaaNOl1z2d4v3XHJNl/6namVMG0OAVcV6UadPRmK2qTQ2giffhvTdtOg6n1bSpAbTlRZg2HYfQpvdobWoAzbyHAYebVXmzezTIKG1qAC1AghWWKBBSvskgbWoAzQv2RgvvPdugdaZpj57WtJFAb21qAO2JnUabWoZUT7lFzQmVkiSdPcfVADpQ0Fb0bKDgfu+GNv1rbiOfAXSEnM2BGiG837t2alMD6EgZ25I/UoC/dW/VpgbQKvJ1znuPJrB4/jh5khPxt81m4zWMAXScQG/q3Xj57Cy1a7gE0KZ/2Ww2HMu+jAK2w59leT2991bjtM5rITvqJdOgdYQZa1IK8BoVNV627xtAxwsxOULjPB3yaSZVJGsArSLG9CBNwskrVtt0uJANoMNlV9zTe8/WiGeKO1jDGxIwgO4IDAbSYYI2gA6TW+9ezXKP43SoJ+z1lpnRTINENrxTA9L31lCK5/r16+67775zDzzwgLvllluGP3TQ89dff3U///yzu+OOO4rHMw1aLKo6DRueFJAu+vr888+3AH300UerAfTq1avuxx9/3I5ZehlASyVVsd1aMqHQeLW0J+L75ptv3C+//OLuu+++YmkaQItFVa9hs9QTymMXqV0dEjCAzgQP7z0OE7tH7TKALg8DRjuVvRPToGVyqt7KAFomUgNomZyqt1ozQHGeuGo6UG0CNoBWh17ZgN57EklWd/4oNNGnn37qzp496y5cuFD2sIlW8Kx33XVXlhM1gA4W8biOa3WSINqvXbvm7rnnni3Ahl4ffPCBu/POO91DDz3UOYQBdKiER/ZbK0BHPvaN7t9///32/zmQG0BrSbznON57eFASm/fyQtMeHx9vTYEcCLsEYACdCR7e+xsbw3YxBRwbQpcsq7fddtvktzw9Pd2aAtipBtDJxV33Bk0k6bjuqN2jAU7i62Odm13NGWcMDWwadFcSD+4zR8IIGvTLL7/carTaGpTlvPaYaOAvvvjCADoDPtlDD70EzbT6S5oZr/7++++v/jymQauLND/gPu2fxxsnje78+fPu3LlzNx4erYpJwd/PnDnTKRRp9hTxbwDN46l6i7VUIcEOJD0uB7CUgATchx9+uJOMlwZua2cArQ6//IBr4EA/++wz99NPPzls10ceeaS3jVkaDqXdDz/80PolMIDm8VS9hfceD36xuaCABoqIJRfnB/tyrssAumPJ1/TgWR7xdvHMp07c+Pbbb93tt9+ejZ2XiJMvAPF8LrRz6sJ+RYMbQEskWrFNTQ+ehAuWxymoo/CRBShI/iGeOnwm88TO5GI8bFTNPSVeHC++EAbQiuArGWotDlL8LKU2ZRvYAORjjz1WIqKb2hhAe4tsXIc1OEjjnjDdeyiZbwCd4m10jLl0B2nH4rhxOzQ0P3FEygC6wzdS00EaO200Gk4WHGftMCVzw8m5++67ixkAnCbmFO+ZN4COfdM9+i8pgqTMeKaP41ObSvrkk0+2zIIco5yYcIoAaOzVG0Bzkqv4+dK2ecB1fv3111sQTaFF+xZ+SLU3gFYEYG6oNdmfaECuUKMpCZn8TtL2UhfU12azaf08J6P4cwNoX4kNbL8k+7PkEeAu0aohEEs2zIlgbyPgdW8lk9x7772dYDaAlrytCm3msj/hH4kC1Yo2AdKu6nQpvlREP8Q71fK4GId8T5w0ajWR0YTNimOF6fHggw9ufzeAVgBfyRBz8Z+qUpfLKgqfAUABoNxWDcXs6du1BVnJ0m2mAYDkB40NYLGLVVXPAFqCrpFt5tjioSkPiQAJMDlQM7a0IKYA2vqrr77agrUkRY/2bM269dZbt5QXTAJaM6whagAdCb6S7jXj7yX3G9sG7akNb328ewCnnZzYloAOsLU5VFBL9OlK5zOAjn2bBf3XXOam4PFam7RxmyzhaFjAmaoXGtJNBtAxb6Cw75R74JWRzrLapqkKp7lths3aRSP1GYu2MbcJONGyAFQOUzimngfHiR8DaF+J92w/Nb3Utieo5zS3zUX9YAuG+4tKx2IumARdZgHeOqxCG0Dl3bOXCY/eAFoq/YHtdkEvDc0UGvhIrd2otwQFFYY3VcdJoGWuAJQvQQxkBQLC/FYDaO23FI03F71U+lhEjHJet8h3gIeXzX4lvO84zp4i9wFtaktyKnuJKNTJycl2aVcdewNo6Zsc0K45r3N7rHTpVbq1oobWFE3Ect7FeSoj/tKlS1ut9+GHH241ZViZTtxpuMTzN2zOlLaUAyXQy8QQ9STKyQBaipwB7bz3zzrnOKuz+CLtTDsp2zqVhByLbzigYSqaJNsSDYuzFp/kofQ+OXJoS36wRcMoF19QxlKGlQF0wAsq7TLV8i5nhpcN37jLSwBCm+LE6GLzHpvcZGPG2ztE/oecJ5oZDUtYUxpc+5X43UKdE77ZOaNHbY+VCzmWiEMA5MvRtZMUQLLJLgRefMocmhJQA3bGwtZFm4axftOgJW9lQJshy/uA2xR3UWVkNCB2Yle2kUwIllna8zvtQ0B2UUoq/BU6OyUTvXLlynbJh2KCDwXkBtASyQ1os7TkZECGxsL7zm0fVkz94sWLWzsxlemeopQkppQ3rs8YC+YgXNZT4uVUOuL6BtAB4Mt1WeLy3jXnXAqd+mIvKuMoRSmF9wCIaNyUGaBIUi5binkZQHNoG/C5954T5DhJbpEX4KFoAllE2IAAJhcq1bLfdfCBIkRttiljcNlpxzPDotGg/yNNcuapJG8f0lTwjSWZSzhY0nx473GMXSHXrqUbswDwkuvZts04nrBp0IkQtEsnqSt82PZ4XUtw2EeJxOGuT/rqrCTxnSLqASBATp0zr/1KOEJhbaYuNsAAOhFAGdZ7/4Zz7qkJb7EdWtxk7SrHcmjicQHjxx9/vOVB41pN0s5dyc6aL3OP28XH0xhAJ0RPE+p8b+pSiwpZQtqH5HmNRwMw2IyxluvK1CcUin2borIUysXhYgzmLP4TbhUzIMx0MoDWeIsdY3jvX3TOvTD2NmgzHJqSrRThveATufr2a5svyzQ8Z5gowt9IPNa+pC4PHwCGPKxsV/IB4D/1hQC8gNkAOhY5Bf299+865/5c0LS1icKC2kxWOhZJGbzs0gofStZoAzTjsYyztKuNkpBLiPkYvHCi4W5PPZee1wBa+qZHtGuSlrFHB3v1QzSoYvYUUigFKIAB0HGNJD2+CHTAyJIsDrUta0k2siqYxGLkfpgD8ZmdzJ0fA+gI4PXp2pa4LE0xpHZm7v54ygAopn60fMJpxpwkAORSEgomAn9DY8oOVapfKgGE5R6NGGpgtC6/99mSwjjMzQCae8sVP09lN+EgAJjcqb9DpoGtCCGPtgudHHnROXKee8pGxOHhy8Q48tzjFDra60sx9guHo0WkyQA65M0P7OO9f8I5hz06+QEKihalqtZ1JRLr0QCmQpGMRR9pwq4y4CzltO8q5KAMfbKYuOT82TlJA4FVs5uW+lQlt5r3kZbMFV9I3VM7K8OyjKVaV9GiOPspvE+YTIKG58vQxuGaBq2JioKxvPebk5OTf12/fv1poi216J/41mgxlvjc7kyFMKF+FBWS9mVu0mpKJMYu7Nq1mSvGAPihpLjgbKlMAkBTDIAlixQAaoomly9fxpt/99KlS4/XJta75osWBHDhl0LRohKKqCR+Lu+7LVMJ2xJWQSyBckfFg4bz536mQadAYMGYc2Q8dUV4clMGLB999NEflmJ2eKJVu2zOcOz4SBo+i80d8lZZ+rFRDaC5NzPh52OjTGgrllReZEkKW067dT0qIIJWQjOigVl+Werx2rEf401yY8QmJsAqi4yRYoW+2KPOOQh88kd7XYANkLCPHJ6zT5Gv1I1SsXWcGUj0mAmQWRDSVGGBhlxeaNeDck+y/m3bcS84TNe4oZ7e6RNlCvcM5Q4/gPbBzkulv+mp5LUDcu1TVwIKAE3RSizD2hRHW7QeGo+/odWHZFZhQmjJF/tgS/x02CseuaQ8o7QWyyvLOaAADDknS5EqbRNWYkdI3qsNEw5j/W0ZS4okqTgulFK4Y5NUPKJJqfCqzhdNgZ6wJ+MQcZJNawAthtF0DZul/mXn3HNtdwEsOCRcubru8RgCFH8PQSWzQH/j8zAsmjoQQcd0A2SAjTaPo2CyT2PiXcUaFOtPEfOEVbFzNTcD6HS46zVyA1KW+lFZT7mbtu0LAsTwkWEhCLx+7EGFLWUKcI+46CzjAlg0elvMXYd1oc1zG+b0HAbQ3Bvd4efYo1euXHnn3LlzF3K2Zde0RLTHnGdbHxWSjYl5bMLQERKpj4kRg1B8pgj/1Py1zQQKCU2Zqg8az9EAukMAltzq6Ojo2YsXL76SiwChsQBgyntXNCe2KdvuT3iSKwSjIlFo1NKz6OOdn9orFVchUaizJLfVAFqCmh22KbFHtdSGzkQ4RTxsATi2D/kM4IR/R5sRfkxVoZNXHabaQSnFTo6cH9X+5HM5PXLQlNisnZ0lYjWAlkhpx21y9igAAyQAtISgD6cfb7mIH00lbViGARI0E7ajtJ20X1zwSxSRqCY0OwBlfirbyBeBcVMmQpuIDaA7Bl/p7YbwoyVjA5q2yI8SkLFF0YjQWCz7AFRaUGUW26rbhQknKghREkTg3nwhoKdCB8oAWvJWZ2pTwo8yNTRqCIaQVuJzLetdZD3tFGKEv9S5RTG4tOUYEIVOjhKbZcfqoNqutDuJNTx5ObaFDaAzga/ktiX2KOPIgwYcipmHeaB8DuBS5HiYqBHvSQ/nCOi5ACxV6MTFytZF+8nsoI08dv7OvTEN4tKK4fgs/3L6QufPAFqClBnblMbrtV1Xdl54EAHT53Pi9rIH+RsODZoXezJny6ZOP2aMrip3uq/CplTL61tw1wA6I/hKb93YoySVPF7aJ24n54a956KwADPaFeDk7ERVUI6zlhgDMh+HLbXNBACX5JqakzT0zS6k3/Hx8ZOnp6dvnD17diOSXEkauXqfegRAptLaUzxW6oxP7qmDFQiTcv/S3FHmaBp0ijc10ZhHR0fPnzlz5mVxmCUlb7pK1KDxcKAAULhTM6dNeTw0MmHNsG3XNpNU+UbmBu3Utu0FcBtAJwLTFMM29iinhjxTOn6qEgjAUEyeKsYAC5CoTlK4WU52JNpRmfNhZlVJuFJzjes8SeOm9mbpHgbQ0je9kHbee/YzkVTyROhZt00PLYQzFDpN4d51xdcBKMsvoNH/Naa4z7B4bSorSu0VSOD38IiZeI7SuClNzBzRzgbQhQCvzzRE4l+9evUCLzmsIqcEZRyTkPAOtyGroFhumwZj0Q8nCgYgrA6iohApe1KAjo9FDJ+ROYi7jZd42dZodANoH2QsqC2b7k5PT9+M+U0tm2F2PG0ADfxiuD0kJvTjxxPQFNakvcomYgbwO5oOzjW0RXMFyLgP3j/ziumweA4G0AWBru9U2jbdKUlD8XMV/Arj54r8dFFA2vdE5Q+YA0WHVL8zPsMzN3/uCSjjUjypfqps8n8KfNmdfnWkbQAAAABJRU5ErkJggg=='
            />
            <image
                id='l'
                width={291}
                height={95}
                xlinkHref='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASMAAABfCAYAAACjt6EjAAAT5ElEQVR4Xu2dB68tNxWFdyCUUAOBEDqhgwRC/AEk/jg/ACEkRA+hhd5LgBCqvmhW5Dgel+nn3HWkp/fePTP29prxurv7kfDHCBgBI3ABBB65gAwWwQgYASMQJiO/BEbACFwCAZPRJR6DhTACRsBk5HfACBiBSyBgMrrEY7AQRsAImIz8DhgBI3AJBExGl3gMFsIIGAGTkd8BI2AELoGAyegSj8FCGAEjYDLyO3AGAq+LiLdHxO/OmNxzXhMBk9E1n8u9S/XeiHg8In4QEf+698V6fX0ImIz6cPJV2yLw1oh4TUT8edthPdotI2AyuuWnZ9mNwB0hYDK6o4fppRiBW0bAZHTLT8+yn4nAmyZ/l31eGz0Fk9FGQHqYB4XAGyLioxHx94j4yYNa+Y6LNRntCK6HvmsE3jmR0Qt3vcoDF2cyOhBsT2UEjMA8AiYjvx1GwAhcAgGT0SUeg4UwAkbAZOR34CEiQDkKPp9fP8TFX3XNJqOrPhnL1YsA2dwvRsQ/e2+IiHdFxLsj4nsR8d+B+3zpjgiYjHYE10MfgsBnIuLNEfHMQHkJmhF/CM37cxEETEYXeRAWYzECkMpnI+KvEfHDxaP4xtMRMBmd/ggswI0jgO8JM/H5G1/H6eKbjE5/BBbghhF4bUR8MiL+sMIZTiY3HQxop/KgPyajB/34b2LxmGHUgV213QiykYXd6wh/R0Q8ERG/mHxW75mewmhkT7hgnvbO/ZZp7ucG7jnsJTEZHQa1J1qIgBqx/WzyCy0cZtVtH4+I325EiJDRUxGxdj1oVNTIjYzzgYgg+njJpnYmo1XvqG8+AIE3Ti1qRzWHLUX78ERGW0Xf0GpGqv25Hg2K+TEJ+QgXSLJXM8IcxLQcmXtLHKtjmYwOg9oTGYHFCEBGaGdrfFOLJz/qRpPRUUh7nltC4H2Tn+o/kxl0BU0CraZXA7olrF+W1WR0k4/NQu+MAH4qQvZsfvoVrTHP7p5EtnoWJqOtkPQ494YAmd34Y1rHKXHkEn4Y+XJSHD4YEUSwLukwvtoDMxld7YlYnj0RIJL0v84ERSJPf+q4FtKiLq6U/Y12hWZUIjQITFG6EpHticMlxzYZXfKxWKiFCLSiRWx+nMG9mgo5RPiP5sL6EApFt+T6jJpy3Pv0dO+ZkcKFUG9/m8loe0w94nkIKCcJLaVUxU+OD0W15Ob0fCAjwvokKC5JusSEI6foVwvvl4yQLFodhHcFZ3oPdsPXmIyGIfMNF0aAzQ+BYBadtWkxzdC+0KZeP+UH/b7D3KvBqgMAMBt/uQJ//FePTbKtGGafW01G++DqUa+JACTBxkbD2CtMrizntVG4FEGZg2hnaw4A+NRE0pfsbmAyuuameehSKeMYx+6oL6aGHVoLmcz4aPZyGkN2kMeWcm/1PmDu8dmLiFfJaTJaBZ9v3gkBmSW10Dq+HD5z55ZBaJhtkI42HySBqZL6XriOEDxz4Yge+SAn5uDo5uY+7llrSmKS4kv6W2YGsm6IF9/Y2jlG8Fh1rcloFXy+eUcEWtXwKhSdM4fkzG5pQYqYMc7Ixu0hzDl4SAeA+EqOdJEo37da6WqNzJM62SEoNEB1BtjqMUFyuznRTUZbPSaPszUCLZNCrThoh1HatGxqNiVO31HNpWctaFlPTqQy2ljtQ5Ns3ynI9sWpP/c3OpzVap+rFrojZNqzxvQaiEhpDq1E0NGxX7reZLQINt90AAI4WzE/esPwoyKxufiUQvYQzSem70ajVxADWhskOJc/BJFClD8tCP2xiOD7b650Vo/i0bqedZFTtVuk0mTUegT+/iwEePHRaPZyNEMYj0bE9wsLhIy+NPlhvr7QfEsr7OXDwWxqmV5L8N7VfFoi0JJ7TEZLUPM9ZyKg5mQ9ofOaqcdvekhnLlQu7QXNrGbm4ZtByyFcrutK/i6yrSGoJcmTNbyVmFnLQUJG9jrJl5f9mIwu+2gs2AwCvZ0f2aT0p0YT6S3/WAI6Tc6QCXLcwzfVkkm+qz9WiLVWP0d0kTPk9pK/5ft7eX0mo9aj9vdXQ6Cl0Uhekg8hI3w+c+UhPWtjo7KhUv+PfEJbmZBoVmhocw7otW1IIGaIsqQFghMlMmC0hwNcUc/mgZkmo57X0ddcHQE2FCT1o0RQ1XPx8zXRH7QKNml6egc5TphFW5hc6uJYyqniu49ExNsmzWXNOs56ht2nn5iMznpEnndLBHB2P575bbYaH0Kg4+NeJpgSF9Gycs2E7/A1YYqRBpB+T5gdwt0r2gh+yoRHK9xDa3rFMzIZbfXKepxbQ2DrI5BaTfbVMoR0hVa6gGroyF8qkaG0KTQlNKqRDyYh2dk9xxUpsfOQ3tsmo5HH6GvvCQE5wpe2B0mxUEJgzTeljU0Gswhkrn5NNXRzxxCt8SERWWP8nmgka2xlwm/2TpiMNoPSA90YAmgXbEqZR/wb7WVU02DZ6pOUmjNsYkxHiEolKcxBmQe1cLVTZKW1lUov1CFyTUJoS4s75VGajE6B3ZPuhABhdkhgSZQLp7S6QKbilarw0S4gmVLCpO4lg5z99Y+Cs5sx+W5JOxDICIc9pLZknTtBv35Yk9F6DD3C/gigRUAyrRqwVi+h2vHOjM8nN52IpvHBgawPfhfGqvl+GA+nb6/jl/EIsacpBKQV4Dy/OumouJfoYu96X/XWmIz230ieYT0C+HcggJomwiyp47c0KxEoNJpmzktyM6YVnyWEgDwQCp0eW2UgyixXgiYaEHlSeVqBRJsjzxbarZym1v2l7+UzW+V/Mxktgd73HI0AGwjtaG1ez8g4bHbmTLUx/o8pKO0JoiLfiA/+Ifw4pABg8skXhbaGI5pTSVqZzrljumbOfW4i6K/OaCNoWuQn4QOTtsL6kacWHUMG2uWOmJAQpzpoLn43TEaLofONd4JATjBalk4SSfshSQNQbg8bG20AkkELYpOzidHA0vtkxnBdSyvrLZ9Aa4IAMR/VFC5t2paWzSiXCVnxd3G9EijzE1UgUsZpaaGbP36T0eaQesAbQgDCIWESjSsPo5ea+6NZKDqGNsAmZ2MzDp9SIzfGh4RUsd/SONRNAHOtlmiJLJCGOlkq90gFs2keFQSDrCUiFPlovrlDKUeavi16BUxGi2DzTQsQmNNA8qHYZDhtMYXYGPz2ZyMvdYyKDEo5QPJFqZp+6Ry189rwBbGGWgtYTD/WjUmF5gLJpL2OIBJ+zvdzTny11MU3VSK8uXA+8jF/KxEz1QpH2/N2vS4moy6YfNEGCPQ2wyd6BRlhJihBb86J2yMWm0i+mlGyQWaIBAd06q9i80JA8h2tSUKEaCBF/DQ5YWLuQSz8kR/qzAMf16xTzwqi5fMqh77JqOd19jVbIMBvbn4Ls4FrJ2ew6SAjNAk2KgmC/D8tVJ2TB5LQoYut396QFARQS3JUWD+PEqV+ldbJsJJp7iBHTDzOMkMTyh30fKfykV5f0hbPas8x0l82r5jHZLQn7B57CwTYzJBRj1ajaNFcGUUqj/woqTaCJoQWIrKc85+kJ9NCRvS0hkjS8L/SCPgZRILDmHWgab2YmFs4wdES+FmecV2qS2MsWtPiT3q2ArB8POnpKFs8j7VjlKKUL41pMloLre/fGwE2Ky9wy6E7KkcpWxvnMRnTLf9JPheklftqREapViWzE9JJj1gSidaOZtKczEUkjTG+lQiSl7MomraksZzkWXuC7dAzMRkNweWLT0AA0sDPkJowqvHq0ZZSkVuZ3GxCxpyLeEEEZEmzSZWDpI2bm3JKwExPr0Wjoj8RmhvEI6cw86murbUmxoXo8iOzMemQSSH5mlNdmOiYJmRJ8VVR76okxtF3xWQ0ipivPxsBhbDnzh2ryUdkDSLDZOrNqFaPa65Xvg6EgRzqe83Pc38Pc31+igR+dwr/QzpKCSA/CCLjOiJk8l0xLtpgHjlDbghmzuwqkQ8/Yzy0Nv7GNIX05E+TpjZCOupxBMn2Ytj1zpiMumDyRRdDIA3/j4hWqqFKtSw2L5E3NiubTSUazAEB6bhtfD/IkG9GnO1oFZAUpAMZsfnRhCACxuUP19RC9Gg5aD5pZ0clYab+sJZTO81x4tqnsogdMoJJK/cpxVha05JfBtVnZTIaeZV97a0hoGbzEIKc0mw+fEMqk5AWwsbPTa50M/ccYKicolpz+56i0lIIHdm4Nz2UEoKDUCC/0gcTF5m2Puus1ONodVKkyejWtpflHUFAVfypNpEeS82JGtpY8tWwgUuaQkoQPf2A5gpsS85hmYLpEdtzvqF0/ZAl16UOd/mBZEayx5EFTYu5+ZP2Ch/Bs3at8shGTL5XjGcy2upReJyjEEATYPNCGC2fxVwV/9LkPREJa21FqXQqRtp6RBjllfOKfKVpBiIjQv6QjRIwyTtKEx/zULnGYi7KPzAduUZ5W/wbMkq1G2GaFtW2TMD8eaflJ4veBZPRIth804kIyIGNCKWN3hJNhx6qjkwRrVobVvVBggjwKfVmhM9pWe+f/EY/TurPUm0LIlCxLXNJm2Ntef2bzoZTqoCij9yHacq4+WGVwkAaYykoAJnymTMBWzgPf28yGobMNxyAQM0MUruKuXPAWuKpU6KOGtLGrJFRaoIwLxsdjYV709B9a259/+Up6/orM9noJZlKZh9roaMkMhGx6/3o4MfUl5STlnxU0j5HTvLtlcNm2iKkfNNRCOxekJktpBQSZ7Ni7hAxUsg+1XLYuF+YkoYx15RlnVfZMzabWh0b5dhmbPob1Y6b7vFLKfubeRkbDQ6t65kdjlaCjJ6MiJ93dNxc9K5YM1oEm2/aEQHlsfSe1dXqXJj2+CmJTa1UHqZW0/s8vK770VzQSNCK2JxsVObJ6+fwbbGBKRfhu5Qk0mOlmQ8SXlu6gUP7iclXtOMjetXQ4EG6Q6ubZVUmk9GRj8xz7YFAnnmcziFzp1bWQMStlMDXcnKnmpJyiHKHukwd9hmRu1RzkqMZjYaxIC75cCAmHSfEetB2Hp1KVVJtqmRaYT6mpKCOj3+JiH8n/ZjmngVzl04lqT07iBlNb1VDNpPRHtvDYx6JABuejVBKIuztFFCTFxMLrWePk1sVgaJ4FiJTZjRERdkJ2hSaG85kzEU0NeRQe9v06O25ejLlSnE/8yk6V1qzHOWjNWnMAdG2opvWjI7cGZ7r7hCohehZbG/TOAGTXz93RJKuxwRE+8NsRXlA25OzHe1JHQAgGkghT3BEM6JVSposKW0pT4+AvBmjdNS25FlzQIHJ6O62hxd0BAKYTmxaNqhagJT8OtI8Si1nS3Lmp89CImg1mGm1E2kZS9fWNBA5zdGy5PuSpqPcIcwqPrkG1FNcy71EEzcP+dtMO+K19hxXQwDtgpMzatEs9TtSLpP6XKs4VmtirE9P7TxKDty8jq5UotHTmjbXrPh/3qSOcTDdMJmQG9NMCaL8W2vC1EMrUtY5a4Do0HqQr0aKo8mQ6bNXtO+5UkqDyehq28TyHIFATjSlOfM8G52qkRNAK2lytrPhNCmbH+d07vOCGDCvRJgkQeIrwr+kM9PyLHDICH8T17Hh81SDUn9txJApijYFSaUFurXn0ZN+kN5fbX5nMjri1fccRyAw4rvRZq61v+2VWS1BUk0D4kAeNJCag5058tM5Ul8RxEPphhzLyMs86jRQc6rLXOuJjKWdK3vXraztnq6a6ZizUUqTUS/0vu7qCKg3T6/vZs/1oJ1gBvYkH862Yc0EVOM39VJqtf1Q1njpwEZFCClqrR2HVMOolMW9ClOT0Sr4fPOFEMDcwZk8lyzZ0oZaeUUXWupLoqSRtJJsSmvAV5R3j1QEL/d/nbpGk9Gp8HvygxDQufU6AimfVsmRve0vtJm5HjNojVN3CQSSV1oPZtyq7OclQmx9j8loa0Q93hURkJaAhpC3h0Ve1XjNHZKoFhtkMeNoVtGoQuM4gEm8VJuOkp+GTG8yoBkDf0tJjhw7ykgY+9sR8Zvky9RPhUbI2CPmKU53iHmu26SmapXabPqsTUabwunB7hQBOZDRPpRfk/YDwjxk4xKFghhKfpqnJy2KzGrGq7U/0UkfXEuLkK9N2dcleGvdHElHgLjSM9vkeE7XUhpX1/W2S1n96E1GqyH0AA8EgVamtDQstKaSn0YwSSuptR5Rv2s1UcuTHPOw/9wjEBnlBb+QJw7wHs1ortSm57FLa5M5W73HZNQDqa+5CgJsQjZzrcf0XrKWmpT1zFXqGoDpRW7RXGHpXIdKzdfTa7tHti2uqTn+WTudJtN2urNzmoy2eBwe4ygE1NO61fL1KHla88hxnps6S/J6WnOd8b3KTeaO7h6SyWQ0BJcvPhEBHT3d6/wtibp31AnZyOHBLMIno1wc/l2qJ+upBatBjobFGHkfpd7H1Or11Bqnp7C2NcbL35uMuqHyhScikIeyl4iiMUa0KggwrXZvzauiWUoxWv4YxlKiZl4LBqFRjd+KuHE/n7RB/5yM6l6p3k3S2kbbhbQwWPy9yWgxdL7xYASWNP1KRVTv7J4SEByvj02HHpYiY7WljyRPMg/rSslkTRSrNrfGVQpALSlS64OMiRKW6tw2f/wmo80h9YB3gIAKR9NGZqPLwnFLLg+RpNFP6cRcyATimovUiWwgW50Uks87QpTci4+O9IKespbRNep65CZS+bzJaCmEvu+eEWiVWrTWjtZBXhGO6zliaI3BJoXQMNdUcAs5EJIvRRN16gkV+71V9y0Z+H6UwHrGzDVWUhBeMBmNQufr7wUBNjtV8TiblxaLtsw1CIJPXhvGz2QCzZGVEi3TSBwFuIy5Rwvc05/r/wG8Y2jTyaU5GwAAAABJRU5ErkJggg=='
            />
            <image
                id='m'
                width={557}
                height={431}
                xlinkHref='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAi0AAAGvCAYAAACXeeU8AAAgAElEQVR4Xu3d7RM0WX0W4BNdVyMkQhAkawhvsrBqURX95N/vV19KK+EtkZSs2YW4CIEgYcMG6yZ9Km2nZ6Z7pmemfz1XV1HsPk9P9+nrnIK7zutvNBcBAgQIECBAoIDAbxQooyISIECAAAECBJrQohEQIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAQIECBAgIDQog0QIECAAAECJQSElhLVpJAECBAgQICA0KINECBAgAABAiUEhJYS1aSQBAgQIECAgNCiDRAgQIAAAQIlBISWEtWkkAR2I/CPW2u/2E1pFIQAgZcSEFpeqrp9LIGbBH6rtfZ7rbX3Wmt/cdOT/JgAAQJXCAgtV6D5CYEXFfhHrbV/NgSWv35RA59NgMATBYSWJ+J7NYEdCSSQCCI7qhBFIUDg7wsILVoFgdcW+HRr7Xdaax+11v7ktSl8PQECexcQWvZeQ8pH4L4C6WH5J0No+b/3fdWvw9GbrbXv3/k9Hk+AwEEFhJaDVqzPIrAzgX/YWnt7WHn03Z2VTXEIECgiILQUqSjFJHBHgSxjznXvpcyZxJt3/NUdv8WjCRA4sIDQcuDK9WkEFgq8M0zCPTWn5R8MQ0j3Hj5aWFy3ESDwqgJCy6vWvO8m8HcC/7y19jettf9zAuXzrbV/2lrLsM5cb0x6avJ7q4+0KgIE7iogtNyV18MJ7EIggSPXtT0ln2ytfay19oOZYJIhn7daa/+7tfbBLr5WIQgQOKyA0HLYqvVhBH4t0CfAJrD8zzuY3HvDuY+31rIs+3/pyblD7XkkgWICQkuxClNcAlcIZPjnL4tOgP3d1tonhsB1bU/RFWR+QoDAHgWElj3WijIRuE0gvR8Zssl+KPdeEXSupOnl+VdDOa49qyjfkudYcXRbm/BrAocQEFoOUY0+gsD/J5A5LJk8e+pgwwSB7ICbybP3vBI2vtha+1lr7f17vsizCRB4DQGh5TXq2VcSGAtkifNPh3kiZAgQIFBGQGgpU1UKSmAzgUtLnDd7kQcRIEBgSwGhZUtNzyJAgAABAgTuJiC03I3WgwkQWCiQAxuztDmb2917ns3CIrmNAIE9Cggte6wVZSJwf4GEhEyUPbWqJ0EiG8dl07geJPpGctkzJXNitroyXNX3YtnyuVuVz3MIENiJgNCyk4pQDAIbCSRYvDmEjXOP/FJrLdvvf3N0U1Yd9b1Q+v4o44CyJFzk/bnWLHFOeEpZ7MOyUSPwGAJHFRBajlqzvutVBbKcOYHk2xcApuHit1prvzds1Z9hmvS0JMT8eDJkMw42eUV6SH4+bF6XZ/zL4d/vsfvuq9ap7yZAYBAQWjQFAscTSODIZmw5nXnpHJH8Jj0pOT9ozUZu2Q8mPSXZyC7//EZr7Y9m3pswlYCT4SYHKx6vzfkiAg8REFoewuwlBJ4i8NUhJJw6vXmLQvUdaxNEMqSUIZ6596VnJ6Hl3Sfv0rvFN3sGAQJPEhBangTvtQQeIJAt9BMg7hlaHvAZXkGAAIG/FRBatAQCryWQIaMMBV2a9Jq5K7k3By3u5eonVtvNdy81ohwEHiwgtDwY3OsIPFmgrxr6k9HckoSTnKScMNDnm2Sr/wSbaybULg1GaykSWjJZOGcZZe6NiwCBFxMQWl6swn3uywtkhU/2aBkfYJjlxgkzWSnU/zw9LZnEe25Sbuaz5L7p8uZ/0Vr7nSHwXOrRefkKAUCAwHIBoWW5lTsJVBVID0WCRE52/sGJj5ie/Jxwk8DSe14SQnLP+PdZLZTQMu61yeM/2Vr72HDvuZVC+e3nHjBZuGq9KTcBAhMBoUWTIPAaAgkYmcvyx6PlyAkNCRXTYJE/z/3juSOZ1JvQMt6MLuEkgWjNUE1WESUAZdO6DCO9NYSWPc2deY0W4SsJFBQQWgpWmiITuEIggSNXDyj59wSR7JsyDR0JIhlC+sVoeChDSPnzW4d75nbaveJz/IQAgVcUEFpesdZ9M4G/DSDZTC69KeMgkl6Q9Iak5yOBpq8iyq63GWLKvJdzwWUajuasc8+0dyfvTZnyThcBAgRmBYQWDYPA6wgkFPzqwi65WTWUK8Eku9xmgm56XLIp3KmembFg7skE3u+uZL32dytf43YCBCoLCC2Va0/ZCdwuMN3qPz0efX+WTMRNr0sfJuqTdXNPJtrOLYfuE3YTXNb0mmTib3pf1hwhcPvXewIBAqUEhJZS1aWwBDYV6Kc2J3ysmauSYaKEllO9KQkuuWf83MyJSZBx7tCmVehhBF5LQGh5rfr2tQTGAln986nReUBZMZQ5K9N9V/KbhI70uCy90nOSTeASVPpOtvn92mGjpe9zHwECLyAgtLxAJftEAgsE+mqiLEXO5NzxlQCSnWizR8u15xhlaXOGfq79/YJPcAsBAkcXEFqOXsO+j8BpgcxXSUBJb8iprfdzT19plKGdhJoth3jy3qxQsk+LlkqAwEUBoeUikRsIHFYgw0GZLJv5LFm9kyu72/ar977k3xMqsnfLufkvmcuSDezeWyHWt/yf6+FZ8Ri3EiDwCgJCyyvUsm8kMC8wXjnUVwRlmfO4J+UzrbVfDsM6CSQZ4jm10dzXW2sftta+tRA8w059H5hscLe0B2dun5eFr3QbAQKVBYSWyrWn7AS2E+griRIeMhk3ASI9MQkImTybIaRc/b7eKzPeYfdrw4GLp7b1TzBKUMmeL/nfnreHMHTqPKS5r9tifs12ap5EgMBDBYSWh3J7GYFdC/RA0k97zr9/YhgyytBQVholpLwxDBf1SbV9OXM2ostw06nJtpnMm96ahKD8b0+e2efULIXJ/Jo854fmwSwlcx+B4wgILcepS19C4FaBBIIMB2XJ83TfllNzT/qfJ6ikJ2XuLKMMAeVasxfM9FsylJXnp2xLh5Fu9fB7AgR2JiC07KxCFIfATgSmm8FlmCihJnNa0gPz5jDhNquLspz53ATdU5N814SPPiyUcLRmOGknnIpBgMAWAkLLFoqeQeAYAgkmCSEJEwkiGbrJqp7xlV6TLwzhpW8UNz0KYKqRZ+bqm9b1VUlr933Jc9JbsybsHKNmfAUBAr8WEFo0BAIEukDvNcmy534C9HT/lMxb+c1hnsuaHXLHyn0YarxiKMNMCTPTkLRV7WQuTb4p83XsCbOVqucQeLCA0PJgcK8jsGOB9KIkOMxt49+Lnb/P0NHc//H3wxYzhNNXGy393H6kwHifmKW/XXJfgtIXh9ByanXTkue4hwCBJwoILU/E92oChQT6qp3sw3JqT5Ws6slBin98RWgpRKGoBAg8S0BoeZa89xLYt0D2aMnVd8xNaPnd1tpXhn1W5npE0lOTibrpZUmAyaZ02ayuX723I3NSMnF3i+vTwwTh8Xu2eK5nECCwQwGhZYeVokgEniyQIaD/MGwE958nwSNzWnJ686UVPF9trX00ORagh5YEm63mrvRwtVUIejK91xMgcE5AaNE+CBCYE0ivSiau/tGVQz1ZUZQrm9PlOrXhXIJM5rNM91/JxNnMkcnE2Vv2d1G7BAgcSEBoOVBl+hQCTxBIsEjPy6mVRHM9Lr2YfS+Y7OPSd+HN32WYKcNQGV5Kj8y5icFP+GSvJEDgWQJCy7PkvZdAfYG+38o4cEy/6tRuuPnzDO1kWCe9LZnnkmGjXPn3BJr8mT1Z6rcTX0BgMwGhZTNKDyJwWIEM9WSYJ5vNJUQkrHxuOP8nq4V+csXeJ31ib+bGCCaHbTo+jMC2AkLLtp6eRuCIAr1XpG+hn16Q7Ip77nDEIzr4JgIEniwgtDy5AryeQAGB9IokuGTuytJN4zJPJff2rf4zsTbnByXo3HJl196sSrKr7S2KfkugqIDQUrTiFJvAEwWyB0sCyXuTMnx8mJCb4Z7MV8lwUl811E+Dzv4u1w4H9Tk0mfSbMJR/T5hyHtETG4NXE3ikgNDySG3vIlBPIPNZ0kvSlx2n1yW9KAke7w4HLGZ1T+5JmElPyqlt8nuoicItwSU9LQlNWZKdzeXOvbOeuBITIHBSQGjROAgQOCeQHpP0Znxz5qZ+wGJCQ3o/Elou9aRkc7o3Wmvf2YC9n0o93eNlg0d7BAECexQQWvZYK8pEYD8Cp+aQpJej97Bkrkt6PLJny7nQkl6bT7XWfnWmNybP6KuU9qOgJAQI7EJAaNlFNSgEgVIC07klvfAZIup7reTPxidC92GlBJe+Cmnuo98Zem36BN61MOntyVDWqR141z7P/QQI7EhAaNlRZSgKgQICWe6coaBMrM28lHE4yJyV9KRkgm7+LgEiK4bS+9LnoCS0/GgIN7n/s8NKoH7gYYJOn7OyliNly/BTQouziNbquZ9AAQGhpUAlKSKBnQj0OSzZEG6uJ6OHlGy9nyGeBIgEiW+fWCqdM4cSWsY9L/1QxXzy3EnSlyjGJ01futffEyBQTEBoKVZhikvgwQLpKflw6F3JIYrZGfdUT0b+Lvf2lUb5bXpW1pwd1ENLnvO94Vv74YtL94h5MJHXESDwKAGh5VHS3kOgpkAmxqb3Ir0nmbOS4JKekWkQeau19gettf/RWvtWay1DPzn0MMNE3xh6WvoBiWuXO/cVR32YqaakUhMgcLOA0HIzoQcQOLRA5pjkuhQ0Mpcl4SITaHMWUX73teGk5j8cQkvf32XtfJMMS6XXJnNl9LYcurn5OALnBYQWLYQAgbUCCRFZ4pzN5TIpd3wluGQ4Z24+yjXDRWvL5n4CBA4sILQcuHJ9GoENBRJEei9HP0CxT7gdvybDSbkyhNRXEyXcjHtI+u9PTejdsNgeRYDAkQSEliPVpm8hcD+B7IybpcgJKrkSYv7tEE76n/VzgHopTg3r9NBi+/371ZcnEzikgNByyGr1UQQ2F8i+LLnSO5Lri621L7fW/ntr7c+Hpc0ZGsp8laweSo9LVgItPdU592f4aNork3dlfkyGozJXxunOm1etBxKoIyC01KkrJSWwJ4EEjISJ8X4t6VnJjrj9HKLcM3dm0dx3ZJJurrm5MEs3jUvvT8o0nWezJzdlIUDgBgGh5QY8PyXwggLpPcm5Qwkr51YUJTzk3r6tf4aEEipO9ZRcChxLNo3rpz4vDUovWH0+mUBtAaGldv0pPYFHC/TN33585tDDXqYElz4xN/+dHpDpmUJ9RVGGlNLb8sGCIaWUIXNs8vw/GwWh/HvCzZrN7B7t530ECNwgILTcgOenBF5UYLxD7bkDCvuE2/S2pFcm82GmvTMJKgkh2eo/QSRh6FLoyP2/P/T4/HAmCL1otfhsAscXEFqOX8e+kMAWAhl6eXN4UDZ5y9V3yM2Qz6kJt7knW/Kf2hQuPS1ZldS3/l9T1lsOV1zzHvcSILATAaFlJxWhGAR2LpDVQn3oJUuc+/yRJcM5O/80xSNAoIqA0FKlppSTwHMFciJzhm16j0mGddLTkR6S9LxkhU96XPJn+bv82aVhnud+kbcTIFBOQGgpV2UKTGAXAlnenMMTfzSsCsoJz+mByfyV7OkyN39lFwVXCAIE6goILXXrTskJPEOgT67NPJXMcenzWzI3ZU1QyWTezHfJxNxLhzGe+s706lz722fYeScBAjcKCC03Avo5gRcT6Bu9vTEMB6V3ZU1wyGqjLH1Oj0z+OauF3r/CMD09bw29Oz+94vd+QoBAQQGhpWClKTKBJwuMD088V5QcmJgJu9l+v++cm2XNfflz5slkHkwCTP48gehPh79PL0x+e6r3poeWfmzAk0m8ngCBRwgILY9Q9g4CxxNIIPnscFbQqW3zM7flq0NvyHRTualIAkqCSj98sffoOFTxeG3HFxG4WkBouZrODwm8tEB2uE0oyaZwp/ZgCdAte6ks2bo/5cjw0JohqpeuOB9PoLKA0FK59pSdwPMEsittljZnbkvmpCRgpMclPSM5kfnnF84ZSsnnwk6eMzc5NwEpk33HByrm32+ZF/M8PW8mQOAqAaHlKjY/IvDyAgktX2mtfbm19o1haCc722ZOSno/pgFjDJYAknumvTR9j5e5ybnZ3G66827uz9yW7Aejp+XlmySAVxAQWl6hln0jge0F0iOS0PDbrbWfDUNFcwcizr3560PISK/JOGz0E6TzvLnToDMBOPcIKNvXpycSKCEgtJSoJoUksBuB9KAkNKTnI5Nm+3Lj8SGKvbBZkpwJteNl0ZlsmyGd758ZPjr1sfldwtJ3VmgkWOV3WYV0zflGK17lVgIE7i0gtNxb2PMJHEsgq4EyDJSwkv+cCwLvDJ9+bkv/ubBzSiyBJcNBS/d1ybOzU2+Go8YB61g14msIvJCA0PJCle1TCWwgkJ6LfnDipcf1XW8Tck4ti87+LHlm9mrJXJZcc0NDl9419/eZKJxeoYQmQ0rXCPoNgZ0JCC07qxDFIXAAgfSG5MoE2fS2pEem778y/bwMN2XPl/SIZCXSL88cttgn3majunPLrPs7EogSmE69+wDUPoHAawkILa9V376WwCMEcpBiQkiGjhI00oPywYUX97ky6R3J/y792WgX3f7TvsTZUM8jatE7COxQQGjZYaUoEoHiAgkq2aslw0MZmjnXK/Kl4b6+/0om6vZTojNkNL0ckli8cSg+gVsEhJZb9PyWwLEE1gSCbLvfw0XvRcnv82cZDsrQ0JIrz0mo6WcTnfpNhnoyLyarjlwECLyogNDyohXvswlMBPrQS4Z0cgjhuSt7pfzr1trHWmt/OJo4288LOrdaaC18X130udbahytWDq19j/sJECggILQUqCRFJPAAgfSSZF+VbOx2av7JeHO3TLZNz8d0CKf31uTvE4CyaieBKPdds4Jnbvv+B3B4BQECexQQWvZYK8pEYJ8CS1fjZEl07s2QT4aK8s/XntacZ2XL/74CKKEo/7FR3D7biFIRuKuA0HJXXg8ncCiB9Jikt+XUfJX01KSHJZNqM6E2vSuZr9J3pJ2bWJvlzpm0myGpJcuY+zDW9AiAU9Ap75LnHqqifAyBowoILUetWd9F4DECCSk9dKRHJIpI1boAABFHSURBVPNasmNtDwuXekXymwwBLQ0hmU+T3pd+fMDcV/Z5MHl2ll5/d0FwSTlzXTOE9RhpbyFA4Nf7IbgIECCwRGDaa5EA8fbww5zt01cAZRlzwkt6VtLjktAw3RF3/Kzck/CTMLK0x+VceTMclWelPPnvnDx96ep7y0xPnr70O39PgMADBYSWB2J7FYHCAgkWfzDMLXl3+I6ElhycmCtho/dSZBlzhnESZD41TO6dLmnOJnIJNZmrkmGlrEZKD803F/SKXGLMcFTev7T3Js9LT0t+c2np9aV3+3sCBO4oILTcEdejCRxI4DOttX/fWvuvK/dKGW8el96Vzw5hJUM3GeJJSMg//+YQWk6dUdQpp5vRzREngCRQzc2hOVCV+BQCrycgtLxenftiAlsLZAimT7rtz07PTIaI0vvS/9Mn6iaopBemrzLKb8bDS+fKl/kveZ4eka1r0fMIFBAQWgpUkiIS2JFAQkOu9JJk2XGf1zINHX1ey/icoAzbJMz0oaT89pPD87Ii6dpJsAk/6cXZ6nToHXErCgECYwGhRXsgQGCpQEJG5qJk7ke20+97pySM5FDEHhoyPJMdbLNRXf48Qz59i//0kKzZYyW9Mz+5EEi+OgSeTPh1ESBwYAGh5cCV69MI3EkgPRu5evjIXiuZq9J7UDIRN8ugM0/lz4dw05c2T1cSJcz0zeem+7/k7xKI0gPTA9LcJ+W+jzaYwHsnLo8lQGArAaFlK0nPIfC6An3Yp++HkhCRYJP/pJclvSvpoUmw6MuPE1QSRn7YWstQ0pbnFb1uTfhyAgcXEFoOXsE+j8CMQOZ/ZNO1zEu5dh5Jek6+0lr71rBDbt93JUNH2fMky43HO9H2uTCZ+5IrvTE5cDG9M3at1UwJEFgkILQsYnITgUMJ9K3w0wty7TyQhI7srfLfJtv6Z95Lel7Sc5JAND44cQ5RYDlU0/IxBO4rILTc19fTCexRoK/aSag4dY7QknL3E51P3Zslzxn66Uucp/f1PVcubbOfFUdvzEzG7fNh8nxLoJfUmHsIFBcQWopXoOITuINAej++MMw3uSXUpGjpaUmPztxGb5nX0rf5PzdM1ZdP56To9BL1rf57KJo7QTqBJu++ZSn1HWg9kgCBWwSEllv0/JbAMQXyf/ZZajwXBvoXJ2xkXkuWPve5K30CbubKTE9Wzr35z7RXZcnwUMqT3qFfDauU5s4ymtZEX8F07huOWXu+isCBBYSWA1euTyNwg8C5oZ/8XVYD5Rqv+ulhZ25320zazWTcb9x5KCdlSGhKyNHTckMD8FMCexQQWvZYK8pEYL8C6S3J0uUM2fQDDxMSciXM5O/7hnL9K3rISe9Lekn6UFDuTbDIcE96bv5Na+1Hw8qjawT6BOM8b80Gdte8y28IEHiCgNDyBHSvJFBUoIeP7L+SUJBelsxXyWqhDMNk/kgPNeO5MOn1yG+yQ+542ChDODkFOkEm/5ydbdMTkw3prrnODU9d8zy/IUBgZwJCy84qRHEI7FigL2dOD0t6V/Lf6d3I/JcEmGzj//bQ0/L+wu9I4EkAyvMSeBJs5s4Qyg67eX/m0LgIEHhRAaHlRSveZxPYUGA8/+XSMujxa3vPTZ8DM3fIYr8/G9ZlM7psWrfFlZVLef9Wz9uiTJ5BgMAFAaFFEyFAoAtc2ghuGjjS+5Ft+DNENL7WPGf8u/TaZBlz9lyZrj7aupYyKTjv+t7WD/Y8AgTuJyC03M/WkwlUEuh7nmQS7ZKhnX4AYg4y/HAIGZlg23tPMln3O5UAlJUAgf0LCC37ryMlJPAogfSQJHicW3mTIZxc4zODpvNY8u/pLflgVPCEmfSkLD3vKKEoc1gywXd65e8SlObmvjzKynsIEHiCgNDyBHSvJFBY4HOttY8Pc0EyxJIQkjCSoJOgklVCmS8y3gAugeXrrbVfDn/el0ifY8g+MPndNyc39Z6c6dEAWTKdeS/p+bn2EMjC1aLoBF5DQGh5jXr2lQSuEciqoKzmyfLlhIXMYcnwUf45c06y8icBYTqZNSFmvLw59+dZCSvjM4Kmk3bTg9J7YvJ3ueYCSP4uw08JSLnS45LhrQSqd2fm2Fzz7X5DgMAOBYSWHVaKIhHYgUDv0UgPSoaC+uqdhI70sOTPExrmdr9N8RMiEmwunSmUYZ70jkzft4Sgrzaa9sYs+a17CBAoKCC0FKw0RSYwEkgPRoLB3NyPMdS5OSJzoJlPkmGghJM8P70n/ZygvpnceM7K9BnZKC5nBZ2bjJshoM+21v7L8J7+jqWHNCbopJxzhzEubSS9B+kn5sgsJXMfgecJCC3Ps/dmArcK5P+wM+k1S44zh+Tc1Q8QPNUrkZ6RXNPly2vKOD78MM/Lvirpmcl8k/zddILvJ4d70luTYJT7EnRuKcOa8ubevvW/gxXXyrmfwBMEhJYnoHslgQ0Fzs39mL4moeBUr8Q7w83fvnKPlD4BN3NSMtwzvr7WWvtya+0/ttbSozG9Er7S65KQ8/Nhjsytk2kT0jI8NZ5Dc4p9zYZ4G1adRxEgsFZAaFkr5n4CxxTI8FGCxzRwnPraca9K7knPyheGHpXxyqH83W+31v5da+0/nRiCGR8PkGCVyb4Z9prOl8lwVSYDL1khlBDW5+Mcs8Z8FYEXFBBaXrDSfTKBGwX6UFPCw3j5cvZ5+f1hHst4iGfJpNxxkfpGdznPaDy/JYEmvSLTgxfnPqevMLr3zro3Uvo5AQJrBISWNVruJUAgApmLktOZEyrG81T6XinpIRn/ed9zJauQTm1cl5DRVyUtGdJREwQIvKCA0PKCle6TCTxYoC9N7pNd05OSIaFxgFl7jMD4EzK0lcCUEOUiQODAAkLLgSvXpxG4s8DSYZ/0omRIKUM9CSpZMp1VO+l5SeDou+lmnkyutUM66clJCMokYhcBAgcWEFoOXLk+jcAdBfpmcNPVQn3fk7nTn3txck8m/WYn2y8Oy50TYE5d00m/0/umK6hyf0LMqRVICTkZgjIMdccG4tEE7iEgtNxD1TMJvIZAek/SSzI3zDOdpHsukFzqXclKoCV70fR3ZDjqjcnGdukV6pODE1oStjL3xkWAQCEBoaVQZSkqgQ0Fpic65//oEz6+v8E7zu17kqXMCRCZf5IQcalXJMXJBN08c7wcO+XPEFOeMx1OypBTrt6T0nuFsoPvpZ2DN/h8jyBA4F4CQsu9ZD2XwH4F+v+JZz+U94diZtv9DKdc2ll37VclDCWY9EMVM58lm8jlPXlfej1yTQ9d7O8Z95CM352zkD4xzIs5tSKp39/3gcmQVYakXAQIFBUQWopWnGITuEGg71473rr+0ryR8esSAhIa0lNyqefi88OJzKc2rUsvSp7XV/6kB+XN4bnnDlFc0kNzA5GfEiCwRwGhZY+1okwE7iuQkNBX8yw5bDABIQGizwnp2+5/NNNDkkCU+6/t0egrizKU00+UThlNmr1vm/B0AiUEhJYS1aSQBJ4q0IPEeHv+U8uT07OS4DLdyv/cB2RuSg5KTNDpwz4JKWsmyuad6bVJ2Bnv0vtUOC8nQGBbAaFlW09PI3BEgQSCDNskEFw6yDC75WZ4Z2ngSGDJ5NyEoJxA3ZdDZ57KpXeNrfsGdktXLc3V09J9Z45Yx76JQAkBoaVENSkkgUMKJLCkFyfDTN8bnUCdJc4JLHOTc7MyKD0p00CTP88w0qVJuacg00uTZ6zt4TlkxfgoAnsVEFr2WjPKRWCdQHoq0iOS/9Neu6Psujdtd3d6b9LLkms8nJQAkSCTnp3plZCTLftz/5bfmQCVeT6ZWHztfJztZDyJAIFZAaFFwyBwDIEeADIsc+uk1YSGBKDsUrtlMJiT7nNgsgX/qXelLJ8efpxl2vnnaWjJsFIfZkpwWzo8dYza9xUEXkRAaHmRivaZhxfIip7MJ0lguTVo5DmfGe2lcgkvvTzpqciQzdrhmSVLl/swUr6r7+8yLVM/cDH3xODSUuxL3+TvCRDYoYDQssNKUSQCxQR6YFiy1X56Q342HJ649jMz5yTh7FQgufbAxbXlcD8BAk8SEFqeBO+1BIoIJCj0E5nPFXkuMOS3H47miCRw5IDEhJa+E+8ahuzaO7c3zJpnuJcAgcICQkvhylN0AjcKZG5I5oLkvKFTQ0p9j5YsR55emUeTYJL5I9Nhod77Ml2Nc0tvyC2/vZHKzwkQ2IOA0LKHWlAGAs8RyNLiXJlwu3YuSn7XN4Kb2xslvSqZQJtelVvn2DxHx1sJENidgNCyuypRIAIPE0ioSKBYspX/qUKdO9F5/Ju57f0/PhyemDkq+d+ihKCEp1tXP43f289JyqojS5kf1rS8iMB9BISW+7h6KgECfyeQ4PD28K/jYabeU5NN5BKecuJzAlSGmzL0lDBzay9NPycpz02PkosAgcICQkvhylN0AjsSSMj4xDA/ph+sOC5e5r7kGveipJcmoaL39OTfM9E2+8TkWdcOW01Z+nNPBaCULT1Bp06i3hGzohB4bQGh5bXr39cT2Eoge7t8athif+nGbnNBJuWZhpmtynjqOffaZffe5fZ8Ai8nILS8XJX7YAJ3E7jUo5EXp0cjvSgZ+sluuPlNhofWHI54tw/wYAIE9i0gtOy7fpSOwB4EstQ45/1cs8JoWv6c75Ol1hmKybBQQsxfLPjIvH+reS4LXucWAgT2KCC07LFWlInAOoFr9i9JAEh4eG9BGMkwTuaZrOkR6WchTeelpGdlaVAZK/TnpbxLQs46QXcTIFBCQGgpUU0KSeCsQHaK/VVr7TsrnNaElkyWzfLkNWGhbzyXHpWthn6WDD+tIHArAQLVBISWajWmvAT+vkBfKlxp9UuGe96wd4rmTIDAGgGhZY2WewkQmAokfGSZ8trelEzCzTBRTm2eLpHOcNRPLzwzBy/mnU5z1iYJvJCA0PJCle1TCdwgkHkzGSaahpMvDT0ma4amUowcwphJudPhowSZBJqEkQ/OlDfvzflGc2ciZQlzQs+a4awbaPyUAIFHCQgtj5L2HgK1BTIElSuTccdXJugmyMxtvZ+/SwjJZNylO9smGGXPlwSOc7035/ZyyU67eU6l4bLarUPpCTxIQGh5ELTXECgukCCQYZw15wIlfHy2tfbtFaGlOJPiEyBwTwGh5Z66nk2AAAECBAhsJiC0bEbpQQQIECBAgMA9BYSWe+p6NgECBAgQILCZgNCyGaUHESBwR4FM6M0Ovu+aH3NHZY8msHMBoWXnFaR4BF5IoK82+tOZb85E4By0OD0WYGueLKOe7huz9Ts8jwCBKwWElivh/IwAgc0FTi2rzovOLXHeqiD9jKUfrFwltdX7PYcAgQsCQosmQoDAtQLZcG7p/itL3nHNwY9Lnrv0nr7hXZZ125huqZr7CDxQQGh5ILZXEdiZQOaI9M3f1hYtwyjZlTa71tpKf62e+wkQuEpAaLmKzY8IHELg3HDMkg/McEquNRvOLXmuewgQIDArILRoGAQI3EvApNZ7yXougRcVEFpetOJ9NoE7C2TibHpyftxae//O7/J4AgReREBoeZGK9pkEHiyQAwtz2vIPW2t/+eB3ex0BAgcVEFoOWrE+iwABAgQIHE1AaDlajfoeAgQIECBwUAGh5aAV67MIECBAgMDRBISWo9Wo7yFQR+DzrbW/bq29V6fISkqAwDMFhJZn6ns3gdcW+GJr7a+sLnrtRuDrCawREFrWaLmXAAECBAgQeJqA0PI0ei8mQIAAAQIE1ggILWu03EuAAAECBAg8TUBoeRq9FxMgQIAAAQJrBISWNVruJUCAAAECBJ4mILQ8jd6LCRxG4K3W2t+01r5/mC/yIQQI7FJAaNlltSgUgVIC77TWftFa+26pUissAQLlBISWclWmwAR2J5ATnT8aelt2VzgFIkDgOAL/Dwz4qfsWTxCPAAAAAElFTkSuQmCC'
            />
            <image
                id='n'
                width={203}
                height={180}
                xlinkHref='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMsAAAC0CAYAAAA6j9gnAAAgAElEQVR4Xu2d+69321XWx8LTYj1tKaUNUClFrjVIVS4ihhYtAkYjKBCMYIiaKAmJP2viv2Bi4g8m/tJ6AYOIBTm1tCX0WE7tRU8LtEAL7REpyClSLAdLlQPpNJ95nrEYa60515prfdfe3/d999xJ0/fsva5zjTHH7RnPGKz/9BU4cQVSSp9mZl9vZu8fhuH9Ry+dUvojZvZpwzA8efQa8byU0rea2W8Nw/CWo9cbjp7Yz+srUFqBlNKzzOwVZvZrZwn6GSudUvrjeqanjl6vK8vRlevn3bkV6Mpyy588pfQS7by4Kb9c2Z1fZmZfYWbvrh0zP0/uz4vN7JeHYfi9W36tO3G7riy3/JlTSpuKIMHHbUChmtyGlBJxAvHCTw7D8NGW11Jc8Coz+41hGN7dcs5dPqYrywPy9VNKn21mKOJ7h2H4RMtrKb5AKT8xDMOH1s6RYv3eUaulTcI3gKJFbXnmax7TleWaq38f3VvZJIL2dx557GD5ml3LI/e5yXO6stzk6t6D15Y1sT0W4owMlyzTs1rdyg0r94VyObGii/gspfSXOH8Yhjee+Qm6spy5mvfgtSSkpHJxs3DPiG2eHIbh8SOPq+u9ZMttO3Lt1nNSSq82sxeY2RtLLmdXltaVfICPSyn9WTN7ak+xL6XELoyy4D79hpmRjSOgb4prClk3noFrkBAgBnnHGdZiz2drsVIcc/Qda8/SLcuer6RjcUv2uDEHblE8JaX0SjPj3ruq0GTXzhJoCSop6t8yMxSRjF2T4smdw7KR3l5U90PC4UOt1ywtlK7zV83sw0ctaOm6XVl2SrKExT/4e3eefurhQXAJvE+vraSUqPWgnIeC+oJVAsJCPFEM8lNKLzIzUtko0+FUtpQFRWZdmlLvLR+mK0vLKoVjzgh2d96yergsDbt8c21lz711/YfPCJSl2ATdVSuktUVBcfMeuYkNYM/7z4/tynLJ6l35XNVWnr2jys/OTa3ktN12xQ3CghAbZaukoPvpLRdS1gWlaiqs3uYn6Mpym6s9tVAUEBeBtoJ4hGWX69MSl0hgf2cYhsdu8rVlIUgEkHXLxc4txRZqgaD8FJTxnvdrda27suxZ1ROPVZFvEYCq0o2yNFe5g69PYDzGURJQsmfZ9ZFAEoNMdm0d96Vm9r/i+Se+7ualjrh8Un5g97s2lkIs5W0Fk/XrbtjmZzvvAAXIxBQ/Mfe/JeAI8sWBedjJ+dh5Z9Zu+b1m9pFhGL5v7a1SSn/ezP60mf34MAw/27oCgr3j1q1CZVqupxQ312raJPTOZAc/eoaCt8B5umVp+ZIHj5FCUIsg+7OZXj0zJZ1Ser6Z/WMz+6lhGH5gQ1lwCclUoWxV5ZWAYpncUpGepX+lWBw8uGynn6ZNC0W8KHvZleX0T3PsgiklCoekO7FC1QBcuzmxzmYAfInylWKMefZNuzGbAcr2zmEYfq329gFJsIqk1vsBCn2sYI3JlAH63NWBqTiQzWBxzT1fqyvLntW6wWMlJGSrqlZIAletU5z5eIoHCLhf59cNgoxiuHVBUb5Az72m5CjA12y1G0tJ/6SZPV6IrYqtwXOLd+Y6xGt1ZdFqyGWiptDkM9/UB9m67jxo3zr+6N91H+odKAVFwk03cuteSjBgGZrjNMeimdnvkPaWZZk8y5HkwNazlv7eleUPlIUdG1N9IwW+SgYGQOIul6LlI0vQX3DptWVJvAel+pxrG40Cd9LVh1LCoVmuCl3ZSku3rNlGTEe27FVdWf5AWXAT2EmbsU4tH0ECx2LjXo07qvxo7rcao7Tco6CI+Pa4RxcF3q1wmpLLxjOFlPYlfTAkEE6HruxZV1nEL+zKsmfVnhEABBwfHb99051wQZrDN24K6h46Ehc+f3xVvQdK9Ukz+xQp7aarJcEhszQeq99hyRYubFCYi6iRChsCCsT/bg313JVlv7JQmaaXAnetRbjYGcd0687b5ULiHnhKcFtW3cmgVC81s19BWSR8uF0ZlxWyXaSUnwpo3l38W0rdUmhdBUfqOFzhzY1I7t3n6tjN71BxgydKv/VturJsrdAV/u4KEgR/NS171iOGGMWVBcXhfz8/DMMHAoiUYurFhciCAHuvzMR9LFlzPeuhxEPIKu6C8HdlOUvSDlxHH5zYYqzwS0FIkb7PzP6bdntQAOzuRQEtWR8JBNeuCtRWHUbK8aK9wfnadRWMs6MX60Tzpi29x58zM9bgrdRyWlkvXcnmWLig9KxNtV6l74NFzMmNriwHhLx2ityI5qKZXInPjh8z0BP99jAMb1egTP8MiN0FAFLK9U1m9qvDMLzBn01COdY1dC8E31HAxF7s5Nld2xuLhfvgNmF9iFdwh8gqVgN6xXAkU14n145/j/i1SmzyVbrmW8N9qUmtwoX0Pdgw3iFYzBo6YUEX666eI6W7spyrLPSGsxPt6mTcegQJPjUgR/Ai6C9Xay8f+e8iDGb2b2aB9yhQ81qEAu+v9OJfSgn/39uFFzFWjegi7PK0LKOIIBGqblpK6UvM7GvN7GfM7H+o2WuV8UXvzya0q7VAGw9rwHuuJhgcx7fWu9OVZUtSd/x9RaDI2lANvwibFHZVdnKHxnziCFJ57bVSSmC+UEwUMQfcEupU2ggE1dnkHgvPz25PWzKWiFrTJIu25R7u+CQkSEiwYEFHkGnpfCk9G11VIbuy7Fn5g8dKmDw22ZW5Ce7R6sc++GjF0/S8CA2Kguv2mLuYuENS/KYioyzYi1sLpKWkRmt7s9dDRDS4mdbfu2ZdWfau2C0fH9hZuPMjCG/N/9YuigXb5a7E+AM3znf2EuZKQe+fMrPn0dylHXutul/McBViE1xAirf8sLGMdSIpy8S107pwPNaa43EjURCnSDpVWXjvriy3LPxHbqfdFiVBKH32ySIzFgqA1RqL/H96QLIwaTd+jpl9qsjIPe7ANcKyvGwGpuR31GY+n9MVeGf3UjHCN+gd/4sSBxyPZcmuloScBMAc3+VK1ZQmF3fYw6E+RG8LcdC7WorFe78DCtuVZe+qNRx/lLOq1Ew199/XmpRCsF3MRsmlQyhzHUOW4++Y2QvNjExajjsExUGYcbmIKaqxVqzo63p/Q9f7j6VYRNmysTc/WjVZlmpmrLb0eobvktX9Vy1g2COYta4sDcIfD5lXtQvuhBfyqhkeCSOB5wjHD5xa3kzlOz81lyo10Dy4l+Ug+IfadHTHwkiKMX2snf6r5brQ67HKvFLoL/GJAJPi3tpmoQ2Bmglu1mr8JvdrtRYSlA1LR9brbWt9NeF4khjUe5opXruyzKTdC4W1RQwxRBEAGTirisVA/Z1aBMowwW+VrIaCbRTI6xgIKLWZnJ5W5gpUr/93TYAdVX2IYigQe3Nbt0y4WCgmSulp6i02fu9r2WoW4513EeXVrG4pS9nCajnfCLuyLJUlA/TWdpw9qc2dx/r4h3kq1QkVqGUQVMfi4qQ4F/o/JnHBpf06IaBeoJkDZmxOmEEc4eiD3WnzGF+FTks2oUkmrgLu5N6ZXUaF0InF3uNQjMq256R+7L4VCBQ7IGNX24ADXmnBMFIiZ9DvAFluthcH1wOBuSRb5lZrE0Ec3ofbE6OM6INgXbnOxBIFgOcE3hOLnwX4ClbzaQdVztcytBWPHZ6yyhRQqa2sKrK3fHfLsk/+dx2tD/wVaxX9EAPxwbAg2Y9v9OcnmapZsIyFnHAGz122lpeRRSLw94QA13XLh7ARr4y99zGGiv0wSu96Ro93/DYlAv7lDHWAQmJhJ/xmui6tEcRicyon798ZN5oWiy5UA2u9yqM2QoVaFqwfc3MrEDBc2YcPpBBbxBUoFjHDInsUkgUTAm4JfjMjZUhFO5QlMrtwf4R6nDQWdnSUaxI4h/ciNU31nrrKiGrQxsLvarEesQ69+YtZnA74lELSV9MctK992XmioluWm9OD5ivHwNTBlTXiCh2bLU8Q5kWwXIPeFLJ3HqTjDuGmjT0eukaOoySIKEiRiE4JgAzMLD27B9S6VobTzAgBvc6ycPFKxVG5URPi8jnwseUDSEkBnM7dPgeajmvblaVlRa9wzByrJEHgSVy4adbKQlyC7kfYfsjgLYqVAV5CwRPF+PgwDG8uKJVzhJHFIxs2qZCrSPiZZvb2tTpHDasVXLYSpa2n48c+F10HtPWnDMPwoy2fSM+IJX53KPSyQaAYc+VlY5iM1OjK0rLKy4xZ5sraMvcB18UHas4GBQ6xUTBDRoede3WScWjiwkUiG8RH5xxcu0VtQ4L6xWb2F/Wq/7xQYc+VeFyoGpymUEBFEBcj+QJqgDaEYq1Fawey+tfN7A8p1T6SAIYkAS3RvysY/ujG6e/UkLiHIwyoWfEDbMjdSLo33Z1dhch0ZTmmLAjf58bAvYJf4oPgKlQpRud9JnIv+HjMKRnZZiq1gnGokv5OcMwHhzaIf+d24BD4I7wE5aSV5+lXlIlnpVA6wXrJ3fPdtybcXPuzzOz/CuZCMA80B2F+gz+HnvO7zQzl/P7aJhJaCLjmRwT1mXBAzwq5PDPvlovBKaUvNzPu8++GYaCfhZoUf/+MYRgePfDZe/PXkUUrnaNM024q0+AiTYqFWzFHsB5eIHQfm8fbGhaUd9cZ2wzKQhBNcD4h2g73ql2X9yZ9+3lm9nMwP0pZcd0+bmbv0Zq5daWZ69PN7NGGrB8bBtcnruDfuJ+uuPAEjGM0In90SgnYzUuHYfgnLd84dJZWKWy7ZWlZyYZjHE6y1pteU4AWLJmuj7XhY75/3mUZ3JJVhdV5i96aQM1UymR5nARwkX78Cao5WDWyXKB+2cHZ6R1fxn877dOuFoVgFVFk7s9Pvn5l1F5WHj1H8zQCeQYgl980mzrAvZ4gU9mVpUERzjgkFChxgUaWkxDX8PHX+sF9hNzPDMPwRHwmV7aQcSK2QFDGgp+sQ66RrLg+xRhDLgzB+98H2bsWUNcC+D1rGGs7QVm8EQ1F4N8jcnrmZmLNJkXQlns78iF0o3IPOjoBmZIY6crSspBnHCMh8h0xcm551yMKxN8Rgjx2Wxkb4pIq3mpO3hAr5zNovVM4LeoULe+n+/wjWoGHYfgXM2XFarDzI8go9YSA26E28+FNJbi+jv0WZdXG2Cn004+KULLIWjP4Cpqa02rvrusQ94DfgyqqxywtgrKyoOzEuyAnUoIFOYJ+j+KM804kIKvuS8icjfGErAhZq4XA6G9/hSyRmb1W/GDcF9dsi9dr0psSdnSvkWRIv2otuEyZMDzEG1i7TDQe2gXmUBg2DGKaN7uQho2DBEQM+HNWUAq6WonXJsL5Cwteq/bPWXO6G3aBtrRyAc9vEXbJTQTwVjwTGC+JFwjMPZNW62lh5/+bshCPSIi+XVbhh0JT2Fis3ArCfQMosFQinAT1XssYifZC1X3iToXW4AWNrtAOn2Nmf1hKmCE9UtBN8Kuyc6xLnI6WoTJBiausMV1ZNpRljRFSgsYHY3dsNvtH4OESyEx8Ee8n4WI3Jk5BWYCmTOY5zlwmBBdELkErKVZSzPByYRWgXsqQlgDDybWa0jKVYos9e0/AxS16VvYCRfUsXkQstlVX0u8jCiBYuyJKoSvLtrJQyNpE2e4Rkq1jpQCLYaQBXzW6MzEAbrEABSvnVEEfNLMvigDGLerYLXLz+fkBDJljGv03hdCHzOw/xASHrPZfMLOfdv60mdLz3E7kzrWo6RA3lepEzm22Svoe4D0o70LhurJsKwt+Mab7EAnElmJUdmyPAagpkIrNQqBjHVa+iC+2XLatZ9liiywoGkVX6h9Yn8nUr7BLj9iq6Lb6WD6KhCpQTgi+ZXVwFz+minu+fXATfY2cJJBNjXgmo5i14eTCrJTKEdKPbyGSa/NeurJsSdAN/l07Mz57qafD4ew+hm51fEQAVa4S1p39Oiu1IxRpLB7KjeSdHOKPkm11S+aCpJgrJ2M0pEz8nXvgevIz0sIGxcx1I60Px4BcZvPh3iXSDy/u0iLwprheXVnOlp7G64UiIlmraj9FmMDF7h3nu5DWpGLuJN7EIijWGD9t7aAtj+qj8VpZNls7MvdawdCpObpSIU1eGpHu4MvRhZbbR2GXdaS4usDr6bt4PWpSQL2zyqKP6liiW3OxWgS05ZiU0l/TOO7XVOaisOvix5N4gCIIOMqWYi5S4VIWdvcmIGhK6TvN7I+Z2T8bhuH/bL2LBJ70e3OCZBa7oBQ5TT6fTePXjgVMvruwa7wr67NGuM4ajo14d1lZfLEOFekqsQY70qRyPvuwmHgE7+K5laUej4Bv8uvjuuBqgAwgA5bh6SEpwPMA8cgNXCGlXeQd0+4+SdGG2IB1JNCGN4xEwQ+WEAlBWD3o5nGILWKdiHWEm+y5JQV3108p6bwJKKbjfZ8tlIErj9dW5uBQZJ8EAu7iCHGRu+gbDTIyWq07qyxbO96Rv28NAg3Zoy0i7NwFWUAGjyjjirI2TQQOypLR0xIIoPxOqldkmPQaiCvcjC3TA+0MS6kpiplBno4yA67M0BRhyKJ7hQIAywexnJlrUkoE75CKQybOc7NGjj9DWTx9zr8928Yxjr726co8H8kBftg4SLlz7jigKdSemIpGW0O2el1ZjmhFOCfCK7bqJ44/Ej5rbfwB7gEfet7shBAtCOpm1mt1hMP8dQvpXYTny0q97oVzEXYE+L+3zK+URfgeIPfDMPzQSnIgY9RmP5Do4d69Rpk0Z8LJLcQzxa22ZIf6EWyaKBXjNlAWNqJodVEo1vI97gl0ZblcWUhZ7gburd1WCph3zpAqdTb4TO8TBIQMU2m46yLLVhB2z/yMhcc9MyCl/CQZ6J/x3X0kDqxYP3b6Vbxb4TmxBmwUmWww1EMmxWAJPVZtbDHQM/oYjGwx9TvgOGwKuFmlrFhmwlHLQt7YurJcrizEApsMIRfepnh6gLqMO2nIEBWr0DMrVCzW6RqkYYlBcJtQ0NUR5HPijdr7ppSwXMQRTTM5L7GaUgynb2Jcxg/79bQp8O3YKCYo7tqzd2W5UIrlx7NTNvN3bViV7Ge3ZJ/mbp92VmIAsnvuq1/EJi+FnOCpVhSBXX2LkhVLSI2l2OIsAc+NaLNOVLeCMREwyd7JInsVP6bZxwYxXX/y360i0JWldaUuOC70rKy6KPqQi3il9dYppewSBjaWBa7LMVdBoarZOz1Ptcdlx3NNJi5v1X9SSl+najw1pBiY5+yeB9zaHEA2e+zBv/+ymf1IRCzPrJP3BUWof40rgA1nJNDoytL6xS84ThaAgPED4gbj4xTnrBRG4jlid8F6UvDtc3CvlOqEmSS4H16sg/jCOy+baihHl0BKXJ0zWXiP4oz7Sv/LmNBQNhLL/JYVIowJD0FwW8cOUW1uKCbX4pvl/qKuLEcl4ILzQg/K5iySgLFatPtuuHOOUJ6zUo4QkpZXODKaoSD8u4P6wjXcDauCWufZNRVUWTefDcO7ewNeLkSHpjwsGIE+lh28GnSwpI6hduqp4xZhuYljtJsR6LLbrsYUodA4fvTg14+NYgXhqpLWbb1TaA0GDQyxxGayYCWOccuY37U0oTlYPRQCV4pNZM5LxnWKMJRwPkqZKV5lYUlte59PTg8rw1Udr6GExof1bTrcZUtY7oe/b/EWB4XcdN8qPj1KQv2E4iGKupkoKA0xDYBGL1rm0Rex5TkIu7PutzTFoTiTtLkUkXQwbthT/jxSEu/heW8rfm0uB90Nux80o/CMUoZNAvG9rxebvraKpwVr9o0ah/FvgwLg9zMmL5JnTLJmPjJC52SU8YaLGaEqgFCx0lUrW3hO4hF432IquTphYIQW7V3Mfvz2CoQOyuZx19tXvfePSClBageei/751aFGM2uGy4gC5YFMQdEWqWiHFImBkkMRchIVgEXhFeBai1EW8+sqeKdXKCtZoLEtUdzmpEi3LBsyuJd5nssF16M5A3SJKpSG+Ry5nqzK7pmOQbgRqjxBeKveMhPekvXxgH6S2BC+DvcL8KOPEvxSBe5vE4gzF1EDChlGSgCWKFKelSNrAZDyubiEgcV/QbKn7/nyriwrUqUF9dmD8OM2/ZSg4VsnzmdDbh0/E7ZqHFC7jjPOB9Ch1x92t1Bv1U32vEu0Ks7cP2fILLhVf93MGDdOa3Iko/AUNL9zStsIIWLdPlkhQh9rLGPx98iL3KVzlObFVK/CPS5dE2Vhnr0yy7IKkPQGsS0qo5mCuSBRSSdL5bWfXZal1D586VoUXCYyWYvxeLPjWJ/MFFNj3SwoGdcdv20o2LoVwnKNlqhbljO/7AXX0ocqjrALhbNbcetKryH3B0WKxHfULeD4eo6E6rQmOvXWOP0r+DSsA0Ls0wCq9/Li5DAMr9/zSUILBW4bmwkbSJ40xqbZlWXPal7xWPnNt0qcEVyicQDsbDaku2676zCBBqnIuCLrQNo7TgFAgB37VRud4Q1vxDrxXNyqBfdxgCKB7eM9HQGwSJV3ZbmiAtzmrSWcZI2aQJEFl6UIkozM9QW3qOrS6XmwGPSLTJhhjq5LSHsvWiYECH1obm10DiQWuYVYAM+i1erKcvTL7DjvADnDAnW743bFQwMn8oLc4dJrF5SEX4EsvlG3cd7SzE0l/BOrot9P+ukLmwGZMazP62f8ZSPIsivLmZJSuFbI31eZHQsfjh334WEYmjNwLa9RswIt524dE2A5VNDBUuXYpjBZONLLVgGcCH2NxMKzbwF1/K4Cbxnu1Dgfs2QpnWZJygTRBl2fPzCLy0gCAKF5S1eWLSm48O/a/SZTfbcuWWu33Trvmn8PluuXgMmsjNLzOOdjtQlcYYOpDU8C7MiOD3J60e8fUv5F8GnoBo19988XH8EvzCinRj6ErizXlLB7+N4hAJ+M2jv7kUs4rYCAmCCm/d5hovMCcBmOQcip0AOknLBmhrZkYpM872U2l8W5oiflgq4sZ3/9B+R6AYWw2UZwySsLEIq7dMrs+oK7BYDSZ8ZMulkD0SGuFlD8R0PP/ohCSCk9z8z+dleWS770PXpu+OCrhbytx3eOr63jLvm7rATKcjGXWkFRcNX4X+YTqPwdYnIsCS7fZER4gMBAy/S3urJc8qWvdO4WxDz45Kv1D6/aH2WDvK3Xn8NpWjFsocmO0d9wkKEQOU0dJxWspL+p62TWUgbJdmU58MWp9G7hlQ5ctvmU4CKt8WNN+t5LFw8MlPk6JZbL5oe64MC1hIasJAF9pp4N8JpNAvTAJYai/Hqc+hXefW3+zKT9uyvLzo+sXehrzk7r7nyMUw73BrHQdutM9UX61lNuOrtIiBsy82TFVUJZ+DvK4j30kcHSGSpH8vSQXi7WV8Lwo2aEdFeWAxKwt8h44BZXOUXuDYW5ZgE640FLuLPW6wZLA6qYDkmAlAT1ZMJg9HQYf45fZqP8CPxJL5egM7QIvFwtzvnvXVlav0o/7sZWwNG+R7jX5GrlWTZyJfk3lgj0wDjKI8QvkZAQ6qja7E02DVLKzmL5rK4sNyYC/cKtK6D4AYLykc2+taFNyoLFcKH2Pv5JPCdlofYycrellOiBoXEMxv817ulnxnW0vlA/rq/ATa2AFGPep4+AApdZrb8IIAk1a57SpbrNYg6NZk7S6PWov4fiFuK0CdtLbMQLafiPdmW5KQlouK4+FuZ+dTBow6UeuEMa0+N5DF+tjhIXZQ8uTqSA8IahgCgt/TpdWa4pZaHZ6Ear5Nd4xzBuDrj8KTzQM+EHb0cAPhlEdMa7ehuxaHC5DwDLz+yW5YzVPXgN79W/14uCR14vgCFvpCVgToq+9oy1Uekz5fORFrVBTq/synJEEvo5mytwtKd/88IHDlC8QnD/QXEXl6Avm6QfXVkOLH4/5fZXIPTLbLp1MSgXqpj4g3Zk4sPMuD9/A1mfV6xNju7Kcvvfvd/xwAqEfplNqqbgAkLsjYyDDKCwyKTi3VORlXZ+UVeWAx/uXj8ljLj4bR+XcK8/c2GnnxCKKy0MdGWBIFYVnzrNOC7Q6W1jN2TLGpR6ZYTF6xX8lgW8344JnYKbu/C9+m4B6Lj5DhJwslYjvKXlvUqBfwBfMhQKyEzmDeN63bK0rGo/5tZXIPSS0JOzOnpPVgcwJdAVnxS2OgZd51DtJ5aBJ5lW6DhaD2g+Mc44zq8ry62LQb/hmSug+MQHyWbY/ryFocRBFhSMacsvNDNIL8YGNLl2kGaM4767spz55fq1LloBCf7TrUF4QBzTZ0/gnq1QUCCq+8Q+uYYibjDqPpOuTKGtM/Wrv0CY9TIWPbuyXPR5+8lnrUCgqF0Q5NXuEYfJbgAhcadIH9M+/L7aOIwCKHNCLNiV5ayv3a9z8QrIIlQnlUmYfaTF5iSyvQ/k6OfZkCNioWcybXsv2I/vK3CNFZAVof8kzeOLtedp5WAL2bdJu7LweyQB3teV5Rpfvt9z9wooaKf/5CNSlpYMmROaF/FpkQhDVgtgZnEsOFavK8vuz9ZPuMYKCGJPz0vznByln3GjFkSBwZJUh72GyWEkDt7fleUaX77f80ZXoDTOQk1iNIW9M9RYSDmvjfl2KiTIMt7UleVGP1u/+G2swLwSH+KMTBiuuIW+/N+t8SuvZNzo6Qdi81RXltv4mv0ep6yA6iq0AcM+EwuIKALE3sQbzn9GS3Jzxiyl9PlmxvyWX5TlcTbL5wzD8Jv8rivLKZ+xX+Q2VkAWBGV5YqYsmenezNaGJ4Edy2O8S8+aUvoHZgZN62uFUGbw7qebGUr0Ws7rynIbX7nf46orEFktRcWK4qBYo+KklL7YzD51GIb3hZiGHv//Z2Y/DjKgK8tVP2O/eesKnDE+PHAewHcMuV51mFLpubqytH6tftzVVkDNV0BWqhD8lNLXmRku2huGYfiArAOWAYhL5jOe9+1LeZ5rZlAkLahj5y/cleVqItBv3LoCjcOLGFgE5B5IfUYKqzaDyzWCJyN5nzjGGBdOlmwcA16j5+3K0lNQHboAAA7ASURBVPrF+nFXXYFW2MraQwaUcm4o82vmTNczHMn0sFBb4WfRdNaV5aoi0G/esgIBkXxo+nEoUhKrPCwof4nhBZeNrNrvw9rv5IejorY8bD+mr8A1V0DCiiADWzlCOOEYsc2J0ar0U7NBYdwCUcf5ZLcs15SCO3zvM7Jbe5avlb5V4ypQSBrKSC/jnpFc6MTgexa8H3veCigT9ftH2WfkWpHtAuTYXKmPbxBilAymdEJwevk1tHVS5OyW5bzv36+0YwVKzPk7TifT5VPK5v0nWAH+tjm9TFm2P2Fm/0nKQr8MPygLisgPwEuYXjrcZc8H6sfeOysgQf9aM/vZaJ1kHYCoAKJc7XkpZMe8/Zj/R1mYRfkr0pOXdMty73z/O/8ke9PDKaXvNbM/amb/9AhTfwnKz0fwQbRSGOo0xC8PdWW58yJ6OwsgS0BfSDWbNe852XoyIYXpj/+vNSui+0I8kaEtUpDMMWZmryrVU3Qcx0yetyvL1hfpfz9lBVQth+YoT+gq/Sjor2K2DnZLknKmhz5TGgUeZFw0aiqL4qPugyJNmGa6spwiCv0iWyvgrs1WHLF2nTB78vWtGTBZEizLyJwvZUBZsB5k056K99Wz4n7RM0NfS2/+2vrA/e/31gq0DjAKRcwna/0rwdXKvTC1URMamYe1e2O3LPeWPPSnOWEFpCywUAKPGelXpSBkusCCQfNKZR5XDOtShOvHYaxdWU74OP0S568ArlJl6BCuExzE44z7SvxTJAZXEoGBqh47UdBEYXC3csW+9jZdWc7/zv2KF65AqKzTvzKplShuQaChRHoGhqJ4JATvYMhqlgLFgFIp9vDnEXma7zLhQY6v0pXlwg/bTx/7RnIQfMZ6KN0Lq8o4nGh+3ZCxGhUj8HztYnERMTizWLgWsJdXm9nzzOznYszTleWMr3vHryHfH7fnjbe1FCkl6itYA8grIvs97tTI7AKsJiqxFKNKbKG4BmWhtwUrM2beurLc1td9gO8jAXz2fJTDTb1ysCqr/S3BLaN7EookbzPO5+k6X8kwo3mxVH9D6caUc1eWm/qi/bo3tgLKdiH4VcZ9WQjSwl/uOLGUEoOLyIC9VT35WKFvN7Nf3UoYZGt1Y2/UL9xX4EorEDBfDCiKgfw3KikAGd8TsjTgy2gK+0F/XFkk3DySBGTf8nW6slzpg97124a59jmoPms91Lz1GeL7AsoSlYUYZ+yBkaX5TmD4kd1FjP0w6sMhRuzy8zDGdGU56yv16+xagTD3sdh3ovQxlfMig2TtZhGDpp4Z4o5qlq40Ik8uXJ76FZleurLs+sT94LNWQJZlUu+I1xbMhMFF40zHlntHmL+szIvNrDpWopCSJhNGGnxR9OzK0vIF+jG3vgLKRpGOHiH9shTUQyaB/YwLjKCd6v+TshoviZCXOeN+QVkoUHL9CUymB/i3LgL9hjPrgWB/m5n9z7iTy0WjKEngPbpQwXWbVOhlhbAGjwRrsqj+y70CTewTvuZoY+ITajDzacaZUb9bli6/h1cgZI0IkHcH6SklWOr/oZn92DAMbw3ZKBjsH/IREuH3CK3D6kcYjJSI2ATiPCAwxBt5Qlho9iLYpzqf4S4CWcZiJrrwTWr4eiz21ghR8IquLIdF5f488cyJvwrCvyBWufeuyrzCHgQcF2wTPhNdsNK9pTzUWt5TsxhmhmsHyQWM+b+kyv04/MhT0V1Z9n7d+/x47ZjsrFWS7T2vWOMF3nONo8emlEgR/z0UwczettJaTHGSzBqWZUQjC6bD3z5uZnAej8NXS3wAXVmOfqn79Ly9pBD38mumlL7EzL4D4m/14VeHs8oCvdTMmMPirPpYE+ouT0tRVl3Jriz3sjTcx88mdw8M1uYI7rXXnOO7CtkrrAtyvNqLIov6RWZGZf5HfWhRiIewMPxkC1RIRHS4y30sj7f+6ErnshPnYLn2ACX4/NGH1bW+rIUHbEPpyK4BmlyQVMjaklSgAEoSgSSBgy85nnTye7tlOfoV7+B5ewgj5tzCEkhSs4uZ9CtKl0kjStZJQfdXiWYVS7GZjQttxCjCvKnM6ZE848aGQAWf/2aD6FzHd1DmD7/yJfHOXib8MGZiQVWkjBlu03eZGW7Yv5bSZAHX37EOKBvxSB4zYWacQ8Hyh2duVm5VFkastxUflpB+4q2tgDoUiRngF6ZGggCD+C0KsBQQN4k0Lz8j73FIGT8hMORvDsPwY6WXUTyDmzZmw0rHdTfs1kSh32jF3fKZ8xDiFXFZG/EIWS0sygLBLGTxnxGE5dFgdSbk4fMRGKX6TVeWLsOnroAKlezSj7XEERJeLAMuUjPgMbhiuFpFFkvFWN9Ac5cmeWE56JjE7cIdyxZs/hMSFPzpg5pJ+VRXllNF5cG4WGieIrge22pb3k6CSPaqGS0csGBF2IzcLXrpJ88S0so8GufCXzz+pJS+hdn2ZvZTFB5LPMtOuSRMGbHNT+gCzin2WWb2AfpdurK0SMAdO0axAtN/J7NPWpeh4NIQVyDsu0fcyYIwWoL07fc75ku/90wVPGITKxGsA1RJxbHdcrVQCu+ZwQWMmDKuz7NjiT7claVVAu7YcWfCWBRAj+Tce5cypUSfPOnbf9+qcCFVTbFy0kCmdmKQx/SsTLjHCi7ZN6s+8/auLHu/XD9+9wrIrVtYFsUUxCqr8U2s2bR0P249YHAVcwyzdryeEYjMf+7KsrWy/e+nrIDPSYnV/yMWR/SrgCEf2RByXKhXmtn/NrNfLBQhsSggppsSEcRHXVlOEYW7exGH/Jc6C2fBNrEBI7Obx0X4+QrkmeuIAnCdBV+YLAC/j52VpKI/h7HcDl8J15xwJoe+F9LP8+p+hrx0ZbmDcr4FTtyzJMoiPTQMQ65hKPD2MQ5RcNnJsQgLAoq1qWDzSn5pRHc4JrOwzJTUA/SFEuhZ/e+4Y9ReisR9JD26suyRjAfkWCkLLgjp1otQwaUlcQzZHFZSWz5hthhJt6h7xMFCGywtmY2l5RMpVU2WjD59lJjmMO5NEgGlwerwd0cSYNF6p2TL4t61YySg+PtATYps9BvxQubnaqUxksAinJudkbIGWIBMfKfMFgDNx1tqQsEKjSPwPPMX+vdx+Ugju7JgKb++W5a7pgkN7yuBynirrUC64XKLQy5JS0c4PYocCPEmbcNCEvD8HIPy8m8HWYIwWPS/rFX28zMfedl+zoO/AooNHj6b7DsI+2S46SzOeIZNpeJWKYtGDJIr+konY11g1M9VfJHtpWEYXu8s/wryF6BMKRx1IOiPRrrW+VfuyvLgy/3V33AOSkwpfbeZvdDMvq8y3cuxYqVhRs6EP0L3pYCcM7piuicK99FgfYoQHB2bMWZSFtZsgV7oynJ1Ubq/H8An/wYXZyS50w7vwv3hYRge1+/YvT3BkOOUiA9TVZ0i5rv1+5fF2S9z6H5Ln03OZjXAbRQ/4aYtcHFdWe5vWb3q04cUdAyWSQw4ewydhgTH3iFZxYbJtUKxJoBIxRH0zeNygRQu4rw2Eg5kvEZIvpQLheCaPCuZtE1O5a4sVxW3e/fm8vlRgiKMXdbACevG+ol2fYQTBpWmVG641shwP18Zr/Z7OjoMJsq98g3KQnrYIfq4XPzvJ4X7Im2duY3XBjN1Zbl35fWqTyb3h/Tp5o5bEOzipOAQjL9gK3GQUgLmT9D9aKkvRkKNO0dssUcpcROB7j9/GIbXKFPGe+bAXzUilD3HS6EdurO7XFUiH8CbS9ioscA7vFAa/R1B9a5FdniEk175EaelJABDUF+7khUDtk+9JcdCFWuEIowk3yEZQKbMx3uPp4ZJyfTsYzmxrLiWXVkeQHm96ispxqCm8SGBHsdKeHC3RmrWsJOjLGSrfIfHqpC6rlo2XX90oQrKQqxEomAxPqKiXMQx/PAMKDHnZoXKin/Vle03v+9WQLGCZ7JW6YfkKjGDJaMAKpaG3buV1zjjy4Tf8gIj/41g45IVmfNr946LL4uDpSILRiFzMvW4W5b7TlSv/8BbNYvaEzoTfUufvTJoBPsjAcWsLz6PnHDl07UnVEYhU+cJChDIxSlj/sxbKehuWa4vf/fUE2yx0rc8bAA/Ek94RZ0UMhaAgHzLImElPN3sVslT0Oz4/A4iCkZWvHkFyQy3MaTh3O+r9W8IwEkjN2HJ4vt2ZWn5+nfkmBLI8Miry1XLwlnKeoW2XgQXKzFv+/XeeuDyE+Z7uVRYkW8FGWxmEObBF0DAvlmDkWuIlXnXnOBi6127smyt0B36eyscfsXV8mo99YsqUXegS0JZJgmAQpDuVqZaT9mb5j4K5OzK8oArgzJGkxHXN/XKoVrP/VYplAKHMC5RxmEJ8Pg02avQuYj7NcLl15499qkceUetVdU968pyZFXvo3MiVP1ee+wAO8EKUQAkpgE1APiReON75Mq9buvZgws5YtC2zpllw0gbM+vlR2ruWVeWPSvajx1X4JJxe1JgGqywPgvyPMUlxC3MeGQ4KyR5+WctY6V4BHbKpiaymbKQUMDlmwx37QF+F/pdK1Aah32EmUXCnrsOsSB6CICM1EyISVrGRjBHBUV6h4SbGk2NRI8aDm4ek8G4HwqBi7hQJqdrWiMi75Zll9jczYNL47IlXE3FxELQTjYLgSUr5XPti1V2Keo4jUtWCSUAwoLSFWErUkyOwzqRPgYhQNYMxkkn1quCREtfuivL3ZT/XW+dUgIiD/jxSD9+7m8p7dhyqdY6Ij27lmH7QkKD2cISUb8ZAZAtL+TtxVLSJyMVbOl8FUK5R7ZEXVlaVrkfs3sF5KaxsyNo7OSL6nnIiBHUL5DDsirAZXIdRtfknyhRDuQVO6GQWB8yaiOZxdpDy0Jxnar7N8eedWXZLQb9hJYVkOuWXSxB7RdUqcp+kQErTveq3UcKgYLgihHD8PMxkMwScKwO7lYm/V6p8MN3XB1gJMgMQM2cBu/K0vLl+zHFFZBbU2zY8qyVgnE6ERd1F52P1cG1GtlX4s0k/PxqtABhtiVxDhYJCza6S7JCJBJeXUMRrChitRfn/wN5HgYIM2g/+wAAAABJRU5ErkJggg=='
            />
            <clipPath id='a'>
                <path
                    fill='#fff'
                    transform='translate(.5)'
                    d='M0 0h321v246H0z'
                />
            </clipPath>
            <clipPath id='j'>
                <path
                    fill='#fff'
                    transform='translate(62.152 52.057)'
                    d='M0 0h58.517v58.304H0z'
                />
            </clipPath>
        </defs>
    </svg>
);

export default SvgComponent;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect} from 'react';
import {useIntl} from 'react-intl';

import {trackEvent} from 'actions/telemetry_actions';

import AccessProblemSVG from 'components/common/svg_images_components/access_problem_svg';

import './access_problem.scss';

const AccessProblem = () => {
    const {formatMessage} = useIntl();
    useEffect(() => {
        trackEvent('signup', 'click_login_no_account__closed_server');
    }, []);
    return (
        <div className='AccessProblem__body'>
            <AccessProblemSVG/>
            <div className='AccessProblem__title'>
                {formatMessage({id: 'login.contact_admin.title'})}
            </div>
            <div className='AccessProblem__description'>
                {formatMessage({id: 'login.contact_admin.detail'})}
            </div>
        </div>
    );
};

export default AccessProblem;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {UserProfile} from '@mattermost/types/users';
import {Channel, ChannelStats, ChannelMembership} from '@mattermost/types/channels';

import Constants from 'utils/constants';
import * as UserAgent from 'utils/user_agent';

import ChannelMembersDropdown from 'components/channel_members_dropdown';
import SearchableUserList from 'components/searchable_user_list/searchable_user_list_container';
import LoadingScreen from 'components/loading_screen';

const USERS_PER_PAGE = 50;

export type Props = {
    currentTeamId: string;
    currentChannelId: string;
    searchTerm: string;
    usersToDisplay: UserProfile[];
    actionUserProps: {
        [userId: string]: {
            channel: Channel;
            teamMember: any;
            channelMember: ChannelMembership;
        };
    };
    totalChannelMembers: number;
    channel: Channel;
    actions: {
        searchProfiles: (term: string, options?: Record<string, unknown>) => Promise<{data: UserProfile[]}>;
        getChannelMembers: (channelId: string) => Promise<{data: ChannelMembership[]}>;
        getChannelStats: (channelId: string) => Promise<{data: ChannelStats}>;
        setModalSearchTerm: (term: string) => Promise<{data: boolean}>;
        loadProfilesAndTeamMembersAndChannelMembers: (
            page: number,
            perPage: number,
            teamId?: string,
            channelId?: string,
            options?: any
        ) => Promise<{
            data: boolean;
        }>;
        loadStatusesForProfilesList: (users: UserProfile[]) => Promise<{data: boolean}>;
        loadTeamMembersAndChannelMembersForProfilesList: (
            profiles: any,
            teamId: string,
            channelId: string
        ) => Promise<{
            data: boolean;
        }>;
    };
}

type State = {
    loading: boolean;
}

export default class MemberListChannel extends React.PureComponent<Props, State> {
    private searchTimeoutId: number;

    constructor(props: Props) {
        super(props);

        this.searchTimeoutId = 0;

        this.state = {
            loading: true,
        };
    }

    async componentDidMount() {
        const {
            actions,
            currentChannelId,
            currentTeamId,
        } = this.props;

        await Promise.all([
            actions.loadProfilesAndTeamMembersAndChannelMembers(0, Constants.PROFILE_CHUNK_SIZE, currentTeamId, currentChannelId, {active: true}),
            actions.getChannelMembers(currentChannelId),
            actions.getChannelStats(currentChannelId),
        ]);
        this.loadComplete();
    }

    componentWillUnmount() {
        this.props.actions.setModalSearchTerm('');
    }

    componentDidUpdate(prevProps: Props) {
        if (prevProps.searchTerm !== this.props.searchTerm) {
            clearTimeout(this.searchTimeoutId);
            const searchTerm = this.props.searchTerm;

            if (searchTerm === '') {
                this.loadComplete();
                this.searchTimeoutId = 0;
                return;
            }

            const searchTimeoutId = window.setTimeout(
                async () => {
                    const {data} = await prevProps.actions.searchProfiles(searchTerm, {team_id: this.props.currentTeamId, in_channel_id: this.props.currentChannelId});

                    if (searchTimeoutId !== this.searchTimeoutId) {
                        return;
                    }

                    this.props.actions.loadStatusesForProfilesList(data);
                    this.props.actions.loadTeamMembersAndChannelMembersForProfilesList(data, this.props.currentTeamId, this.props.currentChannelId).then(({data: membersLoaded}) => {
                        if (membersLoaded) {
                            this.loadComplete();
                        }
                    });
                },
                Constants.SEARCH_TIMEOUT_MILLISECONDS,
            );

            this.searchTimeoutId = searchTimeoutId;
        }
    }

    loadComplete = () => {
        this.setState({loading: false});
    }

    nextPage = (page: number) => {
        this.props.actions.loadProfilesAndTeamMembersAndChannelMembers(page + 1, USERS_PER_PAGE, undefined, undefined, {active: true});
    }

    handleSearch = (term: string) => {
        this.props.actions.setModalSearchTerm(term);
    }

    render() {
        if (this.state.loading) {
            return (<LoadingScreen/>);
        }
        const channelIsArchived = this.props.channel.delete_at !== 0;
        return (
            <SearchableUserList
                users={this.props.usersToDisplay}
                usersPerPage={USERS_PER_PAGE}
                total={this.props.totalChannelMembers}
                nextPage={this.nextPage}
                search={this.handleSearch}
                actions={channelIsArchived ? [] : [ChannelMembersDropdown]}
                actionUserProps={this.props.actionUserProps}
                focusOnMount={!UserAgent.isMobile()}
            />
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';

import {createSelector} from 'reselect';

import {searchProfilesInCurrentChannel, getProfilesInCurrentChannel} from 'mattermost-redux/selectors/entities/users';
import {getMembersInCurrentChannel, getCurrentChannelStats, getCurrentChannel} from 'mattermost-redux/selectors/entities/channels';
import {getMembersInCurrentTeam} from 'mattermost-redux/selectors/entities/teams';
import {getChannelStats, getChannelMembers} from 'mattermost-redux/actions/channels';
import {searchProfiles} from 'mattermost-redux/actions/users';
import {sortByUsername} from 'mattermost-redux/utils/user_utils';
import {UserProfile} from '@mattermost/types/users';
import {Channel, ChannelMembership} from '@mattermost/types/channels';
import {ActionFunc, GenericAction} from 'mattermost-redux/types/actions';

import {
    loadProfilesAndTeamMembersAndChannelMembers,
    loadTeamMembersAndChannelMembersForProfilesList,
} from 'actions/user_actions';
import {loadStatusesForProfilesList} from 'actions/status_actions';
import {setModalSearchTerm} from 'actions/views/search';

import {GlobalState} from 'types/store';

import MemberListChannel, {Props} from './member_list_channel';

const getUsersAndActionsToDisplay = createSelector(
    'getUsersAndActionsToDisplay',
    (state: GlobalState, users: UserProfile[]) => users,
    getMembersInCurrentTeam,
    getMembersInCurrentChannel,
    getCurrentChannel,
    (users = [], teamMembers = {}, channelMembers = {}, channel) => {
        const actionUserProps: {
            [userId: string]: {
                channel: Channel;
                teamMember: any;
                channelMember: ChannelMembership;
            };
        } = {};
        const usersToDisplay = [];

        for (let i = 0; i < users.length; i++) {
            const user = users[i];

            if (teamMembers[user.id] && channelMembers[user.id] && user.delete_at === 0) {
                usersToDisplay.push(user);

                actionUserProps[user.id] = {
                    channel,
                    teamMember: teamMembers[user.id],
                    channelMember: channelMembers[user.id],
                };
            }
        }

        return {
            usersToDisplay: usersToDisplay.sort(sortByUsername),
            actionUserProps,
        };
    },
);

function mapStateToProps(state: GlobalState) {
    const searchTerm = state.views.search.modalSearch;

    let users;
    if (searchTerm) {
        users = searchProfilesInCurrentChannel(state, searchTerm);
    } else {
        users = getProfilesInCurrentChannel(state);
    }

    const stats = getCurrentChannelStats(state) || {member_count: 0};

    return {
        ...getUsersAndActionsToDisplay(state, users),
        currentTeamId: state.entities.teams.currentTeamId,
        currentChannelId: state.entities.channels.currentChannelId,
        searchTerm,
        totalChannelMembers: stats.member_count,
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc | GenericAction>, Props['actions']>({
            getChannelMembers,
            searchProfiles,
            getChannelStats,
            setModalSearchTerm,
            loadProfilesAndTeamMembersAndChannelMembers,
            loadStatusesForProfilesList,
            loadTeamMembersAndChannelMembersForProfilesList,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(MemberListChannel);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

import {Channel} from '@mattermost/types/channels';

import MemberListChannel from 'components/member_list_channel';
import ChannelInviteModal from 'components/channel_invite_modal';

import {ModalData} from 'types/actions';

import {ModalIdentifiers} from 'utils/constants';

type Props = {

    /**
     * Bool whether user has permission to manage current channel
     */
    canManageChannelMembers: boolean;

    /**
     * Object with info about current channel
     */
    channel: Channel;

    /**
     * Function that is called after the modal is hidden
     */
    onExited: () => void;

    actions: {
        openModal: <P>(modalData: ModalData<P>) => void;
    };
}

type State = {
    show: boolean;
}

export default class ChannelMembersModal extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            show: true,
        };
    }

    handleHide = () => {
        this.setState({show: false});
    }

    onAddNewMembersButton = () => {
        const {channel, actions} = this.props;

        actions.openModal({
            modalId: ModalIdentifiers.CHANNEL_INVITE,
            dialogType: ChannelInviteModal,
            dialogProps: {channel},
        });

        this.handleHide();
    }

    render() {
        const channelIsArchived = this.props.channel.delete_at !== 0;
        return (
            <div>
                <Modal
                    dialogClassName='a11y__modal more-modal more-modal--action'
                    show={this.state.show}
                    onHide={this.handleHide}
                    onExited={this.props.onExited}
                    role='dialog'
                    aria-labelledby='channelMembersModalLabel'
                    id='channelMembersModal'
                >
                    <Modal.Header closeButton={true}>
                        <Modal.Title
                            componentClass='h1'
                            id='channelMembersModalLabel'
                        >
                            <span className='name'>{this.props.channel.display_name}</span>
                            <FormattedMessage
                                id='channel_members_modal.members'
                                defaultMessage=' Members'
                            />
                        </Modal.Title>
                        {this.props.canManageChannelMembers && !channelIsArchived &&
                            <a
                                id='showInviteModal'
                                className='btn btn-md btn-primary'
                                href='#'
                                onClick={this.onAddNewMembersButton}
                            >
                                <FormattedMessage
                                    id='channel_members_modal.addNew'
                                    defaultMessage=' Add Members'
                                />
                            </a>
                        }
                    </Modal.Header>
                    <Modal.Body>
                        <MemberListChannel
                            channel={this.props.channel}
                        />
                    </Modal.Body>
                </Modal>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';
import {connect} from 'react-redux';

import {canManageChannelMembers} from 'mattermost-redux/selectors/entities/channels';
import {Action} from 'mattermost-redux/types/actions';

import {openModal} from 'actions/views/modals';

import {ModalData} from 'types/actions';
import {GlobalState} from 'types/store';

import ChannelMembersModal from './channel_members_modal';

const mapStateToProps = (state: GlobalState) => ({
    canManageChannelMembers: canManageChannelMembers(state),
});

type Actions = {
    openModal: <P>(modalData: ModalData<P>) => void;
}

const mapDispatchToProps = (dispatch: Dispatch) => ({
    actions: bindActionCreators<ActionCreatorsMapObject<Action>, Actions>({openModal}, dispatch),
});

export default connect(mapStateToProps, mapDispatchToProps)(ChannelMembersModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import Textbox from 'components/textbox';
import BaseTextbox from 'components/textbox/textbox';

type Props = Omit<React.ComponentPropsWithRef<typeof Textbox>, 'suggestionListPosition'> & {
    suggestionListStyle?: React.ComponentPropsWithRef<typeof Textbox>['suggestionListPosition'];
}

const PluginTextbox = React.forwardRef((props: Props, ref?: React.Ref<BaseTextbox>) => {
    const {
        suggestionListStyle,
        ...otherProps
    } = props;

    return (
        <Textbox
            ref={ref}
            suggestionListPosition={suggestionListStyle}
            {...otherProps}
        />
    );
});

export default PluginTextbox;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {
    IntegrationTypes,
} from 'mattermost-redux/action_types';

import {openModal} from 'actions/views/modals';

import {ModalIdentifiers} from 'utils/constants';

import InteractiveDialog from 'components/interactive_dialog';
import store from '../stores/redux_store';

export function openInteractiveDialog(dialog) {
    store.dispatch({type: IntegrationTypes.RECEIVED_DIALOG, data: dialog});

    store.dispatch(openModal({modalId: ModalIdentifiers.INTERACTIVE_DIALOG, dialogType: InteractiveDialog}));
}

// This code is problematic for a couple of different reasons:
// * it monitors the store to modify the store: this is perhaps better handled by a saga
// * it makes importing this file impure by triggering a side-effect which may not be obvious
// * it's not really located in the "right place": dialogs are applicable to non-plugins too
// * it's nigh impossible to test as written
//
// It's worth fixing all of this, but I think this requires some refactoring.
let previousTriggerId = '';
store.subscribe(() => {
    const state = store.getState();
    const currentTriggerId = state.entities.integrations.dialogTriggerId;

    if (currentTriggerId === previousTriggerId) {
        return;
    }

    previousTriggerId = currentTriggerId;

    const dialog = state.entities.integrations.dialog || {};
    if (dialog.trigger_id !== currentTriggerId) {
        return;
    }

    store.dispatch(openModal({modalId: ModalIdentifiers.INTERACTIVE_DIALOG, dialogType: InteractiveDialog}));
});

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {closeRightHandSide, selectPostById} from 'actions/views/rhs';
import {getSelectedPostId, getIsRhsOpen} from 'selectors/rhs';

import messageHtmlToComponent from 'utils/message_html_to_component';
import {formatText} from 'utils/text_formatting';
import {getHistory} from 'utils/browser_history';

import {openModal} from 'actions/views/modals';
import {ModalIdentifiers} from 'utils/constants';
import {useWebSocket, useWebSocketClient, WebSocketContext} from 'utils/use_websocket';
import {imageURLForUser} from 'utils/utils';

import ChannelInviteModal from 'components/channel_invite_modal';
import ChannelMembersModal from 'components/channel_members_modal';
import PurchaseModal from 'components/purchase_modal';
import {useNotifyAdmin} from 'components/notify_admin_cta/notify_admin_cta';
import Timestamp from 'components/timestamp';
import Avatar from 'components/widgets/users/avatar';
import BotBadge from 'components/widgets/badges/bot_badge';

import {openPricingModal} from '../components/global_header/right_controls/plan_upgrade_button';

import Textbox from './textbox';

// The following import has intentional side effects. Do not remove without research.
import {openInteractiveDialog} from './interactive_dialog';

// Common libraries exposed on window for plugins to use as Webpack externals.
window.React = require('react');
window.ReactDOM = require('react-dom');
window.ReactIntl = require('react-intl');
window.Redux = require('redux');
window.ReactRedux = require('react-redux');
window.ReactBootstrap = require('react-bootstrap');
window.ReactRouterDom = require('react-router-dom');
window.PropTypes = require('prop-types');
window.Luxon = require('luxon');
window.StyledComponents = require('styled-components');

// Functions exposed on window for plugins to use.
window.PostUtils = {formatText, messageHtmlToComponent};
window.openInteractiveDialog = openInteractiveDialog;
window.useNotifyAdmin = useNotifyAdmin;
window.WebappUtils = {
    modals: {openModal, ModalIdentifiers},
};
Object.defineProperty(window.WebappUtils, 'browserHistory', {
    get: () => getHistory(),
});

// This need to be a function because `openPricingModal`
// is initialized when `UpgradeCloudButton` is loaded.
// So if we export `openPricingModal` directly, it will be locked
// to the initial value of undefined.
window.openPricingModal = () => openPricingModal;

// Components exposed on window FOR INTERNAL PLUGIN USE ONLY. These components may have breaking changes in the future
// outside of major releases. They will be replaced by common components once that project is more mature and able to
// guarantee better compatibility.
window.Components = {
    Textbox,
    PurchaseModal,
    Timestamp,
    ChannelInviteModal,
    ChannelMembersModal,
    Avatar,
    imageURLForUser,
    BotBadge,
};

// This is a prototype of the Product API for use by internal plugins only while we transition to the proper architecture
// for them using module federation.
window.ProductApi = {
    useWebSocket,
    useWebSocketClient,
    WebSocketProvider: WebSocketContext,
    closeRhs: closeRightHandSide,
    selectRhsPost: selectPostById,
    getRhsSelectedPostId: getSelectedPostId,
    getIsRhsOpen,
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import Constants, {EventTypes, A11yClassNames, A11yAttributeNames, A11yCustomEventTypes} from 'utils/constants';
import {isKeyPressed, cmdOrCtrlPressed, isMac} from 'utils/utils';
import {isDesktopApp} from 'utils/user_agent';

const listenerOptions = {
    capture: true,
};

export default class A11yController {
    constructor() {
        this.regionHTMLCollection = this.getAllRegions();
        this.sectionHTMLCollection = null; // populated when region changes
        this.modalHTMLCollection = this.getAllModals();
        this.popupHTMLCollection = this.getAllPopups();

        this.activeRegion = null;
        this.activeSection = null;
        this.activeElement = null;

        this.mouseIsPressed = false;

        // The default behaviour is to only show a visible focus if the user is currently
        // in the middle of using the keyboard (i.e. the user is pressing a key on the keyboard).
        // This behaviour was introduced in https://github.com/mattermost/mattermost-webapp/pull/3922.
        // But we want to be able to manually focus elements with the custom focus event, even if
        // no keys are currently pressed, for components that manually handle focus such as
        // popovers and modals. So we need a distinction between these two actions.
        this.lastInputEventIsKeyDown = false;
        this.lastInputEventIsKeyboard = true;

        this.manualFocus = false;

        this.enterKeyIsPressed = false;
        this.f6KeyIsPressed = false;
        this.upArrowKeyIsPressed = false;
        this.downArrowKeyIsPressed = false;
        this.tabKeyIsPressed = false;
        this.tildeKeyIsPressed = false;
        this.lKeyIsPressed = false;
        this.escKeyIsPressed = false;
        this.windowIsFocused = true;

        // used to reset navigation whenever navigation within a region occurs (section or element)
        this.resetNavigation = false;

        document.addEventListener(EventTypes.KEY_DOWN, this.handleKeyDown, listenerOptions);
        document.addEventListener(EventTypes.KEY_UP, this.handleKeyUp, listenerOptions);
        document.addEventListener(EventTypes.CLICK, this.handleMouseClick, listenerOptions);
        document.addEventListener(EventTypes.MOUSE_DOWN, this.handleMouseDown, listenerOptions);
        document.addEventListener(EventTypes.MOUSE_UP, this.handleMouseUp, listenerOptions);
        document.addEventListener(EventTypes.FOCUS, this.handleFocus, listenerOptions);
        document.addEventListener(A11yCustomEventTypes.FOCUS, this.handleA11yFocus, listenerOptions);
        window.addEventListener(EventTypes.BLUR, this.handleWindowBlur, listenerOptions);
    }

    destroy() {
        this.clearActiveRegion();
        this.clearCurrentFocus();

        document.removeEventListener(EventTypes.KEY_DOWN, this.handleKeyDown, listenerOptions);
        document.removeEventListener(EventTypes.KEY_UP, this.handleKeyUp, listenerOptions);
        document.removeEventListener(EventTypes.CLICK, this.handleMouseClick, listenerOptions);
        document.removeEventListener(EventTypes.MOUSE_DOWN, this.handleMouseDown, listenerOptions);
        document.removeEventListener(EventTypes.MOUSE_UP, this.handleMouseUp, listenerOptions);
        document.removeEventListener(EventTypes.FOCUS, this.handleFocus, listenerOptions);
        document.removeEventListener(A11yCustomEventTypes.FOCUS, this.handleA11yFocus, listenerOptions);
        window.removeEventListener(EventTypes.BLUR, this.handleWindowBlur, listenerOptions);
    }

    // convenience getter/setters

    /**
     * Determines if keyboard navigation is currently in progress based on several criteria as follows:
     * 1. There must be defined regions and a single region must be active
     * 2. The last input event detected must be a keyboard event
     * 3. There must be no open modals and/or popups
     * 4. There must be an active element and it must support classList
     */
    get navigationInProgress() {
        if (!this.regions || !this.regions.length || !this.isElementValid(this.activeRegion)) {
            return false;
        }
        if (!this.lastInputEventIsKeyDown) {
            return false;
        }
        if (this.modalIsOpen || this.popupIsOpen) {
            return false;
        }
        if (!this.isElementValid(this.activeElement)) {
            return false;
        }
        return true;
    }

    /**
     * Returns an array of available regions sorted by A11yAttributeNames.SORT_ORDER
     */
    get regions() {
        let domElements = this.sortElementsByAttributeOrder(this.regionHTMLCollection);
        domElements = domElements.filter((element) => {
            return this.elementIsVisible(element);
        });
        return domElements;
    }

    /**
     * Returns an array of available sections sorted by A11yAttributeNames.SORT_ORDER and optionally reversed
     */
    get sections() {
        let domElements = this.sortElementsByAttributeOrder(this.sectionHTMLCollection);
        domElements = domElements.filter((element) => {
            return this.elementIsVisible(element);
        });
        if (this.shouldReverseSections) {
            domElements.reverse();
        }
        return domElements;
    }

    /**
     * Returns the index of the active region
     */
    get activeRegionIndex() {
        if (!this.activeRegion) {
            return null;
        }
        return this.regions.indexOf(this.activeRegion);
    }

    /**
     * Returns the index of the active section
     */
    get activeSectionIndex() {
        if (!this.activeSection) {
            return null;
        }
        return this.sections.indexOf(this.activeSection);
    }

    /**
     * Returns whether the regions requires reverse section navigation
     */
    get shouldReverseSections() {
        if (!this.activeRegion) {
            return false;
        }
        return this.getOrderReverseAttribute(this.activeRegion);
    }

    /**
     * Returns the element that should currently have focus
     */
    get focusedElement() {
        let focusedElement;
        if (this.activeElement) {
            focusedElement = this.activeElement;
        } else if (this.activeSection) {
            focusedElement = this.activeSection;
        } else if (this.activeRegion) {
            focusedElement = this.activeRegion;
        }
        return focusedElement;
    }

    /**
     * Returnes whether an a11y-specific key is currently pressed
     */
    get a11yKeyIsPressed() {
        return this.f6KeyIsPressed ||
               this.upArrowKeyIsPressed ||
               this.downArrowKeyIsPressed ||
               this.tabKeyIsPressed ||
               this.tildeKeyIsPressed ||
               this.lKeyIsPressed ||
               this.escKeyIsPressed;
    }

    /**
     * Indicates if a modal window is currently open
     * - modals must have A11yClassNames.MODAL to be considered
     */
    get modalIsOpen() {
        return this.modalHTMLCollection.length > 0;
    }

    /**
     * Indicates if a popup/dropdown element is currently open
     * - popups/dropdowns must have A11yClassNames.POPUP to be considered
     */
    get popupIsOpen() {
        return this.popupHTMLCollection.length > 0;
    }

    /**
     * Indicates if the region should disallow the change of active sections and regions
     * This stops sections and regions from changing in the controller while this class is applied, such that another package can
     * utilize the a11y_controller to stop other keyboard events for accessibility reasons in favour of its own
     */
    get disableNavigation() {
        return this.activeRegion && this.activeRegion.getAttribute(A11yAttributeNames.DISABLE_NAVIGATION) === 'true';
    }

    // public methods

    /**
     * Determines the next region, sets it as active and updates the current focus
     */
    nextRegion() {
        const regions = this.regions;
        if (
            !regions ||
            !regions.length ||
            this.modalIsOpen ||
            this.popupIsOpen
        ) {
            return;
        }
        if (!this.disableNavigation) {
            let newRegion;
            if (
                !this.activeRegion ||
                this.activeRegionIndex === regions.length - 1 ||
                this.resetNavigation
            ) {
                newRegion = regions[0];
            } else {
                newRegion = regions[this.activeRegionIndex + 1];
            }
            this.setActiveRegion(newRegion);
        }
        this.setCurrentFocus();
        this.resetNavigation = false;
    }

    /**
     * Determines the previous region, sets it as active and updates the current focus
     */
    previousRegion() {
        const regions = this.regions;
        if (
            !regions ||
            !regions.length ||
            this.modalIsOpen ||
            this.popupIsOpen
        ) {
            return;
        }
        if (!this.disableNavigation) {
            let newRegion;
            if (!this.activeRegion || (this.activeRegionIndex !== 0 && this.resetNavigation)) {
                newRegion = regions[0];
            } else if (this.activeRegionIndex === 0) {
                newRegion = regions[regions.length - 1];
            } else {
                newRegion = regions[this.activeRegionIndex - 1];
            }
            this.setActiveRegion(newRegion);
        }
        this.setCurrentFocus();
        this.resetNavigation = false;
    }

    /**
     * Determines the next section, sets it as active and updates the current focus
     */
    nextSection() {
        const sections = this.sections;
        const shouldLoopNavigation = this.getLoopNavigationAttribute(this.activeRegion);
        if (
            this.modalIsOpen ||
            this.popupIsOpen ||
            !sections ||
            !sections.length ||
            (!shouldLoopNavigation && this.activeSectionIndex === sections.length - 1)
        ) {
            return;
        }
        if (!this.disableNavigation) {
            let newSection;
            if (this.activeSection && this.activeSectionIndex < sections.length - 1) {
                newSection = sections[this.activeSectionIndex + 1];
            } else {
                newSection = sections[0];
            }
            this.setActiveSection(newSection);
        }
        this.setCurrentFocus();
        this.resetNavigation = true;
    }

    /**
     * Determines the previous section, sets it as active and updates the current focus
     */
    previousSection() {
        const sections = this.sections;
        const shouldLoopNavigation = this.getLoopNavigationAttribute(this.activeRegion);
        if (
            this.modalIsOpen ||
            this.popupIsOpen ||
            !sections ||
            !sections.length ||
            (!shouldLoopNavigation && this.activeSectionIndex === 0)
        ) {
            return;
        }
        if (!this.disableNavigation) {
            let newSection;
            if (this.activeSection && this.activeSectionIndex > 0) {
                newSection = sections[this.activeSectionIndex - 1];
            } else if (this.activeSection && this.activeSectionIndex === 0) {
                newSection = sections[sections.length - 1];
            } else {
                newSection = sections[0];
            }
            this.setActiveSection(newSection);
        }
        this.setCurrentFocus();
        this.resetNavigation = true;
    }

    /**
     * Takes the provided dom element, finds it's parent section and region (if available),
     * sets them as active and updates the current focus
     * @param {HTMLElement} element - the DOM element to set as the active element
     * @param {array or boolean} elementPath - array of element's dom branch or boolean to find section/region of element
     */
    nextElement(element, elementPath = false) {
        let region;
        let section;
        if (elementPath && elementPath.length) {
            // is the current element in an active region?
            if (elementPath.indexOf(this.activeRegion) < 0) {
                region = elementPath.find((pathElement) => {
                    if (!pathElement.classList) {
                        return false;
                    }
                    return pathElement.classList.contains(A11yClassNames.REGION);
                });
            }

            // is the current element in an active section?
            if (elementPath.indexOf(this.activeSection) < 0) {
                section = elementPath.find((pathElement) => {
                    if (!pathElement.classList) {
                        return false;
                    }
                    return pathElement.classList.contains(A11yClassNames.SECTION);
                });
            }
        } else if (elementPath && typeof element.closest === 'function') {
            region = element.closest(`.${A11yClassNames.REGION}`);
            section = element.closest(`.${A11yClassNames.SECTION}`);
        }
        if (region && this.activeRegion !== region) {
            this.setActiveRegion(region, false);
        }
        if (section && this.activeSection !== section) {
            this.setActiveSection(section);
        }
        this.setActiveElement(element);
        this.setCurrentFocus();
        this.resetNavigation = true;
    }

    /**
     * Resets the a11y navigation controller, active region/section/element, clears focus and resets user interraction states
     */
    cancelNavigation() {
        this.clearActiveRegion();
        this.setCurrentFocus();
        this.resetInterractionStates();
    }

    // private methods

    /**
     * Sets the currently active region and stores a list of the regions sections
     * @param {HTMLElement} element - DOM element to set as the active region
     * @param {boolean} canFocusChild - whether to focus child section instead of provide region
     * @emits {A11yCustomEventTypes.ACTIVATE} - emitted on the provided DOM element once set to active
     */
    setActiveRegion(element, canFocusChild = true) {
        if (!this.isElementValid(element, [this.activeRegion]) && !this.resetNavigation) {
            return;
        }

        // clear previous active region
        this.clearActiveRegion();

        // setup new active region
        this.activeRegion = element;
        this.activeRegion.addEventListener(A11yCustomEventTypes.UPDATE, this.handleActiveRegionUpdate);
        this.activeRegion.dispatchEvent(new Event(A11yCustomEventTypes.ACTIVATE));

        // apply visual updates to active region
        this.updateActiveRegion();

        // retrieve all sections for the new active region
        this.sectionHTMLCollection = this.getAllSectionsForRegion(this.activeRegion);

        // should the visual focus start on a child section
        if (canFocusChild && this.getFocusChildAttribute(this.activeRegion) && this.sections && this.sections.length) {
            this.setActiveSection(this.sections[0]);
        }
    }

    /**
     * Sets the currently active section
     * @param {HTMLElement} element - DOM element to set as the active section
     * @emits {A11yCustomEventTypes.ACTIVATE} - emitted on the provided DOM element once set to active
     */
    setActiveSection(element) {
        if (!this.isElementValid(element, [this.activeSection])) {
            return;
        }

        // clear previous active section
        this.clearActiveSection();

        // setup new active section
        this.activeSection = element;
        this.activeSection.addEventListener(A11yCustomEventTypes.UPDATE, this.handleActiveSectionUpdate);
        this.activeSection.dispatchEvent(new Event(A11yCustomEventTypes.ACTIVATE));

        // apply visual updates to active section
        this.updateActiveSection();
    }

    /**
     * Sets the currently active element
     * @param {HTMLElement} element - DOM element to set as the active element
     * @emits {A11yCustomEventTypes.ACTIVATE} - emitted on the provided DOM element once set to active
     */
    setActiveElement(element) {
        if (!this.isElementValid(element, [this.activeElement])) {
            return;
        }

        // clear previous active element
        this.clearActiveElement();

        // setup new active element
        this.activeElement = element;
        this.activeElement.addEventListener(A11yCustomEventTypes.UPDATE, this.handleActiveElementUpdate);
        if (this.activeElement !== this.activeRegion && this.activeElement !== this.activeSection) {
            this.activeElement.dispatchEvent(new Event(A11yCustomEventTypes.ACTIVATE));
        }

        // apply visual updates to active element
        this.updateActiveElement();
    }

    /**
     * Updates the focus status of the element that should now have focus
     */
    setCurrentFocus() {
        this.clearCurrentFocus();
        if (!this.focusedElement) {
            return;
        }

        // set focus on the element that should have focus if needed
        if (document.activeElement !== this.focusedElement) {
            this.focusedElement.focus();
        }

        // apply visual updates to focused element
        this.udpateCurrentFocus();
    }

    /**
     * Updates the visual state of the active region and makes sure it is focusable
     */
    updateActiveRegion() {
        if (!this.activeRegion) {
            return;
        }
        this.activeRegion.classList.add(A11yClassNames.ACTIVE);

        // ensure active region element is focusable
        if (!this.activeRegion.getAttribute('tabindex')) {
            this.activeRegion.setAttribute('tabindex', -1);
        }
    }

    /**
     * Updates the visual state of the active section and makes sure it is focusable
     */
    updateActiveSection() {
        if (!this.activeSection) {
            return;
        }
        this.activeSection.classList.add(A11yClassNames.ACTIVE);

        // ensure active section element is focusable
        if (!this.activeSection.getAttribute('tabindex')) {
            this.activeSection.setAttribute('tabindex', -1);
        }
    }

    /**
     * Updates the visual state of the active element
     */
    updateActiveElement() {
        if (!this.activeElement) {
            return;
        }
        this.activeElement.classList.add(A11yClassNames.ACTIVE);
    }

    /**
     * Updates the visual state of the currently focused element
     */
    udpateCurrentFocus(forceUpdate = false) {
        if ((!this.focusedElement || !(this.a11yKeyIsPressed || this.manualFocus)) && !forceUpdate) {
            return;
        }
        this.focusedElement.classList.add(A11yClassNames.FOCUSED);
    }

    /**
     * Clears all a11y-applied classes, events and the active region DOM element reference
     */
    clearActiveRegion() {
        if (this.activeRegion) {
            this.activeRegion.classList.remove(A11yClassNames.ACTIVE);
            this.activeRegion.dispatchEvent(new Event(A11yCustomEventTypes.DEACTIVATE));
            this.activeRegion.removeEventListener(A11yCustomEventTypes.UPDATE, this.handleActiveRegionUpdate);
            this.activeRegion = null;
        }
        this.clearActiveSection();
    }

    /**
     * Clears all a11y-applied classes, events and the active section DOM element reference
     */
    clearActiveSection() {
        if (this.activeSection) {
            this.activeSection.classList.remove(A11yClassNames.ACTIVE);
            this.activeSection.dispatchEvent(new Event(A11yCustomEventTypes.DEACTIVATE));
            this.activeSection.removeEventListener(A11yCustomEventTypes.UPDATE, this.handleActiveSectionUpdate);
            this.activeSection = null;
        }
        this.clearActiveElement();
    }

    /**
     * Clears all a11y-applied classes, events and the active DOM element reference
     */
    clearActiveElement() {
        if (this.activeElement) {
            if (this.activeElement !== this.activeRegion && this.activeElement !== this.activeSection) {
                this.activeElement.classList.remove(A11yClassNames.ACTIVE);
                this.activeElement.dispatchEvent(new Event(A11yCustomEventTypes.DEACTIVATE));
            }
            this.activeElement.removeEventListener(A11yCustomEventTypes.UPDATE, this.handleActiveElementUpdate);
            this.activeElement = null;
        }
    }

    /**
     * Clears all focused element classes and blurs the active element if requested
     */
    clearCurrentFocus(blurActiveElement = false) {
        Array.from(document.getElementsByClassName(A11yClassNames.FOCUSED)).forEach((element) => {
            element.classList.remove(A11yClassNames.FOCUSED);
        });
        if (blurActiveElement) {
            document.activeElement.blur();
        }
    }

    /**
     * Resets the state of all a11y-defined interraction methods
     */
    resetInterractionStates() {
        this.mouseIsPressed = false;
        this.f6KeyIsPressed = false;
        this.upArrowKeyIsPressed = false;
        this.downArrowKeyIsPressed = false;
        this.tabKeyIsPressed = false;
        this.tildeKeyIsPressed = false;
        this.enterKeyIsPressed = false;
        this.lKeyIsPressed = false;
        this.lastInputEventIsKeyDown = false;
    }

    // helper methods

    /**
     * Returns an HTMLCollection object of all defined regions
     * - use of HTMLCollection is intentional as this object auto updates to reflect DOM changes
     */
    getAllRegions() {
        return document.getElementsByClassName(A11yClassNames.REGION);
    }

    /**
     * Returns an HTMLCollection object of all defined sections for the currently active region
     * - use of HTMLCollection is intentional as this object auto updates to reflect DOM changes
     */
    getAllSectionsForRegion(region) {
        if (!region) {
            return null;
        }
        return region.getElementsByClassName(A11yClassNames.SECTION);
    }

    /**
     * Sort a list of DOM elements by defined A11yAttributeNames.SORT_ORDER attribute
     * @param {HTMLCollection} elements - list of elements to be sorted
     */
    sortElementsByAttributeOrder(elements) {
        if (!elements || !elements.length) {
            return [];
        }
        return Array.from(elements).sort((elementA, elementB) => {
            const elementAOrder = parseInt(elementA.getAttribute(A11yAttributeNames.SORT_ORDER), 10);
            const elementBOrder = parseInt(elementB.getAttribute(A11yAttributeNames.SORT_ORDER), 10);

            if (isNaN(elementAOrder) && isNaN(elementBOrder)) {
                return 0;
            }
            if (isNaN(elementBOrder)) {
                return -1;
            }
            if (isNaN(elementAOrder)) {
                return 1;
            }

            return elementAOrder - elementBOrder;
        });
    }

    /**
     * Returns whether a DOM element is currently visible or not
     * @param {HTMLElement} element - the DOM element to check
     */
    elementIsVisible(element) {
        return element && element.offsetParent;
    }

    /**
     * Retuns an HTMLCollection of all DOM elements that have the A11yClassNames.MODAL class
     */
    getAllModals() {
        return document.getElementsByClassName(A11yClassNames.MODAL);
    }

    /**
     * Retuns an HTMLCollection of all DOM elements that have the A11yClassNames.POPUP class
     */
    getAllPopups() {
        return document.getElementsByClassName(A11yClassNames.POPUP);
    }

    /**
     * Helper to retrieve the value of the A11yAttributeNames.LOOP_NAVIGATION attribute for the provided DOM element
     * @param {HTMLElement} element - the element to retrive the A11yAttributeNames.LOOP_NAVIGATION value from
     */
    getLoopNavigationAttribute(element) {
        const attributeValue = element.getAttribute(A11yAttributeNames.LOOP_NAVIGATION);
        if (attributeValue && attributeValue.toLowerCase() === 'false') {
            return false;
        }
        return true;
    }

    /**
     * Helper to retrieve the value of the A11yAttributeNames.ORDER_REVERSE attribute for the provided DOM element
     * @param {HTMLElement} element - the element to retrive the A11yAttributeNames.ORDER_REVERSE value from
     */
    getOrderReverseAttribute(element) {
        const attributeValue = element.getAttribute(A11yAttributeNames.ORDER_REVERSE);
        if (attributeValue && attributeValue.toLowerCase() === 'true') {
            return true;
        }
        return false;
    }

    /**
     * Helper to retrieve the value of the A11yAttributeNames.FOCUS_CHILD attribute for the provided DOM element
     * @param {HTMLElement} element - the element to retrive the A11yAttributeNames.FOCUS_CHILD value from
     */
    getFocusChildAttribute(element) {
        const attributeValue = element.getAttribute(A11yAttributeNames.FOCUS_CHILD);
        if (attributeValue && attributeValue.toLowerCase() === 'true') {
            return true;
        }
        return false;
    }

    /**
     * Helper method to verify if a provided DOM element is a valid element for a11y navigation
     * @param {HTMLElement} element - the DOM element to check
     * @param {arry of HTMLElements} invalidElements - a list of invalid DOM elements to check against
     */
    isElementValid(element, invalidElements = []) {
        if (
            element &&
            element.classList &&
            !invalidElements.includes(element)
        ) {
            return true;
        }
        return false;
    }

    // event handling methods

    handleKeyDown = (event) => {
        this.lastInputEventIsKeyboard = true;

        const modifierKeys = {
            ctrlIsPressed: event.ctrlKey,
            altIsPressed: event.altKey,
            shiftIsPressed: event.shiftKey,
        };
        switch (true) {
        case isKeyPressed(event, Constants.KeyCodes.TAB):
            this.lastInputEventIsKeyDown = true;
            if ((!isMac() && modifierKeys.altIsPressed) || cmdOrCtrlPressed(event)) {
                return;
            }
            this.tabKeyIsPressed = true;
            break;
        case isKeyPressed(event, Constants.KeyCodes.TILDE):
            this.lastInputEventIsKeyDown = true;
            if (!this.regions || !this.regions.length) {
                return;
            }

            // Check to make sure both aren't pressed because some older webkit browsers set CTRL and ALT when AltGr is pressed
            if (modifierKeys.ctrlIsPressed && !modifierKeys.altIsPressed) {
                this.tildeKeyIsPressed = true;
                event.preventDefault();
                if (modifierKeys.shiftIsPressed) {
                    this.previousRegion();
                } else {
                    this.nextRegion();
                }
            }
            break;
        case isKeyPressed(event, Constants.KeyCodes.F6):
            this.lastInputEventIsKeyDown = true;
            if (!isDesktopApp() && !cmdOrCtrlPressed(event)) {
                return;
            }
            this.f6KeyIsPressed = true;
            event.preventDefault();
            if (modifierKeys.shiftIsPressed) {
                this.previousRegion();
            } else {
                this.nextRegion();
            }
            break;
        case isKeyPressed(event, Constants.KeyCodes.UP):
            this.lastInputEventIsKeyDown = true;
            if (!this.navigationInProgress || !this.sections || !this.sections.length) {
                return;
            }
            this.upArrowKeyIsPressed = true;
            event.preventDefault();
            if (this.shouldReverseSections) {
                this.nextSection();
            } else {
                this.previousSection();
            }
            break;
        case isKeyPressed(event, Constants.KeyCodes.DOWN):
            this.lastInputEventIsKeyDown = true;
            if (!this.navigationInProgress || !this.sections || !this.sections.length) {
                return;
            }
            this.downArrowKeyIsPressed = true;
            event.preventDefault();
            if (this.shouldReverseSections) {
                this.previousSection();
            } else {
                this.nextSection();
            }
            break;
        case isKeyPressed(event, Constants.KeyCodes.ESCAPE):
            this.escKeyIsPressed = true;
            this.lastInputEventIsKeyDown = true;
            if (!this.navigationInProgress) {
                return;
            }
            event.preventDefault();
            this.cancelNavigation();
            break;
        case isKeyPressed(event, Constants.KeyCodes.ENTER):
            this.enterKeyIsPressed = true;
            break;
        case isKeyPressed(event, Constants.KeyCodes.SPACE):
            if (event.target.nodeName === 'BUTTON') {
                event.preventDefault();
                event.stopPropagation();
                event.target.click();
            }
            break;
        case isKeyPressed(event, Constants.KeyCodes.L):
            // For the Ctrl+Shift+L keyboard shortcut
            this.lastInputEventIsKeyDown = true;
            this.lKeyIsPressed = true;
            break;
        }
    }

    handleKeyUp = () => {
        this.resetInterractionStates();
    }

    handleMouseClick = (event) => {
        // hitting enter on a <button> triggers a click event
        if (!this.enterKeyIsPressed) {
            this.lastInputEventIsKeyDown = false;
        }
        if (event.target === this.activeElement) {
            return;
        }
        this.cancelNavigation();
    }

    handleMouseDown = () => {
        this.mouseIsPressed = true;
        this.lastInputEventIsKeyboard = false;
    }

    handleMouseUp = () => {
        this.mouseIsPressed = false;
    }

    handleFocus = (event) => {
        // since the post-list (in which the EditPost component lives) has the attribute `data-a11y-child-focus` hitting
        // the UP-Key causes the a11y controller to go through the posts. This is unwanted behavior in a textarea, so we
        // decided to leave this fix in for now. If we find the need for a more sustainable fix we can certainly do
        // that, as well, but for now this is sufficient.
        // @see: https://github.com/mattermost/mattermost-webapp/pull/8882#discussion_r790905592
        if (this.lastInputEventIsKeyDown && this.windowIsFocused && event.target.id !== 'edit_textbox') {
            this.nextElement(event.target, event.path || true);
        }

        // focus just came back to the app
        if (!this.windowIsFocused) {
            this.windowIsFocused = true;
        }
    }

    handleA11yFocus = (event) => {
        if (!event.detail.target) {
            return;
        }
        if (!event.detail.keyboardOnly || this.lastInputEventIsKeyboard) {
            this.manualFocus = true;
            this.nextElement(event.detail.target, true);
            this.manualFocus = false;
        } else {
            event.detail.target.focus();
        }
    }

    handleWindowBlur = (event) => {
        if (event.target === window) {
            this.windowIsFocused = false;
        }
    }

    handleActiveRegionUpdate = () => {
        if (this.navigationInProgress) {
            this.updateActiveRegion();
            if (this.focusedElement === this.activeRegion) {
                this.udpateCurrentFocus(true);
            }
        }
    }

    handleActiveSectionUpdate = () => {
        if (this.navigationInProgress) {
            this.updateActiveSection();
            if (this.focusedElement === this.activeSection) {
                this.udpateCurrentFocus(true);
            }
        }
    }

    handleActiveElementUpdate = () => {
        if (this.navigationInProgress) {
            this.updateActiveElement();
            if (this.focusedElement === this.activeElement) {
                this.udpateCurrentFocus(true);
            }
        }
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {injectIntl, IntlShape} from 'react-intl';
import {Link} from 'react-router-dom';
import {Draggable} from 'react-beautiful-dnd';
import classNames from 'classnames';

import {mark, trackEvent} from 'actions/telemetry_actions.jsx';
import Constants from 'utils/constants';
import {isDesktopApp} from 'utils/user_agent';
import {localizeMessage} from 'utils/utils';
import CopyUrlContextMenu from 'components/copy_url_context_menu';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import TeamIcon from '../../widgets/team_icon/team_icon';
import KeyboardShortcutSequence, {
    KEYBOARD_SHORTCUTS,
} from 'components/keyboard_shortcuts/keyboard_shortcuts_sequence';

interface Props {
    btnClass?: string;
    url: string;
    displayName?: string;
    content?: React.ReactNode;
    tip: string | JSX.Element;
    order?: number;
    showOrder?: boolean;
    active?: boolean;
    disabled?: boolean;
    unread?: boolean;
    mentions?: number;
    placement?: 'left' | 'right' | 'top' | 'bottom';
    teamIconUrl?: string | null;
    switchTeam: (url: string) => void;
    intl: IntlShape;
    isDraggable?: boolean;
    teamIndex?: number;
    teamId?: string;
    isInProduct?: boolean;
    hasUrgent?: boolean;
}

// eslint-disable-next-line react/require-optimization
class TeamButton extends React.PureComponent<Props> {
    handleSwitch = (e: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => {
        e.preventDefault();
        mark('TeamLink#click');
        trackEvent('ui', 'ui_team_sidebar_switch_team');
        this.props.switchTeam(this.props.url);
    }

    handleDisabled = (e: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => {
        e.preventDefault();
    }

    render() {
        const {teamIconUrl, displayName, btnClass, mentions, unread, isDraggable = false, teamIndex, teamId, order} = this.props;
        const {formatMessage} = this.props.intl;

        let teamClass: string = this.props.active ? 'active' : '';
        const disabled: string = this.props.disabled ? 'team-disabled' : '';
        const isNotCreateTeamButton: boolean = !this.props.url.endsWith('create_team') && !this.props.url.endsWith('select_team');
        const handleClick = (this.props.active || this.props.disabled) ? this.handleDisabled : this.handleSwitch;

        let badge: JSX.Element | undefined;

        let ariaLabel = formatMessage({
            id: 'team.button.ariaLabel',
            defaultMessage: '{teamName} team',
        },
        {
            teamName: displayName,
        });

        if (!teamClass) {
            if (unread && !this.props.isInProduct) {
                teamClass = 'unread';

                badge = (
                    <span className={'unread-badge'}/>
                );
            } else if (isNotCreateTeamButton) {
                teamClass = '';
            } else {
                teamClass = 'special';
            }
            ariaLabel = formatMessage({
                id: 'team.button.unread.ariaLabel',
                defaultMessage: '{teamName} team unread',
            },
            {
                teamName: displayName,
            });

            if (mentions) {
                ariaLabel = formatMessage({
                    id: 'team.button.mentions.ariaLabel',
                    defaultMessage: '{teamName} team, {mentionCount} mentions',
                },
                {
                    teamName: displayName,
                    mentionCount: mentions,
                });

                badge = (
                    <span className={classNames('badge badge-max-number pull-right small', {urgent: this.props.hasUrgent})}>{mentions > 99 ? '99+' : mentions}</span>
                );
            }
        }

        ariaLabel = ariaLabel.toLowerCase();

        const content = (
            <TeamIcon
                className={teamClass}
                withHover={true}
                content={this.props.content || displayName || ''}
                url={teamIconUrl}
            />
        );

        let toolTip = this.props.tip || localizeMessage('team.button.name_undefined', 'This team does not have a name');
        let orderIndicator: JSX.Element | undefined;
        if (typeof this.props.order !== 'undefined' && this.props.order < 10) {
            toolTip = (
                <>
                    {toolTip}
                    <KeyboardShortcutSequence
                        shortcut={KEYBOARD_SHORTCUTS.teamNavigation}
                        values={{order}}
                        hideDescription={true}
                        isInsideTooltip={true}
                    />
                </>
            );

            if (this.props.showOrder) {
                orderIndicator = (
                    <div className='order-indicator'>
                        {order}
                    </div>
                );
            }
        }

        const btn = (
            <OverlayTrigger
                delayShow={Constants.OVERLAY_TIME_DELAY}
                placement={this.props.placement}
                overlay={
                    <Tooltip id={`tooltip-${this.props.url}`}>
                        {toolTip}
                    </Tooltip>
                }
            >
                <div className={'team-btn ' + btnClass}>
                    {!this.props.isInProduct && badge}
                    {content}
                </div>
            </OverlayTrigger>
        );

        let teamButton = (
            <Link
                id={`${this.props.url.slice(1)}TeamButton`}
                aria-label={ariaLabel}
                className={disabled}
                to={this.props.url}
                onClick={handleClick}
            >
                {btn}
            </Link>
        );

        if (isDesktopApp()) {
            // if this is not a "special" team button, give it a context menu
            if (isNotCreateTeamButton) {
                teamButton = (
                    <CopyUrlContextMenu
                        link={this.props.url}
                        menuId={this.props.url}
                    >
                        {teamButton}
                    </CopyUrlContextMenu>
                );
            }
        }

        return isDraggable ? (
            <Draggable
                draggableId={teamId!}
                index={teamIndex!}
            >
                {(provided, snapshot) => {
                    return (
                        <div
                            className='draggable-team-container'
                            ref={provided.innerRef}
                            {...provided.draggableProps}
                            {...provided.dragHandleProps}
                        >
                            <div

                                className={classNames([`team-container ${teamClass}`, {isDragging: snapshot.isDragging}])}
                            >
                                {teamButton}
                                {orderIndicator}
                            </div>
                        </div>
                    );
                }}
            </Draggable>
        ) : (
            <div className={`team-container ${teamClass}`}>
                {teamButton}
                {orderIndicator}
            </div>
        );
    }
}

export default injectIntl(TeamButton);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import Scrollbars from 'react-custom-scrollbars';
import {FormattedMessage} from 'react-intl';
import classNames from 'classnames';
import {DragDropContext, Droppable, DroppableProvided, DropResult} from 'react-beautiful-dnd';
import {RouteComponentProps} from 'react-router-dom';

import {Team} from '@mattermost/types/teams';

import Permissions from 'mattermost-redux/constants/permissions';

import {Constants} from 'utils/constants';
import {filterAndSortTeamsByDisplayName} from 'utils/team_utils';
import * as Utils from 'utils/utils';

import Pluggable from 'plugins/pluggable';

import {getCurrentProduct} from 'utils/products';
import SystemPermissionGate from 'components/permissions_gates/system_permission_gate';
import TeamButton from 'components/team_sidebar/components/team_button';

import type {PropsFromRedux} from './index';

export interface Props extends PropsFromRedux {
    location: RouteComponentProps['location'];
}

type State = {
    showOrder: boolean;
    teamsOrder: Team[];
}

export function renderView(props: Props) {
    return (
        <div
            {...props}
            className='scrollbar--view'
        />
    );
}

export function renderThumbHorizontal(props: Props) {
    return (
        <div
            {...props}
            className='scrollbar--horizontal'
        />
    );
}

export function renderThumbVertical(props: Props) {
    return (
        <div
            {...props}
            className='scrollbar--vertical'
        />
    );
}

export default class TeamSidebar extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            showOrder: false,
            teamsOrder: [],
        };
    }

    switchToPrevOrNextTeam = (e: KeyboardEvent, currentTeamId: string, teams: Team[]) => {
        if (Utils.isKeyPressed(e, Constants.KeyCodes.UP) || Utils.isKeyPressed(e, Constants.KeyCodes.DOWN)) {
            e.preventDefault();
            const delta = Utils.isKeyPressed(e, Constants.KeyCodes.DOWN) ? 1 : -1;
            const pos = teams.findIndex((team: Team) => team.id === currentTeamId);
            const newPos = pos + delta;

            let team;
            if (newPos === -1) {
                team = teams[teams.length - 1];
            } else if (newPos === teams.length) {
                team = teams[0];
            } else {
                team = teams[newPos];
            }

            this.props.actions.switchTeam(`/${team.name}`);
            return true;
        }
        return false;
    }

    switchToTeamByNumber = (e: KeyboardEvent, currentTeamId: string, teams: Team[]) => {
        const digits = [
            Constants.KeyCodes.ONE,
            Constants.KeyCodes.TWO,
            Constants.KeyCodes.THREE,
            Constants.KeyCodes.FOUR,
            Constants.KeyCodes.FIVE,
            Constants.KeyCodes.SIX,
            Constants.KeyCodes.SEVEN,
            Constants.KeyCodes.EIGHT,
            Constants.KeyCodes.NINE,
            Constants.KeyCodes.ZERO,
        ];

        for (const idx in digits) {
            if (Utils.isKeyPressed(e, digits[idx]) && parseInt(idx, 10) < teams.length) {
                e.preventDefault();

                // prevents reloading the current team, while still capturing the keyboard shortcut
                if (teams[idx].id === currentTeamId) {
                    return false;
                }
                const team = teams[idx];
                this.props.actions.switchTeam(`/${team.name}`);
                return true;
            }
        }
        return false;
    }

    handleKeyDown = (e: KeyboardEvent) => {
        if ((e.ctrlKey || e.metaKey) && e.altKey) {
            const {currentTeamId} = this.props;
            const teams = filterAndSortTeamsByDisplayName(this.props.myTeams, this.props.locale, this.props.userTeamsOrderPreference);

            if (this.switchToPrevOrNextTeam(e, currentTeamId, teams)) {
                return;
            }

            if (this.switchToTeamByNumber(e, currentTeamId, teams)) {
                return;
            }

            this.setState({showOrder: true});
        }
    }

    handleKeyUp = (e: KeyboardEvent) => {
        if (!((e.ctrlKey || e.metaKey) && e.altKey)) {
            this.setState({showOrder: false});
        }
    }

    componentDidMount() {
        this.props.actions.getTeams(0, 200);
        document.addEventListener('keydown', this.handleKeyDown);
        document.addEventListener('keyup', this.handleKeyUp);
    }

    componentWillUnmount() {
        document.removeEventListener('keydown', this.handleKeyDown);
        document.removeEventListener('keyup', this.handleKeyUp);
    }

    onDragEnd = (result: DropResult) => {
        const {
            updateTeamsOrderForUser,
        } = this.props.actions;

        if (!result.destination) {
            return;
        }

        const teams = filterAndSortTeamsByDisplayName(this.props.myTeams, this.props.locale, this.props.userTeamsOrderPreference);

        const sourceIndex = result.source.index;
        const destinationIndex = result.destination.index;

        // Positioning the dropped Team button
        const popElement = (list: Team[], idx: number) => {
            return [...list.slice(0, idx), ...list.slice(idx + 1, list.length)];
        };

        const pushElement = (list: Team[], idx: number, itemId: string): Team[] => {
            return [
                ...list.slice(0, idx),
                teams.find((team) => team.id === itemId)!,
                ...list.slice(idx, list.length),
            ];
        };

        const newTeamsOrder = pushElement(
            popElement(teams, sourceIndex),
            destinationIndex,
            result.draggableId,
        );
        updateTeamsOrderForUser(newTeamsOrder.map((o: Team) => o.id));
        this.setState({teamsOrder: newTeamsOrder});
    }

    render() {
        const root: Element | null = document.querySelector('#root');
        if (this.props.myTeams.length <= 1) {
            root!.classList.remove('multi-teams');
            return null;
        }
        root!.classList.add('multi-teams');

        const plugins = [];
        const sortedTeams = filterAndSortTeamsByDisplayName(this.props.myTeams, this.props.locale, this.props.userTeamsOrderPreference);

        const currentProduct = getCurrentProduct(this.props.products, this.props.location.pathname);
        if (currentProduct && !currentProduct.showTeamSidebar) {
            return null;
        }

        const teams = sortedTeams.map((team: Team, index: number) => {
            return (
                <TeamButton
                    key={'switch_team_' + team.name}
                    url={`/${team.name}`}
                    tip={team.display_name}
                    active={team.id === this.props.currentTeamId}
                    displayName={team.display_name}
                    order={index + 1}
                    showOrder={this.state.showOrder}
                    unread={this.props.unreadTeamsSet.has(team.id)}
                    mentions={this.props.mentionsInTeamMap.has(team.id) ? this.props.mentionsInTeamMap.get(team.id) : 0}
                    hasUrgent={this.props.teamHasUrgentMap.has(team.id) ? this.props.teamHasUrgentMap.get(team.id) : false}
                    teamIconUrl={Utils.imageURLForTeam(team)}
                    switchTeam={(url: string) => this.props.actions.switchTeam(url, currentProduct ? team : undefined)}
                    isDraggable={true}
                    teamId={team.id}
                    teamIndex={index}
                    isInProduct={Boolean(currentProduct)}
                />
            );
        });

        const joinableTeams = [];

        const plusIcon = (
            <i
                className='icon icon-plus'
                role={'img'}
                aria-label={Utils.localizeMessage('sidebar.team_menu.button.plusIcon', 'Plus Icon')}
            />
        );

        if (this.props.moreTeamsToJoin && !this.props.experimentalPrimaryTeam) {
            joinableTeams.push(
                <TeamButton
                    btnClass='team-btn__add'
                    key='more_teams'
                    url='/select_team'
                    tip={
                        <FormattedMessage
                            id='team_sidebar.join'
                            defaultMessage='Other teams you can join'
                        />
                    }
                    content={plusIcon}
                    switchTeam={this.props.actions.switchTeam}
                />,
            );
        } else {
            joinableTeams.push(
                <SystemPermissionGate
                    permissions={[Permissions.CREATE_TEAM]}
                    key='more_teams'
                >
                    <TeamButton
                        btnClass='team-btn__add'
                        url='/create_team'
                        tip={
                            <FormattedMessage
                                id='navbar_dropdown.create'
                                defaultMessage='Create a Team'
                            />
                        }
                        content={plusIcon}
                        switchTeam={this.props.actions.switchTeam}
                    />
                </SystemPermissionGate>,
            );
        }

        // Disable team sidebar pluggables in products until proper support can be provided.
        const isNonChannelsProduct = !currentProduct;
        if (isNonChannelsProduct) {
            plugins.push(
                <div
                    key='team-sidebar-bottom-plugin'
                    className='team-sidebar-bottom-plugin is-empty'
                >
                    <Pluggable pluggableName='BottomTeamSidebar'/>
                </div>,
            );
        }

        return (
            <div
                className={classNames('team-sidebar', {'move--right': this.props.isOpen})}
                role='navigation'
                aria-labelledby='teamSidebarWrapper'
            >
                <div
                    className='team-wrapper'
                    id='teamSidebarWrapper'
                >
                    <Scrollbars
                        autoHide={true}
                        autoHideTimeout={500}
                        autoHideDuration={500}
                        renderThumbHorizontal={renderThumbHorizontal}
                        renderThumbVertical={renderThumbVertical}
                        renderView={renderView}
                    >
                        <DragDropContext
                            onDragEnd={this.onDragEnd}
                        >
                            <Droppable
                                droppableId='my_teams'
                                type='TEAM_BUTTON'
                            >
                                {(provided: DroppableProvided) => {
                                    return (
                                        <div
                                            ref={provided.innerRef}
                                            {...provided.droppableProps}
                                        >
                                            {teams}
                                            {provided.placeholder}
                                        </div>
                                    );
                                }}
                            </Droppable>
                        </DragDropContext>
                        {joinableTeams}
                    </Scrollbars>
                </div>
                {plugins}
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect, ConnectedProps} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';
import {withRouter} from 'react-router-dom';

import {ClientConfig} from '@mattermost/types/config';
import {Team} from '@mattermost/types/teams';

import {getTeams} from 'mattermost-redux/actions/teams';
import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {
    getCurrentTeamId,
    getJoinableTeamIds,
    getMyTeams,
} from 'mattermost-redux/selectors/entities/teams';
import {get} from 'mattermost-redux/selectors/entities/preferences';
import {getTeamsUnreadStatuses} from 'mattermost-redux/selectors/entities/channels';

import {GenericAction, GetStateFunc} from 'mattermost-redux/types/actions';

import {GlobalState} from 'types/store';

import {getCurrentLocale} from 'selectors/i18n';
import {getIsLhsOpen} from 'selectors/lhs';

import {switchTeam, updateTeamsOrderForUser} from 'actions/team_actions';

import {Preferences} from 'utils/constants';

import TeamSidebar from './team_sidebar';

function mapStateToProps(state: GlobalState) {
    const config: Partial<ClientConfig> = getConfig(state);

    const experimentalPrimaryTeam: string | undefined = config.ExperimentalPrimaryTeam;
    const joinableTeams: string[] = getJoinableTeamIds(state);
    const moreTeamsToJoin: boolean = joinableTeams && joinableTeams.length > 0;
    const products = state.plugins.components.Product || [];

    const [unreadTeamsSet, mentionsInTeamMap, teamHasUrgentMap] = getTeamsUnreadStatuses(state);

    return {
        currentTeamId: getCurrentTeamId(state),
        myTeams: getMyTeams(state),
        isOpen: getIsLhsOpen(state),
        experimentalPrimaryTeam,
        locale: getCurrentLocale(state),
        moreTeamsToJoin,
        userTeamsOrderPreference: get(state, Preferences.TEAMS_ORDER, '', ''),
        products,
        unreadTeamsSet,
        mentionsInTeamMap,
        teamHasUrgentMap,
    };
}

type Actions = {
    getTeams: (page?: number, perPage?: number, includeTotalCount?: boolean) => void;
    switchTeam: (url: string, team?: Team) => (dispatch: Dispatch<GenericAction>, getState: GetStateFunc) => void;
    updateTeamsOrderForUser: (teamIds: string[]) => (dispatch: Dispatch<GenericAction>, getState: GetStateFunc) => Promise<void>;
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject, Actions>({
            getTeams,
            switchTeam,
            updateTeamsOrderForUser,
        }, dispatch),
    };
}

const connector = connect(mapStateToProps, mapDispatchToProps);

export type PropsFromRedux = ConnectedProps<typeof connector>;

export default withRouter(connector(TeamSidebar));

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {useIntl} from 'react-intl';

import {useDispatch, useSelector} from 'react-redux';

import {Post} from '@mattermost/types/posts';
import {submitCommand} from 'actions/views/create_comment';
import PostMarkdown from 'components/post_markdown';
import {getCurrentChannelId} from 'mattermost-redux/selectors/entities/common';
import {isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';

import {PostDraft} from 'types/store/draft';
import {localizeMessage} from 'utils/utils';

import './index.scss';

export default function WelcomePostRenderer(props: {post: Post}) {
    const isAdmin = useSelector(isCurrentUserSystemAdmin);
    const currentChannelId = useSelector(getCurrentChannelId);
    const {formatMessage} = useIntl();

    const dispatch = useDispatch();

    let message = '';
    const actions: React.ReactNode[] = [];

    const makeOnClickForCommand = (command: string) => {
        return () => {
            const draft: PostDraft = {
                message: command,
                uploadsInProgress: [],
                fileInfos: [],
            } as unknown as PostDraft;
            dispatch(submitCommand(currentChannelId, '', draft));
        };
    };

    const makeButton = (text: React.ReactNode, command: string) => {
        return (
            <button
                onClick={makeOnClickForCommand(command)}
            >
                {text}
            </button>
        );
    };

    const helpButton = makeButton(formatMessage({
        id: 'welcome_post_renderer.button_label.slash_help',
        defaultMessage: '/help',
    }), '/help');

    if (isAdmin) {
        message = [
            '### ' + localizeMessage('welcome_post_renderer.admin_message.title', 'Welcome to Mattermost! :rocket:'),
            '',
            localizeMessage('welcome_post_renderer.admin_message.first_paragraph', 'Mattermost is an open source platform for secure communication, collaboration, and orchestration of work across tools and teams.'),
            localizeMessage('welcome_post_renderer.admin_message.second_paragraph', 'Here is a list of commands to use to try and get familiar with the platform.'),
        ].join('\n');

        actions.push(makeButton(formatMessage({
            id: 'welcome_post_renderer.button_label.slash_marketplace',
            defaultMessage: '/marketplace',
        }), '/marketplace'));
    } else {
        message = [
            '### ' + localizeMessage('welcome_post_renderer.user_message.title', 'Welcome to Mattermost! :rocket:'),
            '',
            localizeMessage('welcome_post_renderer.user_message.first_paragraph', 'Mattermost is an open source platform for secure communication, collaboration, and orchestration of work across tools and teams.'),
            localizeMessage('welcome_post_renderer.user_message.second_paragraph', 'Here is a list of commands to use to try and get familiar with the platform.'),
        ].join('\n');

        actions.push(makeButton(formatMessage({
            id: 'welcome_post_renderer.button_label.slash_settings',
            defaultMessage: '/settings',
        }), '/settings'));
    }
    actions.push(helpButton);

    return (
        <div className='WelcomePostRenderer'>
            <PostMarkdown
                message={message}
                isRHS={false}
                post={props.post}
                channelId={props.post.channel_id}
                mentionKeys={[]}
            />
            {actions.length > 0 && (
                <div className='WelcomePostRenderer__ActionsContainer'>
                    {actions.map((action, idx) => (
                        <div
                            key={'action-' + idx}
                        >
                            {action}
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {Settings} from 'luxon';

import {getCurrentLocale} from 'selectors/i18n';
import {areTimezonesEnabledAndSupported} from 'selectors/general';
import {getUserCurrentTimezone} from 'mattermost-redux/utils/timezone_utils';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {makeGetUserTimezone} from 'mattermost-redux/selectors/entities/timezone';
import {GlobalState} from 'types/store';

let prevTimezone: string | undefined;
let prevLocale: string | undefined;
export function applyLuxonDefaults(state: GlobalState) {
    const locale = getCurrentLocale(state);
    if (locale !== prevLocale) {
        prevLocale = locale;
        Settings.defaultLocale = locale;
    }

    if (areTimezonesEnabledAndSupported(state)) {
        const tz = getUserCurrentTimezone(makeGetUserTimezone()(state, getCurrentUserId(state))) ?? undefined;
        if (tz !== prevTimezone) {
            prevTimezone = tz;
            Settings.defaultZone = tz ?? 'system';
        }
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode} from 'react';
import {IntlProvider as BaseIntlProvider} from 'react-intl';

import {MessageFormatElement} from '@formatjs/icu-messageformat-parser';

import {Client4} from 'mattermost-redux/client';
import {setLocalizeFunction} from 'mattermost-redux/utils/i18n_utils';

import * as I18n from 'i18n/i18n';

import {localizeMessage} from 'utils/utils';
import {ActionFunc} from 'mattermost-redux/types/actions';

type Props = {
    children: ReactNode;
    locale: string;
    translations?: Record<string, string> | Record<string, MessageFormatElement[]>;
    actions: {
        loadTranslations: ((locale: string, url: string) => ActionFunc) | (() => void);
    };
};

export default class IntlProvider extends React.PureComponent<Props> {
    componentDidMount() {
        // Pass localization function back to mattermost-redux
        setLocalizeFunction(localizeMessage);

        this.handleLocaleChange(this.props.locale);
    }

    componentDidUpdate(prevProps: Props) {
        if (prevProps.locale !== this.props.locale) {
            this.handleLocaleChange(this.props.locale);
        }
    }

    handleLocaleChange = (locale: string) => {
        Client4.setAcceptLanguage(locale);

        this.loadTranslationsIfNecessary(locale);
    }

    loadTranslationsIfNecessary = (locale: string) => {
        if (this.props.translations) {
            // Already loaded
            return;
        }
        const localeInfo = I18n.getLanguageInfo(locale);

        if (!localeInfo) {
            return;
        }

        this.props.actions.loadTranslations(locale, localeInfo.url);
    }

    render() {
        if (!this.props.translations) {
            return null;
        }

        return (
            <BaseIntlProvider
                key={this.props.locale}
                locale={this.props.locale}
                messages={this.props.translations}
                textComponent='span'
                wrapRichTextChunksInFragment={false}
            >
                {this.props.children}
            </BaseIntlProvider>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {GenericAction} from 'mattermost-redux/types/actions';

import {loadTranslations} from 'actions/views/root';

import {getCurrentLocale, getTranslations} from 'selectors/i18n';

import {GlobalState} from 'types/store';

import IntlProvider from './intl_provider';

function mapStateToProps(state: GlobalState) {
    const locale = getCurrentLocale(state);

    return {
        locale,
        translations: getTranslations(state, locale),
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            loadTranslations,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(IntlProvider);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import * as React from 'react';

import WebSocketClient from 'client/web_websocket_client';

import IntlProvider from 'components/intl_provider';

import {WebSocketContext} from 'utils/use_websocket';

type Props = {
    children: React.ReactNode;
}

export default function RootProvider(props: Props) {
    return (
        <IntlProvider>
            <WebSocketContext.Provider value={WebSocketClient}>
                {props.children}
            </WebSocketContext.Provider>
        </IntlProvider>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect} from 'react';
import {Redirect, useHistory} from 'react-router-dom';

import * as GlobalActions from 'actions/global_actions';

export type Props = {
    isElegibleForFirstAdmingOnboarding: boolean;
    currentUserId: string;
    location?: Location;
    isFirstAdmin: boolean;
    actions: {
        getFirstAdminSetupComplete: () => Promise<{data: boolean; error: any}>;
    };
}

export default function RootRedirect(props: Props) {
    const history = useHistory();

    useEffect(() => {
        if (props.currentUserId) {
            if (props.isElegibleForFirstAdmingOnboarding) {
                props.actions.getFirstAdminSetupComplete().then((firstAdminCompletedSignup) => {
                    // root.tsx ensures admin profiles are eventually loaded
                    if (firstAdminCompletedSignup.data === false && props.isFirstAdmin) {
                        history.push('/preparing-workspace');
                    } else {
                        GlobalActions.redirectUserToDefaultTeam();
                    }
                });
            } else {
                GlobalActions.redirectUserToDefaultTeam();
            }
        }
    }, [props.currentUserId, props.isElegibleForFirstAdmingOnboarding]);

    if (props.currentUserId) {
        // Ideally, this would be a Redirect like below, but since we need to call an action, this redirect is done above
        return null;
    }

    return (
        <Redirect
            to={{
                ...props.location,
                pathname: '/login',
            }}
        />
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';
import {connect} from 'react-redux';

import {getFirstAdminSetupComplete} from 'mattermost-redux/actions/general';
import {getCurrentUserId, isCurrentUserSystemAdmin, isFirstAdmin} from 'mattermost-redux/selectors/entities/users';
import {getUseCaseOnboarding} from 'mattermost-redux/selectors/entities/preferences';
import {GenericAction} from 'mattermost-redux/types/actions';

import {GlobalState} from 'types/store';

import RootRedirect, {Props} from './root_redirect';

function mapStateToProps(state: GlobalState) {
    const useCaseOnboarding = getUseCaseOnboarding(state);
    let isElegibleForFirstAdmingOnboarding = useCaseOnboarding;
    if (isElegibleForFirstAdmingOnboarding) {
        isElegibleForFirstAdmingOnboarding = isCurrentUserSystemAdmin(state);
    }
    return {
        currentUserId: getCurrentUserId(state),
        isElegibleForFirstAdmingOnboarding,
        isFirstAdmin: isFirstAdmin(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<any>, Props['actions']>({
            getFirstAdminSetupComplete,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(RootRedirect);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import deepEqual from 'fast-deep-equal';
import {Route, Switch, Redirect, RouteComponentProps} from 'react-router-dom';
import throttle from 'lodash/throttle';
import classNames from 'classnames';

import {Client4} from 'mattermost-redux/client';
import {rudderAnalytics, RudderTelemetryHandler} from 'mattermost-redux/client/rudder';
import {General} from 'mattermost-redux/constants';
import {Theme, getUseCaseOnboarding} from 'mattermost-redux/selectors/entities/preferences';
import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getCurrentUser, isCurrentUserSystemAdmin, checkIsFirstAdmin} from 'mattermost-redux/selectors/entities/users';
import {setUrl} from 'mattermost-redux/actions/general';
import {setSystemEmojis} from 'mattermost-redux/actions/emojis';

import {ProductComponent, PluginComponent} from 'types/store/plugins';

import {loadRecentlyUsedCustomEmojis} from 'actions/emoji_actions';
import * as GlobalActions from 'actions/global_actions';
import {measurePageLoadTelemetry, trackEvent, trackSelectorMetrics} from 'actions/telemetry_actions.jsx';

import SidebarRight from 'components/sidebar_right';
import AppBar from 'components/app_bar/app_bar';
import SidebarRightMenu from 'components/sidebar_right_menu';
import AnnouncementBarController from 'components/announcement_bar';
import SystemNotice from 'components/system_notice';

import {makeAsyncComponent} from 'components/async_load';
import CompassThemeProvider from 'components/compass_theme_provider/compass_theme_provider';
import GlobalHeader from 'components/global_header/global_header';
import CloudEffects from 'components/cloud_effects';
import ModalController from 'components/modal_controller';
import {HFTRoute, LoggedInHFTRoute} from 'components/header_footer_template_route';
import {HFRoute} from 'components/header_footer_route/header_footer_route';
import OnBoardingTaskList from 'components/onboarding_tasklist';
import LaunchingWorkspace, {LAUNCHING_WORKSPACE_FULLSCREEN_Z_INDEX} from 'components/preparing_workspace/launching_workspace';
import {Animations} from 'components/preparing_workspace/steps';
import OpenPricingModalPost from 'components/custom_open_pricing_modal_post_renderer';
import AccessProblem from 'components/access_problem';

import {initializePlugins} from 'plugins';
import Pluggable from 'plugins/pluggable';

import BrowserStore from 'stores/browser_store';

import Constants, {StoragePrefixes, WindowSizes} from 'utils/constants';
import {EmojiIndicesByAlias} from 'utils/emoji';
import * as UserAgent from 'utils/user_agent';
import * as Utils from 'utils/utils';

import webSocketClient from 'client/web_websocket_client.jsx';

import 'plugins/export.js';

const LazyErrorPage = React.lazy(() => import('components/error_page'));
const LazyLogin = React.lazy(() => import('components/login/login'));
const LazyAdminConsole = React.lazy(() => import('components/admin_console'));
const LazyLoggedIn = React.lazy(() => import('components/logged_in'));
const LazyPasswordResetSendLink = React.lazy(() => import('components/password_reset_send_link'));
const LazyPasswordResetForm = React.lazy(() => import('components/password_reset_form'));
const LazySignup = React.lazy(() => import('components/signup/signup'));
const LazyTermsOfService = React.lazy(() => import('components/terms_of_service'));
const LazyShouldVerifyEmail = React.lazy(() => import('components/should_verify_email/should_verify_email'));
const LazyDoVerifyEmail = React.lazy(() => import('components/do_verify_email/do_verify_email'));
const LazyClaimController = React.lazy(() => import('components/claim'));
const LazyHelpController = React.lazy(() => import('components/help/help_controller'));
const LazyLinkingLandingPage = React.lazy(() => import('components/linking_landing_page'));
const LazySelectTeam = React.lazy(() => import('components/select_team'));
const LazyAuthorize = React.lazy(() => import('components/authorize'));
const LazyCreateTeam = React.lazy(() => import('components/create_team'));
const LazyMfa = React.lazy(() => import('components/mfa/mfa_controller'));
const LazyPreparingWorkspace = React.lazy(() => import('components/preparing_workspace'));
const LazyTeamController = React.lazy(() => import('components/team_controller'));
const LazyDelinquencyModalController = React.lazy(() => import('components/delinquency_modal'));

import store from 'stores/redux_store.jsx';
import {getSiteURL} from 'utils/url';
import A11yController from 'utils/a11y_controller';
import TeamSidebar from 'components/team_sidebar';

import {UserProfile} from '@mattermost/types/users';

import {ActionResult} from 'mattermost-redux/types/actions';

import WelcomePostRenderer from 'components/welcome_post_renderer';

import {applyLuxonDefaults} from './effects';

import RootProvider from './root_provider';
import RootRedirect from './root_redirect';

const CreateTeam = makeAsyncComponent('CreateTeam', LazyCreateTeam);
const ErrorPage = makeAsyncComponent('ErrorPage', LazyErrorPage);
const TermsOfService = makeAsyncComponent('TermsOfService', LazyTermsOfService);
const Login = makeAsyncComponent('LoginController', LazyLogin);
const AdminConsole = makeAsyncComponent('AdminConsole', LazyAdminConsole);
const LoggedIn = makeAsyncComponent('LoggedIn', LazyLoggedIn);
const PasswordResetSendLink = makeAsyncComponent('PasswordResedSendLink', LazyPasswordResetSendLink);
const PasswordResetForm = makeAsyncComponent('PasswordResetForm', LazyPasswordResetForm);
const Signup = makeAsyncComponent('SignupController', LazySignup);
const ShouldVerifyEmail = makeAsyncComponent('ShouldVerifyEmail', LazyShouldVerifyEmail);
const DoVerifyEmail = makeAsyncComponent('DoVerifyEmail', LazyDoVerifyEmail);
const ClaimController = makeAsyncComponent('ClaimController', LazyClaimController);
const HelpController = makeAsyncComponent('HelpController', LazyHelpController);
const LinkingLandingPage = makeAsyncComponent('LinkingLandingPage', LazyLinkingLandingPage);
const SelectTeam = makeAsyncComponent('SelectTeam', LazySelectTeam);
const Authorize = makeAsyncComponent('Authorize', LazyAuthorize);
const Mfa = makeAsyncComponent('Mfa', LazyMfa);
const PreparingWorkspace = makeAsyncComponent('PreparingWorkspace', LazyPreparingWorkspace);
const TeamController = makeAsyncComponent('TeamController', LazyTeamController);
const DelinquencyModalController = makeAsyncComponent('DelinquencyModalController', LazyDelinquencyModalController);

type LoggedInRouteProps<T> = {
    component: React.ComponentType<T>;
    path: string;
};
function LoggedInRoute<T>(props: LoggedInRouteProps<T>) {
    const {component: Component, ...rest} = props;
    return (
        <Route
            {...rest}
            render={(routeProps: RouteComponentProps) => (
                <LoggedIn {...routeProps}>
                    <Component {...(routeProps as unknown as T)}/>
                </LoggedIn>
            )}
        />
    );
}

const noop = () => {}; // eslint-disable-line no-empty-function

export type Actions = {
    emitBrowserWindowResized: (size?: string) => void;
    getFirstAdminSetupComplete: () => Promise<ActionResult>;
    getProfiles: (page?: number, pageSize?: number, options?: Record<string, any>) => Promise<ActionResult>;
    migrateRecentEmojis: () => void;
    loadConfigAndMe: () => Promise<{data: boolean}>;
    registerCustomPostRenderer: (type: string, component: any, id: string) => Promise<ActionResult>;
    initializeProducts: () => Promise<void[]>;
}

type Props = {
    theme: Theme;
    telemetryEnabled: boolean;
    telemetryId?: string;
    noAccounts: boolean;
    showTermsOfService: boolean;
    permalinkRedirectTeamName: string;
    isCloud: boolean;
    actions: Actions;
    plugins?: PluginComponent[];
    products: ProductComponent[];
    showLaunchingWorkspace: boolean;
    rhsIsExpanded: boolean;
    rhsIsOpen: boolean;
    shouldShowAppBar: boolean;
} & RouteComponentProps

interface State {
    configLoaded?: boolean;
}

export default class Root extends React.PureComponent<Props, State> {
    private desktopMediaQuery: MediaQueryList;
    private smallDesktopMediaQuery: MediaQueryList;
    private tabletMediaQuery: MediaQueryList;
    private mobileMediaQuery: MediaQueryList;
    private mounted: boolean;

    // The constructor adds a bunch of event listeners,
    // so we do need this.
    private a11yController: A11yController; // eslint-disable-line no-unused-vars

    constructor(props: Props) {
        super(props);
        this.mounted = false;

        // Redux
        setUrl(getSiteURL());

        // Disable auth header to enable CSRF check
        Client4.setAuthHeader = false;

        setSystemEmojis(new Set(EmojiIndicesByAlias.keys()));

        // Force logout of all tabs if one tab is logged out
        window.addEventListener('storage', this.handleLogoutLoginSignal);

        // Prevent drag and drop files from navigating away from the app
        document.addEventListener('drop', (e) => {
            if (e.dataTransfer && e.dataTransfer.items.length > 0 && e.dataTransfer.items[0].kind === 'file') {
                e.preventDefault();
                e.stopPropagation();
            }
        });

        document.addEventListener('dragover', (e) => {
            if (!Utils.isTextDroppableEvent(e) && !document.body.classList.contains('focalboard-body')) {
                e.preventDefault();
                e.stopPropagation();
            }
        });

        this.state = {
            configLoaded: false,
        };

        this.a11yController = new A11yController();

        // set initial window size state
        this.desktopMediaQuery = window.matchMedia(`(min-width: ${Constants.DESKTOP_SCREEN_WIDTH + 1}px)`);
        this.smallDesktopMediaQuery = window.matchMedia(`(min-width: ${Constants.TABLET_SCREEN_WIDTH + 1}px) and (max-width: ${Constants.DESKTOP_SCREEN_WIDTH}px)`);
        this.tabletMediaQuery = window.matchMedia(`(min-width: ${Constants.MOBILE_SCREEN_WIDTH + 1}px) and (max-width: ${Constants.TABLET_SCREEN_WIDTH}px)`);
        this.mobileMediaQuery = window.matchMedia(`(max-width: ${Constants.MOBILE_SCREEN_WIDTH}px)`);

        this.updateWindowSize();

        store.subscribe(() => applyLuxonDefaults(store.getState()));
    }

    onConfigLoaded = () => {
        const telemetryId = this.props.telemetryId;

        let rudderKey: string | null | undefined = Constants.TELEMETRY_RUDDER_KEY;
        let rudderUrl: string | null | undefined = Constants.TELEMETRY_RUDDER_DATAPLANE_URL;

        if (rudderKey.startsWith('placeholder') && rudderUrl.startsWith('placeholder')) {
            rudderKey = process.env.RUDDER_KEY; //eslint-disable-line no-process-env
            rudderUrl = process.env.RUDDER_DATAPLANE_URL; //eslint-disable-line no-process-env
        }

        if (rudderKey != null && rudderKey !== '' && this.props.telemetryEnabled) {
            const rudderCfg: {setCookieDomain?: string} = {};
            const siteURL = getConfig(store.getState()).SiteURL;
            if (siteURL !== '') {
                try {
                    rudderCfg.setCookieDomain = new URL(siteURL || '').hostname;
                    // eslint-disable-next-line no-empty
                } catch (_) {}
            }
            rudderAnalytics.load(rudderKey, rudderUrl || '', rudderCfg);

            rudderAnalytics.identify(telemetryId, {}, {
                context: {
                    ip: '0.0.0.0',
                },
                page: {
                    path: '',
                    referrer: '',
                    search: '',
                    title: '',
                    url: '',
                },
                anonymousId: '00000000000000000000000000',
            });

            rudderAnalytics.page('ApplicationLoaded', {
                path: '',
                referrer: '',
                search: ('' as any),
                title: '',
                url: '',
            } as any,
            {
                context: {
                    ip: '0.0.0.0',
                },
                anonymousId: '00000000000000000000000000',
            });

            rudderAnalytics.ready(() => {
                Client4.setTelemetryHandler(new RudderTelemetryHandler());
            });
        }

        // This needs to be called as early as possible to ensure that a redirect won't remove the query string
        this.trackUTMCampaign();

        if (this.props.location.pathname === '/' && this.props.noAccounts) {
            this.props.history.push('/signup_user_complete');
        }

        Promise.all([
            this.props.actions.initializeProducts(),
            initializePlugins(),
        ]).then(() => {
            if (this.mounted) {
                // supports enzyme tests, set state if and only if
                // the component is still mounted on screen
                this.setState({configLoaded: true});
            }
        });

        this.props.actions.migrateRecentEmojis();
        loadRecentlyUsedCustomEmojis()(store.dispatch, store.getState);

        const iosDownloadLink = getConfig(store.getState()).IosAppDownloadLink;
        const androidDownloadLink = getConfig(store.getState()).AndroidAppDownloadLink;
        const desktopAppDownloadLink = getConfig(store.getState()).AppDownloadLink;

        const toResetPasswordScreen = this.props.location.pathname === '/reset_password_complete';

        // redirect to the mobile landing page if the user hasn't seen it before
        let landing;
        if (UserAgent.isAndroidWeb()) {
            landing = androidDownloadLink;
        } else if (UserAgent.isIosWeb()) {
            landing = iosDownloadLink;
        } else {
            landing = desktopAppDownloadLink;
        }

        if (landing && !this.props.isCloud && !BrowserStore.hasSeenLandingPage() && !toResetPasswordScreen && !this.props.location.pathname.includes('/landing') && !window.location.hostname?.endsWith('.test.mattermost.com') && !UserAgent.isDesktopApp() && !UserAgent.isChromebook()) {
            this.props.history.push('/landing#' + this.props.location.pathname + this.props.location.search);
            BrowserStore.setLandingPageSeen(true);
        }

        Utils.applyTheme(this.props.theme);
    }

    componentDidUpdate(prevProps: Props) {
        if (!deepEqual(prevProps.theme, this.props.theme)) {
            Utils.applyTheme(this.props.theme);
        }
        if (this.props.location.pathname === '/') {
            if (this.props.noAccounts) {
                prevProps.history.push('/signup_user_complete');
            } else if (this.props.showTermsOfService) {
                prevProps.history.push('/terms_of_service');
            }
        }
        if (
            this.props.shouldShowAppBar !== prevProps.shouldShowAppBar ||
            this.props.rhsIsOpen !== prevProps.rhsIsOpen ||
            this.props.rhsIsExpanded !== prevProps.rhsIsExpanded
        ) {
            this.setRootMeta();
        }
    }

    async redirectToOnboardingOrDefaultTeam() {
        const storeState = store.getState();
        const isUserAdmin = isCurrentUserSystemAdmin(storeState);
        if (!isUserAdmin) {
            GlobalActions.redirectUserToDefaultTeam();
            return;
        }

        const useCaseOnboarding = getUseCaseOnboarding(storeState);
        if (!useCaseOnboarding) {
            GlobalActions.redirectUserToDefaultTeam();
            return;
        }

        const firstAdminSetupComplete = await this.props.actions.getFirstAdminSetupComplete();
        if (firstAdminSetupComplete?.data) {
            GlobalActions.redirectUserToDefaultTeam();
            return;
        }

        const profilesResult = await this.props.actions.getProfiles(0, General.PROFILE_CHUNK_SIZE, {roles: General.SYSTEM_ADMIN_ROLE});
        if (profilesResult.error) {
            GlobalActions.redirectUserToDefaultTeam();
            return;
        }
        const currentUser = getCurrentUser(store.getState());
        const adminProfiles = profilesResult.data.reduce(
            (acc: Record<string, UserProfile>, curr: UserProfile) => {
                acc[curr.id] = curr;
                return acc;
            },
            {},
        );
        if (checkIsFirstAdmin(currentUser, adminProfiles)) {
            this.props.history.push('/preparing-workspace');
            return;
        }

        GlobalActions.redirectUserToDefaultTeam();
    }

    trackUTMCampaign() {
        const qs = new URLSearchParams(window.location.search);

        // list of key that we want to track
        const keys = ['utm_source', 'utm_medium', 'utm_campaign'];

        const campaign = keys.reduce((acc, key) => {
            if (qs.has(key)) {
                const value = qs.get(key);
                if (value) {
                    acc[key] = value;
                }
                qs.delete(key);
            }
            return acc;
        }, {} as Record<string, string>);

        if (Object.keys(campaign).length > 0) {
            trackEvent('utm_params', 'utm_params', campaign);
            this.props.history.replace({search: qs.toString()});
        }
    }

    initiateMeRequests = async () => {
        const {data: isMeLoaded} = await this.props.actions.loadConfigAndMe();

        if (isMeLoaded && this.props.location.pathname === '/') {
            this.redirectToOnboardingOrDefaultTeam();
        }

        this.onConfigLoaded();
    }

    componentDidMount() {
        this.mounted = true;

        this.initiateMeRequests();

        // See figma design on issue https://mattermost.atlassian.net/browse/MM-43649
        this.props.actions.registerCustomPostRenderer('custom_up_notification', OpenPricingModalPost, 'upgrade_post_message_renderer');
        this.props.actions.registerCustomPostRenderer('system_welcome_post', WelcomePostRenderer, 'welcome_post_renderer');

        if (this.desktopMediaQuery.addEventListener) {
            this.desktopMediaQuery.addEventListener('change', this.handleMediaQueryChangeEvent);
            this.smallDesktopMediaQuery.addEventListener('change', this.handleMediaQueryChangeEvent);
            this.tabletMediaQuery.addEventListener('change', this.handleMediaQueryChangeEvent);
            this.mobileMediaQuery.addEventListener('change', this.handleMediaQueryChangeEvent);
        } else if (this.desktopMediaQuery.addListener) {
            this.desktopMediaQuery.addListener(this.handleMediaQueryChangeEvent);
            this.smallDesktopMediaQuery.addListener(this.handleMediaQueryChangeEvent);
            this.tabletMediaQuery.addListener(this.handleMediaQueryChangeEvent);
            this.mobileMediaQuery.addListener(this.handleMediaQueryChangeEvent);
        } else {
            window.addEventListener('resize', this.handleWindowResizeEvent);
        }

        measurePageLoadTelemetry();
        trackSelectorMetrics();
    }

    componentWillUnmount() {
        this.mounted = false;
        window.removeEventListener('storage', this.handleLogoutLoginSignal);

        if (this.desktopMediaQuery.removeEventListener) {
            this.desktopMediaQuery.removeEventListener('change', this.handleMediaQueryChangeEvent);
            this.smallDesktopMediaQuery.removeEventListener('change', this.handleMediaQueryChangeEvent);
            this.tabletMediaQuery.removeEventListener('change', this.handleMediaQueryChangeEvent);
            this.mobileMediaQuery.removeEventListener('change', this.handleMediaQueryChangeEvent);
        } else if (this.desktopMediaQuery.removeListener) {
            this.desktopMediaQuery.removeListener(this.handleMediaQueryChangeEvent);
            this.smallDesktopMediaQuery.removeListener(this.handleMediaQueryChangeEvent);
            this.tabletMediaQuery.removeListener(this.handleMediaQueryChangeEvent);
            this.mobileMediaQuery.removeListener(this.handleMediaQueryChangeEvent);
        } else {
            window.removeEventListener('resize', this.handleWindowResizeEvent);
        }
    }

    handleLogoutLoginSignal = (e: StorageEvent) => {
        // when one tab on a browser logs out, it sets __logout__ in localStorage to trigger other tabs to log out
        const isNewLocalStorageEvent = (event: StorageEvent) => event.storageArea === localStorage && event.newValue;

        if (e.key === StoragePrefixes.LOGOUT && isNewLocalStorageEvent(e)) {
            console.log('detected logout from a different tab'); //eslint-disable-line no-console
            GlobalActions.emitUserLoggedOutEvent('/', false, false);
        }
        if (e.key === StoragePrefixes.LOGIN && isNewLocalStorageEvent(e)) {
            const isLoggedIn = getCurrentUser(store.getState());

            // make sure this is not the same tab which sent login signal
            // because another tabs will also send login signal after reloading
            if (isLoggedIn) {
                return;
            }

            // detected login from a different tab
            function reloadOnFocus() {
                location.reload();
            }
            window.addEventListener('focus', reloadOnFocus);
        }
    }

    handleWindowResizeEvent = throttle(() => {
        this.props.actions.emitBrowserWindowResized();
    }, 100);

    handleMediaQueryChangeEvent = (e: MediaQueryListEvent) => {
        if (e.matches) {
            this.updateWindowSize();
        }
    }

    setRootMeta = () => {
        const root = document.getElementById('root')!;

        for (const [className, enabled] of Object.entries({
            'app-bar-enabled': this.props.shouldShowAppBar,
            'rhs-open': this.props.rhsIsOpen,
            'rhs-open-expanded': this.props.rhsIsExpanded,
        })) {
            root.classList.toggle(className, enabled);
        }
    }

    updateWindowSize = () => {
        switch (true) {
        case this.desktopMediaQuery.matches:
            this.props.actions.emitBrowserWindowResized(WindowSizes.DESKTOP_VIEW);
            break;
        case this.smallDesktopMediaQuery.matches:
            this.props.actions.emitBrowserWindowResized(WindowSizes.SMALL_DESKTOP_VIEW);
            break;
        case this.tabletMediaQuery.matches:
            this.props.actions.emitBrowserWindowResized(WindowSizes.TABLET_VIEW);
            break;
        case this.mobileMediaQuery.matches:
            this.props.actions.emitBrowserWindowResized(WindowSizes.MOBILE_VIEW);
            break;
        }
    }

    render() {
        if (!this.state.configLoaded) {
            return <div/>;
        }

        return (
            <RootProvider>
                <Switch>
                    <Route
                        path={'/error'}
                        component={ErrorPage}
                    />
                    <HFRoute
                        path={'/login'}
                        component={Login}
                    />
                    <HFRoute
                        path={'/access_problem'}
                        component={AccessProblem}
                    />
                    <HFTRoute
                        path={'/reset_password'}
                        component={PasswordResetSendLink}
                    />
                    <HFTRoute
                        path={'/reset_password_complete'}
                        component={PasswordResetForm}
                    />
                    <HFRoute
                        path={'/signup_user_complete'}
                        component={Signup}
                    />
                    <HFRoute
                        path={'/should_verify_email'}
                        component={ShouldVerifyEmail}
                    />
                    <HFRoute
                        path={'/do_verify_email'}
                        component={DoVerifyEmail}
                    />
                    <HFTRoute
                        path={'/claim'}
                        component={ClaimController}
                    />
                    <HFTRoute
                        path={'/help'}
                        component={HelpController}
                    />
                    <LoggedInRoute
                        path={'/terms_of_service'}
                        component={TermsOfService}
                    />
                    <Route
                        path={'/landing'}
                        component={LinkingLandingPage}
                    />
                    <Route
                        path={'/admin_console'}
                    >
                        <>
                            <Switch>
                                <LoggedInRoute
                                    path={'/admin_console'}
                                    component={AdminConsole}
                                />
                                <RootRedirect/>
                            </Switch>
                            <CompassThemeProvider theme={this.props.theme}>
                                <OnBoardingTaskList/>
                            </CompassThemeProvider>
                        </>
                    </Route>
                    <LoggedInHFTRoute
                        path={'/select_team'}
                        component={SelectTeam}
                    />
                    <LoggedInHFTRoute
                        path={'/oauth/authorize'}
                        component={Authorize}
                    />
                    <LoggedInHFTRoute
                        path={'/create_team'}
                        component={CreateTeam}
                    />
                    <LoggedInRoute
                        path={'/mfa'}
                        component={Mfa}
                    />
                    <LoggedInRoute
                        path={'/preparing-workspace'}
                        component={PreparingWorkspace}
                    />
                    <Redirect
                        from={'/_redirect/integrations/:subpath*'}
                        to={`/${this.props.permalinkRedirectTeamName}/integrations/:subpath*`}
                    />
                    <Redirect
                        from={'/_redirect/pl/:postid'}
                        to={`/${this.props.permalinkRedirectTeamName}/pl/:postid`}
                    />
                    <CompassThemeProvider theme={this.props.theme}>
                        {(this.props.showLaunchingWorkspace && !this.props.location.pathname.includes('/preparing-workspace') &&
                            <LaunchingWorkspace
                                fullscreen={true}
                                zIndex={LAUNCHING_WORKSPACE_FULLSCREEN_Z_INDEX}
                                show={true}
                                onPageView={noop}
                                transitionDirection={Animations.Reasons.EnterFromBefore}
                            />
                        )}
                        <ModalController/>
                        <AnnouncementBarController/>
                        <SystemNotice/>
                        <GlobalHeader/>
                        <CloudEffects/>
                        <OnBoardingTaskList/>
                        <TeamSidebar/>
                        <DelinquencyModalController/>
                        <Switch>
                            {this.props.products?.map((product) => (
                                <Route
                                    key={product.id}
                                    path={product.baseURL}
                                    render={(props) => {
                                        let pluggable = (
                                            <Pluggable
                                                pluggableName={'Product'}
                                                subComponentName={'mainComponent'}
                                                pluggableId={product.id}
                                                webSocketClient={webSocketClient}
                                                css={product.wrapped ? undefined : {gridArea: 'center'}}
                                            />
                                        );
                                        if (product.wrapped) {
                                            pluggable = (
                                                <div className={classNames(['product-wrapper', {wide: !product.showTeamSidebar}])}>
                                                    {pluggable}
                                                </div>
                                            );
                                        }
                                        return (
                                            <LoggedIn {...props}>
                                                {pluggable}
                                            </LoggedIn>
                                        );
                                    }}
                                />
                            ))}
                            {this.props.plugins?.map((plugin) => (
                                <Route
                                    key={plugin.id}
                                    path={'/plug/' + (plugin as any).route}
                                    render={() => (
                                        <Pluggable
                                            pluggableName={'CustomRouteComponent'}
                                            pluggableId={plugin.id}
                                            css={{gridArea: 'center'}}
                                        />
                                    )}
                                />
                            ))}
                            <LoggedInRoute
                                path={'/:team'}
                                component={TeamController}
                            />
                            <RootRedirect/>
                        </Switch>
                        <Pluggable pluggableName='Global'/>
                        <SidebarRight/>
                        <AppBar/>
                        <SidebarRightMenu/>
                    </CompassThemeProvider>
                </Switch>
            </RootProvider>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {bindActionCreators, ActionCreatorsMapObject, Dispatch} from 'redux';
import {connect} from 'react-redux';

import {Action} from 'mattermost-redux/types/actions';
import {isCurrentLicenseCloud} from 'mattermost-redux/selectors/entities/cloud';
import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {shouldShowTermsOfService, getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {getTeam} from 'mattermost-redux/selectors/entities/teams';
import {getTheme} from 'mattermost-redux/selectors/entities/preferences';
import {getFirstAdminSetupComplete} from 'mattermost-redux/actions/general';
import {getProfiles} from 'mattermost-redux/actions/users';

import {getShowLaunchingWorkspace} from 'selectors/onboarding';
import {
    getIsRhsExpanded,
    getIsRhsOpen,
    getRhsState,
} from 'selectors/rhs';
import {shouldShowAppBar} from 'selectors/plugins';
import {migrateRecentEmojis} from 'actions/emoji_actions';
import {emitBrowserWindowResized} from 'actions/views/browser';
import {loadConfigAndMe, registerCustomPostRenderer} from 'actions/views/root';

import {initializeProducts} from 'plugins/products';

import LocalStorageStore from 'stores/local_storage_store';

import {GlobalState} from 'types/store/index';

import Root, {Actions} from './root';

function mapStateToProps(state: GlobalState) {
    const config = getConfig(state);
    const showTermsOfService = shouldShowTermsOfService(state);
    const plugins = state.plugins.components.CustomRouteComponent;
    const products = state.plugins.components.Product;
    const userId = getCurrentUserId(state);

    const teamId = LocalStorageStore.getPreviousTeamId(userId);
    const permalinkRedirectTeam = getTeam(state, teamId!);

    return {
        theme: getTheme(state),
        telemetryEnabled: config.DiagnosticsEnabled === 'true',
        noAccounts: config.NoAccounts === 'true',
        telemetryId: config.DiagnosticId,
        permalinkRedirectTeamName: permalinkRedirectTeam ? permalinkRedirectTeam.name : '',
        showTermsOfService,
        plugins,
        products,
        showLaunchingWorkspace: getShowLaunchingWorkspace(state),
        rhsIsExpanded: getIsRhsExpanded(state),
        rhsIsOpen: getIsRhsOpen(state),
        rhsState: getRhsState(state),
        shouldShowAppBar: shouldShowAppBar(state),
        isCloud: isCurrentLicenseCloud(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, Actions>({
            loadConfigAndMe,
            emitBrowserWindowResized,
            getFirstAdminSetupComplete,
            getProfiles,
            migrateRecentEmojis,
            registerCustomPostRenderer,
            initializeProducts,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(Root);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import ReactDOM from 'react-dom';

interface Props {
    children: React.ReactNode | React.ReactNodeArray;
}
export default class RootPortal extends React.PureComponent<Props> {
    private el: HTMLDivElement

    constructor(props: Props) {
        super(props);
        this.el = document.createElement('div');
    }

    componentDidMount() {
        const rootPortal = document.getElementById('root-portal');
        if (rootPortal) {
            rootPortal.appendChild(this.el);
        }
    }

    componentWillUnmount() {
        const rootPortal = document.getElementById('root-portal');
        if (rootPortal) {
            rootPortal.removeChild(this.el);
        }
    }

    render() {
        return ReactDOM.createPortal(
            this.props.children,
            this.el,
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import LoadingWrapper from 'components/widgets/loading/loading_wrapper';

type Props = {
    saving: boolean;
    disabled?: boolean;
    id?: string;
    onClick?: (e: React.MouseEvent<HTMLButtonElement>) => void;
    savingMessage?: React.ReactNode;
    defaultMessage?: React.ReactNode;
    btnClass?: string;
    extraClasses?: string;
}

export default class SaveButton extends React.PureComponent<Props> {
    public static defaultProps: Partial<Props> = {
        btnClass: 'btn-primary',
        defaultMessage: (
            <FormattedMessage
                id='save_button.save'
                defaultMessage='Save'
            />
        ),
        disabled: false,
        extraClasses: '',
        savingMessage: (
            <FormattedMessage
                id='save_button.saving'
                defaultMessage='Saving'
            />
        ),
    }

    public render() {
        const {
            saving,
            disabled,
            savingMessage,
            defaultMessage,
            btnClass,
            extraClasses,
            ...props
        } = this.props;

        let className = 'save-button btn';
        if (!disabled || saving) {
            className += ' ' + btnClass;
        }

        if (extraClasses) {
            className += ' ' + extraClasses;
        }

        return (
            <button
                type='submit'
                data-testid='saveSetting'
                id='saveSetting'
                className={className}
                disabled={disabled}
                {...props}
            >
                <LoadingWrapper
                    loading={saving}
                    text={savingMessage}
                >
                    <span>{defaultMessage}</span>
                </LoadingWrapper>
            </button>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode} from 'react';

import {ConnectedComponent} from 'react-redux';

import {Client4} from 'mattermost-redux/client';

import ProfilePicture from 'components/profile_picture';
import UserProfile from 'components/user_profile';
import FormattedMarkdownMessage from 'components/formatted_markdown_message';
import Nbsp from 'components/html_entities/nbsp';
import CustomStatusEmoji from 'components/custom_status/custom_status_emoji';

import {UserProfile as UserProfileType} from '@mattermost/types/users';
import {Channel, ChannelMembership} from '@mattermost/types/channels';
import {TeamMembership} from '@mattermost/types/teams';

import {createSafeId, displayFullAndNicknameForUser} from 'utils/utils';

type Props = {
    user: UserProfileType;
    status?: string;
    extraInfo?: Array<string | JSX.Element>;
    actions?: Array<ConnectedComponent<any, any>>;
    actionProps?: {
        mfaEnabled: boolean;
        enableUserAccessTokens: boolean;
        experimentalEnableAuthenticationTransfer: boolean;
        doPasswordReset: (user: UserProfileType) => void;
        doEmailReset: (user: UserProfileType) => void;
        doManageTeams: (user: UserProfileType) => void;
        doManageRoles: (user: UserProfileType) => void;
        doManageTokens: (user: UserProfileType) => void;
        isDisabled?: boolean;
    };
    actionUserProps?: {
        [userId: string]: {
            channel: Channel;
            teamMember: TeamMembership;
            channelMember: ChannelMembership;
        };
    };
    index?: number;
    totalUsers?: number;
    userCount?: number;
};

const UserListRow = ({user, status, extraInfo = [], actions = [], actionProps, actionUserProps = {}, index, totalUsers, userCount}: Props) => {
    let buttons = null;
    if (actions) {
        buttons = actions.map((Action, actionIndex) => {
            return (
                <Action
                    key={actionIndex.toString()}
                    user={user}
                    index={index}
                    totalUsers={totalUsers}
                    {...actionProps}
                    {...actionUserProps}
                />
            );
        });
    }

    // QUICK HACK, NEEDS A PROP FOR TOGGLING STATUS
    let emailProp: ReactNode = user.email;
    let emailStyle = 'more-modal__description';
    let statusProp: string | undefined;
    if (extraInfo && extraInfo.length > 0) {
        emailProp = (
            <FormattedMarkdownMessage
                id='admin.user_item.emailTitle'
                defaultMessage='**Email:** {email}'
                values={{
                    email: user.email,
                }}
            />
        );
        emailStyle = '';
    } else if (user.status) {
        statusProp = user.status;
    } else {
        statusProp = status;
    }

    if (user.is_bot) {
        statusProp = undefined;
        emailProp = undefined;
    }

    let userCountID: string | undefined;
    let userCountEmail: string | undefined;
    if (userCount && userCount >= 0) {
        userCountID = createSafeId('userListRowName' + userCount);
        userCountEmail = createSafeId('userListRowEmail' + userCount);
    }

    return (
        <div
            key={user.id}
            className='more-modal__row'
        >
            <ProfilePicture
                src={Client4.getProfilePictureUrl(user.id, user.last_picture_update)}
                status={statusProp}
                size='md'
                userId={user.id}
                hasMention={true}
                username={user.username}
            />
            <div
                className='more-modal__details'
                data-testid='userListItemDetails'
            >
                <div className='d-flex whitespace--nowrap'>
                    <div
                        id={userCountID}
                        className='more-modal__name'
                    >
                        <UserProfile
                            userId={user.id}
                            hasMention={true}
                            displayUsername={true}
                        />
                        <Nbsp/>
                        {
                            user.first_name || user.last_name || user.nickname ? '-' : null
                        }
                        <Nbsp/>
                        {displayFullAndNicknameForUser(user)}
                    </div>
                    <CustomStatusEmoji
                        userID={user.id}
                        emojiSize={15}
                        showTooltip={true}
                        emojiStyle={{
                            marginLeft: 0,
                            marginBottom: -3,
                        }}
                    />
                </div>
                <div
                    id={userCountEmail}
                    className={emailStyle}
                >
                    {emailProp}
                </div>
                {extraInfo}
            </div>
            <div
                data-testid='userListItemActions'
                className='more-modal__actions'
            >
                {buttons}
            </div>
        </div>
    );
};

export default UserListRow;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getStatusForUserId} from 'mattermost-redux/selectors/entities/users';

import {GlobalState} from 'types/store';

import {UserProfile} from '@mattermost/types/users';

import UserListRow from './user_list_row';

type OwnProps = {
    user: UserProfile;
}

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const user = ownProps.user;
    return {
        status: getStatusForUserId(state, user.id),
    };
}

export default connect(mapStateToProps)(UserListRow);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode} from 'react';
import {FormattedMessage} from 'react-intl';

import LoadingScreen from 'components/loading_screen';

import {UserProfile} from '@mattermost/types/users';
import {Channel, ChannelMembership} from '@mattermost/types/channels';
import {TeamMembership} from '@mattermost/types/teams';

import UserListRow from './user_list_row';

type Props = {
    rowComponentType?: React.ComponentType<any>;
    length?: number;
    actions?: ReactNode[];
    actionUserProps?: {
        [userId: string]: {
            channel?: Channel;
            teamMember: TeamMembership;
            channelMember?: ChannelMembership;
        };
    };
    isDisabled?: boolean;
    users?: UserProfile[] | null;
    extraInfo?: {[key: string]: Array<string | JSX.Element>};
    actionProps?: {
        mfaEnabled: boolean;
        enableUserAccessTokens: boolean;
        experimentalEnableAuthenticationTransfer: boolean;
        doPasswordReset: (user: UserProfile) => void;
        doEmailReset: (user: UserProfile) => void;
        doManageTeams: (user: UserProfile) => void;
        doManageRoles: (user: UserProfile) => void;
        doManageTokens: (user: UserProfile) => void;
        isDisabled?: boolean;
    };
}

export default class UserList extends React.PureComponent <Props> {
    static defaultProps = {
        users: [],
        extraInfo: {},
        actions: [],
        actionProps: {},
        rowComponentType: UserListRow,
    }
    containerRef: React.RefObject<any>;

    constructor(props: Props) {
        super(props);
        this.containerRef = React.createRef();
    }

    scrollToTop = () => {
        if (this.containerRef.current) {
            this.containerRef.current.scrollTop = 0;
        }
    }

    render() {
        const users = this.props.users;
        const RowComponentType = this.props.rowComponentType;

        let content;
        if (users == null) {
            return <LoadingScreen/>;
        } else if (users.length > 0 && RowComponentType && this.props.actionProps) {
            content = users.map((user: UserProfile, index: number) => {
                const {actionUserProps, extraInfo} = this.props;
                const userId = user.id;
                return (
                    <RowComponentType
                        key={user.id}
                        user={user}
                        extraInfo={extraInfo?.[userId]}
                        actions={this.props.actions}
                        actionProps={this.props.actionProps}
                        actionUserProps={actionUserProps?.[userId]}
                        index={index}
                        totalUsers={users.length}
                        userCount={index >= 0 ? index : -1}
                        isDisabled={this.props.isDisabled}
                    />
                );
            });
        } else {
            content = (
                <div
                    key='no-users-found'
                    className='more-modal__placeholder-row'
                    data-testid='noUsersFound'
                >
                    <p>
                        <FormattedMessage
                            id='user_list.notFound'
                            defaultMessage='No users found'
                        />
                    </p>
                </div>
            );
        }

        return (
            <div ref={this.containerRef}>
                {content}
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage, injectIntl, IntlShape} from 'react-intl';
import Scrollbars from 'react-custom-scrollbars';

import {UserProfile} from '@mattermost/types/users';
import {Channel, ChannelMembership} from '@mattermost/types/channels';
import {TeamMembership} from '@mattermost/types/teams';

import QuickInput from 'components/quick_input';
import UserList from 'components/user_list';
import LocalizedInput from 'components/localized_input/localized_input';

import {t} from 'utils/i18n';

const NEXT_BUTTON_TIMEOUT = 500;

type Props = {
    users: UserProfile[] | null;
    usersPerPage: number;
    total: number;
    extraInfo?: {[key: string]: Array<string | JSX.Element>};
    nextPage: () => void;
    previousPage: () => void;
    search: (term: string) => void;
    actions?: React.ReactNode[];
    actionProps?: {
        mfaEnabled: boolean;
        enableUserAccessTokens: boolean;
        experimentalEnableAuthenticationTransfer: boolean;
        doPasswordReset: (user: UserProfile) => void;
        doEmailReset: (user: UserProfile) => void;
        doManageTeams: (user: UserProfile) => void;
        doManageRoles: (user: UserProfile) => void;
        doManageTokens: (user: UserProfile) => void;
        isDisabled: boolean | undefined;
    };
    actionUserProps?: {
        [userId: string]: {
            channel?: Channel;
            teamMember: TeamMembership;
            channelMember?: ChannelMembership;
        };
    };
    focusOnMount?: boolean;
    renderCount?: (count: number, total: number, startCount: number, endCount: number, isSearch: boolean) => JSX.Element | null;
    filter?: string;
    renderFilterRow?: (handleFilter: ((event: React.FormEvent<HTMLInputElement>) => void) | undefined) => JSX.Element;
    page: number;
    term: string;
    onTermChange: (term: string) => void;
    intl: IntlShape;
    isDisabled?: boolean;

    // the type of user list row to render
    rowComponentType?: React.ComponentType<any>;
}

const renderView = (props: Record<string, unknown>): JSX.Element => (
    <div
        {...props}
        className='scrollbar--view'
    />
);

const renderThumbHorizontal = (): JSX.Element => (
    <div/>
);

const renderThumbVertical = (props: Record<string, unknown>): JSX.Element => (
    <div
        {...props}
        className='scrollbar--vertical'
    />
);

type State = {
    nextDisabled: boolean;
};

class SearchableUserList extends React.PureComponent<Props, State> {
    static defaultProps: Partial<Props> = {
        users: [],
        usersPerPage: 50,
        extraInfo: {},
        actions: [],
        actionProps: {
            mfaEnabled: false,
            enableUserAccessTokens: false,
            experimentalEnableAuthenticationTransfer: false,
            doPasswordReset() {},
            doEmailReset() {},
            doManageTeams() {},
            doManageRoles() {},
            doManageTokens() {},
            isDisabled: false,
        },
        actionUserProps: {},
        focusOnMount: false,
    };

    private nextTimeoutId: NodeJS.Timeout;
    private scrollbarsRef: React.RefObject<Scrollbars>;
    private filterRef: React.RefObject<HTMLInputElement>;

    constructor(props: Props) {
        super(props);

        this.nextTimeoutId = {} as NodeJS.Timeout;

        this.state = {
            nextDisabled: false,
        };

        this.scrollbarsRef = React.createRef();
        this.filterRef = React.createRef();
    }

    public scrollToTop = (): void => {
        this.scrollbarsRef.current?.scrollToTop();
    }

    componentDidMount() {
        this.focusSearchBar();
    }

    componentDidUpdate(prevProps: Props) {
        if (this.props.page !== prevProps.page || this.props.term !== prevProps.term) {
            this.scrollToTop();
        }
    }

    componentWillUnmount() {
        clearTimeout(this.nextTimeoutId);
    }

    nextPage = (e: React.MouseEvent) => {
        e.preventDefault();

        this.setState({nextDisabled: true});
        this.nextTimeoutId = setTimeout(() => this.setState({nextDisabled: false}), NEXT_BUTTON_TIMEOUT);

        this.props.nextPage();
        this.scrollToTop();
    }

    previousPage = (e: React.MouseEvent) => {
        e.preventDefault();

        this.props.previousPage();
        this.scrollToTop();
    }

    focusSearchBar = () => {
        if (this.props.focusOnMount && this.filterRef.current) {
            this.filterRef.current.focus();
        }
    }

    handleInput = (e: React.FormEvent<HTMLInputElement> | undefined) => {
        if (e) {
            this.props.onTermChange(e.currentTarget.value);
            this.props.search(e.currentTarget.value);
        }
    }

    renderCount = (users: UserProfile[] | null | undefined) => {
        if (!users || !this.props.users) {
            return null;
        }

        if (this.props.filter) {
            return null;
        }

        const count = users.length;
        const total = this.props.total;
        const isSearch = Boolean(this.props.term);

        let startCount;
        let endCount;
        if (isSearch) {
            startCount = -1;
            endCount = -1;
        } else {
            startCount = this.props.page * this.props.usersPerPage;
            endCount = Math.min(startCount + this.props.usersPerPage, total);
            if (this.props.users.length < endCount) {
                endCount = this.props.users.length;
            }
        }

        if (this.props.renderCount) {
            return this.props.renderCount(count, this.props.total, startCount, endCount, isSearch);
        }

        if (this.props.total) {
            if (isSearch) {
                return (
                    <FormattedMessage
                        id='filtered_user_list.countTotal'
                        defaultMessage='{count, number} {count, plural, one {member} other {members}} of {total, number} total'
                        values={{
                            count,
                            total,
                        }}
                    />
                );
            }

            return (
                <FormattedMessage
                    id='filtered_user_list.countTotalPage'
                    defaultMessage='{startCount, number} - {endCount, number} {count, plural, one {member} other {members}} of {total, number} total'
                    values={{
                        count,
                        startCount: startCount + 1,
                        endCount,
                        total,
                    }}
                />
            );
        }

        return null;
    }

    render() {
        let nextButton;
        let previousButton;
        let usersToDisplay;
        const {formatMessage} = this.props.intl;

        if (this.props.term || !this.props.users) {
            usersToDisplay = this.props.users;
        } else if (!this.props.term) {
            const pageStart = this.props.page * this.props.usersPerPage;
            let pageEnd = pageStart + this.props.usersPerPage;
            if (this.props.users.length < pageEnd) {
                pageEnd = this.props.users.length;
            }

            usersToDisplay = this.props.users.slice(pageStart, pageEnd);

            if (pageEnd < this.props.total) {
                nextButton = (
                    <button
                        id='searchableUserListNextBtn'
                        className='btn btn-link filter-control filter-control__next'
                        onClick={this.nextPage}
                        disabled={this.state.nextDisabled}
                    >
                        <FormattedMessage
                            id='filtered_user_list.next'
                            defaultMessage='Next'
                        />
                    </button>
                );
            }

            if (this.props.page > 0) {
                previousButton = (
                    <button
                        id='searchableUserListPrevBtn'
                        className='btn btn-link filter-control filter-control__prev'
                        onClick={this.previousPage}
                    >
                        <FormattedMessage
                            id='filtered_user_list.prev'
                            defaultMessage='Previous'
                        />
                    </button>
                );
            }
        }

        let filterRow;
        if (this.props.renderFilterRow) {
            filterRow = this.props.renderFilterRow(this.handleInput);
        } else {
            const searchUsersPlaceholder = {id: t('filtered_user_list.search'), defaultMessage: 'Search users'};
            filterRow = (
                <div className='col-xs-12'>
                    <label
                        className='hidden-label'
                        htmlFor='searchUsersInput'
                    >
                        <FormattedMessage
                            id='filtered_user_list.search'
                            defaultMessage='Search users'
                        />
                    </label>
                    <QuickInput
                        id='searchUsersInput'
                        ref={this.filterRef}
                        className='form-control filter-textbox'
                        placeholder={searchUsersPlaceholder}
                        inputComponent={LocalizedInput}
                        value={this.props.term}
                        onInput={this.handleInput}
                        aria-label={formatMessage(searchUsersPlaceholder).toLowerCase()}
                    />
                </div>
            );
        }

        return (
            <div className='filtered-user-list'>
                <div className='filter-row'>
                    {filterRow}
                    <div className='col-sm-12'>
                        <span
                            id='searchableUserListTotal'
                            className='member-count pull-left'
                            aria-live='polite'
                        >
                            {this.renderCount(usersToDisplay)}
                        </span>
                    </div>
                </div>
                <div className='more-modal__list'>
                    <Scrollbars
                        ref={this.scrollbarsRef}
                        autoHide={true}
                        autoHideTimeout={500}
                        autoHideDuration={500}
                        renderThumbHorizontal={renderThumbHorizontal}
                        renderThumbVertical={renderThumbVertical}
                        renderView={renderView}
                    >
                        <UserList
                            users={usersToDisplay}
                            extraInfo={this.props.extraInfo}
                            actions={this.props.actions}
                            actionProps={this.props.actionProps}
                            actionUserProps={this.props.actionUserProps}
                            rowComponentType={this.props.rowComponentType}
                            isDisabled={this.props.isDisabled}
                        />
                    </Scrollbars>
                </div>
                <div className='filter-controls'>
                    {previousButton}
                    {nextButton}
                </div>
            </div>
        );
    }
}

export default injectIntl(SearchableUserList);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState} from 'react';

import {UserProfile} from '@mattermost/types/users';
import {Channel, ChannelMembership} from '@mattermost/types/channels';
import {TeamMembership} from '@mattermost/types/teams';

import SearchableUserList from './searchable_user_list';

type Props = {
    users: UserProfile[] | null;
    usersPerPage: number;
    total: number;
    extraInfo?: {[key: string]: Array<string | JSX.Element>};
    nextPage: (page: number) => void;
    search: (term: string) => void;
    actions?: React.ReactNode[];
    actionProps?: {
        mfaEnabled: boolean;
        enableUserAccessTokens: boolean;
        experimentalEnableAuthenticationTransfer: boolean;
        doPasswordReset: (user: UserProfile) => void;
        doEmailReset: (user: UserProfile) => void;
        doManageTeams: (user: UserProfile) => void;
        doManageRoles: (user: UserProfile) => void;
        doManageTokens: (user: UserProfile) => void;
        isDisabled: boolean | undefined;
    };
    actionUserProps: {
        [userId: string]: {
            channel?: Channel;
            teamMember: TeamMembership;
            channelMember?: ChannelMembership;
        };
    };
    focusOnMount?: boolean;
}

export default function SearchableUserListContainer(props: Props) {
    const [term, setTerm] = useState('');
    const [page, setPage] = useState(0);

    const handleTermChange = (term: string) => {
        setTerm(term);
    };

    const nextPage = () => {
        setPage(page + 1);
        props.nextPage(page + 1);
    };

    const previousPage = () => {
        setPage(page - 1);
    };

    const search = (term: string) => {
        props.search(term);

        if (term !== '') {
            setPage(0);
        }
    };

    return (
        <SearchableUserList
            {...props}
            nextPage={nextPage}
            previousPage={previousPage}
            search={search}
            page={page}
            term={term}
            onTermChange={handleTermChange}
        />
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode} from 'react';
import {FormattedMessage} from 'react-intl';

import SaveButton from 'components/save_button';
import Constants from 'utils/constants';
import {isKeyPressed} from 'utils/utils';
type Props = {

    // Array of inputs selection
    inputs?: ReactNode;
    containerStyle?: string;
    serverError?: ReactNode;

    /**
     * Client error
     */
    clientError?: ReactNode;

    /**
     * Settings extra information
     */
    extraInfo?: ReactNode;

    /**
     * Info position
     */
    infoPosition?: string;

    /**
     * Settings or tab section
     */
    section: string;
    updateSection?: (section: string) => void;
    setting?: string;
    submit?: ((setting?: string) => void) | null;
    disableEnterSubmit?: boolean;
    submitExtra?: ReactNode;
    saving?: boolean;
    title?: ReactNode;
    width?: string;
    cancelButtonText?: ReactNode;
    shiftEnter?: boolean;
    saveButtonText?: string;
}
export default class SettingItemMax extends React.PureComponent<Props> {
    settingList: React.RefObject<HTMLDivElement>;

    static defaultProps = {
        infoPosition: 'bottom',
        saving: false,
        section: '',
        containerStyle: '',
    };

    constructor(props: Props) {
        super(props);
        this.settingList = React.createRef();
    }

    componentDidMount() {
        if (this.settingList.current) {
            const focusableElements: NodeListOf<HTMLElement> = this.settingList.current.querySelectorAll('.btn:not(.save-button):not(.btn-cancel), input.form-control, select, textarea, [tabindex]:not([tabindex="-1"])');
            if (focusableElements.length > 0) {
                focusableElements[0].focus();
            } else {
                this.settingList.current.focus();
            }
        }

        document.addEventListener('keydown', this.onKeyDown);
    }

    componentWillUnmount() {
        document.removeEventListener('keydown', this.onKeyDown);
    }

    onKeyDown = (e: KeyboardEvent) => {
        const target = e.target as HTMLElement;
        if (this.props.shiftEnter && isKeyPressed(e, Constants.KeyCodes.ENTER) && e.shiftKey) {
            return;
        }
        if (this.props.disableEnterSubmit !== true &&
            isKeyPressed(e, Constants.KeyCodes.ENTER) &&
            this.props.submit &&
            target.tagName !== 'SELECT' &&
            target.parentElement &&
            target.parentElement.className !== 'react-select__input' &&
            !target.classList.contains('btn-cancel') &&
            this.settingList.current &&
            this.settingList.current.contains(target)) {
            this.handleSubmit(e);
        }
    }

    handleSubmit = (e: React.MouseEvent | KeyboardEvent) => {
        e.preventDefault();

        if (this.props.setting && this.props.submit) {
            this.props.submit(this.props.setting);
        } else if (this.props.submit) {
            this.props.submit();
        }
    }

    handleUpdateSection = (e: React.MouseEvent) => {
        if (this.props.updateSection) {
            this.props.updateSection(this.props.section);
        }
        e.preventDefault();
    }

    render() {
        let clientError = null;
        if (this.props.clientError) {
            clientError = (
                <div className='form-group'>
                    <label
                        id='clientError'
                        className='col-sm-12 has-error'
                    >
                        {this.props.clientError}
                    </label>
                </div>
            );
        }

        let serverError = null;
        if (this.props.serverError) {
            serverError = (
                <div className='form-group'>
                    <label
                        id='serverError'
                        className='col-sm-12 has-error'
                    >
                        {this.props.serverError}
                    </label>
                </div>
            );
        }

        let extraInfo = null;
        let hintClass = 'setting-list__hint';
        if (this.props.infoPosition === 'top') {
            hintClass = 'pb-3';
        }

        if (this.props.extraInfo) {
            extraInfo = (
                <div
                    id='extraInfo'
                    className={hintClass}
                >
                    {this.props.extraInfo}
                </div>
            );
        }

        let submit: JSX.Element | null = null;
        if (this.props.submit) {
            submit = (
                <SaveButton
                    defaultMessage={this.props.saveButtonText}
                    saving={this.props.saving}
                    disabled={this.props.saving}
                    onClick={this.handleSubmit}
                />
            );
        }

        const inputs = this.props.inputs;
        let widthClass;
        if (this.props.width === 'full') {
            widthClass = 'col-sm-12';
        } else if (this.props.width === 'medium') {
            widthClass = 'col-sm-10 col-sm-offset-2';
        } else {
            widthClass = 'col-sm-9 col-sm-offset-3';
        }

        let title;
        if (this.props.title) {
            title = (
                <h4
                    id='settingTitle'
                    className='col-sm-12 section-title'
                >
                    {this.props.title}
                </h4>
            );
        }

        let listContent = (
            <div className='setting-list-item'>
                {inputs}
                {extraInfo}
            </div>
        );

        if (this.props.infoPosition === 'top') {
            listContent = (
                <div>
                    {extraInfo}
                    {inputs}
                </div>
            );
        }

        let cancelButtonText;
        if (this.props.cancelButtonText) {
            cancelButtonText = this.props.cancelButtonText;
        } else {
            cancelButtonText = (
                <FormattedMessage
                    id='setting_item_max.cancel'
                    defaultMessage='Cancel'
                />
            );
        }

        return (
            <section
                className={`section-max form-horizontal ${this.props.containerStyle}`}
            >
                {title}
                <div className={widthClass}>
                    <div
                        tabIndex={-1}
                        ref={this.settingList}
                        className='setting-list'
                    >
                        {listContent}
                        <div className='setting-list-item'>
                            <hr/>
                            {this.props.submitExtra}
                            {serverError}
                            {clientError}
                            {submit}
                            <button
                                id={'cancelSetting'}
                                className='btn btn-sm btn-cancel cursor--pointer style--none'
                                onClick={this.handleUpdateSection}
                            >
                                {cancelButtonText}
                            </button>
                        </div>
                    </div>
                </div>
            </section>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode} from 'react';
import {FormattedMessage} from 'react-intl';

import EditIcon from 'components/widgets/icons/fa_edit_icon';

interface Props {

    /**
     * Settings title
     */
    title: JSX.Element | string;

    /**
     * Option to disable opening the setting
     */
    disableOpen?: boolean;

    /**
     * Settings or tab section
     */
    section: string;

    /**
     * Function to update section
     */
    updateSection: (section: string) => void;

    /**
     * Settings description
     */
    describe?: ReactNode;

    isMobileView: boolean;
}

export default class SettingItemMin extends React.PureComponent<Props> {
    private edit: HTMLButtonElement | null = null;

    componentDidMount() {
        if (this.edit) {
            this.edit.focus();
        }
    }

    private getEdit = (node: HTMLButtonElement) => {
        this.edit = node;
    }

    handleUpdateSection = (e: React.MouseEvent<HTMLElement>) => {
        e.preventDefault();
        this.props.updateSection(this.props.section);
    }

    render(): JSX.Element {
        let editButton = null;
        let describeSection = null;

        if (!this.props.disableOpen && this.props.isMobileView) {
            editButton = (
                <div className='section-min__edit'>
                    <button
                        id={this.props.section + 'Edit'}
                        className='color--link cursor--pointer style--none'
                        onClick={this.handleUpdateSection}
                        ref={this.getEdit}
                        aria-labelledby={this.props.section + 'Title ' + this.props.section + 'Edit'}
                    >
                        <EditIcon/>
                        {this.props.describe}
                    </button>
                </div>
            );
        } else if (!this.props.disableOpen) {
            editButton = (
                <div className='section-min__edit'>
                    <button
                        id={this.props.section + 'Edit'}
                        className='color--link cursor--pointer style--none text-left'
                        onClick={this.handleUpdateSection}
                        ref={this.getEdit}
                        aria-labelledby={this.props.section + 'Title ' + this.props.section + 'Edit'}
                    >
                        <EditIcon/>
                        <FormattedMessage
                            id='setting_item_min.edit'
                            defaultMessage='Edit'
                        />
                    </button>
                </div>
            );

            describeSection = (
                <div
                    id={this.props.section + 'Desc'}
                    className='section-min__describe'
                >
                    {this.props.describe}
                </div>
            );
        }

        return (
            <div
                className='section-min'
                onClick={this.handleUpdateSection}
            >
                <div className='d-flex'>
                    <h4
                        id={this.props.section + 'Title'}
                        className='section-min__title'
                    >
                        {this.props.title}
                    </h4>
                    {editButton}
                </div>
                {describeSection}
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getIsMobileView} from 'selectors/views/browser';

import {GlobalState} from 'types/store';

import SettingItemMin from './setting_item_min';

function mapStateToProps(state: GlobalState) {
    return {
        isMobileView: getIsMobileView(state),
    };
}

export default connect(mapStateToProps)(SettingItemMin);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ChangeEvent, Component, createRef, CSSProperties, MouseEvent, ReactNode, RefObject} from 'react';
import {FormattedMessage} from 'react-intl';

import * as FileUtils from 'utils/file_utils';

import {Constants} from 'utils/constants';
import {localizeMessage} from 'utils/utils';

import FormError from 'components/form_error';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import LoadingWrapper from 'components/widgets/loading/loading_wrapper';

type Props = {
    clientError?: ReactNode;
    serverError?: ReactNode;
    src?: string | null;
    defaultImageSrc?: string;
    file?: File | null;
    loadingPicture?: boolean;
    submitActive?: boolean;
    onRemove?: () => void;
    onSetDefault?: (() => Promise<void>) | null;
    onSubmit?: (() => void) | null;
    title?: string;
    onFileChange?: (e: ChangeEvent<HTMLInputElement>) => void;
    updateSection?: (e: MouseEvent<HTMLButtonElement>) => void;
    imageContext?: string;
    maxFileSize?: number;
    helpText?: ReactNode;
}

type State = {
    image: string | null;
    removeSrc: boolean;
    setDefaultSrc: boolean;
    orientationStyles?: CSSProperties;
}

export default class SettingPicture extends Component<Props, State> {
    static defaultProps = {
        imageContext: 'profile',
    };
    private readonly settingList: RefObject<HTMLDivElement>;
    private readonly selectInput: RefObject<HTMLInputElement>;
    private readonly confirmButton: RefObject<HTMLButtonElement>;
    private previewBlob: string | null;

    constructor(props: Props) {
        super(props);

        this.settingList = createRef();
        this.selectInput = createRef();
        this.confirmButton = createRef();
        this.previewBlob = null;

        this.state = {
            image: null,
            removeSrc: false,
            setDefaultSrc: false,
        };
    }

    focusFirstElement() {
        this.settingList.current?.focus();
    }

    componentDidMount() {
        this.focusFirstElement();

        if (this.selectInput.current) {
            this.selectInput.current.addEventListener('input', this.handleFileSelected);
        }
    }

    componentDidUpdate(prevProps: Props) {
        if (this.props.file && prevProps.file !== this.props.file) {
            this.setPicture(this.props.file);
        }
    }

    componentWillUnmount() {
        if (this.previewBlob) {
            URL.revokeObjectURL(this.previewBlob);
        }

        if (this.selectInput.current) {
            this.selectInput.current.removeEventListener('input', this.handleFileSelected);
        }
    }

    handleCancel = (e: MouseEvent<HTMLButtonElement>) => {
        this.setState({removeSrc: false, setDefaultSrc: false});
        this.props.updateSection?.(e);
    }

    handleFileSelected = () => {
        if (this.confirmButton.current) {
            this.confirmButton.current.focus();
        }
    }

    handleSave = (e: MouseEvent) => {
        e.preventDefault();
        if (this.props.loadingPicture) {
            return;
        }
        if (this.state.removeSrc) {
            this.props.onRemove?.();
        } else if (this.state.setDefaultSrc) {
            this.props.onSetDefault?.();
        } else {
            this.props.onSubmit?.();
        }
    }

    handleRemoveSrc = (e: MouseEvent) => {
        e.preventDefault();
        this.setState({removeSrc: true});
        this.focusFirstElement();
    }

    handleSetDefaultSrc = (e: MouseEvent) => {
        e.preventDefault();
        this.setState({setDefaultSrc: true});
        this.focusFirstElement();
    }

    handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
        this.setState({removeSrc: false, setDefaultSrc: false});
        this.props.onFileChange?.(e);
    }

    handleInputFile = () => {
        if (this.selectInput.current) {
            this.selectInput.current.value = '';
            this.selectInput.current.click();
        }
    }

    setPicture = (file: File) => {
        if (file) {
            this.previewBlob = URL.createObjectURL(file);

            const reader = new FileReader();
            reader.onload = (e) => {
                const orientation = FileUtils.getExifOrientation(e.target!.result! as ArrayBuffer);
                const orientationStyles = FileUtils.getOrientationStyles(orientation);

                this.setState({
                    image: this.previewBlob,
                    orientationStyles,
                });
            };
            reader.readAsArrayBuffer(file);
        }
    }

    renderImg = () => {
        const imageContext = this.props.imageContext;

        if (this.props.file) {
            const imageStyles = {
                backgroundImage: 'url(' + this.state.image + ')',
                ...this.state.orientationStyles,
            };

            return (
                <div className={`${imageContext}-img-preview`}>
                    <div className='img-preview__image'>
                        <div
                            alt={`${imageContext} image preview`}
                            style={imageStyles}
                            className={`${imageContext}-img-preview`}
                        />
                    </div>
                </div>
            );
        }

        if (this.state.setDefaultSrc) {
            return (
                <img
                    className={`${imageContext}-img`}
                    alt={`${imageContext} image`}
                    src={this.props.defaultImageSrc}
                />
            );
        }

        if (this.props.src && !this.state.removeSrc) {
            const imageElement = (
                <img
                    className={`${imageContext}-img`}
                    alt={`${imageContext} image`}
                    src={this.props.src}
                />
            );
            if (!this.props.onRemove && !this.props.onSetDefault) {
                return imageElement;
            }

            let title;
            let handler;
            if (this.props.onRemove) {
                title = (
                    <FormattedMessage
                        id='setting_picture.remove'
                        defaultMessage='Remove This Icon'
                    />
                );
                handler = this.handleRemoveSrc;
            } else if (this.props.onSetDefault) {
                title = (
                    <FormattedMessage
                        id='setting_picture.remove_profile_picture'
                        defaultMessage='Remove Profile Picture'
                    />
                );
                handler = this.handleSetDefaultSrc;
            }

            return (
                <div className={`${imageContext}-img__container`}>
                    <div
                        className='img-preview__image'
                        aria-hidden={true}
                    >
                        {imageElement}
                    </div>
                    <OverlayTrigger
                        delayShow={Constants.OVERLAY_TIME_DELAY}
                        placement='right'
                        overlay={(
                            <Tooltip id='removeIcon'>
                                <div aria-hidden={true}>
                                    {title}
                                </div>
                            </Tooltip>
                        )}
                    >
                        <button
                            data-testid='removeSettingPicture'
                            className={`${imageContext}-img__remove`}
                            onClick={handler}
                        >
                            <span aria-hidden={true}>{''}</span>
                            <span className='sr-only'>{title}</span>
                        </button>
                    </OverlayTrigger>
                </div>
            );
        }
        return null;
    }

    render() {
        const img = this.renderImg();

        let confirmButtonClass = 'btn btn-sm';
        let disableSaveButtonFocus = false;
        if (this.props.submitActive || this.state.removeSrc || this.state.setDefaultSrc) {
            confirmButtonClass += ' btn-primary';
        } else {
            confirmButtonClass += ' btn-inactive disabled';
            disableSaveButtonFocus = true;
        }

        let imgRender;
        if (img) {
            imgRender = (
                <li
                    className='setting-list-item'
                    role='presentation'
                >
                    {img}
                </li>
            );
        }

        let buttonRender;
        if (this.props.onSubmit) {
            buttonRender = (
                <span>
                    <input
                        data-testid='uploadPicture'
                        ref={this.selectInput}
                        className='hidden'
                        accept={Constants.ACCEPT_STATIC_IMAGE}
                        type='file'
                        onChange={this.handleFileChange}
                        disabled={this.props.loadingPicture}
                        aria-hidden={true}
                        tabIndex={-1}
                    />
                    <button
                        data-testid='inputSettingPictureButton'
                        className='btn btn-sm btn-primary btn-file sel-btn'
                        disabled={this.props.loadingPicture}
                        onClick={this.handleInputFile}
                        aria-label={localizeMessage('setting_picture.select', 'Select')}
                    >
                        <FormattedMessage
                            id='setting_picture.select'
                            defaultMessage='Select'
                        />
                    </button>
                    <button
                        tabIndex={disableSaveButtonFocus ? -1 : 0}
                        data-testid='saveSettingPicture'
                        disabled={disableSaveButtonFocus}
                        ref={this.confirmButton}
                        className={confirmButtonClass}
                        onClick={this.handleSave}
                        aria-label={this.props.loadingPicture ? localizeMessage('setting_picture.uploading', 'Uploading...') : localizeMessage('setting_picture.save', 'Save')}
                    >
                        <LoadingWrapper
                            loading={this.props.loadingPicture}
                            text={localizeMessage('setting_picture.uploading', 'Uploading...')}
                        >
                            <FormattedMessage
                                id='setting_picture.save'
                                defaultMessage='Save'
                            />
                        </LoadingWrapper>
                    </button>
                </span>
            );
        }
        return (
            <section className='section-max form-horizontal'>
                <h4 className='col-xs-12 section-title'>
                    {this.props.title}
                </h4>
                <div className='col-xs-offset-3 col-xs-8'>
                    <div
                        className='setting-list'
                        ref={this.settingList}
                        tabIndex={-1}
                        aria-label={this.props.title}
                        aria-describedby='setting-picture__helptext'
                    >
                        {imgRender}
                        <div
                            id='setting-picture__helptext'
                            className='setting-list-item pt-3'
                        >
                            {this.props.helpText}
                        </div>
                        <div
                            className='setting-list-item'
                        >
                            <hr/>
                            <FormError
                                errors={[this.props.clientError, this.props.serverError]}
                                type={'modal'}
                            />
                            {buttonRender}
                            <button
                                data-testid='cancelSettingPicture'
                                className='btn btn-link btn-sm theme'
                                onClick={this.handleCancel}
                                aria-label={localizeMessage('setting_picture.cancel', 'Cancel')}
                            >
                                <FormattedMessage
                                    id='setting_picture.cancel'
                                    defaultMessage='Cancel'
                                />
                            </button>
                        </div>
                    </div>
                </div>
            </section>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {ChannelType} from '@mattermost/types/channels';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import {Constants} from 'utils/constants';

type Props = {
    className?: string;
    channelType: ChannelType;
    withTooltip?: boolean;
};

const SharedChannelIndicator: React.FC<Props> = (props: Props): JSX.Element => {
    let sharedIcon;
    if (props.channelType === Constants.PRIVATE_CHANNEL) {
        sharedIcon = (<i className={`${props.className || ''} icon-circle-multiple-outline-lock`}/>);
    } else {
        sharedIcon = (<i className={`${props.className || ''} icon-circle-multiple-outline`}/>);
    }

    if (!props.withTooltip) {
        return sharedIcon;
    }

    const sharedTooltip = (
        <Tooltip id='sharedTooltip'>
            <FormattedMessage
                id='shared_channel_indicator.tooltip'
                defaultMessage='Shared with trusted organizations'
            />
        </Tooltip>
    );

    return (
        <OverlayTrigger
            delayShow={Constants.OVERLAY_TIME_DELAY}
            placement='bottom'
            overlay={sharedTooltip}
        >
            {sharedIcon}
        </OverlayTrigger>
    );
};

export default SharedChannelIndicator;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import {Constants} from 'utils/constants';

type Props = {
    className?: string;
    withTooltip?: boolean;
};

const SharedUserIndicator: React.FC<Props> = (props: Props): JSX.Element => {
    const sharedIcon = (<i className={`${props.className || ''} icon-circle-multiple-outline`}/>);

    if (!props.withTooltip) {
        return sharedIcon;
    }

    const sharedTooltip = (
        <Tooltip id='sharedTooltip'>
            <FormattedMessage
                id='shared_user_indicator.tooltip'
                defaultMessage='From trusted organizations'
            />
        </Tooltip>
    );

    return (
        <OverlayTrigger
            delayShow={Constants.OVERLAY_TIME_DELAY}
            placement='bottom'
            overlay={sharedTooltip}
        >
            {sharedIcon}
        </OverlayTrigger>
    );
};

export default SharedUserIndicator;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import classNames from 'classnames';

import './shortcut_key.scss';

export enum ShortcutKeyVariant {
    Contrast = 'contrast',
    Tooltip = 'tooltip',
    TutorialTip = 'tutorialTip',
    ShortcutModal = 'shortcut',
}

export type ShortcutKeyProps = {
    variant?: ShortcutKeyVariant;
    children: React.ReactNode;
}

export const ShortcutKey = ({children, variant}: ShortcutKeyProps): JSX.Element => {
    return (
        <mark
            className={classNames('shortcut-key', {
                'shortcut-key--contrast': variant === ShortcutKeyVariant.Contrast,
                'shortcut-key--tooltip': variant === ShortcutKeyVariant.Tooltip,
                'shortcut-key--tutorial-tip': variant === ShortcutKeyVariant.TutorialTip,
                'shortcut-key--shortcut-modal': variant === ShortcutKeyVariant.ShortcutModal,
            })}
        >
            {children}
        </mark>
    );
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import PropTypes from 'prop-types';
import React from 'react';
import classNames from 'classnames';
import {FormattedMessage} from 'react-intl';

import {DownloadOutlineIcon, LinkVariantIcon, CheckIcon} from '@mattermost/compass-icons/components';

import {localizeMessage, copyToClipboard} from 'utils/utils';
import {t} from 'utils/i18n';
import LoadingImagePreview from 'components/loading_image_preview';
import Tooltip from 'components/tooltip';
import OverlayTrigger from 'components/overlay_trigger';
import {getFileMiniPreviewUrl} from 'mattermost-redux/utils/file_utils';

const MIN_IMAGE_SIZE = 48;
const MIN_IMAGE_SIZE_FOR_INTERNAL_BUTTONS = 100;
const MAX_IMAGE_HEIGHT = 350;

// SizeAwareImage is a component used for rendering images where the dimensions of the image are important for
// ensuring that the page is laid out correctly.
export default class SizeAwareImage extends React.PureComponent {
    static propTypes = {

        /*
         * The source URL of the image
         */
        src: PropTypes.string.isRequired,

        /*
         * dimensions object to create empty space required to prevent scroll pop
         */
        dimensions: PropTypes.object,
        fileInfo: PropTypes.object,

        /**
         * fileURL of the original image
         */
        fileURL: PropTypes.string,

        /*
         * Boolean value to pass for showing a loader when image is being loaded
         */
        showLoader: PropTypes.bool,

        /*
         * A callback that is called as soon as the image component has a height value
         */
        onImageLoaded: PropTypes.func,

        /*
         * A callback that is called when image load fails
         */
        onImageLoadFail: PropTypes.func,

        /*
         * Fetch the onClick function
         */
        onClick: PropTypes.func,

        /*
         * css classes that can added to the img as well as parent div on svg for placeholder
         */
        className: PropTypes.string,

        /*
         * Enables the logic of surrounding small images with a bigger container div for better click/tap targeting
         */
        handleSmallImageContainer: PropTypes.bool,

        /**
         * Enables copy URL functionality through a button on image hover.
         */
        enablePublicLink: PropTypes.bool,

        /**
         * Action to fetch public link of an image from server.
         */
        getFilePublicLink: PropTypes.func,
    }

    constructor(props) {
        super(props);
        const {dimensions} = props;

        this.state = {
            loaded: false,
            isSmallImage: this.dimensionsAvailable(dimensions) ? this.isSmallImage(
                dimensions.width, dimensions.height) : false,
            linkCopiedRecently: false,
            linkCopyInProgress: false,
        };

        this.heightTimeout = 0;
    }

    componentDidMount() {
        this.mounted = true;
    }

    componentWillUnmount() {
        this.mounted = false;
    }

    dimensionsAvailable = (dimensions) => {
        return dimensions && dimensions.width && dimensions.height;
    }

    isSmallImage = (width, height) => {
        return width < MIN_IMAGE_SIZE || height < MIN_IMAGE_SIZE;
    }

    handleLoad = (event) => {
        if (this.mounted) {
            const image = event.target;
            const isSmallImage = this.isSmallImage(image.naturalWidth, image.naturalHeight);
            this.setState({
                loaded: true,
                error: false,
                isSmallImage,
                imageWidth: image.naturalWidth,
            }, () => { // Call onImageLoaded prop only after state has already been set
                if (this.props.onImageLoaded && image.naturalHeight) {
                    this.props.onImageLoaded({height: image.naturalHeight, width: image.naturalWidth});
                }
            });
        }
    };

    handleError = () => {
        if (this.mounted) {
            if (this.props.onImageLoadFail) {
                this.props.onImageLoadFail();
            }
            this.setState({error: true});
        }
    };

    handleImageClick = (e) => {
        this.props.onClick?.(e, this.props.src);
    }

    onEnterKeyDown = (e) => {
        if (e.key === 'Enter') {
            this.handleImageClick(e);
        }
    }

    renderImageLoaderIfNeeded = () => {
        if (!this.state.loaded && this.props.showLoader && !this.state.error) {
            return (
                <div style={{position: 'absolute', top: '50%', transform: 'translate(-50%, -50%)', left: '50%'}}>
                    <LoadingImagePreview
                        containerClass={'file__image-loading'}
                    />
                </div>
            );
        }
        return null;
    }

    renderImageWithContainerIfNeeded = () => {
        const {
            fileInfo,
            src,
            fileURL,
            enablePublicLink,
            ...props
        } = this.props;
        Reflect.deleteProperty(props, 'showLoader');
        Reflect.deleteProperty(props, 'onImageLoaded');
        Reflect.deleteProperty(props, 'onImageLoadFail');
        Reflect.deleteProperty(props, 'dimensions');
        Reflect.deleteProperty(props, 'handleSmallImageContainer');
        Reflect.deleteProperty(props, 'enablePublicLink');
        Reflect.deleteProperty(props, 'onClick');
        Reflect.deleteProperty(props, 'getFilePublicLink');

        let ariaLabelImage = localizeMessage('file_attachment.thumbnail', 'file thumbnail');
        if (fileInfo) {
            ariaLabelImage += ` ${fileInfo.name}`.toLowerCase();
        }

        const image = (
            <img
                {...props}
                aria-label={ariaLabelImage}
                tabIndex='0'
                onClick={this.handleImageClick}
                onKeyDown={this.onEnterKeyDown}
                className={
                    this.props.className +
                    (this.props.handleSmallImageContainer &&
                        this.state.isSmallImage ? ' small-image--inside-container' : '')}
                src={src}
                onError={this.handleError}
                onLoad={this.handleLoad}
            />
        );

        // copyLink, download are two buttons overlayed on image preview
        // copyLinkTooltip, downloadTooltip are tooltips for the buttons respectively.
        // if linkCopiedRecently is true, defaultMessage would be 'Copy Link', else 'Copied!'

        const copyLinkTooltip = (
            <Tooltip
                id='copy-link-tooltip'
                className='hidden-xs'
            >
                {this.state.linkCopiedRecently ? (
                    <FormattedMessage
                        id={t('single_image_view.copied_link_tooltip')}
                        defaultMessage={'Copied'}
                    />
                ) : (
                    <FormattedMessage
                        id={t('single_image_view.copy_link_tooltip')}
                        defaultMessage={'Copy link'}
                    />
                )}
            </Tooltip>
        );
        const copyLink = (
            <OverlayTrigger
                className='hidden-xs'
                delayShow={500}
                placement='top'
                overlay={copyLinkTooltip}
                rootClose={true}
            >
                <button
                    className={classNames('style--none', 'size-aware-image__copy_link', {
                        'size-aware-image__copy_link--recently_copied': this.state.linkCopiedRecently,
                    })}
                    aria-label={localizeMessage('single_image_view.copy_link_tooltip', 'Copy link')}
                    onClick={this.copyLinkToAsset}
                >
                    {this.state.linkCopiedRecently ? (
                        <CheckIcon
                            className={'svg-check style--none'}
                            size={20}
                        />
                    ) : (
                        <LinkVariantIcon
                            className={'style--none'}
                            size={20}
                        />
                    )}
                </button>
            </OverlayTrigger>
        );

        const downloadTooltip = (
            <Tooltip
                id='download-preview-tooltip'
                className='hidden-xs'
            >
                <FormattedMessage
                    id='single_image_view.download_tooltip'
                    defaultMessage='Download'
                />
            </Tooltip>
        );

        const download = (
            <OverlayTrigger
                className='hidden-xs'
                delayShow={500}
                placement='top'
                overlay={downloadTooltip}
                rootClose={true}
            >
                <a
                    href={this.isInternalImage ? fileURL : src}
                    className='style--none size-aware-image__download'
                    target='_blank'
                    rel='noopener noreferrer'
                    download={true}
                    role={this.isInternalImage ? 'button' : undefined}
                    aria-label={localizeMessage('single_image_view.download_tooltip', 'Download')}
                >
                    <DownloadOutlineIcon
                        className={'style--none'}
                        size={20}
                    />
                </a>
            </OverlayTrigger>
        );

        if (this.props.handleSmallImageContainer && this.state.isSmallImage) {
            let className = 'small-image__container cursor--pointer a11y--active';
            if (this.state.imageWidth < MIN_IMAGE_SIZE) {
                className += ' small-image__container--min-width';
            }

            // 24 is the offset on a 48px wide image, for every pixel added to the width of the image, it's added to the left offset to buttons
            const wideImageButtonsOffset = (24 + this.state.imageWidth) - MIN_IMAGE_SIZE;

            /**
             * creation of left offset for 2 nested cases
             *  - if a small image with larger width
             *  - if copy link button is enabled
             */
            const modifierCopyButton = enablePublicLink ? 0 : 8;

            // decrease modifier if imageWidth > 100
            const modifierLargerWidth = this.state.imageWidth > MIN_IMAGE_SIZE_FOR_INTERNAL_BUTTONS ? 40 : 0;

            // since there is a max-width constraint on images, a max-left clause follows.
            const leftStyle = this.state.imageWidth > MIN_IMAGE_SIZE ? {
                left: `min(${wideImageButtonsOffset + (modifierCopyButton - modifierLargerWidth)}px, calc(100% - ${31 - (modifierCopyButton - modifierLargerWidth)}px)`,
            } : {};

            const wideSmallImageStyle = this.state.imageWidth > MIN_IMAGE_SIZE ? {
                width: this.state.imageWidth + 2, // 2px to account for the border
            } : {};
            return (
                <div
                    className='small-image-utility-buttons-wrapper'
                >
                    <div
                        onClick={this.handleImageClick}
                        className={classNames(className)}
                        style={wideSmallImageStyle}
                    >
                        {image}
                    </div>
                    <span
                        className={classNames('image-preview-utility-buttons-container', 'image-preview-utility-buttons-container--small-image', {
                            'image-preview-utility-buttons-container--small-image-no-copy-button': !enablePublicLink,
                        })}
                        style={leftStyle}
                    >
                        {enablePublicLink && copyLink}
                        {download}
                    </span>
                </div>
            );
        }

        // handling external small images (OR) handling all large internal / large external images
        const utilityButtonsWrapper = this.state.isSmallImage && !this.isInternalImage ? null :
            (
                <span
                    className={classNames('image-preview-utility-buttons-container', {

                        // cases for when image isn't a small image but width is < 100px
                        'image-preview-utility-buttons-container--small-image': this.state.imageWidth < MIN_IMAGE_SIZE_FOR_INTERNAL_BUTTONS,
                        'image-preview-utility-buttons-container--small-image-no-copy-button': (!enablePublicLink || !this.isInternalImage) && this.state.imageWidth < MIN_IMAGE_SIZE_FOR_INTERNAL_BUTTONS,
                    })}
                >
                    {(enablePublicLink || !this.isInternalImage) && copyLink}
                    {download}
                </span>
            );
        return (
            <figure className={classNames('image-loaded-container')}>
                {image}
                {utilityButtonsWrapper}
            </figure>
        );
    }

    renderImageOrFallback = () => {
        const {
            dimensions,
            fileInfo,
        } = this.props;

        let ariaLabelImage = localizeMessage('file_attachment.thumbnail', 'file thumbnail');
        if (fileInfo) {
            ariaLabelImage += ` ${fileInfo.name}`.toLowerCase();
        }

        let fallback;

        if (this.dimensionsAvailable(dimensions) && !this.state.loaded) {
            const ratio = dimensions.height > MAX_IMAGE_HEIGHT ? MAX_IMAGE_HEIGHT / dimensions.height : 1;
            const height = dimensions.height * ratio;
            const width = dimensions.width * ratio;

            const miniPreview = getFileMiniPreviewUrl(fileInfo);

            if (miniPreview) {
                fallback = (
                    <div
                        className={`image-loading__container ${this.props.className}`}
                        style={{maxWidth: dimensions.width}}
                    >
                        <img
                            aria-label={ariaLabelImage}
                            className={this.props.className}
                            src={miniPreview}
                            tabIndex='0'
                            height={height}
                            width={width}
                        />
                    </div>
                );
            } else {
                fallback = (
                    <div
                        className={`image-loading__container ${this.props.className}`}
                        style={{maxWidth: width}}
                    >
                        {this.renderImageLoaderIfNeeded()}
                        <svg
                            xmlns='http://www.w3.org/2000/svg'
                            viewBox={`0 0 ${width} ${height}`}
                            style={{maxHeight: height, maxWidth: width, verticalAlign: 'middle'}}
                        />
                    </div>
                );
            }
        }

        const shouldShowImg = !this.dimensionsAvailable(dimensions) || this.state.loaded;

        return (
            <React.Fragment>
                {fallback}
                <div
                    className='file-preview__button'
                    style={{display: shouldShowImg ? 'inline' : 'none'}}
                >
                    {this.renderImageWithContainerIfNeeded()}
                </div>
            </React.Fragment>
        );
    }

    isInternalImage = (this.props.fileInfo !== undefined) && (this.props.fileInfo !== null);

    startCopyTimer = () => {
        // set linkCopiedRecently to true, and reset to false after 1.5 seconds
        this.setState({linkCopiedRecently: true});
        if (this.timeout) {
            clearTimeout(this.timeout);
        }
        this.timeout = setTimeout(() => {
            this.setState({linkCopiedRecently: false, linkCopyInProgress: false});
        }, 1500);
    }

    copyLinkToAsset = () => {
        // if linkCopyInProgress is true return
        if (this.state.linkCopyInProgress !== true) {
            // set linkCopyInProgress to true to prevent multiple api calls
            this.setState({linkCopyInProgress: true});

            // check if image is external, if not copy this.props.src
            if (!this.isInternalImage) {
                copyToClipboard(this.props.src ?? '');
                this.startCopyTimer();
                return;
            }

            // copying public link to clipboard
            this.props.getFilePublicLink().then((data) => {
                const fileURL = data.data.link;
                copyToClipboard(fileURL ?? '');
                this.startCopyTimer();
            });
        }
    }

    render() {
        return (
            this.renderImageOrFallback()
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {PureComponent, ReactNode} from 'react';

import LoadingWrapper from 'components/widgets/loading/loading_wrapper';

type Props = {
    children?: ReactNode;
    spinning: boolean;
    spinningText: ReactNode;
    onClick?: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;
}

export default class SpinnerButton extends PureComponent<Props & React.ButtonHTMLAttributes<HTMLButtonElement>> {
    public static defaultProps: Partial<Props> = {
        spinning: false,
    }

    public render(): JSX.Element {
        const {spinning, spinningText, children, ...props} = this.props; // eslint-disable-line no-use-before-define

        return (
            <button
                disabled={spinning}
                {...props}
            >
                <LoadingWrapper
                    loading={spinning}
                    text={spinningText}
                >
                    {children}
                </LoadingWrapper>
            </button>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {CSSProperties} from 'react';
import {useIntl} from 'react-intl';

export default function StatusAwayAvatarIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='13px'
                height='13px'
                viewBox='0 0 12 12'
                style={style}
                role='img'
                aria-label={formatMessage({id: 'mobile.set_status.away.icon', defaultMessage: 'Away Icon'})}
            >
                <path
                    className='away--icon'
                    d='M9.081,5.712C9.267,5.712 9.417,5.863 9.417,6.048L9.417,9.086L11.864,10.499C12.025,10.592 12.08,10.797 11.987,10.958L11.482,11.832C11.39,11.993 11.184,12.048 11.023,11.955L7.904,10.154C7.788,10.087 7.727,9.961 7.737,9.836C7.736,9.827 7.736,9.818 7.736,9.809L7.736,6.048C7.736,5.863 7.886,5.712 8.072,5.712L9.081,5.712ZM4.812,11.513L4.605,11.513C2.325,11.41 0.253,10.374 0.046,9.027C-0.058,8.923 0.046,8.509 0.046,8.405C0.15,7.576 0.357,6.437 0.771,5.815C0.978,5.401 2.015,5.297 2.015,5.297C2.015,5.297 2.015,7.369 4.605,7.369L5.019,7.369C4.915,7.784 4.812,8.198 4.812,8.612C4.812,9.648 5.226,10.581 5.848,11.41C5.537,11.513 5.123,11.513 4.812,11.513ZM4.605,0.117C6.034,0.117 7.195,1.277 7.195,2.707C7.195,4.136 6.034,5.297 4.605,5.297C3.175,5.297 2.015,4.136 2.015,2.707C2.015,1.277 3.175,0.117 4.605,0.117Z'
                />
            </svg>
        </span>
    );
}

const style: CSSProperties = {
    fillRule: 'evenodd',
    clipRule: 'evenodd',
    strokeLinejoin: 'round',
    strokeMiterlimit: 1.41421,
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {CSSProperties} from 'react';
import {useIntl} from 'react-intl';

export default function StatusAwayIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='100%'
                height='100%'
                viewBox='0 0 20 20'
                style={style}
                role='img'
                aria-label={formatMessage({id: 'mobile.set_status.away.icon', defaultMessage: 'Away Icon'})}
            >
                <path
                    className='away--icon'
                    d='M10,0C15.519,0 20,4.481 20,10C20,15.519 15.519,20 10,20C4.481,20 0,15.519 0,10C0,4.481 4.481,0 10,0ZM10.27,3C10.949,3 11.5,3.586 11.5,4.307L11.5,9.379L15.002,12.881C15.492,13.37 15.499,14.158 15.019,14.638L14.638,15.019C14.158,15.499 13.37,15.492 12.881,15.002L8.887,11.008C8.739,10.861 8.636,10.686 8.576,10.501C8.528,10.402 8.5,10.299 8.5,10.193L8.5,4.307C8.5,3.586 9.051,3 9.73,3L10.27,3Z'
                />
            </svg>
        </span>
    );
}

const style: CSSProperties = {
    fillRule: 'evenodd',
    clipRule: 'evenodd',
    strokeLinejoin: 'round',
    strokeMiterlimit: 1.41421,
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function StatusDndAvatarIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                x='0px'
                y='0px'
                width='13px'
                height='13px'
                viewBox='-299 391 12 12'
                enableBackground='new -299 391 12 12'
                role='img'
                aria-label={formatMessage({id: 'mobile.set_status.dnd.icon', defaultMessage: 'Do Not Disturb Icon'})}
            >
                <g>
                    <ellipse
                        className='dnd--icon'
                        cx='-294.6'
                        cy='394'
                        rx='2.5'
                        ry='2.5'
                    />
                    <path
                        className='dnd--icon'
                        d='M-293.8,399.4c0-0.4,0.1-0.7,0.2-1c-0.3,0.1-0.6,0.2-1,0.2c-2.5,0-2.5-2-2.5-2s-1,0.1-1.2,0.5c-0.4,0.6-0.6,1.7-0.7,2.5 c0,0.1-0.1,0.5,0,0.6c0.2,1.3,2.2,2.3,4.4,2.4c0,0,0.1,0,0.1,0c0,0,0.1,0,0.1,0c0.7,0,1.4-0.1,2-0.3 C-293.3,401.5-293.8,400.5-293.8,399.4z'
                    />
                </g>
                <path
                    className='dnd--icon'
                    d='M-287,400c0,0.1-0.1,0.1-0.1,0.1l-4.9,0c-0.1,0-0.1-0.1-0.1-0.1v-1.6c0-0.1,0.1-0.1,0.1-0.1l4.9,0c0.1,0,0.1,0.1,0.1,0.1 V400z'
                />
            </svg>
        </span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {CSSProperties} from 'react';
import {useIntl} from 'react-intl';

export default function StatusDndIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='100%'
                height='100%'
                viewBox='0 0 20 20'
                style={style}
                role='img'
                aria-label={formatMessage({id: 'mobile.set_status.dnd.icon', defaultMessage: 'Do Not Disturb Icon'})}
            >
                <path
                    className='dnd--icon'
                    d='M10,0c5.519,0 10,4.481 10,10c0,5.519 -4.481,10 -10,10c-5.519,0 -10,-4.481 -10,-10c0,-5.519 4.481,-10 10,-10Zm5.25,8.5l-10.5,0c-0.414,0 -0.75,0.336 -0.75,0.75l0,1.5c0,0.414 0.336,0.75 0.75,0.75l10.5,0c0.414,0 0.75,-0.336 0.75,-0.75l0,-1.5c0,-0.414 -0.336,-0.75 -0.75,-0.75Z'
                />
            </svg>
        </span>
    );
}

const style: CSSProperties = {
    fillRule: 'evenodd',
    clipRule: 'evenodd',
    strokeLinejoin: 'round',
    strokeMiterlimit: 1.41421,
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function StatusOfflineAvatarIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                x='0px'
                y='0px'
                width='13px'
                height='13px'
                viewBox='-299 391 12 12'
                enableBackground='new -299 391 12 12'
                role='img'
                aria-label={formatMessage({id: 'mobile.set_status.offline.icon', defaultMessage: 'Offline Icon'})}
            >
                <g>
                    <g>
                        <ellipse
                            className='offline--icon'
                            cx='-294.5'
                            cy='394'
                            rx='2.5'
                            ry='2.5'
                        />
                        <path
                            className='offline--icon'
                            d='M-294.3,399.7c0-0.4,0.1-0.8,0.2-1.2c-0.1,0-0.2,0-0.4,0c-2.5,0-2.5-2-2.5-2s-1,0.1-1.2,0.5c-0.4,0.6-0.6,1.7-0.7,2.5 c0,0.1-0.1,0.5,0,0.6c0.2,1.3,2.2,2.3,4.4,2.4h0.1h0.1c0.3,0,0.7,0,1-0.1C-293.9,401.6-294.3,400.7-294.3,399.7z'
                        />
                    </g>
                </g>
                <g>
                    <path
                        className='offline--icon'
                        d='M-288.9,399.4l1.8-1.8c0.1-0.1,0.1-0.3,0-0.3l-0.7-0.7c-0.1-0.1-0.3-0.1-0.3,0l-1.8,1.8l-1.8-1.8c-0.1-0.1-0.3-0.1-0.3,0 l-0.7,0.7c-0.1,0.1-0.1,0.3,0,0.3l1.8,1.8l-1.8,1.8c-0.1,0.1-0.1,0.3,0,0.3l0.7,0.7c0.1,0.1,0.3,0.1,0.3,0l1.8-1.8l1.8,1.8 c0.1,0.1,0.3,0.1,0.3,0l0.7-0.7c0.1-0.1,0.1-0.3,0-0.3L-288.9,399.4z'
                    />
                </g>
            </svg>
        </span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {CSSProperties} from 'react';
import {useIntl} from 'react-intl';

export default function StatusOfflineIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='100%'
                height='100%'
                className='offline--icon'
                viewBox='0 0 20 20'
                style={style}
                role='img'
                aria-label={formatMessage({id: 'mobile.set_status.offline.icon', defaultMessage: 'Offline Icon'})}
            >
                <path d='M10,0c5.519,0 10,4.481 10,10c0,5.519 -4.481,10 -10,10c-5.519,0 -10,-4.481 -10,-10c0,-5.519 4.481,-10 10,-10Zm0,2c4.415,0 8,3.585 8,8c0,4.415 -3.585,8 -8,8c-4.415,0 -8,-3.585 -8,-8c0,-4.415 3.585,-8 8,-8Z'/>
            </svg>
        </span>
    );
}

const style: CSSProperties = {
    fillRule: 'evenodd',
    clipRule: 'evenodd',
    strokeLinejoin: 'round',
    strokeMiterlimit: 1.41421,
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function StatusOnlineAvatarIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                x='0px'
                y='0px'
                width='13px'
                height='13px'
                viewBox='-243 245 12 12'
                enableBackground='new -243 245 12 12'
                role='img'
                aria-label={formatMessage({id: 'mobile.set_status.online.icon', defaultMessage: 'Online Icon'})}
            >
                <g>
                    <path
                        className='online--icon'
                        d='M-236,250.5C-236,250.5-236,250.5-236,250.5C-236,250.5-236,250.5-236,250.5C-236,250.5-236,250.5-236,250.5z'
                    />
                    <ellipse
                        className='online--icon'
                        cx='-238.5'
                        cy='248'
                        rx='2.5'
                        ry='2.5'
                    />
                </g>
                <path
                    className='online--icon'
                    d='M-238.9,253.8c0-0.4,0.1-0.9,0.2-1.3c-2.2-0.2-2.2-2-2.2-2s-1,0.1-1.2,0.5c-0.4,0.6-0.6,1.7-0.7,2.5c0,0.1-0.1,0.5,0,0.6 c0.2,1.3,2.2,2.3,4.4,2.4c0,0,0.1,0,0.1,0c0,0,0.1,0,0.1,0c0,0,0.1,0,0.1,0C-238.7,255.7-238.9,254.8-238.9,253.8z'
                />
                <g>
                    <g>
                        <path
                            className='online--icon'
                            d='M-232.3,250.1l1.3,1.3c0,0,0,0.1,0,0.1l-4.1,4.1c0,0,0,0-0.1,0c0,0,0,0,0,0l-2.7-2.7c0,0,0-0.1,0-0.1l1.2-1.2 c0,0,0.1,0,0.1,0l1.4,1.4l2.9-2.9C-232.4,250.1-232.3,250.1-232.3,250.1z'
                        />
                    </g>
                </g>
            </svg>
        </span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {CSSProperties} from 'react';
import {useIntl} from 'react-intl';

export default function StatusOnlineIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='100%'
                height='100%'
                viewBox='0 0 20 20'
                style={style}
                role='img'
                aria-label={formatMessage({id: 'mobile.set_status.online.icon', defaultMessage: 'Online Icon'})}
            >
                <path
                    className='online--icon'
                    d='M10,0c5.519,0 10,4.481 10,10c0,5.519 -4.481,10 -10,10c-5.519,0 -10,-4.481 -10,-10c0,-5.519 4.481,-10 10,-10Zm6.19,7.18c0,0.208 -0.075,0.384 -0.224,0.53l-5.782,5.64l-1.087,1.059c-0.149,0.146 -0.33,0.218 -0.543,0.218c-0.213,0 -0.394,-0.072 -0.543,-0.218l-1.086,-1.059l-2.891,-2.82c-0.149,-0.146 -0.224,-0.322 -0.224,-0.53c0,-0.208 0.075,-0.384 0.224,-0.53l1.086,-1.059c0.149,-0.146 0.33,-0.218 0.543,-0.218c0.213,0 0.394,0.072 0.543,0.218l2.348,2.298l5.24,-5.118c0.149,-0.146 0.33,-0.218 0.543,-0.218c0.213,0 0.394,0.072 0.543,0.218l1.086,1.059c0.149,0.146 0.224,0.322 0.224,0.53Z'
                />
            </svg>
        </span>
    );
}

const style: CSSProperties = {
    fillRule: 'evenodd',
    clipRule: 'evenodd',
    strokeLinejoin: 'round',
    strokeMiterlimit: 1.41421,
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import StatusAwayAvatarIcon from 'components/widgets/icons/status_away_avatar_icon';
import StatusAwayIcon from 'components/widgets/icons/status_away_icon';
import StatusDndAvatarIcon from 'components/widgets/icons/status_dnd_avatar_icon';
import StatusDndIcon from 'components/widgets/icons/status_dnd_icon';
import StatusOfflineAvatarIcon from 'components/widgets/icons/status_offline_avatar_icon';
import StatusOfflineIcon from 'components/widgets/icons/status_offline_icon';
import StatusOnlineAvatarIcon from 'components/widgets/icons/status_online_avatar_icon';
import StatusOnlineIcon from 'components/widgets/icons/status_online_icon';

type Props = {
    button?: boolean;
    status?: string;
    className?: string;
    type?: string;
}

export default class StatusIcon extends React.PureComponent<Props> {
    static defaultProps = {
        className: '',
        button: false,
    };

    render() {
        const {button, status, type} = this.props;

        if (!status) {
            return null;
        }

        let className = 'status ' + this.props.className;

        if (button) {
            className = this.props.className || '';
        }

        let IconComponent: React.ComponentType<{className?: string}> | string;
        const iconComponentProps = {className};
        if (type === 'avatar') {
            if (status === 'online') {
                IconComponent = StatusOnlineAvatarIcon;
            } else if (status === 'away') {
                IconComponent = StatusAwayAvatarIcon;
            } else if (status === 'dnd') {
                IconComponent = StatusDndAvatarIcon;
            } else {
                IconComponent = StatusOfflineAvatarIcon;
            }
        } else if (status === 'online') {
            IconComponent = StatusOnlineIcon;
        } else if (status === 'away') {
            IconComponent = StatusAwayIcon;
        } else if (status === 'dnd') {
            IconComponent = StatusDndIcon;
        } else {
            IconComponent = StatusOfflineIcon;
        }

        return <IconComponent {...iconComponentProps}/>;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/* eslint-disable max-lines */

import {Constants} from 'utils/constants';

import {
    AppsTypes,
    AppCallRequest,
    AppBinding,
    AppCall,
    AppField,
    DoAppCallResult,
    AppLookupResponse,
    AppContext,
    AppForm,
    AppCallValues,
    AppSelectOption,
    AutocompleteSuggestion,
    AutocompleteStaticSelect,
    Channel,
    Store,

    AppBindingLocations,
    AppCallResponseTypes,
    AppFieldTypes,
    makeAppBindingsSelector,
    selectChannel,
    getChannel,
    getCurrentTeamId,
    doAppFetchForm,
    doAppLookup,
    getStore,
    EXECUTE_CURRENT_COMMAND_ITEM_ID,
    COMMAND_SUGGESTION_ERROR,
    getExecuteSuggestion,
    createCallRequest,
    selectUserByUsername,
    getUserByUsername,
    selectUser,
    getUser,
    getChannelByNameAndTeamName,
    getCurrentTeam,
    selectChannelByName,
    errorMessage as parserErrorMessage,
    filterEmptyOptions,
    autocompleteUsersInChannel,
    autocompleteChannels,
    getOpenInModalSuggestion,
    OPEN_COMMAND_IN_MODAL_ITEM_ID,
    getChannelSuggestions,
    getUserSuggestions,
    inTextMentionSuggestions,
    ExtendedAutocompleteSuggestion,
    getAppCommandForm,
    getAppRHSCommandForm,
    makeRHSAppBindingSelector,
} from './app_command_parser_dependencies';

export enum ParseState {
    Start = 'Start',
    Command = 'Command',
    EndCommand = 'EndCommand',
    CommandSeparator = 'CommandSeparator',
    StartParameter = 'StartParameter',
    ParameterSeparator = 'ParameterSeparator',
    Flag1 = 'Flag1',
    Flag = 'Flag',
    FlagValueSeparator = 'FlagValueSeparator',
    StartValue = 'StartValue',
    NonspaceValue = 'NonspaceValue',
    QuotedValue = 'QuotedValue',
    TickValue = 'TickValue',
    EndValue = 'EndValue',
    EndQuotedValue = 'EndQuotedValue',
    EndTickedValue = 'EndTickedValue',
    Error = 'Error',
    MultiselectStart = 'MultiselectStart',
    MultiselectStartValue = 'MultiselectStartValue',
    MultiselectNonspaceValue = 'MultiselectNonspaceValue',
    MultiselectQuotedValue = 'MultiselectQuotedValue',
    MultiselectTickValue = 'MultiselectTickValue',
    MultiselectEndValue = 'MultiselectEndValue',
    MultiselectEndQuotedValue = 'MultiselectEndQuotedValue',
    MultiselectEndTickedValue = 'MultiselectEndTickedValue',
    MultiselectValueSeparator = 'MultiselectValueSeparator',
    MultiselectNextValue = 'MultiselectNextValue',
    Rest = 'Rest',
}

interface FormsCache {
    getSubmittableForm: (location: string, binding: AppBinding) => Promise<{form?: AppForm; error?: string} | undefined>;
}

interface Intl {
    formatMessage(config: {id: string; defaultMessage: string}, values?: {[name: string]: any}): string;
}

const getCommandBindings = makeAppBindingsSelector(AppBindingLocations.COMMAND);
const getRHSCommandBindings = makeRHSAppBindingSelector(AppBindingLocations.COMMAND);

export class ParsedCommand {
    state = ParseState.Start;
    command: string;
    i = 0;
    incomplete = '';
    incompleteStart = 0;
    binding: AppBinding | undefined;
    resolvedForm: AppForm | undefined;
    formsCache: FormsCache;
    field: AppField | undefined;
    position = 0;
    values: {[name: string]: string | string[]} = {};
    location = '';
    error = '';
    intl: Intl;

    constructor(command: string, formsCache: FormsCache, intl: any) {
        this.command = command;
        this.formsCache = formsCache || [];
        this.intl = intl;
    }

    private asError = (message: string): ParsedCommand => {
        this.state = ParseState.Error;
        this.error = message;
        return this;
    };

    // matchBinding finds the closest matching command binding.
    public matchBinding = async (commandBindings: AppBinding[], autocompleteMode = false): Promise<ParsedCommand> => {
        if (commandBindings.length === 0) {
            return this.asError(this.intl.formatMessage({
                id: 'apps.error.parser.no_bindings',
                defaultMessage: 'No command bindings.',
            }));
        }
        let bindings = commandBindings;

        let done = false;
        while (!done) {
            let c = '';
            if (this.i < this.command.length) {
                c = this.command[this.i];
            }

            switch (this.state) {
            case ParseState.Start: {
                if (c !== '/') {
                    return this.asError(this.intl.formatMessage({
                        id: 'apps.error.parser.no_slash_start',
                        defaultMessage: 'Command must start with a `/`.',
                    }));
                }
                this.i++;
                this.incomplete = '';
                this.incompleteStart = this.i;
                this.state = ParseState.Command;
                break;
            }

            case ParseState.Command: {
                switch (c) {
                case '': {
                    if (autocompleteMode) {
                        // Finish in the Command state, 'incomplete' will have the query string
                        done = true;
                    } else {
                        this.state = ParseState.EndCommand;
                    }
                    break;
                }
                case ' ':
                case '\t': {
                    this.state = ParseState.EndCommand;
                    break;
                }
                default:
                    this.incomplete += c;
                    this.i++;
                    break;
                }
                break;
            }

            case ParseState.EndCommand: {
                const binding = bindings.find((b: AppBinding) => b.label.toLowerCase() === this.incomplete.toLowerCase());
                if (!binding) {
                    // gone as far as we could, this token doesn't match a sub-command.
                    // return the state from the last matching binding
                    done = true;
                    break;
                }
                this.binding = binding;
                this.location += '/' + binding.label;
                bindings = binding.bindings || [];
                this.state = ParseState.CommandSeparator;
                break;
            }

            case ParseState.CommandSeparator: {
                if (c === '') {
                    done = true;
                }

                switch (c) {
                case ' ':
                case '\t': {
                    this.i++;
                    break;
                }
                default: {
                    this.incomplete = '';
                    this.incompleteStart = this.i;
                    this.state = ParseState.Command;
                    break;
                }
                }
                break;
            }

            default: {
                return this.asError(this.intl.formatMessage({
                    id: 'apps.error.parser.unexpected_state',
                    defaultMessage: 'Unreachable: Unexpected state in matchBinding: `{state}`.',
                }, {
                    state: this.state,
                }));
            }
            }
        }

        if (!this.binding) {
            if (autocompleteMode) {
                return this;
            }

            return this.asError(this.intl.formatMessage({
                id: 'apps.error.parser.no_match',
                defaultMessage: '`{command}`: No matching command found in this workspace.',
            }, {
                command: this.command,
            }));
        }

        if (!autocompleteMode && this.binding.bindings?.length) {
            return this.asError(this.intl.formatMessage({
                id: 'apps.error.parser.execute_non_leaf',
                defaultMessage: 'You must select a subcommand.',
            }));
        }

        if (!this.binding.bindings?.length) {
            // No more sub-bindings, must be a submit or a form.
            if (this.binding.submit && !this.binding.form) {
                // Submit, no form in the binding, construct an empty form for
                // submission.
                this.resolvedForm = {
                    submit: this.binding.submit,
                };
            } else if (this.binding.form && !this.binding.submit) {
                // Form, no submit in the binding. Refresh the form from the
                // source/cache as needed.
                const form = this.binding.form;
                if (!form.submit) {
                    const fetched = await this.formsCache.getSubmittableForm(this.location, this.binding);
                    if (fetched?.error) {
                        return this.asError(fetched.error);
                    }
                    this.resolvedForm = fetched?.form;
                }
                this.resolvedForm = this.binding?.form;
            } else {
                return this.asError(this.intl.formatMessage({
                    id: 'apps.error.parser',
                    defaultMessage: 'Parsing error: {error}',
                }, {
                    error: 'unreachable: invalid binding, neither or both Submit and Form',
                }));
            }
        }
        return this;
    };

    // parseForm parses the rest of the command using the previously matched form.
    public parseForm = (autocompleteMode = false): ParsedCommand => {
        if (this.state === ParseState.Error || !this.resolvedForm) {
            return this;
        }

        let fields: AppField[] = [];
        if (this.resolvedForm.fields) {
            fields = this.resolvedForm.fields;
        }

        fields = fields.filter((f) => f.type !== AppFieldTypes.MARKDOWN && !f.readonly);
        this.state = ParseState.StartParameter;
        this.i = this.incompleteStart || 0;
        let flagEqualsUsed = false;
        let escaped = false;

        // eslint-disable-next-line no-constant-condition
        while (true) {
            let c = '';
            if (this.i < this.command.length) {
                c = this.command[this.i];
            }

            switch (this.state) {
            case ParseState.StartParameter: {
                switch (c) {
                case '':
                    return this;
                case '-': {
                    // Named parameter (aka Flag). Flag1 consumes the optional second '-'.
                    this.state = ParseState.Flag1;
                    this.i++;
                    break;
                }
                case '': {
                    // Em dash, introduced when two '-' are set in iOS. Will be considered as such.
                    this.state = ParseState.Flag;
                    this.i++;
                    this.incomplete = '';
                    this.incompleteStart = this.i;
                    flagEqualsUsed = false;
                    break;
                }
                default: {
                    // Positional parameter.
                    this.position++;
                    // eslint-disable-next-line no-loop-func
                    let field = fields.find((f: AppField) => f.position === this.position);
                    if (!field) {
                        field = fields.find((f) => f.position === -1 && f.type === AppFieldTypes.TEXT);
                        if (!field || this.values[field.name]) {
                            return this.asError(this.intl.formatMessage({
                                id: 'apps.error.parser.no_argument_pos_x',
                                defaultMessage: 'Unable to identify argument.',
                            }));
                        }
                        this.incompleteStart = this.i;
                        this.incomplete = '';
                        this.field = field;
                        this.state = ParseState.Rest;
                        break;
                    }
                    this.field = field;
                    this.state = ParseState.StartValue;
                    break;
                }
                }
                break;
            }

            case ParseState.Rest: {
                if (!this.field) {
                    return this.asError(this.intl.formatMessage({
                        id: 'apps.error.parser.missing_field_value',
                        defaultMessage: 'Field value is missing.',
                    }));
                }

                if (autocompleteMode && c === '') {
                    return this;
                }

                if (c === '') {
                    this.values[this.field.name] = this.incomplete;
                    return this;
                }

                this.i++;
                this.incomplete += c;
                break;
            }

            case ParseState.ParameterSeparator: {
                this.incompleteStart = this.i;
                switch (c) {
                case '':
                    this.state = ParseState.StartParameter;
                    return this;
                case ' ':
                case '\t': {
                    this.i++;
                    break;
                }
                default:
                    this.state = ParseState.StartParameter;
                    break;
                }
                break;
            }

            case ParseState.Flag1: {
                // consume the optional second '-'
                if (c === '-') {
                    this.i++;
                }
                this.state = ParseState.Flag;
                this.incomplete = '';
                this.incompleteStart = this.i;
                flagEqualsUsed = false;
                break;
            }

            case ParseState.Flag: {
                if (c === '' && autocompleteMode) {
                    return this;
                }

                switch (c) {
                case '':
                case ' ':
                case '\t':
                case '=': {
                    const field = fields.find((f) => f.label?.toLowerCase() === this.incomplete.toLowerCase());
                    if (!field) {
                        return this.asError(this.intl.formatMessage({
                            id: 'apps.error.parser.unexpected_flag',
                            defaultMessage: 'Command does not accept flag `{flagName}`.',
                        }, {
                            flagName: this.incomplete,
                        }));
                    }
                    this.state = ParseState.FlagValueSeparator;
                    this.field = field;
                    this.incomplete = '';
                    break;
                }
                default: {
                    this.incomplete += c;
                    this.i++;
                    break;
                }
                }
                break;
            }

            case ParseState.FlagValueSeparator: {
                this.incompleteStart = this.i;
                switch (c) {
                case '': {
                    if (autocompleteMode) {
                        return this;
                    }
                    this.state = ParseState.StartValue;
                    break;
                }
                case ' ':
                case '\t': {
                    this.i++;
                    break;
                }
                case '=': {
                    if (flagEqualsUsed) {
                        return this.asError(this.intl.formatMessage({
                            id: 'apps.error.parser.multiple_equal',
                            defaultMessage: 'Multiple `=` signs are not allowed.',
                        }));
                    }
                    flagEqualsUsed = true;
                    this.i++;
                    break;
                }
                default: {
                    this.state = ParseState.StartValue;
                }
                }
                break;
            }

            case ParseState.StartValue: {
                this.incomplete = '';
                this.incompleteStart = this.i;
                switch (c) {
                case '"': {
                    this.state = ParseState.QuotedValue;
                    this.i++;
                    break;
                }
                case '`': {
                    this.state = ParseState.TickValue;
                    this.i++;
                    break;
                }
                case ' ':
                case '\t':
                    return this.asError(this.intl.formatMessage({
                        id: 'apps.error.parser.unexpected_whitespace',
                        defaultMessage: 'Unreachable: Unexpected whitespace.',
                    }));
                case '[':
                    if (!this.field?.multiselect) {
                        return this.asError(this.intl.formatMessage({
                            id: 'apps.error.parser.unexpected_squared_bracket',
                            defaultMessage: 'Unexpected list opening.',
                        }));
                    }
                    this.state = ParseState.MultiselectStart;
                    this.i++;
                    break;
                default: {
                    this.state = ParseState.NonspaceValue;
                    break;
                }
                }
                break;
            }

            case ParseState.NonspaceValue: {
                switch (c) {
                case '':
                case ' ':
                case '\t': {
                    this.state = ParseState.EndValue;
                    break;
                }
                default: {
                    this.incomplete += c;
                    this.i++;
                    break;
                }
                }
                break;
            }

            case ParseState.QuotedValue: {
                switch (c) {
                case '': {
                    if (!autocompleteMode) {
                        return this.asError(this.intl.formatMessage({
                            id: 'apps.error.parser.missing_quote',
                            defaultMessage: 'Matching double quote expected before end of input.',
                        }));
                    }
                    return this;
                }
                case '"': {
                    if (this.incompleteStart === this.i - 1) {
                        return this.asError(this.intl.formatMessage({
                            id: 'apps.error.parser.empty_value',
                            defaultMessage: 'Empty values are not allowed.',
                        }));
                    }
                    this.i++;
                    this.state = ParseState.EndQuotedValue;
                    break;
                }
                case '\\': {
                    escaped = true;
                    this.i++;
                    break;
                }
                default: {
                    this.incomplete += c;
                    this.i++;
                    if (escaped) {
                        //TODO: handle \n, \t, other escaped chars
                        escaped = false;
                    }
                    break;
                }
                }
                break;
            }

            case ParseState.TickValue: {
                switch (c) {
                case '': {
                    if (!autocompleteMode) {
                        return this.asError(this.intl.formatMessage({
                            id: 'apps.error.parser.missing_tick',
                            defaultMessage: 'Matching tick quote expected before end of input.',
                        }));
                    }
                    return this;
                }
                case '`': {
                    if (this.incompleteStart === this.i - 1) {
                        return this.asError(this.intl.formatMessage({
                            id: 'apps.error.parser.empty_value',
                            defaultMessage: 'Empty values are not allowed.',
                        }));
                    }
                    this.i++;
                    this.state = ParseState.EndTickedValue;
                    break;
                }
                default: {
                    this.incomplete += c;
                    this.i++;
                    break;
                }
                }
                break;
            }

            case ParseState.EndTickedValue:
            case ParseState.EndQuotedValue:
            case ParseState.EndValue: {
                if (!this.field) {
                    return this.asError(this.intl.formatMessage({
                        id: 'apps.error.parser.missing_field_value',
                        defaultMessage: 'Field value is missing.',
                    }));
                }

                // special handling for optional BOOL values ('--boolflag true'
                // vs '--boolflag next-positional' vs '--boolflag
                // --next-flag...')
                if (this.field.type === AppFieldTypes.BOOL &&
                    ((autocompleteMode && !'true'.startsWith(this.incomplete) && !'false'.startsWith(this.incomplete)) ||
                    (!autocompleteMode && this.incomplete !== 'true' && this.incomplete !== 'false'))) {
                    // reset back where the value started, and treat as a new parameter
                    this.i = this.incompleteStart;
                    this.values[this.field.name] = 'true';
                    this.state = ParseState.StartParameter;
                } else {
                    if (autocompleteMode && c === '') {
                        return this;
                    }
                    this.values[this.field.name] = this.incomplete;
                    this.incomplete = '';
                    this.incompleteStart = this.i;
                    if (c === '') {
                        return this;
                    }
                    this.state = ParseState.ParameterSeparator;
                }
                break;
            }

            case ParseState.MultiselectStart:
                if (!this.field) {
                    return this.asError(this.intl.formatMessage({
                        id: 'apps.error.parser.missing_field_value',
                        defaultMessage: 'Field value is missing.',
                    }));
                }

                this.values![this.field.name] = [];
                switch (c) {
                case ' ':
                case '\t':
                    this.i++;
                    break;
                case ']':
                    this.i++;
                    this.state = ParseState.ParameterSeparator;
                    break;
                default:
                    this.state = ParseState.MultiselectStartValue;
                    break;
                }
                break;

            case ParseState.MultiselectStartValue:
                this.incomplete = '';
                this.incompleteStart = this.i;
                switch (c) {
                case '':
                    if (!autocompleteMode) {
                        return this.asError(this.intl.formatMessage({
                            id: 'apps.error.parser.missing_list_end',
                            defaultMessage: 'Expected list closing token.',
                        }));
                    }
                    return this;
                case '"': {
                    this.state = ParseState.MultiselectQuotedValue;
                    this.i++;
                    break;
                }
                case '`': {
                    this.state = ParseState.MultiselectTickValue;
                    this.i++;
                    break;
                }
                case ' ':
                case '\t':
                    return this.asError(this.intl.formatMessage({
                        id: 'apps.error.parser.unexpected_whitespace',
                        defaultMessage: 'Unreachable: Unexpected whitespace.',
                    }));
                case ',':
                    return this.asError(this.intl.formatMessage({
                        id: 'apps.error.parser.unexpected_comma',
                        defaultMessage: 'Unexpected comma.',
                    }));
                default: {
                    this.state = ParseState.MultiselectNonspaceValue;
                    break;
                }
                }
                break;

            case ParseState.MultiselectNonspaceValue: {
                switch (c) {
                case '':
                case ' ':
                case '\t':
                case ',':
                case ']': {
                    this.state = ParseState.MultiselectEndValue;
                    break;
                }
                default: {
                    this.incomplete += c;
                    this.i++;
                    break;
                }
                }
                break;
            }

            case ParseState.MultiselectQuotedValue: {
                switch (c) {
                case '': {
                    if (!autocompleteMode) {
                        return this.asError(this.intl.formatMessage({
                            id: 'apps.error.parser.missing_quote',
                            defaultMessage: 'Matching double quote expected before end of input.',
                        }));
                    }
                    return this;
                }
                case '"': {
                    if (this.incompleteStart === this.i - 1) {
                        return this.asError(this.intl.formatMessage({
                            id: 'apps.error.parser.empty_value',
                            defaultMessage: 'empty values are not allowed',
                        }));
                    }
                    this.i++;
                    this.state = ParseState.MultiselectEndQuotedValue;
                    break;
                }
                case '\\': {
                    escaped = true;
                    this.i++;
                    break;
                }
                default: {
                    this.incomplete += c;
                    this.i++;
                    if (escaped) {
                        //TODO: handle \n, \t, other escaped chars
                        escaped = false;
                    }
                    break;
                }
                }
                break;
            }

            case ParseState.MultiselectTickValue: {
                switch (c) {
                case '': {
                    if (!autocompleteMode) {
                        return this.asError(this.intl.formatMessage({
                            id: 'apps.error.parser.missing_tick',
                            defaultMessage: 'Matching tick quote expected before end of input.',
                        }));
                    }
                    return this;
                }
                case '`': {
                    if (this.incompleteStart === this.i - 1) {
                        return this.asError(this.intl.formatMessage({
                            id: 'apps.error.parser.empty_value',
                            defaultMessage: 'empty values are not allowed',
                        }));
                    }
                    this.i++;
                    this.state = ParseState.MultiselectEndTickedValue;
                    break;
                }
                default: {
                    this.incomplete += c;
                    this.i++;
                    break;
                }
                }
                break;
            }

            case ParseState.MultiselectEndTickedValue:
            case ParseState.MultiselectEndQuotedValue:
            case ParseState.MultiselectEndValue: {
                if (!this.field) {
                    return this.asError(this.intl.formatMessage({
                        id: 'apps.error.parser.missing_field_value',
                        defaultMessage: 'Field value is missing.',
                    }));
                }

                if (autocompleteMode && c === '') {
                    return this;
                }
                (this.values![this.field.name] as string[]).push(this.incomplete);
                this.incomplete = '';
                this.incompleteStart = this.i;
                if (c === '') {
                    return this;
                }
                this.state = ParseState.MultiselectValueSeparator;
                break;
            }

            case ParseState.MultiselectValueSeparator:
                switch (c) {
                case '':
                    if (!autocompleteMode) {
                        return this.asError(this.intl.formatMessage({
                            id: 'apps.error.parser.missing_list_end',
                            defaultMessage: 'Expected list closing token.',
                        }));
                    }
                    return this;
                case ']':
                    this.i++;
                    this.state = ParseState.ParameterSeparator;
                    break;
                case ' ':
                case '\t':
                    this.i++;
                    break;
                case ',':
                    this.i++;
                    this.state = ParseState.MultiselectNextValue;
                    break;
                default:
                    return this.asError(this.intl.formatMessage({
                        id: 'apps.error.parser.unexpected_character',
                        defaultMessage: 'Unexpected character.',
                    }));
                }
                break;
            case ParseState.MultiselectNextValue:
                switch (c) {
                case ' ':
                case '\t':
                    this.i++;
                    break;
                default:
                    this.state = ParseState.MultiselectStartValue;
                }
                break;
            default:
                return this.asError(this.intl.formatMessage({
                    id: 'apps.error.parser.unexpected_state',
                    defaultMessage: 'Unreachable: Unexpected state in matchBinding: `{state}`.',
                }, {
                    state: this.state,
                }));
            }
        }
    };
}

export class AppCommandParser {
    private store: Store;
    private channelID: string;
    private teamID: string;
    private rootPostID?: string;
    private intl: Intl;

    constructor(store: Store|null, intl: Intl, channelID: string, teamID = '', rootPostID = '') {
        this.store = store || getStore();
        this.channelID = channelID;
        this.rootPostID = rootPostID;
        this.teamID = teamID;
        this.intl = intl;
    }

    // composeCommandSubmitCall creates the form submission call
    public composeCommandSubmitCall = async (command: string): Promise<{creq: AppCallRequest | null; errorMessage?: string}> => {
        let parsed = new ParsedCommand(command, this, this.intl);

        const commandBindings = this.getCommandBindings();
        if (!commandBindings) {
            return {creq: null,
                errorMessage: this.intl.formatMessage({
                    id: 'apps.error.parser.no_bindings',
                    defaultMessage: 'No command bindings.',
                })};
        }

        parsed = await parsed.matchBinding(commandBindings, false);
        parsed = parsed.parseForm(false);
        if (parsed.state === ParseState.Error) {
            return {creq: null, errorMessage: parserErrorMessage(this.intl, parsed.error, parsed.command, parsed.i)};
        }

        await this.addDefaultAndReadOnlyValues(parsed);

        const missing = this.getMissingFields(parsed);
        if (missing.length > 0) {
            const missingStr = missing.map((f) => f.label).join(', ');
            return {creq: null,
                errorMessage: this.intl.formatMessage({
                    id: 'apps.error.command.field_missing',
                    defaultMessage: 'Required fields missing: `{fieldName}`.',
                }, {
                    fieldName: missingStr,
                })};
        }

        const {creq, errorMessage} = await this.composeCallRequest(parsed, parsed.resolvedForm?.submit);
        if (errorMessage) {
            return {creq: null, errorMessage};
        }

        return {creq};
    };

    public composeFormFromCommand = async (command: string): Promise<{form: AppForm | null; context: AppContext | null; errorMessage?: string}> => {
        let parsed = new ParsedCommand(command, this, this.intl);

        const commandBindings = this.getCommandBindings();
        if (!commandBindings) {
            return {
                form: null,
                context: null,
                errorMessage: this.intl.formatMessage({
                    id: 'apps.error.parser.no_bindings',
                    defaultMessage: 'No command bindings.',
                })};
        }

        parsed = await parsed.matchBinding(commandBindings, false);
        parsed = parsed.parseForm(false);

        const form = JSON.parse(JSON.stringify(parsed.resolvedForm));
        if (!form) {
            return {
                form: null,
                context: null,
                errorMessage: this.intl.formatMessage({
                    id: 'apps.error.parser.no_form',
                    defaultMessage: 'No form found.',
                }),
            };
        }

        const values: AppCallValues = parsed.values;
        await this.expandOptions(parsed, values);

        for (const field of form.fields || []) {
            if (values[field.name]) {
                field.value = values[field.name];
            }
        }

        if (!form.title) {
            form.title = parsed.binding?.location;
        }

        const context = this.getAppContext(parsed.binding!);
        return {form, context};
    };

    private async addDefaultAndReadOnlyValues(parsed: ParsedCommand) {
        if (!parsed.resolvedForm?.fields) {
            return;
        }

        await Promise.all(parsed.resolvedForm?.fields.map(async (f) => {
            if (!f.value) {
                return;
            }

            if (f.readonly || !(f.name in parsed.values)) {
                switch (f.type) {
                case AppFieldTypes.TEXT:
                    parsed.values[f.name] = f.value as string;
                    break;
                case AppFieldTypes.BOOL:
                    parsed.values[f.name] = 'true';
                    break;
                case AppFieldTypes.USER: {
                    const userID = (f.value as AppSelectOption).value;
                    let user = selectUser(this.store.getState(), userID);
                    if (!user) {
                        const dispatchResult = await this.store.dispatch(getUser(userID));
                        if ('error' in dispatchResult) {
                            // Silently fail on default value
                            break;
                        }
                        user = dispatchResult.data;
                    }
                    parsed.values[f.name] = user.username;
                    break;
                }
                case AppFieldTypes.CHANNEL: {
                    const channelID = (f.value as AppSelectOption).label;
                    let channel = selectChannel(this.store.getState(), channelID);
                    if (!channel) {
                        const dispatchResult = await this.store.dispatch(getChannel(channelID));
                        if ('error' in dispatchResult) {
                            // Silently fail on default value
                            break;
                        }
                        channel = dispatchResult.data;
                    }
                    parsed.values[f.name] = channel.name;
                    break;
                }
                case AppFieldTypes.STATIC_SELECT:
                case AppFieldTypes.DYNAMIC_SELECT:
                    parsed.values[f.name] = (f.value as AppSelectOption).value;
                    break;
                case AppFieldTypes.MARKDOWN:

                    // Do nothing
                }
            }
        }) || []);
    }

    // getSuggestionsBase is a synchronous function that returns results for base commands
    public getSuggestionsBase = (pretext: string): AutocompleteSuggestion[] => {
        const command = pretext.toLowerCase();
        const result: AutocompleteSuggestion[] = [];

        const bindings = this.getCommandBindings();

        for (const binding of bindings) {
            let base = binding.label;
            if (!base) {
                continue;
            }

            if (base[0] !== '/') {
                base = '/' + base;
            }

            if (base.startsWith(command)) {
                result.push({
                    Complete: binding.label,
                    Suggestion: base,
                    Description: binding.description || '',
                    Hint: binding.hint || '',
                    IconData: binding.icon || '',
                    type: Constants.Integrations.COMMAND,
                });
            }
        }

        return result;
    };

    // getSuggestions returns suggestions for subcommands and/or form arguments
    public getSuggestions = async (pretext: string): Promise<ExtendedAutocompleteSuggestion[]> => {
        let parsed = new ParsedCommand(pretext, this, this.intl);
        let suggestions: ExtendedAutocompleteSuggestion[] = [];

        const commandBindings = this.getCommandBindings();
        if (!commandBindings) {
            return [];
        }

        parsed = await parsed.matchBinding(commandBindings, true);
        if (parsed.state === ParseState.Error) {
            suggestions = this.getErrorSuggestion(parsed);
        }

        if (parsed.state === ParseState.Command) {
            suggestions = this.getCommandSuggestions(parsed);
        }

        if (parsed.resolvedForm || parsed.incomplete) {
            parsed = parsed.parseForm(true);
            if (parsed.state === ParseState.Error) {
                suggestions = this.getErrorSuggestion(parsed);
            }
            const argSuggestions = await this.getParameterSuggestions(parsed);
            suggestions = suggestions.concat(argSuggestions);
        }

        // Add "Execute Current Command" suggestion
        // TODO get full text from SuggestionBox
        const executableStates: string[] = [
            ParseState.EndCommand,
            ParseState.CommandSeparator,
            ParseState.StartParameter,
            ParseState.ParameterSeparator,
            ParseState.EndValue,
            ParseState.Rest,
        ];

        const modalStates: string[] = [
            ParseState.StartParameter,
            ParseState.Error,
            ParseState.TickValue,
            ParseState.QuotedValue,
            ParseState.EndValue,
            ParseState.Rest,
            ParseState.Flag,
            ParseState.FlagValueSeparator,
        ];
        const call = parsed.resolvedForm?.submit || parsed.binding?.form?.submit;
        const hasRequired = this.getMissingFields(parsed).length === 0;
        const hasValue = (parsed.state !== ParseState.EndValue || (parsed.field && parsed.values[parsed.field.name] !== undefined));

        if (executableStates.includes(parsed.state) && call && hasRequired && hasValue) {
            const execute = getExecuteSuggestion(parsed);
            if (execute) {
                suggestions = [execute, ...suggestions];
            }
        } else if (suggestions.length === 0 && (parsed.field?.type !== AppFieldTypes.USER && parsed.field?.type !== AppFieldTypes.CHANNEL)) {
            suggestions = this.getNoMatchingSuggestion();
        }

        if (modalStates.includes(parsed.state) && call && parsed.resolvedForm?.fields?.length) {
            const open = getOpenInModalSuggestion(parsed);
            if (open) {
                suggestions = [...suggestions, open];
            }
        }

        return suggestions.map((suggestion) => this.decorateSuggestionComplete(parsed, suggestion));
    }

    getNoMatchingSuggestion = () => {
        return [{
            Complete: '',
            Suggestion: '',
            Hint: this.intl.formatMessage({
                id: 'apps.suggestion.no_suggestion',
                defaultMessage: 'No matching suggestions.',
            }),
            IconData: COMMAND_SUGGESTION_ERROR,
            Description: '',
        }];
    };

    getErrorSuggestion = (parsed: ParsedCommand) => {
        return [{
            Complete: '',
            Suggestion: '',
            Hint: this.intl.formatMessage({
                id: 'apps.suggestion.errors.parser_error',
                defaultMessage: 'Parsing error',
            }),
            IconData: COMMAND_SUGGESTION_ERROR,
            Description: parsed.error,
        }];
    };

    // composeCallRequest creates the form submission call
    private composeCallRequest = async (parsed: ParsedCommand, call: AppCall | undefined): Promise<{creq: AppCallRequest | null; errorMessage?: string}> => {
        if (!parsed.binding) {
            return {creq: null,
                errorMessage: this.intl.formatMessage({
                    id: 'apps.error.parser.missing_binding',
                    defaultMessage: 'Missing command bindings.',
                })};
        }
        if (!call) {
            return {creq: null,
                errorMessage: this.intl.formatMessage({
                    id: 'apps.error.parser.missing_submit',
                    defaultMessage: 'No submit call in binding or form.',
                })};
        }

        const values: AppCallValues = parsed.values;
        const {errorMessage} = await this.expandOptions(parsed, values);
        if (errorMessage) {
            return {creq: null, errorMessage};
        }

        const context = this.getAppContext(parsed.binding);
        return {creq: createCallRequest(call, context, {}, values, parsed.command)};
    };

    private expandOptions = async (parsed: ParsedCommand, values: AppCallValues): Promise<{errorMessage?: string}> => {
        if (!parsed.resolvedForm?.fields) {
            return {};
        }

        const errors: {[key: string]: string} = {};
        await Promise.all(parsed.resolvedForm.fields.map(async (f) => {
            if (!values[f.name]) {
                return;
            }
            switch (f.type) {
            case AppFieldTypes.DYNAMIC_SELECT:
                if (f.multiselect && Array.isArray(values[f.name])) {
                    const options: AppSelectOption[] = [];
                    const commandValues = values[f.name] as string[];
                    for (const value of commandValues) {
                        if (options.find((o) => o.value === value)) {
                            errors[f.name] = this.intl.formatMessage({
                                id: 'apps.error.command.same_option',
                                defaultMessage: 'Option repeated for field `{fieldName}`: `{option}`.',
                            }, {
                                fieldName: f.name,
                                option: value,
                            });
                        }
                    }
                    values[f.name] = options;
                    break;
                }

                values[f.name] = {label: values[f.name], value: values[f.name]};
                break;
            case AppFieldTypes.STATIC_SELECT: {
                const getOption = (value: string) => {
                    return f.options?.find((o) => (o.value === value));
                };

                const setOptionError = (value: string) => {
                    errors[f.name] = this.intl.formatMessage({
                        id: 'apps.error.command.unknown_option',
                        defaultMessage: 'Unknown option for field `{fieldName}`: `{option}`.',
                    }, {
                        fieldName: f.name,
                        option: value,
                    });
                    values[f.name] = undefined;
                };

                if (f.multiselect && Array.isArray(values[f.name])) {
                    const options: AppSelectOption[] = [];
                    const commandValues = values[f.name] as string[];
                    for (const value of commandValues) {
                        const option = getOption(value);
                        if (!option) {
                            setOptionError(value);
                            return;
                        }
                        if (options.find((o) => o.value === option.value)) {
                            errors[f.name] = this.intl.formatMessage({
                                id: 'apps.error.command.same_option',
                                defaultMessage: 'Option repeated for field `{fieldName}`: `{option}`.',
                            }, {
                                fieldName: f.name,
                                option: value,
                            });
                        }
                        options.push(option);
                    }
                    values[f.name] = options;
                    break;
                }

                const option = getOption(values[f.name]);
                if (!option) {
                    setOptionError(values[f.name]);
                    return;
                }
                values[f.name] = option;
                break;
            }
            case AppFieldTypes.USER: {
                const getUser = async (userName: string) => {
                    let user = selectUserByUsername(this.store.getState(), userName);
                    if (!user) {
                        const dispatchResult = await this.store.dispatch(getUserByUsername(userName) as any);
                        if ('error' in dispatchResult) {
                            return null;
                        }
                        user = dispatchResult.data;
                    }
                    return user;
                };

                const setUserError = (username: string) => {
                    errors[f.name] = this.intl.formatMessage({
                        id: 'apps.error.command.unknown_user',
                        defaultMessage: 'Unknown user for field `{fieldName}`: `{option}`.',
                    }, {
                        fieldName: f.name,
                        option: username,
                    });
                };

                if (f.multiselect && Array.isArray(values[f.name])) {
                    const options: AppSelectOption[] = [];
                    const commandValues = values[f.name] as string[];
                    /* eslint-disable no-await-in-loop */
                    for (const value of commandValues) {
                        let userName = value;
                        if (userName[0] === '@') {
                            userName = userName.substr(1);
                        }
                        const user = await getUser(userName);
                        if (!user) {
                            setUserError(userName);
                            return;
                        }

                        if (options.find((o) => o.value === user?.id)) {
                            errors[f.name] = this.intl.formatMessage({
                                id: 'apps.error.command.same_user',
                                defaultMessage: 'User repeated for field `{fieldName}`: `{option}`.',
                            }, {
                                fieldName: f.name,
                                option: userName,
                            });
                        }
                        options.push({label: user.username, value: user.id});
                    }
                    /* eslint-enable no-await-in-loop */
                    values[f.name] = options;
                    break;
                }

                let userName = values[f.name] as string;
                if (userName[0] === '@') {
                    userName = userName.substr(1);
                }
                const user = await getUser(userName);
                if (!user) {
                    setUserError(userName);
                    return;
                }
                values[f.name] = {label: user.username, value: user.id};
                break;
            }
            case AppFieldTypes.CHANNEL: {
                const getChannel = async (channelName: string) => {
                    let channel = selectChannelByName(this.store.getState(), channelName);
                    if (!channel) {
                        const dispatchResult = await this.store.dispatch(getChannelByNameAndTeamName(getCurrentTeam(this.store.getState()).name, channelName) as any);
                        if ('error' in dispatchResult) {
                            return null;
                        }
                        channel = dispatchResult.data;
                    }
                    return channel;
                };

                const setChannelError = (channelName: string) => {
                    errors[f.name] = this.intl.formatMessage({
                        id: 'apps.error.command.unknown_channel',
                        defaultMessage: 'Unknown channel for field `{fieldName}`: `{option}`.',
                    }, {
                        fieldName: f.name,
                        option: channelName,
                    });
                };

                if (f.multiselect && Array.isArray(values[f.name])) {
                    const options: AppSelectOption[] = [];
                    const commandValues = values[f.name] as string[];
                    /* eslint-disable no-await-in-loop */
                    for (const value of commandValues) {
                        let channelName = value;
                        if (channelName[0] === '~') {
                            channelName = channelName.substr(1);
                        }
                        const channel = await getChannel(channelName);
                        if (!channel) {
                            setChannelError(channelName);
                            return;
                        }

                        if (options.find((o) => o.value === channel?.id)) {
                            errors[f.name] = this.intl.formatMessage({
                                id: 'apps.error.command.same_channel',
                                defaultMessage: 'Channel repeated for field `{fieldName}`: `{option}`.',
                            }, {
                                fieldName: f.name,
                                option: channelName,
                            });
                        }

                        options.push({label: channel?.display_name, value: channel?.id});
                    }
                    /* eslint-enable no-await-in-loop */
                    values[f.name] = options;
                    break;
                }

                let channelName = values[f.name] as string;
                if (channelName[0] === '~') {
                    channelName = channelName.substr(1);
                }
                const channel = await getChannel(channelName);
                if (!channel) {
                    setChannelError(channelName);
                    return;
                }
                values[f.name] = {label: channel?.display_name, value: channel?.id};
                break;
            }
            case AppFieldTypes.BOOL: {
                const strValue = values[f.name] as string;
                if (strValue.toLowerCase() === 'true') {
                    values[f.name] = true;
                } else {
                    values[f.name] = false;
                }
            }
            }
        }));

        if (Object.keys(errors).length === 0) {
            return {};
        }

        let errorMessage = '';
        Object.keys(errors).forEach((v) => {
            errorMessage = errorMessage + errors[v] + '\n';
        });
        return {errorMessage};
    };

    // decorateSuggestionComplete applies the necessary modifications for a suggestion to be processed
    private decorateSuggestionComplete = (parsed: ParsedCommand, choice: AutocompleteSuggestion): AutocompleteSuggestion => {
        if (choice.Complete && (
            choice.Complete.endsWith(EXECUTE_CURRENT_COMMAND_ITEM_ID) ||
            choice.Complete.endsWith(OPEN_COMMAND_IN_MODAL_ITEM_ID))) {
            return choice as AutocompleteSuggestion;
        }

        let goBackSpace = 0;
        if (choice.Complete === '') {
            goBackSpace = 1;
        }
        let complete = parsed.command.substring(0, parsed.incompleteStart - goBackSpace);
        complete += choice.Complete === undefined ? choice.Suggestion : choice.Complete;
        choice.Hint = choice.Hint || '';
        complete = complete.substring(1);

        return {
            ...choice,
            Complete: complete,
        };
    };

    // getCommandBindings returns the commands in the redux store.
    // They are grouped by app id since each app has one base command
    private getCommandBindings = (): AppBinding[] => {
        const state = this.store.getState();
        if (this.rootPostID) {
            return getRHSCommandBindings(state);
        }
        return getCommandBindings(state);
    };

    // getChannel gets the channel in which the user is typing the command
    private getChannel = (): Channel | null => {
        const state = this.store.getState();
        return selectChannel(state, this.channelID);
    };

    public setChannelContext = (channelID: string, teamID = '', rootPostID?: string) => {
        this.channelID = channelID;
        this.rootPostID = rootPostID;
        this.teamID = teamID;
    };

    // isAppCommand determines if subcommand/form suggestions need to be returned.
    // When this returns true, the caller knows that the parser should handle all suggestions for the current command string.
    // When it returns false, the caller should call getSuggestionsBase() to check if there are any base commands that match the command string.
    public isAppCommand = (pretext: string): boolean => {
        const command = pretext.toLowerCase();
        for (const binding of this.getCommandBindings()) {
            let base = binding.label;
            if (!base) {
                continue;
            }

            if (base[0] !== '/') {
                base = '/' + base;
            }

            if (command.startsWith(base + ' ')) {
                return true;
            }
        }
        return false;
    };

    // getAppContext collects post/channel/team info for performing calls
    private getAppContext = (binding: AppBinding): AppContext => {
        const context: AppContext = {
            app_id: binding.app_id,
            location: binding.location,
            root_id: this.rootPostID,
        };

        const channel = this.getChannel();
        if (!channel) {
            return context;
        }

        context.channel_id = channel.id;
        context.team_id = channel.team_id || getCurrentTeamId(this.store.getState());

        return context;
    };

    // fetchSubmittableForm unconditionaly retrieves the form for the given binding (subcommand)
    private fetchSubmittableForm = async (source: AppCall, context: AppContext): Promise<{form?: AppForm; error?: string} | undefined> => {
        const payload = createCallRequest(source, context);
        const res = await this.store.dispatch(doAppFetchForm(payload, this.intl)) as DoAppCallResult;
        if (res.error) {
            const errorResponse = res.error;
            return {error: errorResponse.text || this.intl.formatMessage({
                id: 'apps.error.unknown',
                defaultMessage: 'Unknown error.',
            })};
        }

        const callResponse = res.data!;
        switch (callResponse.type) {
        case AppCallResponseTypes.FORM:
            break;
        case AppCallResponseTypes.NAVIGATE:
        case AppCallResponseTypes.OK:
            return {error: this.intl.formatMessage({
                id: 'apps.error.responses.unexpected_type',
                defaultMessage: 'App response type was not expected. Response type: {type}',
            }, {
                type: callResponse.type,
            })};
        default:
            return {error: this.intl.formatMessage({
                id: 'apps.error.responses.unknown_type',
                defaultMessage: 'App response type not supported. Response type: {type}.',
            }, {
                type: callResponse.type,
            })};
        }

        if (!callResponse.form?.submit) {
            return {error: this.intl.formatMessage({
                id: 'apps.error.parser.missing_submit',
                defaultMessage: 'No submit call in binding or form.',
            })};
        }

        return {form: callResponse.form};
    };

    public getSubmittableForm = async (location: string, binding: AppBinding): Promise<{form?: AppForm; error?: string} | undefined> => {
        const rootID = this.rootPostID || '';
        const key = `${this.channelID}-${rootID}-${location}`;
        const submittableForm = this.rootPostID ? getAppRHSCommandForm(this.store.getState(), key) : getAppCommandForm(this.store.getState(), key);
        if (submittableForm) {
            return {form: submittableForm};
        }

        if (!binding.form?.source) {
            return {error: this.intl.formatMessage({
                id: 'apps.error.parser.missing_source',
                defaultMessage: 'Form has neither submit nor source.',
            })};
        }
        const context = this.getAppContext(binding);
        const fetched = await this.fetchSubmittableForm(binding.form.source, context);
        if (fetched?.form) {
            let actionType: string = AppsTypes.RECEIVED_APP_COMMAND_FORM;
            if (this.rootPostID) {
                actionType = AppsTypes.RECEIVED_APP_RHS_COMMAND_FORM;
            }
            this.store.dispatch({
                data: {form: fetched.form, location: key},
                type: actionType,
            });
        }
        return fetched;
    };

    // getSuggestionsForSubCommands returns suggestions for a subcommand's name
    private getCommandSuggestions = (parsed: ParsedCommand): AutocompleteSuggestion[] => {
        if (!parsed.binding?.bindings?.length) {
            return [];
        }
        const bindings = parsed.binding.bindings;
        const result: AutocompleteSuggestion[] = [];

        bindings.forEach((b) => {
            if (b.label.toLowerCase().startsWith(parsed.incomplete.toLowerCase())) {
                result.push({
                    Complete: b.label,
                    Suggestion: b.label,
                    Description: b.description || '',
                    Hint: b.hint || '',
                    IconData: b.icon || '',
                    type: Constants.Integrations.COMMAND,
                });
            }
        });

        return result;
    };

    // getParameterSuggestions computes suggestions for positional argument values, flag names, and flag argument values
    private getParameterSuggestions = async (parsed: ParsedCommand): Promise<ExtendedAutocompleteSuggestion[]> => {
        switch (parsed.state) {
        case ParseState.StartParameter: {
            // see if there's a matching positional field
            const positional = parsed.resolvedForm?.fields?.find((f: AppField) => f.position === parsed.position + 1);
            if (positional) {
                parsed.field = positional;
                return this.getValueSuggestions(parsed);
            }
            return this.getFlagNameSuggestions(parsed);
        }

        case ParseState.Flag:
            return this.getFlagNameSuggestions(parsed);

        case ParseState.FlagValueSeparator: {
            const suggestions = await this.getValueSuggestions(parsed);
            if (parsed.field?.multiselect) {
                suggestions.unshift({
                    Complete: '[',
                    Suggestion: '[',
                    Description: 'Start building a list',
                    Hint: '',
                    IconData: '',
                });
            }
            return suggestions;
        }
        case ParseState.EndValue:
        case ParseState.NonspaceValue:
        case ParseState.MultiselectNextValue:
        case ParseState.MultiselectStart:
        case ParseState.MultiselectNonspaceValue:
        case ParseState.MultiselectEndValue:
        case ParseState.MultiselectStartValue:
            return this.getValueSuggestions(parsed);
        case ParseState.EndQuotedValue:
        case ParseState.QuotedValue:
        case ParseState.MultiselectQuotedValue:
            return this.getValueSuggestions(parsed, '"');
        case ParseState.EndTickedValue:
        case ParseState.TickValue:
        case ParseState.MultiselectTickValue:
            return this.getValueSuggestions(parsed, '`');
        case ParseState.MultiselectValueSeparator:
            return this.getMultiselectValueSeparatorSuggestion();
        case ParseState.Rest: {
            return this.getValueSuggestions(parsed);
        }
        }
        return [];
    };

    private getMultiselectValueSeparatorSuggestion = (): AutocompleteSuggestion[] => {
        return [
            {
                Complete: ',',
                Suggestion: ',',
                Description: 'Add new element',
                Hint: '',
                IconData: '',
            },
            {
                Complete: ']',
                Suggestion: ']',
                Description: 'End list',
                Hint: '',
                IconData: '',
            },
        ];
    };

    // getMissingFields collects the required fields that were not supplied in a submission
    private getMissingFields = (parsed: ParsedCommand): AppField[] => {
        const form = parsed.resolvedForm;
        if (!form) {
            return [];
        }

        const missing: AppField[] = [];

        const values = parsed.values || [];
        const fields = form.fields || [];
        for (const field of fields) {
            if (field.is_required && !values[field.name]) {
                missing.push(field);
            }
        }

        return missing;
    };

    // getFlagNameSuggestions returns suggestions for flag names
    private getFlagNameSuggestions = (parsed: ParsedCommand): AutocompleteSuggestion[] => {
        if (!parsed.resolvedForm?.fields?.length) {
            return [];
        }

        // There have been 0 to 2 dashes in the command prior to this call, adjust.
        const prevCharIndex = parsed.incompleteStart - 1;
        let prefix = '--';
        for (let i = prevCharIndex; i > 0 && i >= parsed.incompleteStart - 2 && parsed.command[i] === '-'; i--) {
            prefix = prefix.substring(1);
        }
        if (prevCharIndex > 0 && parsed.command[prevCharIndex] === '') {
            prefix = '';
        }

        const applicable = parsed.resolvedForm.fields.filter((field) => field.label && field.label.toLowerCase().startsWith(parsed.incomplete.toLowerCase()) && !parsed.values[field.name]);
        if (applicable) {
            return applicable.map((f) => {
                return {
                    Complete: prefix + (f.label || f.name),
                    Suggestion: '--' + (f.label || f.name),
                    Description: f.description || '',
                    Hint: f.hint || '',
                    IconData: parsed.binding?.icon || '',
                };
            });
        }

        return [];
    };

    // getSuggestionsForField gets suggestions for a positional or flag field value
    private getValueSuggestions = async (parsed: ParsedCommand, delimiter?: string): Promise<ExtendedAutocompleteSuggestion[]> => {
        if (!parsed || !parsed.field) {
            return [];
        }
        const f = parsed.field;

        switch (f.type) {
        case AppFieldTypes.USER:
            return this.getUserFieldSuggestions(parsed);
        case AppFieldTypes.CHANNEL:
            return this.getChannelFieldSuggestions(parsed);
        case AppFieldTypes.BOOL:
            return this.getBooleanSuggestions(parsed);
        case AppFieldTypes.DYNAMIC_SELECT:
            return this.getDynamicSelectSuggestions(parsed, delimiter);
        case AppFieldTypes.STATIC_SELECT:
            return this.getStaticSelectSuggestions(parsed, delimiter);
        }

        const mentionSuggestions = await inTextMentionSuggestions(parsed.incomplete, this.store, this.channelID, this.teamID, delimiter);
        if (mentionSuggestions) {
            return mentionSuggestions;
        }

        // Handle text values
        let complete = parsed.incomplete;
        if (complete && delimiter) {
            complete = delimiter + complete + delimiter;
        }

        const fieldName = parsed.field.modal_label || parsed.field.label || parsed.field.name;
        return [{
            Complete: complete,
            Suggestion: `${fieldName}: ${delimiter || '"'}${parsed.incomplete}${delimiter || '"'}`,
            Description: f.description || '',
            Hint: '',
            IconData: parsed.binding?.icon || '',
        }];
    };

    // getStaticSelectSuggestions returns suggestions specified in the field's options property
    private getStaticSelectSuggestions = (parsed: ParsedCommand, delimiter?: string): AutocompleteSuggestion[] => {
        const f = parsed.field as AutocompleteStaticSelect;
        const opts = f.options?.filter((opt) => opt.label.toLowerCase().startsWith(parsed.incomplete.toLowerCase()));
        if (!opts?.length) {
            return [{
                Complete: '',
                Suggestion: '',
                Hint: this.intl.formatMessage({
                    id: 'apps.suggestion.no_static',
                    defaultMessage: 'No matching options.',
                }),
                Description: '',
                IconData: COMMAND_SUGGESTION_ERROR,
            }];
        }
        return opts.map((opt) => {
            let complete = opt.value;
            if (delimiter) {
                complete = delimiter + complete + delimiter;
            } else if (isMultiword(opt.value)) {
                complete = '`' + complete + '`';
            }
            return {
                Complete: complete,
                Suggestion: opt.label,
                Hint: f.hint || '',
                Description: f.description || '',
                IconData: opt.icon_data || parsed.binding?.icon || '',
            };
        });
    };

    // getDynamicSelectSuggestions fetches and returns suggestions from the server
    private getDynamicSelectSuggestions = async (parsed: ParsedCommand, delimiter?: string): Promise<AutocompleteSuggestion[]> => {
        const f = parsed.field;
        if (!f) {
            // Should never happen
            return this.makeDynamicSelectSuggestionError(this.intl.formatMessage({
                id: 'apps.error.parser.unexpected_error',
                defaultMessage: 'Unexpected error.',
            }));
        }

        const {creq, errorMessage} = await this.composeCallRequest(parsed, f.lookup);
        if (!creq) {
            return this.makeDynamicSelectSuggestionError(this.intl.formatMessage({
                id: 'apps.error.lookup.error_preparing_request',
                defaultMessage: 'Error preparing lookup request: {errorMessage}',
            }, {
                errorMessage,
            }));
        }
        creq.query = parsed.incomplete;
        creq.selected_field = parsed.field?.name;

        const res = await this.store.dispatch(doAppLookup(creq, this.intl)) as DoAppCallResult<AppLookupResponse>;

        if (res.error) {
            const errorResponse = res.error;
            return this.makeDynamicSelectSuggestionError(errorResponse.text || this.intl.formatMessage({
                id: 'apps.error.unknown',
                defaultMessage: 'Unknown error.',
            }));
        }

        const callResponse = res.data!;
        switch (callResponse.type) {
        case AppCallResponseTypes.OK:
            break;
        case AppCallResponseTypes.NAVIGATE:
        case AppCallResponseTypes.FORM:
            return this.makeDynamicSelectSuggestionError(this.intl.formatMessage({
                id: 'apps.error.responses.unexpected_type',
                defaultMessage: 'App response type was not expected. Response type: {type}',
            }, {
                type: callResponse.type,
            }));
        default:
            return this.makeDynamicSelectSuggestionError(this.intl.formatMessage({
                id: 'apps.error.responses.unknown_type',
                defaultMessage: 'App response type not supported. Response type: {type}.',
            }, {
                type: callResponse.type,
            }));
        }

        let items = callResponse?.data?.items;
        items = items?.filter(filterEmptyOptions);
        if (!items?.length) {
            return [{
                Complete: '',
                Suggestion: '',
                Hint: this.intl.formatMessage({
                    id: 'apps.suggestion.no_static',
                    defaultMessage: 'No matching options.',
                }),
                IconData: '',
                Description: this.intl.formatMessage({
                    id: 'apps.suggestion.no_dynamic',
                    defaultMessage: 'No data was returned for dynamic suggestions',
                }),
            }];
        }

        return items.map((s): AutocompleteSuggestion => {
            let complete = s.value;
            if (delimiter) {
                complete = delimiter + complete + delimiter;
            } else if (isMultiword(s.value)) {
                complete = '`' + complete + '`';
            }
            return ({
                Complete: complete,
                Description: s.label || s.value,
                Suggestion: s.value,
                Hint: '',
                IconData: s.icon_data || parsed.binding?.icon || '',
            });
        });
    };

    private makeDynamicSelectSuggestionError = (message: string): AutocompleteSuggestion[] => {
        const errMsg = this.intl.formatMessage({
            id: 'apps.error',
            defaultMessage: 'Error: {error}',
        }, {
            error: message,
        });
        return [{
            Complete: '',
            Suggestion: '',
            Hint: this.intl.formatMessage({
                id: 'apps.suggestion.dynamic.error',
                defaultMessage: 'Dynamic select error',
            }),
            IconData: COMMAND_SUGGESTION_ERROR,
            Description: errMsg,
        }];
    };

    private getUserFieldSuggestions = async (parsed: ParsedCommand): Promise<AutocompleteSuggestion[]> => {
        let input = parsed.incomplete.trim();
        if (input[0] === '@') {
            input = input.substring(1);
        }
        const {data} = await this.store.dispatch(autocompleteUsersInChannel(input, this.channelID));
        return getUserSuggestions(data);
    };

    private getChannelFieldSuggestions = async (parsed: ParsedCommand): Promise<AutocompleteSuggestion[]> => {
        let input = parsed.incomplete.trim();
        if (input[0] === '~') {
            input = input.substring(1);
        }
        const {data} = await this.store.dispatch(autocompleteChannels(this.teamID, input));
        return getChannelSuggestions(data);
    };

    // getBooleanSuggestions returns true/false suggestions
    private getBooleanSuggestions = (parsed: ParsedCommand): AutocompleteSuggestion[] => {
        const suggestions: AutocompleteSuggestion[] = [];

        if ('true'.startsWith(parsed.incomplete)) {
            suggestions.push({
                Complete: 'true',
                Suggestion: 'true',
                Description: parsed.field?.description || '',
                Hint: parsed.field?.hint || '',
                IconData: parsed.binding?.icon || '',
            });
        }
        if ('false'.startsWith(parsed.incomplete)) {
            suggestions.push({
                Complete: 'false',
                Suggestion: 'false',
                Description: parsed.field?.description || '',
                Hint: parsed.field?.hint || '',
                IconData: parsed.binding?.icon || '',
            });
        }
        return suggestions;
    };
}

function isMultiword(value: string) {
    if (value.indexOf(' ') !== -1) {
        return true;
    }

    if (value.indexOf('\t') !== -1) {
        return true;
    }

    return false;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import type {UserAutocomplete} from '@mattermost/types/autocomplete';
import type {AutocompleteSuggestion} from '@mattermost/types/integrations';
import type {Channel} from '@mattermost/types/channels';
import type {UserProfile} from '@mattermost/types/users';
import type {DispatchFunc} from 'mattermost-redux/types/actions';
import type {GlobalState} from 'types/store';

import {autocompleteUsersInChannel} from 'actions/views/channel';
import {autocompleteChannels} from 'mattermost-redux/actions/channels';

import {Constants} from 'utils/constants';

export const COMMAND_SUGGESTION_CHANNEL = Constants.Integrations.COMMAND_SUGGESTION_CHANNEL;
export const COMMAND_SUGGESTION_USER = Constants.Integrations.COMMAND_SUGGESTION_USER;

export type Store = {
    dispatch: DispatchFunc;
    getState: () => GlobalState;
}

export async function inTextMentionSuggestions(pretext: string, store: Store, channelID: string, teamID: string, delimiter = ''): Promise<AutocompleteSuggestion[] | null> {
    const separatedWords = pretext.split(' ');
    const incompleteLessLastWord = separatedWords.slice(0, -1).join(' ');
    const lastWord = separatedWords[separatedWords.length - 1];
    if (lastWord.startsWith('@')) {
        const {data} = await store.dispatch(autocompleteUsersInChannel(lastWord.substring(1), channelID));
        const users = await getUserSuggestions(data);
        users.forEach((u) => {
            let complete = incompleteLessLastWord ? incompleteLessLastWord + ' ' + u.Complete : u.Complete;
            if (delimiter) {
                complete = delimiter + complete;
            }
            u.Complete = complete;
        });
        return users;
    }

    if (lastWord.startsWith('~') && !lastWord.startsWith('~~')) {
        const {data} = await store.dispatch(autocompleteChannels(teamID, lastWord.substring(1)));
        const channels = await getChannelSuggestions(data);
        channels.forEach((c) => {
            let complete = incompleteLessLastWord ? incompleteLessLastWord + ' ' + c.Complete : c.Complete;
            if (delimiter) {
                complete = delimiter + complete;
            }
            c.Complete = complete;
        });
        return channels;
    }

    return null;
}

export async function getUserSuggestions(usersAutocomplete?: UserAutocomplete): Promise<AutocompleteSuggestion[]> {
    const notFoundSuggestions = [{
        Complete: '',
        Suggestion: '',
        Description: 'No user found',
        Hint: '',
        IconData: '',
    }];
    if (!usersAutocomplete) {
        return notFoundSuggestions;
    }

    if (!usersAutocomplete.users.length && !usersAutocomplete.out_of_channel?.length) {
        return notFoundSuggestions;
    }

    const items: AutocompleteSuggestion[] = [];
    usersAutocomplete.users.forEach((u) => {
        items.push(getUserSuggestion(u));
    });
    usersAutocomplete.out_of_channel?.forEach((u) => {
        items.push(getUserSuggestion(u));
    });

    return items;
}

export async function getChannelSuggestions(channels?: Channel[]): Promise<AutocompleteSuggestion[]> {
    const notFoundSuggestion = [{
        Complete: '',
        Suggestion: '',
        Description: 'No channel found',
        Hint: '',
        IconData: '',
    }];
    if (!channels) {
        return notFoundSuggestion;
    }
    if (!channels.length) {
        return notFoundSuggestion;
    }

    const items = channels.map((c) => {
        return {
            Complete: '~' + c.name,
            Suggestion: c.name,
            Description: '',
            Hint: '',
            IconData: '',
            type: COMMAND_SUGGESTION_CHANNEL,
            item: c,
        };
    });

    return items;
}

function getUserSuggestion(u: UserProfile) {
    return {
        Complete: '@' + u.username,
        Suggestion: u.username,
        Description: '',
        Hint: '',
        IconData: '',
        type: COMMAND_SUGGESTION_USER,
        item: u,
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

export type {
    AppCall,
    AppCallRequest,
    AppCallValues,
    AppBinding,
    AppField,
    AppContext,
    AppForm,
    AutocompleteElement,
    AutocompleteDynamicSelect,
    AutocompleteStaticSelect,
    AutocompleteUserSelect,
    AutocompleteChannelSelect,
    AppLookupResponse,
    AppSelectOption,
} from '@mattermost/types/apps';

export type {
    DoAppCallResult,
} from 'types/apps';

import type {
    AutocompleteSuggestion,
} from '@mattermost/types/integrations';
export type {AutocompleteSuggestion};

import type {
    Channel,
} from '@mattermost/types/channels';
export type {Channel};

import {
    GlobalState,
} from 'types/store';

import type {
    DispatchFunc,
} from 'mattermost-redux/types/actions';

export type {
    UserAutocomplete,
} from '@mattermost/types/autocomplete';

import type {
    UserProfile,
} from '@mattermost/types/users';
export type {UserProfile};

export {
    AppBindingLocations,
    AppFieldTypes,
    AppCallResponseTypes,
} from 'mattermost-redux/constants/apps';

export {autocompleteUsersInChannel} from 'actions/views/channel';

export {makeAppBindingsSelector, makeRHSAppBindingSelector, getAppCommandForm, getAppRHSCommandForm} from 'mattermost-redux/selectors/entities/apps';

export {getPost} from 'mattermost-redux/selectors/entities/posts';
export {getChannel as selectChannel, getCurrentChannel, getChannelByName as selectChannelByName} from 'mattermost-redux/selectors/entities/channels';
export {getCurrentTeamId, getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';
export {getUserByUsername as selectUserByUsername, getUser as selectUser} from 'mattermost-redux/selectors/entities/users';

export {getUserByUsername, getUser} from 'mattermost-redux/actions/users';
export {getChannelByNameAndTeamName, getChannel, autocompleteChannels} from 'mattermost-redux/actions/channels';

export {doAppFetchForm, doAppLookup} from 'actions/apps';
import {sendEphemeralPost} from 'actions/global_actions';

export {
    createCallRequest,
    filterEmptyOptions,
} from 'utils/apps';

import {
    isMac,
    localizeAndFormatMessage,
} from 'utils/utils';

export type Store = {
    dispatch: DispatchFunc;
    getState: () => GlobalState;
}

import ReduxStore from 'stores/redux_store';
export const getStore = () => ReduxStore;

export {getChannelSuggestions, getUserSuggestions, inTextMentionSuggestions} from '../mentions';

import {Constants} from 'utils/constants';
export const EXECUTE_CURRENT_COMMAND_ITEM_ID = Constants.Integrations.EXECUTE_CURRENT_COMMAND_ITEM_ID;
export const OPEN_COMMAND_IN_MODAL_ITEM_ID = Constants.Integrations.OPEN_COMMAND_IN_MODAL_ITEM_ID;
export const COMMAND_SUGGESTION_ERROR = Constants.Integrations.COMMAND_SUGGESTION_ERROR;
export const COMMAND_SUGGESTION_CHANNEL = Constants.Integrations.COMMAND_SUGGESTION_CHANNEL;
export const COMMAND_SUGGESTION_USER = Constants.Integrations.COMMAND_SUGGESTION_USER;

import type {ParsedCommand} from './app_command_parser';
export {AppsTypes} from 'mattermost-redux/action_types';

export const getExecuteSuggestion = (parsed: ParsedCommand): AutocompleteSuggestion | null => {
    let key = 'Ctrl';
    if (isMac()) {
        key = '';
    }

    return {
        Complete: parsed.command.substring(1) + EXECUTE_CURRENT_COMMAND_ITEM_ID,
        Suggestion: 'Execute Current Command',
        Hint: '',
        Description: 'Select this option or use ' + key + '+Enter to execute the current command.',
        IconData: EXECUTE_CURRENT_COMMAND_ITEM_ID,
    };
};

export const getOpenInModalSuggestion = (parsed: ParsedCommand): AutocompleteSuggestion | null => {
    return {
        Complete: parsed.command.substring(1) + OPEN_COMMAND_IN_MODAL_ITEM_ID,
        Suggestion: 'Open in modal',
        Hint: '',
        Description: 'Select this option to open the current command in a modal.',
        IconData: OPEN_COMMAND_IN_MODAL_ITEM_ID,
    };
};

export type ExtendedAutocompleteSuggestion = AutocompleteSuggestion & {
    item?: UserProfile | Channel;
}

export const displayError = (err: string, channelID: string, rootID?: string) => {
    ReduxStore.dispatch(sendEphemeralPost(err, channelID, rootID));
};

// Shim of mobile-version intl
export const intlShim = {
    formatMessage: (config: {id: string; defaultMessage: string}, values?: {[name: string]: any}) => {
        return localizeAndFormatMessage(config.id, config.defaultMessage, values);
    },
};

export const errorMessage = (intl: typeof intlShim, error: string, _command: string, _position: number): string => { // eslint-disable-line @typescript-eslint/no-unused-vars
    return intl.formatMessage({
        id: 'apps.error.parser',
        defaultMessage: 'Parsing error: {error}',
    }, {
        error,
    });
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import Provider from './provider';
import Suggestion from './suggestion.jsx';

class ChannelSuggestion extends Suggestion {
    render() {
        const isSelection = this.props.isSelection;
        const item = this.props.item;

        const channelName = item.display_name;
        const purpose = item.purpose;

        const icon = (
            <span className='suggestion-list__icon suggestion-list__icon--large'>
                <i className='icon icon--standard icon--no-spacing icon-globe'/>
            </span>
        );
        let className = 'suggestion-list__item';
        if (isSelection) {
            className += ' suggestion--selected';
        }

        const description = '(~' + item.name + ')';

        return (
            <div
                className={className}
                onClick={this.handleClick}
                onMouseMove={this.handleMouseMove}
                {...Suggestion.baseProps}
            >
                {icon}
                <div className='suggestion-list__ellipsis'>
                    <span className='suggestion-list__main'>
                        {channelName}
                    </span>
                    <span className='ml-2'>
                        {' '}
                        {description}
                    </span>
                    <span className='ml-2'>
                        {' '}
                        {purpose}
                    </span>
                </div>
            </div>
        );
    }
}

export default class ChannelProvider extends Provider {
    constructor(channelSearchFunc) {
        super();

        this.autocompleteChannels = channelSearchFunc;
    }

    handlePretextChanged(pretext, resultsCallback) {
        const normalizedPretext = pretext.toLowerCase();
        this.startNewRequest(normalizedPretext);

        this.autocompleteChannels(
            normalizedPretext,
            (data) => {
                if (this.shouldCancelDispatch(normalizedPretext)) {
                    return;
                }

                const channels = Object.assign([], data);

                resultsCallback({
                    matchedPretext: normalizedPretext,
                    terms: channels.map((channel) => channel.display_name),
                    items: channels,
                    component: ChannelSuggestion,
                });
            },
        );

        return true;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {Client4} from 'mattermost-redux/client';

import * as Utils from 'utils/utils';
import {isGuest} from 'mattermost-redux/utils/user_utils';

import GuestBadge from 'components/widgets/badges/guest_badge';
import BotBadge from 'components/widgets/badges/bot_badge';
import Avatar from 'components/widgets/users/avatar';

import Provider from './provider';
import Suggestion from './suggestion.jsx';
import {UserAutocomplete, UserProfile} from './command_provider/app_command_parser/app_command_parser_dependencies.js';

export type ProviderResults = {
    matchedPretext: string;
    terms: string[];
    items: Array<Record<string, any>>;
    component?: React.ReactNode;
}

class UserSuggestion extends Suggestion {
    render() {
        const {item, isSelection} = this.props;

        let className = 'suggestion-list__item';
        if (isSelection) {
            className += ' suggestion--selected';
        }

        const username = item.username;
        let description = '';

        if ((item.first_name || item.last_name) && item.nickname) {
            description = `- ${Utils.getFullName(item)} (${item.nickname})`;
        } else if (item.nickname) {
            description = `- (${item.nickname})`;
        } else if (item.first_name || item.last_name) {
            description = `- ${Utils.getFullName(item)}`;
        }

        return (
            <div
                className={className}
                onClick={this.handleClick}
                onMouseMove={this.handleMouseMove}
                {...Suggestion.baseProps}
            >
                <Avatar
                    size='xxs'
                    username={username}
                    url={Client4.getUsersRoute() + '/' + item.id + '/image?_=' + (item.last_picture_update || 0)}
                />
                <div className='suggestion-list__ellipsis'>
                    <span className='suggestion-list__main'>
                        {'@' + username}
                    </span>
                    <span>
                        {' '}
                        {description}
                    </span>
                </div>
                <BotBadge show={Boolean(item.is_bot)}/>
                <GuestBadge show={isGuest(item.roles)}/>
            </div>
        );
    }
}

export default class UserProvider extends Provider {
    autocompleteUsers: (text: string) => Promise<UserAutocomplete>;
    constructor(searchUsersFunc: (username: string) => Promise<UserAutocomplete>) {
        super();
        this.autocompleteUsers = searchUsersFunc;
    }
    async handlePretextChanged(pretext: string, resultsCallback: (res: ProviderResults) => void) {
        const normalizedPretext = pretext.toLowerCase();
        this.startNewRequest(normalizedPretext);

        const data = await this.autocompleteUsers(normalizedPretext);

        if (this.shouldCancelDispatch(normalizedPretext)) {
            return false;
        }

        const users = Object.assign([], data.users);

        resultsCallback({
            matchedPretext: normalizedPretext,
            terms: users.map((user: UserProfile) => user.username),
            items: users,
            component: UserSuggestion,
        });

        return true;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {ProviderResults} from './generic_user_provider';

import Provider from './provider';
import Suggestion from './suggestion.jsx';

class MenuActionSuggestion extends Suggestion {
    render() {
        const {item, isSelection} = this.props;

        let className = 'suggestion-list__item';
        if (isSelection) {
            className += ' suggestion--selected';
        }

        return (
            <div
                className={className}
                onClick={this.handleClick}
                onMouseMove={this.handleMouseMove}
                {...Suggestion.baseProps}
            >
                {item.text}
            </div>
        );
    }
}

export default class MenuActionProvider extends Provider {
    private options: Array<Record<string, any>>;

    constructor(options: Array<Record<string, any>>) {
        super();
        this.options = options;
    }

    handlePretextChanged(prefix: string, resultsCallback: (res: ProviderResults) => void) {
        if (prefix.length === 0) {
            this.displayAllOptions(resultsCallback);
            return true;
        }

        if (prefix) {
            this.filterOptions(prefix, resultsCallback);
            return true;
        }

        return false;
    }

    async displayAllOptions(resultsCallback: (res: ProviderResults) => void) {
        const terms = this.options.map((option) => option.text);

        resultsCallback({
            matchedPretext: '',
            terms,
            items: this.options,
            component: MenuActionSuggestion,
        });
    }

    async filterOptions(prefix: string, resultsCallback: (res: ProviderResults) => void) {
        const filteredOptions = this.options.filter((option) => option.text.toLowerCase().indexOf(prefix.toLowerCase()) >= 0);
        const terms = filteredOptions.map((option) => option.text);

        resultsCallback({
            matchedPretext: prefix,
            terms,
            items: filteredOptions,
            component: MenuActionSuggestion,
        });
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import PropTypes from 'prop-types';
import React from 'react';

import SuggestionList from 'components/suggestion/suggestion_list.jsx';
import {getClosestParent} from 'utils/utils';

export default class ModalSuggestionList extends React.PureComponent {
    static propTypes = {
        position: PropTypes.string.isRequired,
        open: PropTypes.bool.isRequired,
        cleared: PropTypes.bool.isRequired,
        inputRef: PropTypes.object.isRequired,
        onLoseVisibility: PropTypes.func.isRequired,
    }

    constructor(props) {
        super(props);

        this.state = {
            scroll: 0,
            modalBounds: {top: 0, bottom: 0},
            inputBounds: {top: 0, bottom: 0, width: 0},
            position: props.position,
        };

        this.container = React.createRef();
        this.suggestionList = React.createRef();
        this.latestHeight = 0;
    }

    calculateInputRect = () => {
        if (this.props.inputRef.current) {
            const rect = this.props.inputRef.current.getBoundingClientRect();
            return {top: rect.top, bottom: rect.bottom, width: rect.width};
        }
        return {top: 0, bottom: 0, width: 0};
    }

    onModalScroll = (e) => {
        if (this.state.scroll !== e.target.scrollTop &&
            this.latestHeight !== 0) {
            this.setState({scroll: e.target.scrollTop});
        }
    }

    componentDidMount() {
        if (this.container.current) {
            const modalBodyContainer = getClosestParent(this.container.current, '.modal-body');
            modalBodyContainer.addEventListener('scroll', this.onModalScroll);
        }
        window.addEventListener('resize', this.updateModalBounds);
    }

    componentWillUnmount() {
        if (this.container.current) {
            const modalBodyContainer = getClosestParent(this.container.current, '.modal-body');
            modalBodyContainer.removeEventListener('scroll', this.onModalScroll);
        }
        window.removeEventListener('resize', this.updateModalBounds);
    }

    componentDidUpdate(prevProps, prevState) {
        if (!this.props.open || this.props.cleared) {
            return;
        }

        if (prevProps.open !== this.state.open ||
            prevProps.cleared !== this.state.cleared ||
            prevState.scroll !== this.state.scroll ||
            prevState.modalBounds.top !== this.state.modalBounds.top ||
            prevState.modalBounds.bottom !== this.state.modalBounds.bottom) {
            const newInputBounds = this.updateInputBounds();
            this.updatePosition(newInputBounds);

            if (this.container.current) {
                const modalBodyRect = getClosestParent(this.container.current, '.modal-body').getBoundingClientRect();
                if ((newInputBounds.bottom < modalBodyRect.top) || (newInputBounds.top > modalBodyRect.bottom)) {
                    this.props.onLoseVisibility();
                    return;
                }
            }

            this.updateModalBounds();
        }
    }

    getChildHeight = () => {
        if (!this.container.current) {
            return 0;
        }

        const listElement = this.suggestionList.current?.getContent()?.[0];
        if (!listElement) {
            return 0;
        }

        return listElement.getBoundingClientRect().height;
    }

    updateInputBounds = () => {
        const inputBounds = this.calculateInputRect();
        if (inputBounds.top !== this.state.inputBounds.top ||
            inputBounds.bottom !== this.state.inputBounds.bottom ||
            inputBounds.width !== this.state.inputBounds.width) {
            this.setState({inputBounds});
        }
        return inputBounds;
    }

    updatePosition = (newInputBounds) => {
        let inputBounds = newInputBounds;
        if (!newInputBounds) {
            inputBounds = this.state.inputBounds;
        }

        if (!this.container.current) {
            return;
        }

        this.latestHeight = this.getChildHeight();

        let newPosition = this.props.position;
        if (window.innerHeight < inputBounds.bottom + this.latestHeight) {
            newPosition = 'top';
        }
        if (inputBounds.top - this.latestHeight < 0) {
            newPosition = 'bottom';
        }

        if (this.state.position !== newPosition) {
            this.setState({position: newPosition});
        }
    }

    updateModalBounds = () => {
        if (!this.container.current) {
            return;
        }

        const modalContainer = getClosestParent(this.container.current, '.modal-content');
        const modalBounds = modalContainer.getBoundingClientRect();

        if (this.state.modalBounds.top !== modalBounds.top || this.state.modalBounds.bottom !== modalBounds.bottom) {
            this.setState({modalBounds: {top: modalBounds.top, bottom: modalBounds.bottom}});
        }
    }

    render() {
        const {
            ...props
        } = this.props;

        Reflect.deleteProperty(props, 'onLoseVisibility');

        let position = {};
        if (this.state.position === 'top') {
            position = {bottom: this.state.modalBounds.bottom - this.state.inputBounds.top};
        } else {
            position = {top: this.state.inputBounds.bottom - this.state.modalBounds.top};
        }

        return (
            <div
                style={{position: 'fixed', zIndex: 101, width: this.state.inputBounds.width, ...position}}
                ref={this.container}
            >
                <SuggestionList
                    {...props}
                    position={this.state.position}
                    ref={this.suggestionList}
                />
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

export type ProviderResult = {
    matchedPretext: string;
    terms: string[];
    items: Array<Record<string, any>>;
    component?: React.ReactNode;
}

export default class Provider {
    latestPrefix: string;
    latestComplete: boolean;
    disableDispatches: boolean;
    requestStarted: boolean;
    forceDispatch: boolean;

    constructor() {
        this.latestPrefix = '';
        this.latestComplete = true;
        this.disableDispatches = false;
        this.requestStarted = false;
        this.forceDispatch = false;
    }

    handlePretextChanged(pretext: string, callback: (res: ProviderResult) => void) {// eslint-disable-line @typescript-eslint/no-unused-vars
        // NO-OP for inherited classes to override
    }

    resetRequest() {
        this.requestStarted = false;
    }

    startNewRequest(prefix: string) {
        this.latestPrefix = prefix;
        this.latestComplete = false;
        this.requestStarted = true;
    }

    shouldCancelDispatch(prefix: string) {
        if (this.forceDispatch) {
            return false;
        }

        if (this.disableDispatches) {
            return true;
        }

        if (!this.requestStarted) {
            return true;
        }

        if (prefix === this.latestPrefix) {
            this.latestComplete = true;
        } else if (this.latestComplete) {
            return true;
        }

        return false;
    }

    allowDividers() {
        return true;
    }

    presentationType() {
        return 'text';
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import PropTypes from 'prop-types';
import React from 'react';

export default class Suggestion extends React.PureComponent {
    static get propTypes() {
        return {
            item: PropTypes.oneOfType([
                PropTypes.object,
                PropTypes.string,
            ]).isRequired,
            term: PropTypes.string.isRequired,
            matchedPretext: PropTypes.string.isRequired,
            isSelection: PropTypes.bool,
            onClick: PropTypes.func,
            onMouseMove: PropTypes.func,
        };
    }

    static baseProps = {
        role: 'button',
        tabIndex: -1,
    };

    handleClick = (e) => {
        e.preventDefault();

        this.props.onClick(this.props.term, this.props.matchedPretext);
    }

    handleMouseMove = (e) => {
        e.preventDefault();

        this.props.onMouseMove(this.props.term);
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import PropTypes from 'prop-types';
import React from 'react';

import EventEmitter from 'mattermost-redux/utils/event_emitter';

import QuickInput from 'components/quick_input';
import Constants from 'utils/constants';
import * as UserAgent from 'utils/user_agent';
import * as Utils from 'utils/utils';

const EXECUTE_CURRENT_COMMAND_ITEM_ID = Constants.Integrations.EXECUTE_CURRENT_COMMAND_ITEM_ID;
const OPEN_COMMAND_IN_MODAL_ITEM_ID = Constants.Integrations.OPEN_COMMAND_IN_MODAL_ITEM_ID;
const KeyCodes = Constants.KeyCodes;

export default class SuggestionBox extends React.PureComponent {
    static propTypes = {

        /**
         * The list component to render, usually SuggestionList
         */
        listComponent: PropTypes.func.isRequired,

        /**
         * Where the list will be displayed relative to the input box, defaults to 'top'
         */
        listPosition: PropTypes.oneOf(['top', 'bottom']),

        /**
         * The input component to render (it is passed through props to the QuickInput)
         */
        inputComponent: PropTypes.elementType,

        /**
         * The date component to render
         */
        dateComponent: PropTypes.func,

        /**
         * The value of in the input
         */
        value: PropTypes.string.isRequired,

        /**
         * Array of suggestion providers
         */
        providers: PropTypes.arrayOf(PropTypes.object).isRequired,

        /**
         * CSS class for the div parent of the input box
         */
        containerClass: PropTypes.string,

        /**
         * Set to ['all'] to draw all available dividers, or use an array of the types of dividers to only render those
         * (e.g. [Constants.MENTION_RECENT_CHANNELS, Constants.MENTION_PUBLIC_CHANNELS]) between types of list items
         */
        renderDividers: PropTypes.arrayOf(PropTypes.string),

        /**
         * Set to true to render a message when there were no results found, defaults to false
         */
        renderNoResults: PropTypes.bool,

        /**
         * Set to true if we want the suggestions to take in the complete word as the pretext, defaults to false
         */
        shouldSearchCompleteText: PropTypes.bool,

        /**
         * Set to allow TAB to select an item in the list, defaults to true
         */
        completeOnTab: PropTypes.bool,

        /**
         * Function called when input box gains focus
         */
        onFocus: PropTypes.func,

        /**
         * Function called when input box loses focus
         */
        onBlur: PropTypes.func,

        /**
         * Function called when input box value changes
         */
        onChange: PropTypes.func,

        /**
         * Function called when a key is pressed and the input box is in focus
         */
        onKeyDown: PropTypes.func,
        onKeyPress: PropTypes.func,
        onComposition: PropTypes.func,

        onSelect: PropTypes.func,
        onSearchTypeSelected: PropTypes.func,

        /**
         * Function called when an item is selected
         */
        onItemSelected: PropTypes.func,

        /**
         * Flags if the suggestion_box is for the RHS (Reply).
         */
        isRHS: PropTypes.bool,

        /**
         * The number of characters required to show the suggestion list, defaults to 1
         */
        requiredCharacters: PropTypes.number,

        /**
         * If true, the suggestion box is opened on focus, default to false
         */
        openOnFocus: PropTypes.bool,

        /**
         * If true, the suggestion box is disabled
         */
        disabled: PropTypes.bool,

        /**
         * If true, it displays allow to display a default list when empty
         */
        openWhenEmpty: PropTypes.bool,

        /**
         * If true, replace all input in the suggestion box with the selected option after a select, defaults to false
         */
        replaceAllInputOnSelect: PropTypes.bool,

        /**
         * An optional, opaque identifier that distinguishes the context in which the suggestion
         * box is rendered. This allows the reused component to otherwise respond to changes.
         */
        contextId: PropTypes.string,

        /**
         * If true, listen for clicks on a mention and populate the input with said mention, defaults to false
         */
        listenForMentionKeyClick: PropTypes.bool,

        /**
         * Allows parent to access received suggestions
         */
        onSuggestionsReceived: PropTypes.func,

        /**
         * To show suggestions even when focus is lost
         */
        forceSuggestionsWhenBlur: PropTypes.bool,

        /**
         * aligns the suggestionlist with the textbox dimension
         */
        alignWithTextbox: PropTypes.bool,

        actions: PropTypes.shape({
            addMessageIntoHistory: PropTypes.func.isRequired,
        }).isRequired,
    }

    static defaultProps = {
        listPosition: 'top',
        containerClass: '',
        renderDividers: [],
        renderNoResults: false,
        shouldSearchCompleteText: false,
        completeOnTab: true,
        isRHS: false,
        requiredCharacters: 1,
        openOnFocus: false,
        openWhenEmpty: false,
        replaceAllInputOnSelect: false,
        listenForMentionKeyClick: false,
        forceSuggestionsWhenBlur: false,
        alignWithTextbox: false,
    }

    constructor(props) {
        super(props);
        this.suggestionReadOut = React.createRef();

        // Keep track of whether we're composing a CJK character so we can make suggestions for partial characters
        this.composing = false;

        this.pretext = '';

        // Used for debouncing pretext changes
        this.timeoutId = '';

        // Used for preventing suggestion list to close when scrollbar is clicked
        this.preventSuggestionListCloseFlag = false;

        // pretext: the text before the cursor
        // matchedPretext: a list of the text before the cursor that will be replaced if the corresponding autocomplete term is selected
        // terms: a list of strings which the previously typed text may be replaced by
        // items: a list of objects backing the terms which may be used in rendering
        // components: a list of react components that can be used to render their corresponding item
        // selection: the term currently selected by the keyboard
        this.state = {
            focused: false,
            cleared: true,
            matchedPretext: [],
            items: [],
            terms: [],
            components: [],
            selection: '',
            selectionIndex: 0,
            allowDividers: true,
            presentationType: 'text',
            suggestionBoxAlgn: undefined,
        };

        this.inputRef = React.createRef();
    }

    componentDidMount() {
        if (this.props.listenForMentionKeyClick) {
            EventEmitter.addListener('mention_key_click', this.handleMentionKeyClick);
        }
        this.handlePretextChanged(this.pretext);
    }

    componentWillUnmount() {
        EventEmitter.removeListener('mention_key_click', this.handleMentionKeyClick);
    }

    componentDidUpdate(prevProps) {
        const {value} = this.props;

        // Post was just submitted, update pretext property.
        if (value === '' && this.pretext !== value) {
            this.handlePretextChanged(value);
            return;
        }

        if (prevProps.contextId !== this.props.contextId) {
            const textbox = this.getTextbox();
            const pretext = textbox.value.substring(0, textbox.selectionEnd).toLowerCase();

            this.handlePretextChanged(pretext);
        }
    }

    handleMentionKeyClick = (mentionKey, isRHS) => {
        if (this.props.isRHS !== isRHS) {
            return;
        }

        let insertText = '@' + mentionKey;

        // if the current text does not end with a whitespace, then insert a space
        if (this.props.value && (/[^\s]$/).test(this.props.value)) {
            insertText = ' ' + insertText;
        }

        this.addTextAtCaret(insertText, '');
    }

    getTextbox = () => {
        if (!this.inputRef.current) {
            return null;
        }

        return this.inputRef.current;
    }

    handleEmitClearSuggestions = (delay = 0) => {
        setTimeout(() => {
            this.clear();
        }, delay);
    }

    preventSuggestionListClose = () => {
        this.preventSuggestionListCloseFlag = true;
    }

    handleFocusOut = (e) => {
        if (this.preventSuggestionListCloseFlag) {
            this.preventSuggestionListCloseFlag = false;
            return;
        }

        // Focus is switching TO e.relatedTarget, so only treat this as a blur event if we're not switching
        // between children (like from the textbox to the suggestion list)
        if (this.container.contains(e.relatedTarget)) {
            return;
        }

        if (UserAgent.isIos() && !e.relatedTarget) {
            // On Safari and iOS classic app, the autocomplete stays open
            // when you tap outside of the post textbox or search box.
            return;
        }

        if (!this.props.forceSuggestionsWhenBlur) {
            this.handleEmitClearSuggestions();
        }

        this.setState({focused: false});

        if (this.props.onBlur) {
            this.props.onBlur();
        }
    };

    handleFocusIn = (e) => {
        // Focus is switching FROM e.relatedTarget, so only treat this as a focus event if we're not switching
        // between children (like from the textbox to the suggestion list). PreventSuggestionListCloseFlag is
        // checked because if true, it means that the focusIn comes from a click in the suggestion box, an
        // option choice, so we don't want the focus event to be triggered
        if (this.container.contains(e.relatedTarget) || this.preventSuggestionListCloseFlag) {
            return;
        }

        this.setState({focused: true});

        if (this.props.openOnFocus || this.props.openWhenEmpty) {
            setTimeout(() => {
                const textbox = this.getTextbox();
                if (textbox) {
                    const pretext = textbox.value.substring(0, textbox.selectionEnd);
                    if (this.props.openWhenEmpty || pretext.length >= this.props.requiredCharacters) {
                        if (this.pretext !== pretext) {
                            this.handlePretextChanged(pretext);
                        }
                    }
                }
            });
        }

        if (this.props.onFocus) {
            this.props.onFocus();
        }
    };

    handleChange = (e) => {
        const textbox = this.getTextbox();
        const pretext = this.props.shouldSearchCompleteText ? textbox.value.trim() : textbox.value.substring(0, textbox.selectionEnd);

        if (!this.composing && this.pretext !== pretext) {
            this.handlePretextChanged(pretext);
        }

        if (this.props.onChange) {
            this.props.onChange(e);
        }
    }

    handleCompositionStart = () => {
        this.composing = true;
        if (this.props.onComposition) {
            this.props.onComposition();
        }
    }

    handleCompositionUpdate = (e) => {
        if (!e.data) {
            return;
        }

        // The caret appears before the CJK character currently being composed, so re-add it to the pretext
        const textbox = this.getTextbox();
        const pretext = textbox.value.substring(0, textbox.selectionStart) + e.data;

        this.handlePretextChanged(pretext);
        if (this.props.onComposition) {
            this.props.onComposition();
        }
    }

    handleCompositionEnd = () => {
        this.composing = false;
        if (this.props.onComposition) {
            this.props.onComposition();
        }
    }

    addTextAtCaret = (term, matchedPretext) => {
        const textbox = this.getTextbox();
        const caret = textbox.selectionEnd;
        const text = this.props.value;
        const pretext = textbox.value.substring(0, textbox.selectionEnd);

        let prefix;
        let keepPretext = false;
        if (pretext.toLowerCase().endsWith(matchedPretext.toLowerCase())) {
            prefix = pretext.substring(0, pretext.length - matchedPretext.length);
        } else {
            // the pretext has changed since we got a term to complete so see if the term still fits the pretext
            const termWithoutMatched = term.substring(matchedPretext.length);
            const overlap = SuggestionBox.findOverlap(pretext, termWithoutMatched);

            keepPretext = overlap.length === 0;
            prefix = pretext.substring(0, pretext.length - overlap.length - matchedPretext.length);
        }

        const suffix = text.substring(caret);

        let newValue;
        if (keepPretext) {
            newValue = pretext;
        } else {
            newValue = prefix + term + ' ' + suffix;
        }

        textbox.value = newValue;

        if (this.props.onChange) {
            // fake an input event to send back to parent components
            const e = {
                target: textbox,
            };

            // don't call handleChange or we'll get into an event loop
            this.props.onChange(e);
        }

        // set the caret position after the next rendering
        window.requestAnimationFrame(() => {
            if (textbox.value === newValue) {
                Utils.setCaretPosition(textbox, prefix.length + term.length + 1);
            }
        });
    }

    replaceText = (term) => {
        const textbox = this.getTextbox();
        textbox.value = term;

        if (this.props.onChange) {
            // fake an input event to send back to parent components
            const e = {
                target: textbox,
            };

            // don't call handleChange or we'll get into an event loop
            this.props.onChange(e);
        }
    }

    handleCompleteWord = (term, matchedPretext, e) => {
        let fixedTerm = term;
        let finish = false;
        let openCommandInModal = false;
        if (term.endsWith(EXECUTE_CURRENT_COMMAND_ITEM_ID)) {
            fixedTerm = term.substring(0, term.length - EXECUTE_CURRENT_COMMAND_ITEM_ID.length);
            finish = true;
        }

        if (term.endsWith(OPEN_COMMAND_IN_MODAL_ITEM_ID)) {
            fixedTerm = term.substring(0, term.length - OPEN_COMMAND_IN_MODAL_ITEM_ID.length);
            finish = true;
            openCommandInModal = true;
        }

        if (!finish) {
            if (this.props.replaceAllInputOnSelect) {
                this.replaceText(fixedTerm);
            } else {
                this.addTextAtCaret(fixedTerm, matchedPretext);
            }
        }

        if (this.props.onItemSelected) {
            const items = this.state.items;
            const terms = this.state.terms;
            for (let i = 0; i < terms.length; i++) {
                if (terms[i] === fixedTerm) {
                    this.props.onItemSelected(items[i]);
                    break;
                }
            }
        }

        this.clear();

        if (openCommandInModal) {
            const appProvider = this.props.providers.find((p) => p.openAppsModalFromCommand);
            if (!appProvider) {
                return false;
            }
            appProvider.openAppsModalFromCommand(fixedTerm);
            this.props.actions.addMessageIntoHistory(fixedTerm);
            this.inputRef.current.value = '';
            this.handleChange({target: this.inputRef.current});
            return false;
        }

        this.inputRef.current.focus();

        if (finish && this.props.onKeyPress) {
            let ke = e;
            if (!e || Utils.isKeyPressed(e, Constants.KeyCodes.TAB)) {
                ke = new KeyboardEvent('keydown', {
                    bubbles: true, cancelable: true, keyCode: 13,
                });
                if (e) {
                    e.preventDefault();
                }
            }
            this.props.onKeyPress(ke);
            return true;
        }

        if (!finish) {
            for (const provider of this.props.providers) {
                if (provider.handleCompleteWord) {
                    provider.handleCompleteWord(fixedTerm, matchedPretext, this.handlePretextChanged);
                }
            }
        }
        return false;
    }

    selectNext = () => {
        this.setSelectionByDelta(1);
    }

    selectPrevious = () => {
        this.setSelectionByDelta(-1);
    }

    setSelectionByDelta = (delta) => {
        let selectionIndex = this.state.terms.indexOf(this.state.selection);

        if (selectionIndex === -1) {
            this.setState({
                selection: '',
            });
            return;
        }

        selectionIndex += delta;

        if (selectionIndex < 0) {
            selectionIndex = 0;
        } else if (selectionIndex > this.state.terms.length - 1) {
            selectionIndex = this.state.terms.length - 1;
        }

        this.setState({
            selection: this.state.terms[selectionIndex],
            selectionIndex,
        });
    }

    setSelection = (term) => {
        const selectionIndex = this.state.terms.indexOf(this.state.selection);

        this.setState({
            selection: term,
            selectionIndex,
        });
    }

    clear = () => {
        if (!this.state.cleared) {
            this.setState({
                cleared: true,
                matchedPretext: [],
                terms: [],
                items: [],
                components: [],
                selection: '',
                suggestionBoxAlgn: undefined,
            });
            this.handlePretextChanged('');
        }
    }

    hasSuggestions = () => {
        return this.state.items.some((item) => !item.loading);
    }

    handleKeyDown = (e) => {
        if ((this.props.openWhenEmpty || this.props.value) && this.hasSuggestions()) {
            const ctrlOrMetaKeyPressed = e.ctrlKey || e.metaKey;
            if (Utils.isKeyPressed(e, KeyCodes.UP)) {
                this.selectPrevious();
                e.preventDefault();
            } else if (Utils.isKeyPressed(e, KeyCodes.DOWN)) {
                this.selectNext();
                e.preventDefault();
            } else if ((Utils.isKeyPressed(e, KeyCodes.ENTER) && !ctrlOrMetaKeyPressed) || (this.props.completeOnTab && Utils.isKeyPressed(e, KeyCodes.TAB))) {
                let matchedPretext = '';
                for (let i = 0; i < this.state.terms.length; i++) {
                    if (this.state.terms[i] === this.state.selection) {
                        matchedPretext = this.state.matchedPretext[i];
                    }
                }

                // If these don't match, the user typed quickly and pressed enter before we could
                // update the pretext, so update the pretext before completing
                if (this.pretext.toLowerCase().endsWith(matchedPretext.toLowerCase())) {
                    if (this.handleCompleteWord(this.state.selection, matchedPretext, e)) {
                        return;
                    }
                } else {
                    clearTimeout(this.timeoutId);
                    this.nonDebouncedPretextChanged(this.pretext, true);
                }

                if (this.props.onKeyDown) {
                    this.props.onKeyDown(e);
                }
                e.preventDefault();
            } else if (Utils.isKeyPressed(e, KeyCodes.ESCAPE)) {
                this.clear();
                this.setState({presentationType: 'text'});
                e.preventDefault();
            } else if (this.props.onKeyDown) {
                this.props.onKeyDown(e);
            }
        } else if (this.props.onKeyDown) {
            this.props.onKeyDown(e);
        }
    }

    handleSelect = (e) => {
        if (this.props.onSelect) {
            this.props.onSelect(e);
        }
    }

    handleReceivedSuggestions = (suggestions) => {
        let newComponents = [];
        const newPretext = [];
        if (this.props.onSuggestionsReceived) {
            this.props.onSuggestionsReceived(suggestions);
        }

        for (let i = 0; i < suggestions.terms.length; i++) {
            newComponents.push(suggestions.component);
            newPretext.push(suggestions.matchedPretext);
        }

        if (suggestions.components) {
            newComponents = suggestions.components;
        }

        const terms = suggestions.terms;
        const items = suggestions.items;
        let selection = this.state.selection;
        const selectionIndex = terms.indexOf(selection);
        if (selectionIndex !== this.state.selectionIndex) {
            if (terms.length > 0) {
                selection = terms[0];
            } else if (this.state.selection) {
                selection = '';
            }
        }

        this.setState({
            cleared: false,
            selection,
            terms,
            items,
            components: newComponents,
            matchedPretext: newPretext,
        });

        return {selection, matchedPretext: suggestions.matchedPretext};
    }

    handleReceivedSuggestionsAndComplete = (suggestions) => {
        const {selection, matchedPretext} = this.handleReceivedSuggestions(suggestions);
        if (selection) {
            this.handleCompleteWord(selection, matchedPretext);
        }
    }

    nonDebouncedPretextChanged = (pretext, complete = false) => {
        const {alignWithTextbox} = this.props;
        this.pretext = pretext;
        let handled = false;
        let callback = this.handleReceivedSuggestions;
        if (complete) {
            callback = this.handleReceivedSuggestionsAndComplete;
        }
        for (const provider of this.props.providers) {
            handled = provider.handlePretextChanged(pretext, callback) || handled;

            if (handled) {
                if (!this.state.suggestionBoxAlgn && ['@', ':', '~', '/'].includes(provider.triggerCharacter)) {
                    const char = provider.triggerCharacter;
                    const pxToSubstract = Utils.getPxToSubstract(char);

                    // get the alignment for the box and set it in the component state
                    const suggestionBoxAlgn = Utils.getSuggestionBoxAlgn(this.getTextbox(), pxToSubstract, alignWithTextbox);
                    this.setState({
                        suggestionBoxAlgn,
                    });
                }

                this.setState({
                    presentationType: provider.presentationType(),
                    allowDividers: provider.allowDividers(),
                });

                break;
            }
        }
        if (!handled) {
            this.clear();
        }
    }

    debouncedPretextChanged = (pretext) => {
        clearTimeout(this.timeoutId);
        this.timeoutId = setTimeout(() => this.nonDebouncedPretextChanged(pretext), Constants.SEARCH_TIMEOUT_MILLISECONDS);
    };

    handlePretextChanged = (pretext) => {
        this.pretext = pretext;
        this.debouncedPretextChanged(pretext);
    }

    blur = () => {
        this.inputRef.current.blur();
    }

    focus = () => {
        const input = this.inputRef.current;
        if (input.value === '""' || input.value.endsWith('""')) {
            input.selectionStart = input.value.length - 1;
            input.selectionEnd = input.value.length - 1;
        } else {
            input.selectionStart = input.value.length;
        }
        input.focus();

        this.handleChange({target: this.inputRef.current});
    }

    setContainerRef = (container) => {
        // Attach/detach event listeners that aren't supported by React
        if (this.container) {
            this.container.removeEventListener('focusin', this.handleFocusIn);
            this.container.removeEventListener('focusout', this.handleFocusOut);
        }

        if (container) {
            container.addEventListener('focusin', this.handleFocusIn);
            container.addEventListener('focusout', this.handleFocusOut);
        }

        // Save ref
        this.container = container;
    };

    getListPosition = (listPosition) => {
        if (!this.state.suggestionBoxAlgn) {
            return listPosition;
        }

        return listPosition === 'bottom' && this.state.suggestionBoxAlgn.placementShift ? 'top' : listPosition;
    }

    render() {
        const {
            dateComponent,
            listComponent,
            listPosition,
            renderNoResults,
            ...props
        } = this.props;

        // set the renderDivider const to either the value stored in the renderDividers prop or an empty string
        // (the renderDividers prop can also probably be a empty string, but is not guaranteed to be)
        let renderDividers;
        if (this.state.allowDividers) {
            renderDividers = this.props.renderDividers;
        }

        // Don't pass props used by SuggestionBox
        Reflect.deleteProperty(props, 'providers');
        Reflect.deleteProperty(props, 'onChange'); // We use onInput instead of onChange on the actual input
        Reflect.deleteProperty(props, 'onComposition');
        Reflect.deleteProperty(props, 'onItemSelected');
        Reflect.deleteProperty(props, 'completeOnTab');
        Reflect.deleteProperty(props, 'isRHS');
        Reflect.deleteProperty(props, 'requiredCharacters');
        Reflect.deleteProperty(props, 'openOnFocus');
        Reflect.deleteProperty(props, 'openWhenEmpty');
        Reflect.deleteProperty(props, 'onFocus');
        Reflect.deleteProperty(props, 'onBlur');
        Reflect.deleteProperty(props, 'containerClass');
        Reflect.deleteProperty(props, 'replaceAllInputOnSelect');
        Reflect.deleteProperty(props, 'renderDividers');
        Reflect.deleteProperty(props, 'contextId');
        Reflect.deleteProperty(props, 'listenForMentionKeyClick');
        Reflect.deleteProperty(props, 'forceSuggestionsWhenBlur');
        Reflect.deleteProperty(props, 'onSuggestionsReceived');
        Reflect.deleteProperty(props, 'actions');
        Reflect.deleteProperty(props, 'shouldSearchCompleteText');
        Reflect.deleteProperty(props, 'alignWithTextbox');

        // This needs to be upper case so React doesn't think it's an html tag
        const SuggestionListComponent = listComponent;
        const SuggestionDateComponent = dateComponent;

        return (
            <div
                ref={this.setContainerRef}
                className={this.props.containerClass}
            >
                <div
                    ref={this.suggestionReadOut}
                    aria-live='polite'
                    role='alert'
                    className='sr-only'
                />
                <QuickInput
                    ref={this.inputRef}
                    autoComplete='off'
                    {...props}
                    onInput={this.handleChange}
                    onCompositionStart={this.handleCompositionStart}
                    onCompositionUpdate={this.handleCompositionUpdate}
                    onCompositionEnd={this.handleCompositionEnd}
                    onKeyDown={this.handleKeyDown}
                    onSelect={this.handleSelect}
                />
                {(this.props.openWhenEmpty || this.props.value.length >= this.props.requiredCharacters) && this.state.presentationType === 'text' && (
                    <SuggestionListComponent
                        ariaLiveRef={this.suggestionReadOut}
                        open={this.state.focused || this.props.forceSuggestionsWhenBlur}
                        pretext={this.pretext}
                        position={this.getListPosition(listPosition)}
                        renderDividers={renderDividers}
                        renderNoResults={renderNoResults}
                        onCompleteWord={this.handleCompleteWord}
                        preventClose={this.preventSuggestionListClose}
                        onItemHover={this.setSelection}
                        cleared={this.state.cleared}
                        matchedPretext={this.state.matchedPretext}
                        items={this.state.items}
                        terms={this.state.terms}
                        suggestionBoxAlgn={this.state.suggestionBoxAlgn}
                        selection={this.state.selection}
                        components={this.state.components}
                        inputRef={this.inputRef}
                        onLoseVisibility={this.blur}
                    />
                )}
                {(this.props.openWhenEmpty || this.props.value.length >= this.props.requiredCharacters) && this.state.presentationType === 'date' &&
                    <SuggestionDateComponent
                        items={this.state.items}
                        terms={this.state.terms}
                        components={this.state.components}
                        matchedPretext={this.state.matchedPretext}
                        onCompleteWord={this.handleCompleteWord}
                    />
                }
            </div>
        );
    }

    // Finds the longest substring that's at both the end of b and the start of a. For example,
    // if a = "firepit" and b = "pitbull", findOverlap would return "pit".
    static findOverlap(a, b) {
        const aLower = a.toLowerCase();
        const bLower = b.toLowerCase();

        for (let i = bLower.length; i > 0; i--) {
            const substring = bLower.substring(0, i);

            if (aLower.endsWith(substring)) {
                return substring;
            }
        }

        return '';
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';

import {addMessageIntoHistory} from 'mattermost-redux/actions/posts';

import SuggestionBox from './suggestion_box';

function mapDispatchToProps(dispatch) {
    return {
        actions: bindActionCreators({
            addMessageIntoHistory,
        }, dispatch),
    };
}
export default connect(null, mapDispatchToProps, null, {forwardRef: true})(SuggestionBox);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import PropTypes from 'prop-types';
import React from 'react';
import ReactDOM from 'react-dom';
import {FormattedMessage} from 'react-intl';
import {cloneDeep} from 'lodash';

import {Constants} from 'utils/constants';

import {isEmptyObject} from 'utils/utils';
import FormattedMarkdownMessage from 'components/formatted_markdown_message';
import LoadingSpinner from 'components/widgets/loading/loading_spinner';

// When this file is migrated to TypeScript, type definitions for its props already exist in ./suggestion_list.d.ts.

export default class SuggestionList extends React.PureComponent {
    static propTypes = {
        ariaLiveRef: PropTypes.object,
        inputRef: PropTypes.object,
        open: PropTypes.bool.isRequired,
        position: PropTypes.oneOf(['top', 'bottom']),
        renderDividers: PropTypes.arrayOf(PropTypes.string),
        renderNoResults: PropTypes.bool,
        onCompleteWord: PropTypes.func.isRequired,
        preventClose: PropTypes.func,
        onItemHover: PropTypes.func.isRequired,
        pretext: PropTypes.string.isRequired,
        cleared: PropTypes.bool.isRequired,
        matchedPretext: PropTypes.array.isRequired,
        items: PropTypes.array.isRequired,
        terms: PropTypes.array.isRequired,
        selection: PropTypes.string.isRequired,
        components: PropTypes.array.isRequired,
        suggestionBoxAlgn: PropTypes.object,
    };

    static defaultProps = {
        renderDividers: [],
        renderNoResults: false,
    };

    constructor(props) {
        super(props);

        this.contentRef = React.createRef();
        this.wrapperRef = React.createRef();
        this.itemRefs = new Map();
        this.suggestionReadOut = React.createRef();
        this.currentLabel = '';
        this.currentItem = {};
    }

    componentDidMount() {
        this.updateMaxHeight();
    }

    componentDidUpdate(prevProps) {
        if (this.props.selection !== prevProps.selection && this.props.selection) {
            this.scrollToItem(this.props.selection);
        }

        if (!isEmptyObject(this.currentItem)) {
            this.generateLabel(this.currentItem);
        }

        if (this.props.items.length > 0 && prevProps.items.length === 0) {
            this.updateMaxHeight();
        }
    }

    componentWillUnmount() {
        this.removeLabel();
    }

    updateMaxHeight = () => {
        if (!this.props.inputRef?.current) {
            return;
        }

        const inputHeight = this.props.inputRef.current.clientHeight ?? 0;

        this.maxHeight = Math.min(
            window.innerHeight - (inputHeight + Constants.POST_MODAL_PADDING),
            Constants.SUGGESTION_LIST_MAXHEIGHT,
        );

        if (this.contentRef.current) {
            this.contentRef.current.style['max-height'] = this.maxHeight;
        }
    }

    announceLabel() {
        const suggestionReadOut = this.props.ariaLiveRef.current;
        if (suggestionReadOut) {
            suggestionReadOut.innerHTML = this.currentLabel;
        }
    }

    removeLabel() {
        const suggestionReadOut = this.props.ariaLiveRef.current;
        if (suggestionReadOut) {
            suggestionReadOut.innerHTML = '';
        }
    }

    generateLabel(item) {
        if (item.username) {
            this.currentLabel = item.username;
            if ((item.first_name || item.last_name) && item.nickname) {
                this.currentLabel += ` ${item.first_name} ${item.last_name} ${item.nickname}`;
            } else if (item.nickname) {
                this.currentLabel += ` ${item.nickname}`;
            } else if (item.first_name || item.last_name) {
                this.currentLabel += ` ${item.first_name} ${item.last_name}`;
            }
        } else if (item.type === 'mention.channels') {
            this.currentLabel = item.channel.display_name;
        } else if (item.emoji) {
            this.currentLabel = item.name;
        }

        if (this.currentLabel) {
            this.currentLabel = this.currentLabel.toLowerCase();
        }
        this.announceLabel();
    }

    getContent = () => {
        return this.contentRef.current;
    }

    scrollToItem = (term) => {
        const content = this.getContent();
        if (!content) {
            return;
        }

        const visibleContentHeight = content.clientHeight;
        const actualContentHeight = content.scrollHeight;

        if (visibleContentHeight < actualContentHeight) {
            const contentTop = content.scrollTop;
            const contentTopPadding = this.getComputedCssProperty(content, 'paddingTop');
            const contentBottomPadding = this.getComputedCssProperty(content, 'paddingTop');

            const item = ReactDOM.findDOMNode(this.itemRefs.get(term));
            if (!item) {
                return;
            }

            const itemTop = item.offsetTop - this.getComputedCssProperty(item, 'marginTop');
            const itemBottomMargin = this.getComputedCssProperty(item, 'marginBottom') + this.getComputedCssProperty(item, 'paddingBottom');
            const itemBottom = item.offsetTop + this.getComputedCssProperty(item, 'height') + itemBottomMargin;

            if (itemTop - contentTopPadding < contentTop) {
                // the item is off the top of the visible space
                content.scrollTop = itemTop - contentTopPadding;
            } else if (itemBottom + contentTopPadding + contentBottomPadding > contentTop + visibleContentHeight) {
                // the item has gone off the bottom of the visible space
                content.scrollTop = (itemBottom - visibleContentHeight) + contentTopPadding + contentBottomPadding;
            }
        }
    }

    getComputedCssProperty(element, property) {
        return parseInt(getComputedStyle(element)[property], 10);
    }

    getTransform() {
        if (!this.props.suggestionBoxAlgn) {
            return {};
        }

        const {lineHeight, pixelsToMoveX} = this.props.suggestionBoxAlgn;
        let pixelsToMoveY = this.props.suggestionBoxAlgn.pixelsToMoveY;

        if (this.props.position === 'bottom') {
            // Add the line height and 4 extra px so it looks less tight
            pixelsToMoveY += this.props.suggestionBoxAlgn.lineHeight + 4;
        }

        // If the suggestion box was invoked from the first line in the post box, stick to the top of the post box
        pixelsToMoveY = pixelsToMoveY > lineHeight ? pixelsToMoveY : 0;

        return {
            transform: `translate(${pixelsToMoveX}px, ${pixelsToMoveY}px)`,
        };
    }

    renderDivider(type) {
        const id = type ? 'suggestion.' + type : 'suggestion.default';
        return (
            <div
                key={type + '-divider'}
                className='suggestion-list__divider'
            >
                <span>
                    <FormattedMessage id={id}/>
                </span>
            </div>
        );
    }

    renderNoResults() {
        return (
            <div
                key='list-no-results'
                className='suggestion-list__no-results'
                ref={this.contentRef}
            >
                <FormattedMarkdownMessage
                    id='suggestion_list.no_matches'
                    defaultMessage='No items match __{value}__'
                    values={{
                        value: this.props.pretext || '""',
                    }}
                />
            </div>
        );
    }

    render() {
        const {renderDividers} = this.props;

        if (!this.props.open || this.props.cleared) {
            return null;
        }

        const clonedItems = cloneDeep(this.props.items);

        const items = [];
        if (clonedItems.length === 0) {
            if (!this.props.renderNoResults) {
                return null;
            }
            items.push(this.renderNoResults());
        }

        let prevItemType = null;
        for (let i = 0; i < this.props.items.length; i++) {
            const item = this.props.items[i];
            const term = this.props.terms[i];
            const isSelection = term === this.props.selection;

            // ReactComponent names need to be upper case when used in JSX
            const Component = this.props.components[i];
            if ((renderDividers.includes('all') || renderDividers.includes(item.type)) && prevItemType !== item.type) {
                items.push(this.renderDivider(item.type));
                prevItemType = item.type;
            }

            if (item.loading) {
                items.push(<LoadingSpinner key={item.type}/>);
                continue;
            }

            if (isSelection) {
                this.currentItem = item;
            }

            items.push(
                <Component
                    key={term}
                    ref={(ref) => this.itemRefs.set(term, ref)}
                    item={this.props.items[i]}
                    term={term}
                    matchedPretext={this.props.matchedPretext[i]}
                    isSelection={isSelection}
                    onClick={this.props.onCompleteWord}
                    onMouseMove={this.props.onItemHover}
                />,
            );
        }
        const mainClass = 'suggestion-list suggestion-list--' + this.props.position;
        const contentClass = 'suggestion-list__content suggestion-list__content--' + this.props.position;

        return (
            <div
                ref={this.wrapperRef}
                className={mainClass}
            >
                <div
                    id='suggestionList'
                    role='list'
                    ref={this.contentRef}
                    style={{
                        maxHeight: this.maxHeight,
                        ...this.getTransform(),
                    }}
                    className={contentClass}
                    onMouseDown={this.props.preventClose}
                >
                    {items}
                </div>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import PropTypes from 'prop-types';
import {connect} from 'react-redux';
import classNames from 'classnames';

import {UserTypes} from 'mattermost-redux/action_types';
import {Client4} from 'mattermost-redux/client';
import {
    getDirectAndGroupChannels,
    getGroupChannels,
    getMyChannelMemberships,
    getChannelByName,
    getCurrentChannel,
    getDirectTeammate,
    getChannelsInAllTeams,
    getSortedAllTeamsUnreadChannels,
    getAllTeamsUnreadChannelIds,
} from 'mattermost-redux/selectors/entities/channels';
import ProfilePicture from '../profile_picture';
import {getMyPreferences, isGroupChannelManuallyVisible, isCollapsedThreadsEnabled, insightsAreEnabled} from 'mattermost-redux/selectors/entities/preferences';
import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {
    getCurrentTeamId,
    getMyTeams,
    getTeam,
} from 'mattermost-redux/selectors/entities/teams';
import {
    getCurrentUserId,
    getUserIdsInChannels,
    getUser,
    makeSearchProfilesMatchingWithTerm,
    getStatusForUserId,
    getUserByUsername,
} from 'mattermost-redux/selectors/entities/users';
import {fetchAllMyTeamsChannelsAndChannelMembersREST, searchAllChannels} from 'mattermost-redux/actions/channels';
import {getThreadCountsInCurrentTeam} from 'mattermost-redux/selectors/entities/threads';
import {logError} from 'mattermost-redux/actions/errors';
import {sortChannelsByTypeAndDisplayName, isChannelMuted} from 'mattermost-redux/utils/channel_utils';
import SharedChannelIndicator from 'components/shared_channel_indicator';
import BotBadge from 'components/widgets/badges/bot_badge';
import GuestBadge from 'components/widgets/badges/guest_badge';
import CustomStatusEmoji from 'components/custom_status/custom_status_emoji';
import {getPostDraft} from 'selectors/rhs';
import store from 'stores/redux_store.jsx';
import {Constants, StoragePrefixes} from 'utils/constants';
import * as Utils from 'utils/utils';
import {isGuest} from 'mattermost-redux/utils/user_utils';
import {Preferences} from 'mattermost-redux/constants';
import {getPreferenceKey} from 'mattermost-redux/utils/preference_utils';

import Provider from './provider';
import Suggestion from './suggestion.jsx';

const getState = store.getState;
const searchProfilesMatchingWithTerm = makeSearchProfilesMatchingWithTerm();
const ThreadsChannel = {
    id: 'threads',
    name: 'threads',
    display_name: 'Threads',
    type: Constants.THREADS,
    delete_at: 0,
};

const InsightsChannel = {
    id: 'insights',
    name: 'activity-and-insights',
    display_name: 'Insights',
    type: Constants.INSIGHTS,
    delete_at: 0,
};

class SwitchChannelSuggestion extends Suggestion {
    static get propTypes() {
        return {
            ...super.propTypes,
            channelMember: PropTypes.object,
            hasDraft: PropTypes.bool,
            userImageUrl: PropTypes.string,
            dmChannelTeammate: PropTypes.object,
            collapsedThreads: PropTypes.bool,
        };
    }

    render() {
        const {item, isSelection, userImageUrl, status, userItem, collapsedThreads, team, isPartOfOnlyOneTeam} = this.props;
        const channel = item.channel;
        const channelIsArchived = channel.delete_at && channel.delete_at !== 0;

        const member = this.props.channelMember;
        const teammate = this.props.dmChannelTeammate;
        let badge = null;

        if ((member && member.notify_props) || item.unread_mentions) {
            let unreadMentions;
            if (item.unread_mentions) {
                unreadMentions = item.unread_mentions;
            } else {
                unreadMentions = collapsedThreads ? member.mention_count_root : member.mention_count;
            }
            if (unreadMentions > 0) {
                badge = (
                    <div className={classNames('suggestion-list_unread-mentions', (isPartOfOnlyOneTeam ? 'position-end' : ''))}>
                        <span className='badge'>
                            {unreadMentions}
                        </span>
                    </div>
                );
            }
        }

        let className = 'suggestion-list__item';
        if (isSelection) {
            className += ' suggestion--selected';
        }

        let name = channel.display_name;
        let description = '~' + channel.name;
        let icon;
        if (channelIsArchived) {
            icon = (
                <span className='suggestion-list__icon suggestion-list__icon--large'>
                    <i className='icon icon-archive-outline'/>
                </span>
            );
        } else if (this.props.hasDraft) {
            icon = (
                <span className='suggestion-list__icon suggestion-list__icon--large'>
                    <i className='icon icon-pencil-outline'/>
                </span>
            );
        } else if (channel.type === Constants.OPEN_CHANNEL) {
            icon = (
                <span className='suggestion-list__icon suggestion-list__icon--large'>
                    <i className='icon icon-globe'/>
                </span>
            );
        } else if (channel.type === Constants.PRIVATE_CHANNEL) {
            icon = (
                <span className='suggestion-list__icon suggestion-list__icon--large'>
                    <i className='icon icon-lock-outline'/>
                </span>
            );
        } else if (channel.type === Constants.THREADS) {
            icon = (
                <span className='suggestion-list__icon suggestion-list__icon--large'>
                    <i className='icon icon-message-text-outline'/>
                </span>
            );
        } else if (channel.type === Constants.INSIGHTS) {
            icon = (
                <span className='suggestion-list__icon suggestion-list__icon--large'>
                    <i className='icon icon-chart-line'/>
                </span>
            );
        } else if (channel.type === Constants.GM_CHANNEL) {
            icon = (
                <span className='suggestion-list__icon suggestion-list__icon--large'>
                    <div className='status status--group'>{'G'}</div>
                </span>
            );
        } else {
            icon = (
                <ProfilePicture
                    src={userImageUrl}
                    status={teammate && teammate.is_bot ? null : status}
                    size='sm'
                />
            );
        }

        let tag = null;
        let customStatus = null;
        if (channel.type === Constants.DM_CHANNEL) {
            tag = (
                <React.Fragment>
                    <BotBadge
                        show={Boolean(teammate && teammate.is_bot)}
                        className='badge-autocomplete'
                    />
                    <GuestBadge
                        show={Boolean(teammate && isGuest(teammate.roles))}
                        className='badge-autocomplete'
                    />
                </React.Fragment>
            );

            customStatus = (
                <CustomStatusEmoji
                    showTooltip={true}
                    userID={userItem.id}
                    emojiStyle={{
                        marginBottom: 2,
                        marginLeft: 8,
                    }}
                />
            );

            let deactivated = '';
            if (userItem.delete_at) {
                deactivated = (' - ' + Utils.localizeMessage('channel_switch_modal.deactivated', 'Deactivated'));
            }

            if (channel.display_name && !(teammate && teammate.is_bot)) {
                description = '@' + userItem.username + deactivated;
            } else {
                name = userItem.username;
                const currentUserId = getCurrentUserId(getState());
                if (userItem.id === currentUserId) {
                    name += (' ' + Utils.localizeMessage('suggestion.user.isCurrent', '(you)'));
                }
                description = deactivated;
            }
        } else if (channel.type === Constants.GM_CHANNEL) {
            // remove the slug from the option
            name = channel.display_name;
            description = '';
        }

        let sharedIcon = null;
        if (channel.shared) {
            sharedIcon = (
                <SharedChannelIndicator
                    className='shared-channel-icon'
                    channelType={channel.type}
                />
            );
        }

        let teamName = null;
        if (channel.team_id && team) {
            teamName = (<span className='ml-2 suggestion-list__team-name'>{team.display_name}</span>);
        }
        const showSlug = (isPartOfOnlyOneTeam || channel.type === Constants.DM_CHANNEL) && channel.type !== Constants.THREADS;

        return (
            <div
                onClick={this.handleClick}
                onMouseMove={this.handleMouseMove}
                className={className}
                role='listitem'
                ref={(node) => {
                    this.node = node;
                }}
                id={`switchChannel_${channel.name}`}
                data-testid={channel.name}
                aria-label={name}
                {...Suggestion.baseProps}
            >
                {icon}
                <div className='suggestion-list__ellipsis suggestion-list__flex'>
                    <span className='suggestion-list__main'>
                        <span className={item.unread ? 'suggestion-list__unread' : ''}>{name}</span>
                        {showSlug && <span className='ml-2 suggestion-list__desc'>{description}</span>}
                    </span>
                    {customStatus}
                    {sharedIcon}
                    {tag}
                    {badge}
                    {!isPartOfOnlyOneTeam && teamName}
                </div>
            </div>
        );
    }
}

function mapStateToPropsForSwitchChannelSuggestion(state, ownProps) {
    const channel = ownProps.item && ownProps.item.channel;
    const channelId = channel ? channel.id : '';
    const draft = channelId ? getPostDraft(state, StoragePrefixes.DRAFT, channelId) : false;
    const user = channel && getUser(state, channel.userId);
    const userImageUrl = user && Utils.imageURLForUser(user.id, user.last_picture_update);
    let dmChannelTeammate = channel && channel.type === Constants.DM_CHANNEL && getDirectTeammate(state, channel.id);
    const userItem = getUserByUsername(state, channel.name);
    const status = getStatusForUserId(state, channel.userId);
    const collapsedThreads = isCollapsedThreadsEnabled(state);
    const team = getTeam(state, channel.team_id);
    const isPartOfOnlyOneTeam = getMyTeams(state).length === 1;

    if (channel && !dmChannelTeammate) {
        dmChannelTeammate = getUser(state, channel.userId);
    }

    return {
        channelMember: getMyChannelMemberships(state)[channelId],
        hasDraft: draft && Boolean(draft.message.trim() || draft.fileInfos.length || draft.uploadsInProgress.length),
        userImageUrl,
        dmChannelTeammate,
        status,
        userItem,
        collapsedThreads,
        team,
        isPartOfOnlyOneTeam,
    };
}

const ConnectedSwitchChannelSuggestion = connect(mapStateToPropsForSwitchChannelSuggestion, null, null, {forwardRef: true})(SwitchChannelSuggestion);

let prefix = '';

function sortChannelsByRecencyAndTypeAndDisplayName(wrappedA, wrappedB) {
    if (wrappedA.last_viewed_at && wrappedB.last_viewed_at) {
        return wrappedB.last_viewed_at - wrappedA.last_viewed_at;
    } else if (wrappedA.last_viewed_at) {
        return -1;
    } else if (wrappedB.last_viewed_at) {
        return 1;
    }

    // MM-12677 When this is migrated this needs to be fixed to pull the user's locale
    return sortChannelsByTypeAndDisplayName('en', wrappedA.channel, wrappedB.channel);
}

export function quickSwitchSorter(wrappedA, wrappedB) {
    const aIsArchived = wrappedA.channel.delete_at ? wrappedA.channel.delete_at !== 0 : false;
    const bIsArchived = wrappedB.channel.delete_at ? wrappedB.channel.delete_at !== 0 : false;

    if (aIsArchived && !bIsArchived) {
        return 1;
    } else if (!aIsArchived && bIsArchived) {
        return -1;
    }

    if (wrappedA.deactivated && !wrappedB.deactivated) {
        return 1;
    } else if (wrappedB.deactivated && !wrappedA.deactivated) {
        return -1;
    }

    const a = wrappedA.channel;
    const b = wrappedB.channel;

    let aDisplayName = a.display_name.toLowerCase();
    let bDisplayName = b.display_name.toLowerCase();

    if (a.type === Constants.DM_CHANNEL && aDisplayName.startsWith('@')) {
        aDisplayName = aDisplayName.substring(1);
    }

    if (b.type === Constants.DM_CHANNEL && bDisplayName.startsWith('@')) {
        bDisplayName = bDisplayName.substring(1);
    }

    const aStartsWith = aDisplayName.startsWith(prefix) || wrappedA.name.toLowerCase().startsWith(prefix);
    const bStartsWith = bDisplayName.startsWith(prefix) || wrappedB.name.toLowerCase().startsWith(prefix);

    // Open channels user haven't interacted should be at the  bottom of the list
    if (a.type === Constants.OPEN_CHANNEL && !wrappedA.last_viewed_at && (b.type !== Constants.OPEN_CHANNEL || wrappedB.last_viewed_at)) {
        return 1;
    } else if (b.type === Constants.OPEN_CHANNEL && !wrappedB.last_viewed_at) {
        return -1;
    }

    // Sort channels starting with the search term first
    if (aStartsWith && !bStartsWith) {
        return -1;
    } else if (!aStartsWith && bStartsWith) {
        return 1;
    }
    return sortChannelsByRecencyAndTypeAndDisplayName(wrappedA, wrappedB);
}

function makeChannelSearchFilter(channelPrefix) {
    const channelPrefixLower = channelPrefix.toLowerCase();
    const splitPrefixBySpace = channelPrefixLower.trim().split(/[ ,]+/);
    const curState = getState();
    const usersInChannels = getUserIdsInChannels(curState);
    const userSearchStrings = {};

    return (channel) => {
        let searchString = `${channel.display_name}${channel.name}`;
        if (channel.type === Constants.GM_CHANNEL || channel.type === Constants.DM_CHANNEL) {
            const usersInChannel = usersInChannels[channel.id] || new Set([]);

            // In case the channel is a DM and the profilesInChannel is not populated
            if (!usersInChannel.size && channel.type === Constants.DM_CHANNEL) {
                const userId = Utils.getUserIdFromChannelId(channel.name);
                const user = getUser(curState, userId);
                if (user) {
                    usersInChannel.add(userId);
                }
            }

            for (const userId of usersInChannel) {
                let userString = userSearchStrings[userId];

                if (!userString) {
                    const user = getUser(curState, userId);
                    if (!user) {
                        continue;
                    }
                    const {nickname, username} = user;
                    userString = `${nickname}${username}${Utils.getFullName(user)}`;
                    userSearchStrings[userId] = userString;
                }
                searchString += userString;
            }
        }

        if (splitPrefixBySpace.length > 1) {
            const lowerCaseSearch = searchString.toLowerCase();
            return splitPrefixBySpace.every((searchPrefix) => {
                return lowerCaseSearch.includes(searchPrefix);
            });
        }

        return searchString.toLowerCase().includes(channelPrefixLower);
    };
}

export default class SwitchChannelProvider extends Provider {
    /**
     * whenever this gets adjusted/refactored to not call the callback twice we need to adjust the behavior in
     * the ForwardPostChannelSelect component as well.
     *
     * @see {@link components/forward_post_modal/forward_post_channel_select.tsx}
     */
    handlePretextChanged(channelPrefix, resultsCallback) {
        if (channelPrefix) {
            prefix = channelPrefix;
            this.startNewRequest(channelPrefix);
            if (this.shouldCancelDispatch(channelPrefix)) {
                return false;
            }

            // Dispatch suggestions for local data
            const channels = getChannelsInAllTeams(getState()).concat(getDirectAndGroupChannels(getState()));
            const users = Object.assign([], searchProfilesMatchingWithTerm(getState(), channelPrefix, false));
            const formattedData = this.formatList(channelPrefix, [ThreadsChannel, InsightsChannel, ...channels], users, true, true);
            if (formattedData) {
                resultsCallback(formattedData);
            }

            // Fetch data from the server and dispatch
            this.fetchUsersAndChannels(channelPrefix, resultsCallback);
        } else {
            this.fetchAndFormatRecentlyViewedChannels(resultsCallback);
        }

        return true;
    }

    async fetchUsersAndChannels(channelPrefix, resultsCallback) {
        const state = getState();
        const teamId = getCurrentTeamId(state);

        if (!teamId) {
            return;
        }

        const config = getConfig(state);
        let usersAsync;
        if (config.RestrictDirectMessage === 'team') {
            usersAsync = Client4.autocompleteUsers(channelPrefix, teamId, '');
        } else {
            usersAsync = Client4.autocompleteUsers(channelPrefix, '', '');
        }

        const channelsAsync = searchAllChannels(channelPrefix, {nonAdminSearch: true})(store.dispatch, store.getState);

        let usersFromServer = [];
        let channelsFromServer = [];

        try {
            usersFromServer = await usersAsync;
            const {data} = await channelsAsync;
            channelsFromServer = data;
        } catch (err) {
            store.dispatch(logError(err));
        }

        if (this.shouldCancelDispatch(channelPrefix)) {
            return;
        }

        const currentUserId = getCurrentUserId(state);
        const localChannelData = getChannelsInAllTeams(state).concat(getDirectAndGroupChannels(state)) || [];
        const localUserData = Object.assign([], searchProfilesMatchingWithTerm(state, channelPrefix, false)) || [];
        const localFormattedData = this.formatList(channelPrefix, [ThreadsChannel, InsightsChannel, ...localChannelData], localUserData);
        const remoteChannelData = channelsFromServer.concat(getGroupChannels(state)) || [];
        const remoteUserData = Object.assign([], usersFromServer.users) || [];
        const remoteFormattedData = this.formatList(channelPrefix, remoteChannelData, remoteUserData, false);

        store.dispatch({
            type: UserTypes.RECEIVED_PROFILES_LIST,
            data: [...localUserData.filter((user) => user.id !== currentUserId), ...remoteUserData.filter((user) => user.id !== currentUserId)],
        });
        const combinedTerms = [...localFormattedData.terms, ...remoteFormattedData.terms.filter((term) => !localFormattedData.terms.includes(term))];
        const combinedItems = [...localFormattedData.items, ...remoteFormattedData.items.filter((item) => !localFormattedData.terms.includes(item.channel.userId || item.channel.id))];

        resultsCallback({
            ...localFormattedData,
            ...{
                items: combinedItems,
                terms: combinedTerms,
            },
        });
    }

    userWrappedChannel(user, channel) {
        let displayName = '';
        const currentUserId = getCurrentUserId(getState());

        // The naming format is fullname (nickname)
        // username is shown seperately
        if ((user.first_name || user.last_name) && user.nickname) {
            displayName += Utils.getFullName(user);
            if (user.id !== currentUserId) {
                displayName += ` (${user.nickname})`;
            }
        } else if (user.nickname && !user.first_name && !user.last_name) {
            displayName += `${user.nickname}`;
        } else if (user.first_name || user.last_name) {
            displayName += `${Utils.getFullName(user)}`;
        }

        if (user.id === currentUserId && displayName) {
            displayName += (' ' + Utils.localizeMessage('suggestion.user.isCurrent', '(you)'));
        }

        return {
            channel: {
                display_name: displayName,
                name: user.username,
                id: channel ? channel.id : user.id,
                userId: user.id,
                update_at: user.update_at,
                type: Constants.DM_CHANNEL,
                last_picture_update: user.last_picture_update || 0,
            },
            type: 'search.direct',
            name: user.username,
            deactivated: user.delete_at,
        };
    }

    formatList(channelPrefix, allChannels, users, skipNotMember = true, localData = false) {
        const channels = [];

        const members = getMyChannelMemberships(getState());

        const completedChannels = {};

        const channelFilter = makeChannelSearchFilter(channelPrefix);

        const state = getState();
        const config = getConfig(state);
        const viewArchivedChannels = config.ExperimentalViewArchivedChannels === 'true';
        const allUnreadChannelIds = getAllTeamsUnreadChannelIds(state);
        const allUnreadChannelIdsSet = new Set(allUnreadChannelIds);
        const currentUserId = getCurrentUserId(state);

        for (const id of Object.keys(allChannels)) {
            const channel = allChannels[id];

            if (completedChannels[channel.id]) {
                continue;
            }
            if (channelFilter(channel)) {
                const newChannel = Object.assign({}, channel);
                const channelIsArchived = channel.delete_at !== 0;

                let wrappedChannel = {channel: newChannel, name: newChannel.name, deactivated: false};
                if (members[channel.id]) {
                    wrappedChannel.last_viewed_at = members[channel.id].last_viewed_at;
                } else if (skipNotMember && (newChannel.type !== Constants.THREADS && newChannel.type !== Constants.INSIGHTS)) {
                    continue;
                }

                if (!viewArchivedChannels && channelIsArchived) {
                    continue;
                } else if (channelIsArchived && members[channel.id]) {
                    wrappedChannel.type = Constants.ARCHIVED_CHANNEL;
                } else if (newChannel.type === Constants.OPEN_CHANNEL) {
                    wrappedChannel.type = Constants.MENTION_PUBLIC_CHANNELS;
                } else if (newChannel.type === Constants.PRIVATE_CHANNEL) {
                    wrappedChannel.type = Constants.MENTION_PRIVATE_CHANNELS;
                } else if (channelIsArchived && !members[channel.id]) {
                    continue;
                } else if (newChannel.type === Constants.THREADS) {
                    const threadItem = this.getThreadsItem('total');
                    if (threadItem) {
                        wrappedChannel = threadItem;
                    } else {
                        continue;
                    }
                } else if (newChannel.type === Constants.INSIGHTS) {
                    const insightsItem = this.getInsightsItem();
                    if (insightsItem) {
                        wrappedChannel = insightsItem;
                    } else {
                        continue;
                    }
                } else if (newChannel.type === Constants.GM_CHANNEL) {
                    newChannel.name = newChannel.display_name;
                    wrappedChannel.name = newChannel.name;
                    wrappedChannel.type = Constants.MENTION_GROUPS;
                    const isGMVisible = isGroupChannelManuallyVisible(state, channel.id);
                    if (!isGMVisible && skipNotMember) {
                        continue;
                    }
                } else if (newChannel.type === Constants.DM_CHANNEL) {
                    const userId = Utils.getUserIdFromChannelId(newChannel.name);
                    const user = users.find((u) => u.id === userId);

                    if (user) {
                        completedChannels[user.id] = true;
                        wrappedChannel = this.userWrappedChannel(
                            user,
                            newChannel,
                        );
                        if (members[channel.id]) {
                            wrappedChannel.last_viewed_at = members[channel.id].last_viewed_at;
                        }
                    } else {
                        continue;
                    }
                }

                const unread = allUnreadChannelIdsSet.has(newChannel.id) && !isChannelMuted(members[channel.id]);
                if (unread) {
                    wrappedChannel.unread = true;
                }
                completedChannels[channel.id] = true;
                channels.push(wrappedChannel);
            }
        }

        for (let i = 0; i < users.length; i++) {
            const user = users[i];

            if (completedChannels[user.id]) {
                continue;
            }

            const channelName = Utils.getDirectChannelName(currentUserId, user.id);
            const channel = getChannelByName(state, channelName);

            const wrappedChannel = this.userWrappedChannel(user, channel);

            if (channel && members[channel.id]) {
                wrappedChannel.last_viewed_at = members[channel.id].last_viewed_at;
            } else if (skipNotMember) {
                continue;
            }

            const unread = allUnreadChannelIdsSet.has(channel?.id) && !isChannelMuted(members[channel.id]);
            if (unread) {
                wrappedChannel.unread = true;
            }

            completedChannels[user.id] = true;
            channels.push(wrappedChannel);
        }

        const channelNames = channels.
            sort(quickSwitchSorter).
            map((wrappedChannel) => wrappedChannel.channel.userId || wrappedChannel.channel.id);

        if (localData && !channels.length) {
            channels.push({
                type: Constants.MENTION_MORE_CHANNELS,
                loading: true,
            });
        }

        return {
            matchedPretext: channelPrefix,
            terms: channelNames,
            items: channels,
            component: ConnectedSwitchChannelSuggestion,
        };
    }

    fetchAndFormatRecentlyViewedChannels(resultsCallback) {
        const state = getState();
        const recentChannels = getChannelsInAllTeams(state).concat(getDirectAndGroupChannels(state));
        const wrappedRecentChannels = this.wrapChannels(recentChannels, Constants.MENTION_RECENT_CHANNELS);
        const unreadChannels = getSortedAllTeamsUnreadChannels(state);
        const myMembers = getMyChannelMemberships(state);
        const unreadChannelsExclMuted = unreadChannels.filter((channel) => {
            const member = myMembers[channel.id];
            return !isChannelMuted(member);
        }).slice(0, 5);
        let sortedUnreadChannels = this.wrapChannels(unreadChannelsExclMuted, Constants.MENTION_UNREAD);
        if (wrappedRecentChannels.length === 0) {
            prefix = '';
            this.startNewRequest('');
            this.fetchChannels(resultsCallback);
        }
        const sortedUnreadChannelIDs = sortedUnreadChannels.map((wrappedChannel) => wrappedChannel.channel.id);
        const sortedRecentChannels = wrappedRecentChannels.filter((wrappedChannel) => !sortedUnreadChannelIDs.includes(wrappedChannel.channel.id)).
            sort(sortChannelsByRecencyAndTypeAndDisplayName).slice(0, 20);
        const threadsItem = this.getThreadsItem('unread', Constants.MENTION_UNREAD);
        if (threadsItem) {
            sortedUnreadChannels = [threadsItem, ...sortedUnreadChannels].slice(0, 5);
        }
        const sortedChannels = [...sortedUnreadChannels, ...sortedRecentChannels];
        const channelNames = sortedChannels.map((wrappedChannel) => wrappedChannel.channel.id);
        resultsCallback({
            matchedPretext: '',
            terms: channelNames,
            items: sortedChannels,
            component: ConnectedSwitchChannelSuggestion,
        });
    }

    getThreadsItem(countType = 'total', itemType) {
        const state = getState();
        const counts = getThreadCountsInCurrentTeam(state);
        const collapsedThreads = isCollapsedThreadsEnabled(state);

        // adding last viewed at equal to Date.now() to push it to the top of the list
        let threadsItem = {
            channel: ThreadsChannel,
            name: ThreadsChannel.name,
            unread_mentions: counts?.total_unread_mentions || 0,
            deactivated: false,
            last_viewed_at: Date.now(),
        };
        if (itemType) {
            threadsItem = {...threadsItem, type: itemType};
        }
        if (counts?.total_unread_threads) {
            threadsItem.unread = true;
        }
        if (collapsedThreads && ((countType === 'unread' && counts?.total_unread_threads) || (countType === 'total'))) {
            return threadsItem;
        }

        return null;
    }

    getInsightsItem() {
        const state = getState();
        const insightsEnabled = insightsAreEnabled(state);

        // adding last viewed at equal to Date.now() to push it to the top of the list
        const insightsItem = {
            channel: InsightsChannel,
            name: InsightsChannel.name,
            unread_mentions: 0,
            deactivated: false,
            last_viewed_at: Date.now(),
        };

        if (insightsEnabled) {
            return insightsItem;
        }

        return null;
    }

    getTimestampFromPrefs(myPreferences, category, name) {
        const pref = myPreferences[getPreferenceKey(category, name)];
        const prefValue = pref ? pref.value : '0';
        return parseInt(prefValue, 10);
    }

    getLastViewedAt(member, myPreferences, channel) {
        // The server only ever sets the last_viewed_at to the time of the last post in channel,
        // So thought of using preferences but it seems that also not keeping track.
        // TODO Update and remove comment once solution is finalized
        return Math.max(
            member.last_viewed_at,
            this.getTimestampFromPrefs(myPreferences, Preferences.CATEGORY_CHANNEL_APPROXIMATE_VIEW_TIME, channel.id),
            this.getTimestampFromPrefs(myPreferences, Preferences.CATEGORY_CHANNEL_OPEN_TIME, channel.id),
        );
    }

    wrapChannels(channels, channelType) {
        const state = getState();
        const currentChannel = getCurrentChannel(state);
        const myMembers = getMyChannelMemberships(state);
        const myPreferences = getMyPreferences(state);
        const collapsedThreads = isCollapsedThreadsEnabled(state);
        const allUnreadChannelIds = getAllTeamsUnreadChannelIds(state);
        const allUnreadChannelIdsSet = new Set(allUnreadChannelIds);

        const channelList = [];
        for (let i = 0; i < channels.length; i++) {
            const channel = channels[i];
            if (channel.id === currentChannel?.id) {
                continue;
            }
            let wrappedChannel = {channel, name: channel.name, deactivated: false};
            const member = myMembers[channel.id];
            if (member) {
                wrappedChannel.last_viewed_at = this.getLastViewedAt(member, myPreferences, channel);
            }
            if (member && channelType === Constants.MENTION_UNREAD) {
                wrappedChannel.unreadMentions = collapsedThreads ? member.mention_count_root : member.mention_count;
            }
            if (channel.type === Constants.GM_CHANNEL) {
                wrappedChannel.name = channel.display_name;
            } else if (channel.type === Constants.DM_CHANNEL) {
                const user = getUser(getState(), Utils.getUserIdFromChannelId(channel.name));

                if (!user) {
                    continue;
                }
                const userWrappedChannel = this.userWrappedChannel(
                    user,
                    channel,
                );
                wrappedChannel = {...wrappedChannel, ...userWrappedChannel};
            }
            const unread = allUnreadChannelIdsSet.has(channel.id) && !isChannelMuted(member);
            if (unread) {
                wrappedChannel.unread = true;
            }

            wrappedChannel.type = channelType;
            channelList.push(wrappedChannel);
        }
        return channelList;
    }

    async fetchChannels(resultsCallback) {
        const state = getState();
        const teamId = getCurrentTeamId(state);
        if (!teamId) {
            return;
        }
        const channelsAsync = fetchAllMyTeamsChannelsAndChannelMembersREST()(store.dispatch, store.getState);
        let channels;

        try {
            const {data} = await channelsAsync;
            channels = data.channels;
        } catch (err) {
            store.dispatch(logError(err));
        }

        if (this.latestPrefix !== '') {
            return;
        }
        const sortedChannels = this.wrapChannels(channels, Constants.MENTION_PUBLIC_CHANNELS).slice(0, 20);
        const channelNames = sortedChannels.map((wrappedChannel) => wrappedChannel.channel.id);

        resultsCallback({
            matchedPretext: '',
            terms: channelNames,
            items: sortedChannels,
            component: ConnectedSwitchChannelSuggestion,
        });
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {FormattedMessage} from 'react-intl';

import FormattedMarkdownMessage from 'components/formatted_markdown_message';

import * as ServerVersion from 'utils/server_version';
import * as UserAgent from 'utils/user_agent';

import mattermostIcon from 'images/icon50x50.png';
import {Notice} from 'components/system_notice/types';

// Notices are objects with the following fields:
//  - name - string identifier
//  - adminOnly - set to true if only system admins should see this message
//  - icon - the image to display for the notice icon
//  - title - JSX node to display for the notice title
//  - body - JSX node to display for the notice body
//  - allowForget - boolean to allow forget the notice
//  - show - function that check if we need to show the notice
//
// Order is important! The notices at the top are shown first.

const notices: Notice[] = [
    {
        name: 'apiv3_deprecation',
        adminOnly: true,
        title: (
            <FormattedMarkdownMessage
                id='system_notice.title'
                defaultMessage='**Notice**\nfrom Mattermost'
            />
        ),
        icon: mattermostIcon,
        body: (
            <FormattedMessage
                id='system_notice.body.api3'
                defaultMessage='If youve created or installed integrations in the last two years, find out how <link>recent changes</link> may have affected them.'
                values={{
                    link: (msg: React.ReactNode) => (
                        <a
                            href='https://api.mattermost.com/#tag/APIv3-Deprecation'
                            target='_blank'
                            rel='noreferrer'
                        >
                            {msg}
                        </a>
                    ),
                }}
            />
        ),
        allowForget: true,
        show: (serverVersion, config) => {
            if (config.InstallationDate >= new Date(2018, 5, 16, 0, 0, 0, 0).getTime()) {
                return false;
            }
            return true;
        },
    },
    {
        name: 'advanced_permissions',
        adminOnly: true,
        title: (
            <FormattedMarkdownMessage
                id='system_notice.title'
                defaultMessage='**Notice**\nfrom Mattermost'
            />
        ),
        icon: mattermostIcon,
        body: (
            <FormattedMessage
                id='system_notice.body.permissions'
                defaultMessage='Some policy and permission System Console settings have moved with the release of <link>advanced permissions</link> into Mattermost Free and Professional.'
                values={{
                    link: (msg: React.ReactNode) => (
                        <a
                            href='https://docs.mattermost.com/deployment/advanced-permissions.html'
                            target='_blank'
                            rel='noreferrer'
                        >
                            {msg}
                        </a>
                    ),
                }}
            />
        ),
        allowForget: true,
        show: (serverVersion, config, license) => {
            if (license.IsLicensed === 'false') {
                return false;
            }
            if (config.InstallationDate > new Date(2018, 5, 16, 0, 0, 0, 0).getTime()) {
                return false;
            }
            if (license.IsLicensed === 'true' && license.IssuedAt > new Date(2018, 5, 16, 0, 0, 0, 0).getTime()) {
                return false;
            }
            return true;
        },
    },
    {
        name: 'ee_upgrade_advice',
        adminOnly: true,
        title: (
            <FormattedMarkdownMessage
                id='system_notice.title'
                defaultMessage='**Notice**\nfrom Mattermost'
            />
        ),
        icon: mattermostIcon,
        body: (
            <FormattedMessage
                id='system_notice.body.ee_upgrade_advice'
                defaultMessage='Enterprise Edition is recommended to ensure optimal operation and reliability. <link>Learn more</link>.'
                values={{
                    link: (msg: React.ReactNode) => (
                        <a
                            href='https://mattermost.com/performance'
                            target='_blank'
                            rel='noreferrer'
                        >
                            {msg}
                        </a>
                    ),
                }}
            />
        ),
        allowForget: false,
        show: (serverVersion, config, license, analytics) => {
            const USERS_THRESHOLD = 10000;

            // If we don't have the analytics yet, don't show
            if (!analytics?.hasOwnProperty('TOTAL_USERS')) {
                return false;
            }

            if (analytics.TOTAL_USERS < USERS_THRESHOLD) {
                return false;
            }

            if (license.IsLicensed === 'true' && license.Cluster === 'true') {
                return false;
            }

            return true;
        },
    },
    {
        name: 'ie11_deprecation',
        title: (
            <FormattedMarkdownMessage
                id='system_notice.title'
                defaultMessage='**Notice**\nfrom Mattermost'
            />
        ),
        icon: mattermostIcon,
        allowForget: false,
        body: (
            <FormattedMessage
                id='system_notice.body.ie11_deprecation'
                defaultMessage='Your browser, IE11, will no longer be supported in an upcoming release. <link>Find out how to move to another browser in one simple step</link>.'
                values={{
                    link: (msg: React.ReactNode) => (
                        <a
                            href='https://forum.mattermost.com/t/mattermost-is-dropping-support-for-internet-explorer-ie11-in-v5-16/7575'
                            target='_blank'
                            rel='noreferrer'
                        >
                            {msg}
                        </a>
                    ),
                }}
            />
        ),
        show: (serverVersion) => {
            // Don't show the notice after v5.16, show a different notice
            if (ServerVersion.isServerVersionGreaterThanOrEqualTo(serverVersion, '5.16.0')) {
                return false;
            }

            // Only show if they're using IE
            if (!UserAgent.isInternetExplorer()) {
                return false;
            }

            return true;
        },
    },
];

export default notices;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {ClientConfig, ClientLicense} from '@mattermost/types/config';

import {AnalyticsRow} from '@mattermost/types/admin';

import {PreferenceType} from '@mattermost/types/preferences';

import {Preferences} from 'utils/constants';
import {t} from 'utils/i18n';
import LocalizedIcon from 'components/localized_icon';
import MattermostLogo from 'components/widgets/icons/mattermost_logo';
import {Notice} from 'components/system_notice/types';

type Props = {
    currentUserId: string;
    notices: Notice[];
    preferences: {[key: string]: any};
    dismissedNotices: any;
    isSystemAdmin?: boolean;
    serverVersion: string;
    config: Partial<ClientConfig>;
    license: ClientLicense;
    analytics?: Record<string, number | AnalyticsRow[]>;
    actions: {
        savePreferences(userId: string, preferences: PreferenceType[]): void;
        dismissNotice(type: string): void;
        getStandardAnalytics(teamId?: string): void;
    };
}
export default class SystemNotice extends React.PureComponent<Props> {
    componentDidMount() {
        if (this.props.isSystemAdmin) {
            this.props.actions.getStandardAnalytics();
        }
    }

    componentDidUpdate(prevProps: Props) {
        if (prevProps.isSystemAdmin !== this.props.isSystemAdmin && this.props.isSystemAdmin) {
            this.props.actions.getStandardAnalytics();
        }
    }

    getCurrentNotice = () => {
        for (const notice of this.props.notices) {
            // Skip if dismissed previously this session
            if (this.props.dismissedNotices[notice.name]) {
                continue;
            }

            // Skip if dismissed forever
            if (this.props.preferences[notice.name]) {
                continue;
            }

            if (notice.adminOnly && !this.props.isSystemAdmin) {
                continue;
            }

            if (!notice.show?.(this.props.serverVersion, this.props.config, this.props.license, this.props.analytics)) {
                continue;
            }

            return notice;
        }
        return null;
    }

    hide = (remind = false) => {
        const notice = this.getCurrentNotice();
        if (!notice) {
            return;
        }

        if (!remind) {
            this.props.actions.savePreferences(this.props.currentUserId, [{
                user_id: this.props.currentUserId,
                category: Preferences.CATEGORY_SYSTEM_NOTICE,
                name: notice.name,
                value: 'dismissed',
            }]);
        }

        this.props.actions.dismissNotice(notice.name);
    }

    hideAndRemind = () => {
        this.hide(true);
    }

    hideAndForget = () => {
        this.hide(false);
    }

    render() {
        const notice = this.getCurrentNotice();

        if (notice == null) {
            return null;
        }

        let visibleMessage;
        if (notice.adminOnly) {
            visibleMessage = (
                <div className='system-notice__info'>
                    <LocalizedIcon
                        className='fa fa-eye'
                        title={{id: t('system_notice.adminVisible.icon'), defaultMessage: 'Only visible to System Admins Icon'}}
                    />
                    <FormattedMessage
                        id='system_notice.adminVisible'
                        defaultMessage='Only visible to System Admins'
                    />
                </div>
            );
        }

        return (
            <div
                className='system-notice bg--white shadow--2'
            >
                <div className='system-notice__header'>
                    <div className='system-notice__logo'>
                        <MattermostLogo/>
                    </div>
                    <div className='system-notice__title'>
                        {notice.title}
                    </div>
                </div>
                <div className='system-notice__body'>
                    {notice.body}
                </div>
                {visibleMessage}
                <div className='system-notice__footer'>
                    <button
                        id='systemnotice_remindme'
                        className='btn btn-transparent'
                        onClick={this.hideAndRemind}
                    >
                        <FormattedMessage
                            id='system_notice.remind_me'
                            defaultMessage='Remind Me Later'
                        />
                    </button>
                    {notice.allowForget &&
                        <button
                            id='systemnotice_dontshow'
                            className='btn btn-transparent'
                            onClick={this.hideAndForget}
                        >
                            <FormattedMessage
                                id='system_notice.dont_show'
                                defaultMessage="Don't Show Again"
                            />
                        </button>}
                </div>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {createSelector} from 'reselect';

import {makeGetCategory} from 'mattermost-redux/selectors/entities/preferences';
import {getConfig, getLicense} from 'mattermost-redux/selectors/entities/general';
import {haveISystemPermission} from 'mattermost-redux/selectors/entities/roles';
import {savePreferences} from 'mattermost-redux/actions/preferences';
import {Permissions} from 'mattermost-redux/constants';
import {getStandardAnalytics} from 'mattermost-redux/actions/admin';

import {PreferenceType} from '@mattermost/types/preferences';

import {Preferences} from 'utils/constants';

import {dismissNotice} from 'actions/views/notice';

import Notices from 'components/system_notice/notices';
import SystemNotice from 'components/system_notice/system_notice';
import {GlobalState} from 'types/store';

function makeMapStateToProps() {
    const getCategory = makeGetCategory();

    const getPreferenceNameMap = createSelector(
        'getPreferenceNameMap',
        getCategory,
        (preferences) => {
            const nameMap: {[key: string]: PreferenceType} = {};
            preferences.forEach((p) => {
                nameMap[p.name] = p;
            });
            return nameMap;
        },
    );

    return function mapStateToProps(state: GlobalState) {
        const license = getLicense(state);
        const config = getConfig(state);
        const serverVersion = state.entities.general.serverVersion;
        const analytics = state.entities.admin.analytics;

        return {
            currentUserId: state.entities.users.currentUserId,
            preferences: getPreferenceNameMap(state, Preferences.CATEGORY_SYSTEM_NOTICE),
            dismissedNotices: state.views.notice.hasBeenDismissed,
            isSystemAdmin: haveISystemPermission(state, {permission: Permissions.MANAGE_SYSTEM}),
            notices: Notices,
            config,
            license,
            serverVersion,
            analytics,
        };
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators({
            savePreferences,
            dismissNotice,
            getStandardAnalytics,
        }, dispatch),
    };
}

export default connect(makeMapStateToProps, mapDispatchToProps)(SystemNotice);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode} from 'react';
import {FormattedMessage, injectIntl} from 'react-intl';

import {Constants} from 'utils/constants';
import * as Utils from 'utils/utils';
import {isGuest} from 'mattermost-redux/utils/user_utils';

import BotBadge from 'components/widgets/badges/bot_badge';
import GuestBadge from 'components/widgets/badges/guest_badge';
import SharedUserIndicator from 'components/shared_user_indicator';
import Avatar from 'components/widgets/users/avatar';

import Suggestion from '../suggestion.jsx';
import CustomStatusEmoji from 'components/custom_status/custom_status_emoji';
import StatusIcon from 'components/status_icon';

import {UserProfile} from '../command_provider/app_command_parser/app_command_parser_dependencies.js';

interface Item extends UserProfile {
    display_name: string;
    name: string;
    isCurrentUser: boolean;
    type: string;
}

class AtMentionSuggestion extends Suggestion {
    render() {
        const {intl} = this.props;
        const isSelection: boolean = this.props.isSelection;
        const item: Item = this.props.item;

        let itemname: string;
        let description: ReactNode;
        let icon: JSX.Element;
        let customStatus: ReactNode;
        if (item.username === 'all') {
            itemname = 'all';
            description = (
                <span className='ml-2'>
                    <FormattedMessage
                        id='suggestion.mention.all'
                        defaultMessage='Notifies everyone in this channel'
                    />
                </span>
            );
            icon = (
                <span className='suggestion-list__icon suggestion-list__icon--large'>
                    <i
                        className='icon icon-account-multiple-outline'
                        title={intl.formatMessage({id: 'generic_icons.member', defaultMessage: 'Member Icon'})}
                    />
                </span>
            );
        } else if (item.username === 'channel') {
            itemname = 'channel';
            description = (
                <span className='ml-2'>
                    <FormattedMessage
                        id='suggestion.mention.channel'
                        defaultMessage='Notifies everyone in this channel'
                    />
                </span>
            );
            icon = (
                <span className='suggestion-list__icon suggestion-list__icon--large'>
                    <i
                        className='icon icon-account-multiple-outline'
                        title={intl.formatMessage({id: 'generic_icons.member', defaultMessage: 'Member Icon'})}
                    />
                </span>
            );
        } else if (item.username === 'here') {
            itemname = 'here';
            description = (
                <span className='ml-2'>
                    <FormattedMessage
                        id='suggestion.mention.here'
                        defaultMessage='Notifies everyone online in this channel'
                    />
                </span>
            );
            icon = (
                <span className='suggestion-list__icon suggestion-list__icon--large'>
                    <i
                        className='icon icon-account-multiple-outline'
                        title={intl.formatMessage({id: 'generic_icons.member', defaultMessage: 'Member Icon'})}
                    />
                </span>
            );
        } else if (item.type === Constants.MENTION_GROUPS) {
            itemname = item.name;
            description = `- ${item.display_name}`;
            icon = (
                <span className='suggestion-list__icon suggestion-list__icon--large'>
                    <i
                        className='icon icon-account-multiple-outline'
                        title={intl.formatMessage({id: 'generic_icons.member', defaultMessage: 'Member Icon'})}
                    />
                </span>
            );
        } else {
            itemname = item.username;

            if (item.isCurrentUser) {
                if (item.first_name || item.last_name) {
                    description = (
                        <span className='ml-2'>
                            {Utils.getFullName(item)}
                        </span>
                    );
                }
            } else if (item.first_name || item.last_name || item.nickname) {
                description = (
                    <span className='ml-2'>
                        {`${Utils.getFullName(item)} ${
                            item.nickname ? `(${item.nickname})` : ''
                        }`.trim()}
                    </span>
                );
            }

            icon = (
                <span className='status-wrapper style--none'>
                    <span className='profile-icon'>
                        <Avatar
                            username={item && item.username}
                            size='sm'
                            url={Utils.imageURLForUser(item.id, item.last_picture_update)}
                        />
                    </span>
                    <StatusIcon status={item && item.status}/>
                </span>
            );

            customStatus = (
                <CustomStatusEmoji
                    showTooltip={true}
                    userID={item.id}
                    emojiSize={15}
                    emojiStyle={{
                        margin: '0 4px 4px',
                    }}
                />
            );
        }

        let youElement = null;
        if (item.isCurrentUser) {
            youElement =
            (<span className='ml-1'>
                <FormattedMessage
                    id='suggestion.user.isCurrent'
                    defaultMessage='(you)'
                />
            </span>);
        }

        let className = 'suggestion-list__item';
        if (isSelection) {
            className += ' suggestion--selected';
        }

        let sharedIcon;
        if (item.remote_id) {
            sharedIcon = (
                <SharedUserIndicator
                    className='shared-user-icon'
                    withTooltip={true}
                />
            );
        }

        return (
            <div
                className={className}
                data-testid={`mentionSuggestion_${itemname}`}
                onClick={this.handleClick}
                onMouseMove={this.handleMouseMove}
                {...Suggestion.baseProps}
            >
                {icon}
                <span className='suggestion-list__ellipsis'>
                    <span className='suggestion-list__main'>
                        {'@' + itemname}
                    </span>
                    <BotBadge
                        show={Boolean(item.is_bot)}
                        className='badge-autocomplete'
                    />
                    {customStatus}
                    {description}
                    {youElement}
                    {sharedIcon}
                    <GuestBadge
                        show={isGuest(item.roles)}
                        className='badge-autocomplete'
                    />
                </span>
            </div>
        );
    }
}

export default injectIntl(AtMentionSuggestion);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {getSuggestionsSplitBy, getSuggestionsSplitByMultiple} from 'mattermost-redux/utils/user_utils';
import {makeGetProfilesInChannel} from 'mattermost-redux/selectors/entities/users';
import {makeAddLastViewAtToProfiles} from 'mattermost-redux/selectors/entities/utils';

import store from 'stores/redux_store';
import {Constants} from 'utils/constants';

import Provider from '../provider';

import AtMentionSuggestion from './at_mention_suggestion';

const profilesInChannelOptions = {active: true};
const regexForAtMention = /(?:^|\W)@([\p{L}\d\-_. ]*)$/iu;

// The AtMentionProvider provides matches for at mentions, including @here, @channel, @all,
// users in the channel and users not in the channel. It mixes together results from the local
// store with results fetched from the server.
export default class AtMentionProvider extends Provider {
    constructor(props) {
        super();

        this.setProps(props);

        this.data = null;
        this.lastCompletedWord = '';
        this.lastPrefixWithNoResults = '';
        this.triggerCharacter = '@';
        this.getProfilesInChannel = makeGetProfilesInChannel();
        this.addLastViewAtToProfiles = makeAddLastViewAtToProfiles();
    }

    // setProps gives the provider additional context for matching pretexts. Ideally this would
    // just be something akin to a connected component with access to the store itself.
    setProps({currentUserId, channelId, autocompleteUsersInChannel, useChannelMentions, autocompleteGroups, searchAssociatedGroupsForReference, priorityProfiles}) {
        this.currentUserId = currentUserId;
        this.channelId = channelId;
        this.autocompleteUsersInChannel = autocompleteUsersInChannel;
        this.useChannelMentions = useChannelMentions;
        this.autocompleteGroups = autocompleteGroups;
        this.searchAssociatedGroupsForReference = searchAssociatedGroupsForReference;
        this.priorityProfiles = priorityProfiles;
    }

    // specialMentions matches one of @here, @channel or @all, unless using /msg.
    specialMentions() {
        if (this.latestPrefix.startsWith('/msg') || !this.useChannelMentions) {
            return [];
        }

        return ['here', 'channel', 'all'].filter((item) =>
            item.startsWith(this.latestPrefix),
        ).map((name) => ({
            username: name,
            type: Constants.MENTION_SPECIAL,
        }));
    }

    // retrieves the parts of the profile that should be checked
    // against the term
    getProfileSuggestions(profile) {
        const profileSuggestions = [];
        if (!profile) {
            return profileSuggestions;
        }

        if (profile.username) {
            const usernameSuggestions = getSuggestionsSplitByMultiple(profile.username.toLowerCase(), Constants.AUTOCOMPLETE_SPLIT_CHARACTERS);
            profileSuggestions.push(...usernameSuggestions);
        }
        [profile.first_name, profile.last_name, profile.nickname].forEach((property) => {
            const suggestions = getSuggestionsSplitBy(property.toLowerCase(), ' ');
            profileSuggestions.push(...suggestions);
        });
        profileSuggestions.push(profile.first_name.toLowerCase() + ' ' + profile.last_name.toLowerCase());

        return profileSuggestions;
    }

    // retrieves the parts of the group mention that should be checked
    // against the term
    getGroupSuggestions(group) {
        const groupSuggestions = [];
        if (!group) {
            return groupSuggestions;
        }

        if (group.name) {
            const groupnameSuggestions = getSuggestionsSplitByMultiple(group.name.toLowerCase(), Constants.AUTOCOMPLETE_SPLIT_CHARACTERS);
            groupSuggestions.push(...groupnameSuggestions);
        }

        const suggestions = getSuggestionsSplitBy(group.display_name.toLowerCase(), ' ');
        groupSuggestions.push(...suggestions);

        groupSuggestions.push(group.display_name.toLowerCase());
        return groupSuggestions;
    }

    // normalizeString performs a unicode normalization to a string
    normalizeString(name) {
        return name.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    }

    // filterProfile constrains profiles to those matching the latest prefix.
    filterProfile(profile) {
        if (!profile) {
            return false;
        }

        const prefixLower = this.latestPrefix.toLowerCase();
        const profileSuggestions = this.getProfileSuggestions(profile);
        return profileSuggestions.some((suggestion) =>
            this.normalizeString(suggestion).startsWith(this.normalizeString(prefixLower)),
        );
    }

    // filterGroup constrains group mentions to those matching the latest prefix.
    filterGroup(group) {
        if (!group) {
            return false;
        }

        const prefixLower = this.latestPrefix.toLowerCase();
        const groupSuggestions = this.getGroupSuggestions(group);
        return groupSuggestions.some((suggestion) => suggestion.startsWith(prefixLower));
    }

    getProfilesWithLastViewAtInChannel() {
        const state = store.getState();

        const profilesInChannel = this.getProfilesInChannel(state, this.channelId, profilesInChannelOptions);
        const profilesWithLastViewAtInChannel = this.addLastViewAtToProfiles(state, profilesInChannel);

        return profilesWithLastViewAtInChannel;
    }

    // localMembers matches up to 25 local results from the store before the server has responded.
    localMembers() {
        const localMembers = this.getProfilesWithLastViewAtInChannel().
            filter((profile) => this.filterProfile(profile)).
            map((profile) => this.createFromProfile(profile, Constants.MENTION_MEMBERS)).
            splice(0, 25);

        return localMembers;
    }

    filterPriorityProfiles() {
        if (!this.priorityProfiles) {
            return [];
        }

        const priorityProfiles = this.priorityProfiles.
            filter((profile) => this.filterProfile(profile)).
            map((profile) => this.createFromProfile(profile, Constants.MENTION_MEMBERS));

        return priorityProfiles;
    }

    // localGroups matches up to 25 local results from the store
    localGroups() {
        if (!this.autocompleteGroups) {
            return [];
        }

        const localGroups = this.autocompleteGroups.
            filter((group) => this.filterGroup(group)).
            map((group) => this.createFromGroup(group, Constants.MENTION_GROUPS)).
            sort((a, b) => a.name.localeCompare(b.name)).
            splice(0, 25);

        return localGroups;
    }

    // remoteMembers matches the users listed in the channel by the server.
    remoteMembers() {
        if (!this.data) {
            return [];
        }

        const remoteMembers = (this.data.users || []).
            filter((profile) => this.filterProfile(profile)).
            map((profile) => this.createFromProfile(profile, Constants.MENTION_MEMBERS));

        return remoteMembers;
    }

    // remoteGroups matches the users listed in the channel by the server.
    remoteGroups() {
        if (!this.data) {
            return [];
        }
        const remoteGroups = (this.data.groups || []).
            filter((group) => this.filterGroup(group)).
            map((group) => this.createFromGroup(group, Constants.MENTION_GROUPS));

        return remoteGroups;
    }

    // remoteNonMembers matches users listed as not in the channel by the server.
    // listed in the channel from local results.
    remoteNonMembers() {
        if (!this.data) {
            return [];
        }

        return (this.data.out_of_channel || []).
            filter((profile) => this.filterProfile(profile)).
            map((profile) => ({
                type: Constants.MENTION_NONMEMBERS,
                ...profile,
            }));
    }

    items() {
        const priorityProfilesIds = {};
        const priorityProfiles = this.filterPriorityProfiles();

        priorityProfiles.forEach((member) => {
            priorityProfilesIds[member.id] = true;
        });

        const specialMentions = this.specialMentions();
        const localMembers = this.localMembers().filter((member) => !priorityProfilesIds[member.id]);

        const localUserIds = {};

        localMembers.forEach((member) => {
            localUserIds[member.id] = true;
        });

        const remoteMembers = this.remoteMembers().filter((member) => !localUserIds[member.id] && !priorityProfilesIds[member.id]);

        // comparator which prioritises users with usernames starting with search term
        const orderUsers = (a, b) => {
            const aStartsWith = a.username.startsWith(this.latestPrefix);
            const bStartsWith = b.username.startsWith(this.latestPrefix);

            if (aStartsWith && !bStartsWith) {
                return -1;
            } else if (!aStartsWith && bStartsWith) {
                return 1;
            }

            // Sort recently viewed channels first
            if (a.last_viewed_at && b.last_viewed_at) {
                return b.last_viewed_at - a.last_viewed_at;
            } else if (a.last_viewed_at) {
                return -1;
            } else if (b.last_viewed_at) {
                return 1;
            }

            return a.username.localeCompare(b.username);
        };

        // Combine the local and remote members, sorting to mix the results together.
        const localAndRemoteMembers = localMembers.concat(remoteMembers).sort(orderUsers);

        // handle groups
        const localGroups = this.localGroups();

        const localGroupIds = {};
        localGroups.forEach((group) => {
            localGroupIds[group.id] = true;
        });

        const remoteGroups = this.remoteGroups().filter((group) => !localGroupIds[group.id]);

        // comparator which prioritises users with usernames starting with search term
        const orderGroups = (a, b) => {
            const aStartsWith = a.name.startsWith(this.latestPrefix);
            const bStartsWith = b.name.startsWith(this.latestPrefix);

            if (aStartsWith && bStartsWith) {
                return a.name.localeCompare(b.name);
            }
            if (aStartsWith) {
                return -1;
            }
            if (bStartsWith) {
                return 1;
            }
            return a.name.localeCompare(b.name);
        };

        // Combine the local and remote groups, sorting to mix the results together.
        const localAndRemoteGroups = localGroups.concat(remoteGroups).sort(orderGroups);

        const remoteNonMembers = this.remoteNonMembers().
            filter((member) => !localUserIds[member.id]).
            sort(orderUsers);

        return priorityProfiles.concat(localAndRemoteMembers).concat(localAndRemoteGroups).concat(specialMentions).concat(remoteNonMembers);
    }

    // updateMatches invokes the resultCallback with the metadata for rendering at mentions
    updateMatches(resultCallback, items) {
        if (items.length === 0) {
            this.lastPrefixWithNoResults = this.latestPrefix;
        } else if (this.lastPrefixWithNoResults === this.latestPrefix) {
            this.lastPrefixWithNoResults = '';
        }
        const mentions = items.map((item) => {
            if (item.username) {
                return '@' + item.username;
            } else if (item.name) {
                return '@' + item.name;
            }
            return '';
        });

        resultCallback({
            matchedPretext: `@${this.latestPrefix}`,
            terms: mentions,
            items,
            component: AtMentionSuggestion,
        });
    }

    handlePretextChanged(pretext, resultCallback) {
        const captured = regexForAtMention.exec(pretext.toLowerCase());
        if (!captured) {
            return false;
        }

        if (this.lastCompletedWord && captured[0].trim().startsWith(this.lastCompletedWord.trim())) {
            // It appears we're still matching a channel handle that we already completed
            return false;
        }

        const prefix = captured[1];
        if (this.lastPrefixWithNoResults && prefix.startsWith(this.lastPrefixWithNoResults)) {
            // Just give up since we know it won't return any results
            return false;
        }

        this.startNewRequest(prefix);
        this.updateMatches(resultCallback, this.items());

        // If we haven't gotten server-side results in 500 ms, add the loading indicator.
        let showLoadingIndicator = setTimeout(() => {
            if (this.shouldCancelDispatch(prefix)) {
                return;
            }

            this.updateMatches(resultCallback, this.items().concat([{
                type: Constants.MENTION_MORE_MEMBERS,
                loading: true,
            }]));

            showLoadingIndicator = null;
        }, 500);

        // Query the server for remote results to add to the local results.
        this.autocompleteUsersInChannel(prefix).then(({data}) => {
            if (showLoadingIndicator) {
                clearTimeout(showLoadingIndicator);
            }
            if (this.shouldCancelDispatch(prefix)) {
                return;
            }
            this.data = data;
            this.searchAssociatedGroupsForReference(prefix).then((groupsData) => {
                if (this.data && groupsData && groupsData.data) {
                    this.data.groups = groupsData.data;
                }
                this.updateMatches(resultCallback, this.items());
            });
        });

        return true;
    }

    handleCompleteWord(term) {
        this.lastCompletedWord = term;
        this.lastPrefixWithNoResults = '';
    }

    createFromProfile(profile, type) {
        if (profile.id === this.currentUserId) {
            return {
                type,
                ...profile,
                isCurrentUser: true,
            };
        }

        return {
            type,
            ...profile,
        };
    }

    createFromGroup(group, type) {
        return {
            type,
            ...group,
        };
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import AtMentionProvider from './at_mention_provider.jsx';

export default AtMentionProvider;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {Channel} from '@mattermost/types/channels.js';
import {ActionResult} from 'mattermost-redux/types/actions.js';

import {getMyChannels, getMyChannelMemberships} from 'mattermost-redux/selectors/entities/channels';

import {sortChannelsByTypeAndDisplayName} from 'mattermost-redux/utils/channel_utils';

import store from 'stores/redux_store.jsx';

import {Constants} from 'utils/constants';

import Provider from './provider';
import Suggestion from './suggestion.jsx';

export type Results = {
    matchedPretext: string;
    terms: string[];
    items: WrappedChannels[];
    component: React.ElementType;
}

type ResultsCallback = (results: Results) => void;

type WrappedChannels = {
    type: string;
    channel?: Channel;
    loading?: boolean;
}

export class ChannelMentionSuggestion extends Suggestion {
    render() {
        const isSelection = this.props.isSelection;
        const item = this.props.item;
        const channelIsArchived = item.channel.delete_at && item.channel.delete_at !== 0;

        const channelName = item.channel.display_name;
        let channelIcon;
        if (channelIsArchived) {
            channelIcon = (
                <span className='suggestion-list__icon suggestion-list__icon--large'>
                    <i className='icon icon-archive-outline'/>
                </span>
            );
        } else {
            channelIcon = (
                <span className='suggestion-list__icon suggestion-list__icon--large'>
                    <i className={`icon icon--no-spacing icon-${item.channel.type === Constants.OPEN_CHANNEL ? 'globe' : 'lock'}`}/>
                </span>
            );
        }

        let className = 'suggestion-list__item';
        if (isSelection) {
            className += ' suggestion--selected';
        }

        const description = '~' + item.channel.name;

        return (
            <div
                className={className}
                onClick={this.handleClick}
                onMouseMove={this.handleMouseMove}
                {...Suggestion.baseProps}
            >
                {channelIcon}
                <div className='suggestion-list__ellipsis'>
                    <span className='suggestion-list__main'>
                        {channelName}
                    </span>
                    <span className='ml-2'>
                        {description}
                    </span>
                </div>
            </div>
        );
    }
}

export default class ChannelMentionProvider extends Provider {
    lastPrefixTrimmed: string;
    lastPrefixWithNoResults: string;
    lastCompletedWord: string;
    triggerCharacter: string;
    autocompleteChannels: (term: string, success: (channels: Channel[]) => void, error: () => void) => Promise<ActionResult>;
    constructor(channelSearchFunc: (term: string, success: (channels: Channel[]) => void, error: () => void) => Promise<ActionResult>) {
        super();

        this.lastPrefixTrimmed = '';
        this.lastPrefixWithNoResults = '';
        this.lastCompletedWord = '';
        this.triggerCharacter = '~';

        this.autocompleteChannels = channelSearchFunc;
    }

    handlePretextChanged(pretext: string, resultCallback: ResultsCallback) {
        this.resetRequest();

        const captured = (/\B(~([^~\r\n]*))$/i).exec(pretext.toLowerCase());

        if (!captured) {
            // Not a channel mention
            return false;
        }

        if (captured.index > 0 && pretext[captured.index - 1] === '~') {
            // Multiple ~'s in a row so let's return and not show the autocomplete
            return false;
        }

        const prefix = captured[2];

        if (this.lastPrefixTrimmed && prefix.trim() === this.lastPrefixTrimmed) {
            // Don't keep searching if the user keeps typing spaces
            return true;
        }

        this.lastPrefixTrimmed = prefix.trim();

        if (this.lastPrefixWithNoResults && prefix.startsWith(this.lastPrefixWithNoResults)) {
            // Just give up since we know it won't return any results
            return false;
        }

        if (this.lastCompletedWord && captured[0].startsWith(this.lastCompletedWord)) {
            // It appears we're still matching a channel handle that we already completed
            return false;
        }

        // Clear the last completed word since we've started to match new text
        this.lastCompletedWord = '';

        this.startNewRequest(prefix);

        const words = prefix.toLowerCase().split(/\s+/);
        const wrappedChannelIds: Record<string, boolean> = {};
        let wrappedChannels: WrappedChannels[] = [];
        getMyChannels(store.getState()).forEach((item) => {
            if (item.type !== 'O' || item.delete_at > 0) {
                return;
            }
            const nameWords = item.name.toLowerCase().split(/\s+/).concat(item.display_name.toLowerCase().split(/\s+/));
            let matched = true;
            for (let j = 0; matched && j < words.length; j++) {
                if (!words[j]) {
                    continue;
                }
                let wordMatched = false;
                for (let i = 0; i < nameWords.length; i++) {
                    if (nameWords[i].startsWith(words[j])) {
                        wordMatched = true;
                        break;
                    }
                }
                if (!wordMatched) {
                    matched = false;
                    break;
                }
            }
            if (!matched) {
                return;
            }
            wrappedChannelIds[item.id] = true;
            wrappedChannels.push({
                type: Constants.MENTION_CHANNELS,
                channel: item,
            });
        });
        wrappedChannels = wrappedChannels.sort((a, b) => {
            //
            // MM-12677 When this is migrated this needs to be fixed to pull the user's locale
            //
            return sortChannelsByTypeAndDisplayName('en', a.channel as Channel, b.channel as Channel);
        });
        const channelMentions = wrappedChannels.map((item) => '~' + item.channel?.name);
        resultCallback({
            terms: channelMentions.concat([' ']),
            items: wrappedChannels.concat([{
                type: Constants.MENTION_MORE_CHANNELS,
                loading: true,
            }]),
            component: ChannelMentionSuggestion,
            matchedPretext: captured[1],
        });

        const handleChannels = (channels: Channel[], withError: boolean) => {
            if (prefix !== this.latestPrefix || this.shouldCancelDispatch(prefix)) {
                return;
            }

            const myMembers = getMyChannelMemberships(store.getState());

            if (channels.length === 0 && !withError) {
                this.lastPrefixWithNoResults = prefix;
            }

            // Wrap channels in an outer object to avoid overwriting the 'type' property.
            const wrappedMoreChannels: WrappedChannels[] = [];
            channels.forEach((item) => {
                if (item.delete_at > 0 && !myMembers[item.id]) {
                    return;
                }

                if (myMembers[item.id] && !wrappedChannelIds[item.id]) {
                    wrappedChannelIds[item.id] = true;
                    wrappedChannels.push({
                        type: Constants.MENTION_CHANNELS,
                        channel: item,
                    });
                    return;
                }

                if (myMembers[item.id] && wrappedChannelIds[item.id]) {
                    return;
                }

                if (!myMembers[item.id] && wrappedChannelIds[item.id]) {
                    delete wrappedChannelIds[item.id];
                    const idx = wrappedChannels.map((el) => el.channel?.id).indexOf(item.id);
                    if (idx >= 0) {
                        wrappedChannels.splice(idx, 1);
                    }
                }

                wrappedMoreChannels.push({
                    type: Constants.MENTION_MORE_CHANNELS,
                    channel: item,
                });
            });

            wrappedChannels = wrappedChannels.sort((a, b) => {
                //
                // MM-12677 When this is migrated this needs to be fixed to pull the user's locale
                //
                return sortChannelsByTypeAndDisplayName('en', a.channel as Channel, b.channel as Channel);
            });

            const wrapped = wrappedChannels.concat(wrappedMoreChannels);
            const mentions = wrapped.map((item) => '~' + item.channel?.name);

            resultCallback({
                matchedPretext: captured[1],
                terms: mentions,
                items: wrapped,
                component: ChannelMentionSuggestion,
            });
        };

        this.autocompleteChannels(
            prefix,
            (channels: Channel[]) => handleChannels(channels, false),
            () => handleChannels([], true),
        );

        return true;
    }

    handleCompleteWord(term: string) {
        this.lastCompletedWord = term;
        this.lastPrefixWithNoResults = '';
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {Store} from 'redux';

import Icon from '@mattermost/compass-components/foundations/icon/Icon';

import {Client4} from 'mattermost-redux/client';
import {appsEnabled} from 'mattermost-redux/selectors/entities/apps';
import {AutocompleteSuggestion, CommandArgs} from '@mattermost/types/integrations';

import globalStore from 'stores/redux_store';

import * as UserAgent from 'utils/user_agent';
import * as Utils from 'utils/utils';
import {Constants} from 'utils/constants';

import Suggestion from '../suggestion';
import Provider from '../provider';

import {GlobalState} from 'types/store';

import {AppCommandParser} from './app_command_parser/app_command_parser';
import {intlShim} from './app_command_parser/app_command_parser_dependencies';

const EXECUTE_CURRENT_COMMAND_ITEM_ID = Constants.Integrations.EXECUTE_CURRENT_COMMAND_ITEM_ID;
const OPEN_COMMAND_IN_MODAL_ITEM_ID = Constants.Integrations.OPEN_COMMAND_IN_MODAL_ITEM_ID;
const COMMAND_SUGGESTION_ERROR = Constants.Integrations.COMMAND_SUGGESTION_ERROR;

export class CommandSuggestion extends Suggestion {
    render() {
        const {isSelection} = this.props;
        const item = this.props.item as AutocompleteSuggestion;

        let className = 'slash-command';
        if (isSelection) {
            className += ' suggestion--selected';
        }
        let symbolSpan = <span>{'/'}</span>;
        switch (item.IconData) {
        case EXECUTE_CURRENT_COMMAND_ITEM_ID:
            symbolSpan = <span className='block mt-1'>{''}</span>;
            break;
        case OPEN_COMMAND_IN_MODAL_ITEM_ID:
            symbolSpan = (
                <span className='block mt-1'>
                    <Icon
                        size={28}
                        glyph={'dock-window'}
                    />
                </span>
            );
            break;
        case COMMAND_SUGGESTION_ERROR:
            symbolSpan = <span>{'!'}</span>;
            break;
        }
        let icon = <div className='slash-command__icon'>{symbolSpan}</div>;
        if (item.IconData && ![EXECUTE_CURRENT_COMMAND_ITEM_ID, COMMAND_SUGGESTION_ERROR, OPEN_COMMAND_IN_MODAL_ITEM_ID].includes(item.IconData)) {
            icon = (
                <div
                    className='slash-command__icon'
                    style={{backgroundColor: 'transparent'}}
                >
                    <img src={item.IconData}/>
                </div>);
        }

        return (
            <div
                className={className}
                onClick={this.handleClick}
                onMouseMove={this.handleMouseMove}
                {...Suggestion.baseProps}
            >
                {icon}
                <div className='slash-command__info'>
                    <div className='slash-command__title'>
                        {item.Suggestion.substring(1) + ' ' + item.Hint}
                    </div>
                    <div className='slash-command__desc'>
                        {item.Description}
                    </div>
                </div>
            </div>
        );
    }
}

type Props = {
    teamId: string;
    channelId: string;
    rootId?: string;
};

export type Results = {
    matchedPretext: string;
    terms: string[];
    items: AutocompleteSuggestion[];
    component: React.ElementType;
}

type ResultsCallback = (results: Results) => void;

export default class CommandProvider extends Provider {
    private props: Props;
    private store: Store<GlobalState>;
    private triggerCharacter: string;
    private appCommandParser: AppCommandParser;

    constructor(props: Props) {
        super();

        this.store = globalStore;
        this.props = props;
        this.appCommandParser = new AppCommandParser(this.store as any, intlShim, props.channelId, props.teamId, props.rootId);
        this.triggerCharacter = '/';
    }

    setProps(props: Props) {
        this.props = props;
        this.appCommandParser.setChannelContext(props.channelId, props.teamId, props.rootId);
    }

    handlePretextChanged(pretext: string, resultCallback: ResultsCallback) {
        if (!pretext.startsWith(this.triggerCharacter)) {
            return false;
        }

        if (appsEnabled(this.store.getState()) && this.appCommandParser.isAppCommand(pretext)) {
            this.appCommandParser.getSuggestions(pretext).then((suggestions) => {
                const matches = suggestions.map((suggestion) => ({
                    ...suggestion,
                    Complete: '/' + suggestion.Complete,
                    Suggestion: '/' + suggestion.Suggestion,
                }));

                const terms = matches.map((suggestion) => suggestion.Complete);
                resultCallback({
                    matchedPretext: pretext,
                    terms,
                    items: matches,
                    component: CommandSuggestion,
                });
            });
            return true;
        }

        if (UserAgent.isMobile()) {
            this.handleMobile(pretext, resultCallback);
        } else {
            this.handleWebapp(pretext, resultCallback);
        }

        return true;
    }

    handleCompleteWord(term: string, pretext: string, callback: (s: string) => void) {
        callback(term + ' ');
    }

    handleMobile(pretext: string, resultCallback: ResultsCallback) {
        const {teamId} = this.props;

        const command = pretext.toLowerCase();
        Client4.getCommandsList(teamId).then(
            (data) => {
                let matches: AutocompleteSuggestion[] = [];
                if (appsEnabled(this.store.getState())) {
                    const appCommandSuggestions = this.appCommandParser.getSuggestionsBase(pretext);
                    matches = matches.concat(appCommandSuggestions);
                }

                data.forEach((cmd) => {
                    if (!cmd.auto_complete) {
                        return;
                    }

                    if (cmd.trigger === 'shortcuts') {
                        return;
                    }

                    if ((this.triggerCharacter + cmd.trigger).indexOf(command) === 0) {
                        const s = this.triggerCharacter + cmd.trigger;
                        let hint = '';
                        if (cmd.auto_complete_hint && cmd.auto_complete_hint.length !== 0) {
                            hint = cmd.auto_complete_hint;
                        }
                        matches.push({
                            Suggestion: s,
                            Complete: '',
                            Hint: hint,
                            Description: cmd.auto_complete_desc,
                            IconData: '',
                            type: Constants.Integrations.COMMAND,
                        });
                    }
                });

                matches = matches.sort((a, b) => a.Suggestion.localeCompare(b.Suggestion));

                // pull out the suggested commands from the returned data
                const terms = matches.map((suggestion) => suggestion.Suggestion);

                resultCallback({
                    matchedPretext: command,
                    terms,
                    items: matches,
                    component: CommandSuggestion,
                });
            },
        );
    }

    handleWebapp(pretext: string, resultCallback: ResultsCallback) {
        const command = pretext.toLowerCase();

        const {teamId, channelId, rootId} = this.props;
        const args: CommandArgs = {
            team_id: teamId,
            channel_id: channelId,
            root_id: rootId,
        };

        Client4.getCommandAutocompleteSuggestionsList(command, teamId, args).then(
            ((data: AutocompleteSuggestion[]) => {
                let matches: AutocompleteSuggestion[] = [];

                let cmd = 'Ctrl';
                if (Utils.isMac()) {
                    cmd = '';
                }

                if (appsEnabled(this.store.getState())) {
                    const appCommandSuggestions = this.appCommandParser.getSuggestionsBase(pretext).map((suggestion) => ({
                        ...suggestion,
                        Complete: '/' + suggestion.Complete,
                        Suggestion: suggestion.Suggestion,
                    }));
                    matches = matches.concat(appCommandSuggestions);
                }

                data.forEach((s) => {
                    if (!this.contains(matches, this.triggerCharacter + s.Complete)) {
                        matches.push({
                            Complete: this.triggerCharacter + s.Complete,
                            Suggestion: this.triggerCharacter + s.Suggestion,
                            Hint: s.Hint,
                            Description: s.Description,
                            IconData: s.IconData,
                            type: Constants.Integrations.COMMAND,
                        });
                    }
                });

                // sort only if we are looking at base commands
                if (!pretext.includes(' ')) {
                    matches.sort((a, b) => {
                        if (a.Suggestion.toLowerCase() > b.Suggestion.toLowerCase()) {
                            return 1;
                        } else if (a.Suggestion.toLowerCase() < b.Suggestion.toLowerCase()) {
                            return -1;
                        }
                        return 0;
                    });
                }

                if (this.shouldAddExecuteItem(data, pretext)) {
                    matches.unshift({
                        Complete: pretext + EXECUTE_CURRENT_COMMAND_ITEM_ID,
                        Suggestion: '/Execute Current Command',
                        Hint: '',
                        Description: 'Select this option or use ' + cmd + '+Enter to execute the current command.',
                        IconData: EXECUTE_CURRENT_COMMAND_ITEM_ID,
                        type: Constants.Integrations.COMMAND,
                    });
                }

                // pull out the suggested commands from the returned data
                const terms = matches.map((suggestion) => suggestion.Complete);

                resultCallback({
                    matchedPretext: command,
                    terms,
                    items: matches,
                    component: CommandSuggestion,
                });
            }),
        );
    }

    shouldAddExecuteItem(data: AutocompleteSuggestion[], pretext: string) {
        if (data.length === 0) {
            return false;
        }
        if (pretext[pretext.length - 1] === ' ') {
            return true;
        }

        // If suggestion is empty it means that user can input any text so we allow them to execute.
        return data.findIndex((item) => item.Suggestion === '') !== -1;
    }

    contains(matches: AutocompleteSuggestion[], complete: string) {
        return matches.findIndex((match) => match.Complete === complete) !== -1;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {Store} from 'redux';

import globalStore from 'stores/redux_store';

import Provider from '../provider';
import {GlobalState} from 'types/store';

import {Constants} from 'utils/constants';

import {appsEnabled} from 'mattermost-redux/selectors/entities/apps';

import AtMentionSuggestion from '../at_mention_provider/at_mention_suggestion';

import {ChannelMentionSuggestion} from '../channel_mention_provider';

import {openAppsModal} from 'actions/apps';

import {AppCommandParser} from './app_command_parser/app_command_parser';

import {AutocompleteSuggestion, Channel, COMMAND_SUGGESTION_CHANNEL, COMMAND_SUGGESTION_USER, intlShim, UserProfile} from './app_command_parser/app_command_parser_dependencies';
import {CommandSuggestion} from './command_provider';

type Props = {
    teamId: string;
    channelId: string;
    rootId?: string;
};

export type Results = {
    matchedPretext: string;
    terms: string[];
    items: Array<AutocompleteSuggestion | UserProfile | {channel: Channel}>;
    component?: React.ElementType;
    components?: React.ElementType[];
}

type ResultsCallback = (results: Results) => void;

export default class AppCommandProvider extends Provider {
    private store: Store<GlobalState>;
    private triggerCharacter: string;
    private appCommandParser: AppCommandParser;

    constructor(props: Props) {
        super();

        this.store = globalStore;
        this.appCommandParser = new AppCommandParser(this.store as any, intlShim, props.channelId, props.teamId, props.rootId);
        this.triggerCharacter = '/';
    }

    setProps(props: Props) {
        this.appCommandParser.setChannelContext(props.channelId, props.teamId, props.rootId);
    }

    handlePretextChanged(pretext: string, resultCallback: ResultsCallback) {
        if (!pretext.startsWith(this.triggerCharacter)) {
            return false;
        }

        if (!appsEnabled(this.store.getState())) {
            return false;
        }

        if (!this.appCommandParser.isAppCommand(pretext)) {
            return false;
        }

        this.appCommandParser.getSuggestions(pretext).then((suggestions) => {
            const element: React.ElementType[] = [];
            const matches = suggestions.map((suggestion) => {
                switch (suggestion.type) {
                case COMMAND_SUGGESTION_USER:
                    element.push(AtMentionSuggestion);
                    return {...suggestion.item! as UserProfile, type: Constants.Integrations.COMMAND};
                case COMMAND_SUGGESTION_CHANNEL:
                    element.push(ChannelMentionSuggestion);
                    return {channel: suggestion.item! as Channel, type: Constants.Integrations.COMMAND};
                default:
                    element.push(CommandSuggestion);
                    return {
                        ...suggestion,
                        Complete: '/' + suggestion.Complete,
                        Suggestion: '/' + suggestion.Suggestion,
                        type: Constants.Integrations.COMMAND,
                    };
                }
            });

            const terms = suggestions.map((suggestion) => '/' + suggestion.Complete);
            resultCallback({
                matchedPretext: pretext,
                terms,
                items: matches,
                components: element,
            });
        });
        return true;
    }

    public async openAppsModalFromCommand(pretext: string) {
        const {form, context} = await this.appCommandParser.composeFormFromCommand(pretext);
        if (!form || !context) {
            return;
        }
        this.store.dispatch(openAppsModal(form, context) as any);
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {Preferences} from 'utils/constants';

import {autocompleteCustomEmojis} from 'mattermost-redux/actions/emojis';
import {getEmojiImageUrl} from 'mattermost-redux/utils/emoji_utils';

import {getEmojiMap, getRecentEmojisNames} from 'selectors/emojis';

import store from 'stores/redux_store.jsx';

import * as Emoticons from 'utils/emoticons';
import {compareEmojis, emojiMatchesSkin} from 'utils/emoji_utils';

import Suggestion from './suggestion.jsx';
import Provider from './provider';

export const MIN_EMOTICON_LENGTH = 2;
export const EMOJI_CATEGORY_SUGGESTION_BLOCKLIST = ['skintone'];

class EmoticonSuggestion extends Suggestion {
    render() {
        const text = this.props.term;
        const emoji = this.props.item.emoji;

        let className = 'emoticon-suggestion';
        if (this.props.isSelection) {
            className += ' suggestion--selected';
        }

        return (
            <div
                className={className}
                onClick={this.handleClick}
                onMouseMove={this.handleMouseMove}
                {...Suggestion.baseProps}
            >
                <div className='pull-left'>
                    <img
                        alt={text}
                        className='emoticon-suggestion__image'
                        src={getEmojiImageUrl(emoji)}
                        title={text}
                    />
                </div>
                <div className='pull-left'>
                    {text}
                </div>
            </div>
        );
    }
}

export default class EmoticonProvider extends Provider {
    constructor() {
        super();

        this.triggerCharacter = ':';
    }
    handlePretextChanged(pretext, resultsCallback) {
        // Look for the potential emoticons at the start of the text, after whitespace, and at the start of emoji reaction commands
        const captured = (/(^|\s|^\+|^-)(:([^:\s]*))$/g).exec(pretext.toLowerCase());
        if (!captured) {
            return false;
        }

        const prefix = captured[1];
        const text = captured[2];
        const partialName = captured[3];

        if (partialName.length < MIN_EMOTICON_LENGTH) {
            return false;
        }

        // Check for text emoticons if this isn't for an emoji reaction
        if (prefix !== '-' && prefix !== '+') {
            for (const emoticon of Object.keys(Emoticons.emoticonPatterns)) {
                if (Emoticons.emoticonPatterns[emoticon].test(text)) {
                    // Don't show the autocomplete for text emoticons
                    return false;
                }
            }
        }

        if (store.getState().entities.general.config.EnableCustomEmoji === 'true') {
            store.dispatch(autocompleteCustomEmojis(partialName)).then(() => this.findAndSuggestEmojis(text, partialName, resultsCallback));
        } else {
            this.findAndSuggestEmojis(text, partialName, resultsCallback);
        }

        return true;
    }

    formatEmojis(emojis) {
        return emojis.map((item) => ':' + item.name + ':');
    }

    // findAndSuggestEmojis uses the provided partialName to match anywhere inside an emoji name.
    //
    // For example, typing `:welc` would match both `:welcome:` and `:youre_welcome:` if those
    // emojis are present in the local store. Note, however, that the server only does prefix
    // matches, so a query to populate the local store for `:welc` would only return `:welcome:`.
    // This results in surprising differences between a fresh load of the application, and the
    // changes to the cache from expanding the cache with emojis found in existing posts.
    //
    // For now, this behaviour and difference is by design.
    // See https://mattermost.atlassian.net/browse/MM-17320.
    findAndSuggestEmojis(text, partialName, resultsCallback) {
        const recentMatched = [];
        const matched = [];
        const state = store.getState();
        const skintone = state.entities?.preferences?.myPreferences['emoji--emoji_skintone']?.value || 'default';
        const emojiMap = getEmojiMap(state);
        const recentEmojis = getRecentEmojisNames(state);

        // Check for named emoji
        for (const [name, emoji] of emojiMap) {
            if (EMOJI_CATEGORY_SUGGESTION_BLOCKLIST.includes(emoji.category)) {
                continue;
            }

            if (emoji.short_names) {
                // This is a system emoji so it may have multiple names
                for (const alias of emoji.short_names) {
                    if (alias.indexOf(partialName) !== -1) {
                        const matchedArray = recentEmojis.includes(alias) || recentEmojis.includes(name) ? recentMatched : matched;

                        // if the emoji has skin, only add those that match with the user selected skin.
                        if (emojiMatchesSkin(emoji, skintone)) {
                            matchedArray.push({name: alias, emoji, type: Preferences.CATEGORY_EMOJI});
                        }
                        break;
                    }
                }
            } else if (name.indexOf(partialName) !== -1) {
                // This is a custom emoji so it only has one name
                if (emojiMap.hasSystemEmoji(name)) {
                    // System emojis take precedence over custom ones
                    continue;
                }

                const matchedArray = recentEmojis.includes(name) ? recentMatched : matched;

                matchedArray.push({name, emoji, type: Preferences.CATEGORY_EMOJI});
            }
        }

        const sortEmojisHelper = (a, b) => {
            return compareEmojis(a, b, partialName);
        };

        recentMatched.sort(sortEmojisHelper);

        matched.sort(sortEmojisHelper);

        const terms = [
            ...this.formatEmojis(recentMatched),
            ...this.formatEmojis(matched),
        ];

        const items = [
            ...recentMatched,
            ...matched,
        ];

        // Required to get past the dispatch during dispatch error

        resultsCallback({
            matchedPretext: text,
            terms,
            items,
            component: EmoticonSuggestion,
        });
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ChangeEvent, ElementType, FocusEvent, KeyboardEvent, MouseEvent} from 'react';
import {FormattedMessage} from 'react-intl';
import classNames from 'classnames';

import {Channel} from '@mattermost/types/channels';
import {ActionResult} from 'mattermost-redux/types/actions';
import {UserProfile} from '@mattermost/types/users';

import AutosizeTextarea from 'components/autosize_textarea';
import PostMarkdown from 'components/post_markdown';
import Provider from 'components/suggestion/provider';
import AtMentionProvider from 'components/suggestion/at_mention_provider';
import ChannelMentionProvider from 'components/suggestion/channel_mention_provider';
import AppCommandProvider from 'components/suggestion/command_provider/app_provider';
import CommandProvider from 'components/suggestion/command_provider/command_provider';
import EmoticonProvider from 'components/suggestion/emoticon_provider.jsx';
import SuggestionBox from 'components/suggestion/suggestion_box';
import SuggestionBoxComponent from 'components/suggestion/suggestion_box/suggestion_box';
import SuggestionList from 'components/suggestion/suggestion_list.jsx';

import * as Utils from 'utils/utils';

import {TextboxElement} from './index';

const ALL = ['all'];

export type Props = {
    id: string;
    channelId: string;
    rootId?: string;
    tabIndex?: number;
    value: string;
    onChange: (e: ChangeEvent<TextboxElement>) => void;
    onKeyPress: (e: KeyboardEvent<any>) => void;
    onComposition?: () => void;
    onHeightChange?: (height: number, maxHeight: number) => void;
    createMessage: string;
    onKeyDown?: (e: KeyboardEvent<TextboxElement>) => void;
    onSelect?: (e: React.SyntheticEvent<TextboxElement>) => void;
    onMouseUp?: (e: React.MouseEvent<TextboxElement>) => void;
    onKeyUp?: (e: React.KeyboardEvent<TextboxElement>) => void;
    onBlur?: (e: FocusEvent<TextboxElement>) => void;
    supportsCommands?: boolean;
    handlePostError?: (message: JSX.Element | null) => void;
    onPaste?: (e: ClipboardEvent) => void;
    suggestionList?: React.ComponentProps<typeof SuggestionBox>['listComponent'];
    suggestionListPosition?: React.ComponentProps<typeof SuggestionList>['position'];
    alignWithTextbox?: boolean;
    emojiEnabled?: boolean;
    isRHS?: boolean;
    characterLimit: number;
    disabled?: boolean;
    badConnection?: boolean;
    listenForMentionKeyClick?: boolean;
    currentUserId: string;
    currentTeamId: string;
    preview?: boolean;
    autocompleteGroups: Array<{ id: string }> | null;
    actions: {
        autocompleteUsersInChannel: (prefix: string, channelId: string) => Promise<ActionResult>;
        autocompleteChannels: (term: string, success: (channels: Channel[]) => void, error: () => void) => Promise<ActionResult>;
        searchAssociatedGroupsForReference: (prefix: string, teamId: string, channelId: string | undefined) => Promise<{ data: any }>;
    };
    useChannelMentions: boolean;
    inputComponent?: ElementType;
    openWhenEmpty?: boolean;
    priorityProfiles?: UserProfile[];
    hasLabels?: boolean;
};

const VISIBLE = {visibility: 'visible'};
const HIDDEN = {visibility: 'hidden'};

export default class Textbox extends React.PureComponent<Props> {
    private readonly suggestionProviders: Provider[];
    private readonly wrapper: React.RefObject<HTMLDivElement>;
    private readonly message: React.RefObject<SuggestionBoxComponent>;
    private readonly preview: React.RefObject<HTMLDivElement>;

    static defaultProps = {
        supportsCommands: true,
        isRHS: false,
        listenForMentionKeyClick: false,
        inputComponent: AutosizeTextarea,
        suggestionList: SuggestionList,
    };

    constructor(props: Props) {
        super(props);

        this.suggestionProviders = [];

        if (props.supportsCommands) {
            this.suggestionProviders.push(new AppCommandProvider({
                teamId: this.props.currentTeamId,
                channelId: this.props.channelId,
                rootId: this.props.rootId,
            }));
        }

        this.suggestionProviders.push(
            new AtMentionProvider({
                currentUserId: this.props.currentUserId,
                channelId: this.props.channelId,
                autocompleteUsersInChannel: (prefix: string) => this.props.actions.autocompleteUsersInChannel(prefix, this.props.channelId),
                useChannelMentions: this.props.useChannelMentions,
                autocompleteGroups: this.props.autocompleteGroups,
                searchAssociatedGroupsForReference: (prefix: string) => this.props.actions.searchAssociatedGroupsForReference(prefix, this.props.currentTeamId, this.props.channelId),
                priorityProfiles: this.props.priorityProfiles,
            }),
            new ChannelMentionProvider(props.actions.autocompleteChannels),
            new EmoticonProvider(),
        );

        if (props.supportsCommands) {
            this.suggestionProviders.push(new CommandProvider({
                teamId: this.props.currentTeamId,
                channelId: this.props.channelId,
                rootId: this.props.rootId,
            }));
        }

        this.checkMessageLength(props.value);
        this.wrapper = React.createRef();
        this.message = React.createRef();
        this.preview = React.createRef();
    }

    handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        this.props.onChange(e);
    }

    updateSuggestions(prevProps: Props) {
        if (this.props.channelId !== prevProps.channelId ||
            this.props.currentUserId !== prevProps.currentUserId ||
            this.props.autocompleteGroups !== prevProps.autocompleteGroups ||
            this.props.useChannelMentions !== prevProps.useChannelMentions ||
            this.props.currentTeamId !== prevProps.currentTeamId ||
            this.props.priorityProfiles !== prevProps.priorityProfiles) {
            // Update channel id for AtMentionProvider.
            for (const provider of this.suggestionProviders) {
                if (provider instanceof AtMentionProvider) {
                    provider.setProps({
                        currentUserId: this.props.currentUserId,
                        channelId: this.props.channelId,
                        autocompleteUsersInChannel: (prefix: string) => this.props.actions.autocompleteUsersInChannel(prefix, this.props.channelId),
                        useChannelMentions: this.props.useChannelMentions,
                        autocompleteGroups: this.props.autocompleteGroups,
                        searchAssociatedGroupsForReference: (prefix: string) => this.props.actions.searchAssociatedGroupsForReference(prefix, this.props.currentTeamId, this.props.channelId),
                        priorityProfiles: this.props.priorityProfiles,
                    });
                }
            }
        }

        if (this.props.channelId !== prevProps.channelId ||
            this.props.currentTeamId !== prevProps.currentTeamId ||
            this.props.rootId !== prevProps.rootId) {
            // Update channel id for CommandProvider and AppCommandProvider.
            for (const provider of this.suggestionProviders) {
                if (provider instanceof CommandProvider) {
                    provider.setProps({
                        teamId: this.props.currentTeamId,
                        channelId: this.props.channelId,
                        rootId: this.props.rootId,
                    });
                }
                if (provider instanceof AppCommandProvider) {
                    provider.setProps({
                        teamId: this.props.currentTeamId,
                        channelId: this.props.channelId,
                        rootId: this.props.rootId,
                    });
                }
            }
        }

        if (prevProps.value !== this.props.value) {
            this.checkMessageLength(this.props.value);
        }
    }

    componentDidUpdate(prevProps: Props) {
        if (!prevProps.preview && this.props.preview) {
            this.preview.current?.focus();
        }

        this.updateSuggestions(prevProps);
    }

    checkMessageLength = (message: string) => {
        if (this.props.handlePostError) {
            if (message.length > this.props.characterLimit) {
                const errorMessage = (
                    <FormattedMessage
                        id='create_post.error_message'
                        defaultMessage='Your message is too long. Character count: {length}/{limit}'
                        values={{
                            length: message.length,
                            limit: this.props.characterLimit,
                        }}
                    />);
                this.props.handlePostError(errorMessage);
            } else {
                this.props.handlePostError(null);
            }
        }
    }

    // adding in the HTMLDivElement to support event handling in preview state
    handleKeyDown = (e: KeyboardEvent<TextboxElement | HTMLDivElement>) => {
        // since we do only handle the sending when in preview mode this is fine to be casted
        this.props.onKeyDown?.(e as KeyboardEvent<TextboxElement>);
    }

    handleSelect = (e: React.SyntheticEvent<TextboxElement>) => this.props.onSelect?.(e);

    handleMouseUp = (e: MouseEvent<TextboxElement>) => this.props.onMouseUp?.(e);

    handleKeyUp = (e: KeyboardEvent<TextboxElement>) => this.props.onKeyUp?.(e);

    // adding in the HTMLDivElement to support event handling in preview state
    handleBlur = (e: FocusEvent<TextboxElement | HTMLDivElement>) => {
        // since we do only handle the sending when in preview mode this is fine to be casted
        this.props.onBlur?.(e as FocusEvent<TextboxElement>);
    }

    handleHeightChange = (height: number, maxHeight: number) => {
        this.props.onHeightChange?.(height, maxHeight);
    }

    getInputBox = () => {
        return this.message.current?.getTextbox();
    }

    focus = () => {
        const textbox = this.getInputBox();
        if (textbox) {
            textbox.focus();
            Utils.placeCaretAtEnd(textbox);
            setTimeout(() => {
                Utils.scrollToCaret(textbox);
            });

            // reset character count warning
            this.checkMessageLength(textbox.value);
        }
    }

    blur = () => {
        this.getInputBox()?.blur();
    };

    getStyle = () => {
        return this.props.preview ? HIDDEN : VISIBLE;
    }

    render() {
        let preview = null;

        let textboxClassName = 'form-control custom-textarea';
        let textWrapperClass = 'textarea-wrapper';
        if (this.props.emojiEnabled) {
            textboxClassName += ' custom-textarea--emoji-picker';
        }
        if (this.props.badConnection) {
            textboxClassName += ' bad-connection';
        }
        if (this.props.hasLabels) {
            textboxClassName += ' textarea--has-labels';
        }
        if (this.props.preview) {
            textboxClassName += ' custom-textarea--preview';
            textWrapperClass += ' textarea-wrapper--preview';

            preview = (
                <div
                    tabIndex={this.props.tabIndex || 0}
                    ref={this.preview}
                    className={classNames('form-control custom-textarea textbox-preview-area', {'textarea--has-labels': this.props.hasLabels})}
                    onKeyPress={this.props.onKeyPress}
                    onKeyDown={this.handleKeyDown}
                    onBlur={this.handleBlur}
                >
                    <PostMarkdown
                        isRHS={this.props.isRHS}
                        message={this.props.value}
                        mentionKeys={[]}
                        channelId={this.props.channelId}
                    />
                </div>
            );
        }

        return (
            <div
                ref={this.wrapper}
                className={textWrapperClass}
            >
                <SuggestionBox
                    id={this.props.id}
                    ref={this.message}
                    className={textboxClassName}
                    spellCheck='true'
                    placeholder={this.props.createMessage}
                    onChange={this.handleChange}
                    onKeyPress={this.props.onKeyPress}
                    onSelect={this.handleSelect}
                    onKeyDown={this.handleKeyDown}
                    onMouseUp={this.handleMouseUp}
                    onKeyUp={this.handleKeyUp}
                    onComposition={this.props.onComposition}
                    onBlur={this.handleBlur}
                    onHeightChange={this.handleHeightChange}
                    onPaste={this.props.onPaste}
                    style={this.getStyle()}
                    inputComponent={this.props.inputComponent}
                    listComponent={this.props.suggestionList}
                    listPosition={this.props.suggestionListPosition}
                    providers={this.suggestionProviders}
                    channelId={this.props.channelId}
                    value={this.props.value}
                    renderDividers={ALL}
                    isRHS={this.props.isRHS}
                    disabled={this.props.disabled}
                    contextId={this.props.channelId}
                    listenForMentionKeyClick={this.props.listenForMentionKeyClick}
                    openWhenEmpty={this.props.openWhenEmpty}
                    alignWithTextbox={this.props.alignWithTextbox}
                />
                {preview}
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';
import {connect} from 'react-redux';

import {getAssociatedGroupsForReference} from 'mattermost-redux/selectors/entities/groups';
import {getLicense} from 'mattermost-redux/selectors/entities/general';
import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {makeGetProfilesForThread} from 'mattermost-redux/selectors/entities/posts';

import {haveIChannelPermission} from 'mattermost-redux/selectors/entities/roles';
import Permissions from 'mattermost-redux/constants/permissions';

import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';

import {GlobalState} from '@mattermost/types/store';
import {Action} from 'mattermost-redux/types/actions';

import {autocompleteUsersInChannel} from 'actions/views/channel';
import {searchAssociatedGroupsForReference} from 'actions/views/group';
import {autocompleteChannels} from 'actions/channel_actions';

import Textbox, {Props as TextboxProps} from './textbox';

type Props = {
    channelId: string;
    rootId?: string;
};

export type TextboxElement = HTMLInputElement | HTMLTextAreaElement;

const makeMapStateToProps = () => {
    const getProfilesForThread = makeGetProfilesForThread();
    return (state: GlobalState, ownProps: Props) => {
        const teamId = getCurrentTeamId(state);
        const license = getLicense(state);
        const useGroupMentions = license?.IsLicensed === 'true' && license?.LDAPGroups === 'true' && haveIChannelPermission(state,
            teamId,
            ownProps.channelId,
            Permissions.USE_GROUP_MENTIONS,
        );
        const autocompleteGroups = useGroupMentions ? getAssociatedGroupsForReference(state, teamId, ownProps.channelId) : null;

        return {
            currentUserId: getCurrentUserId(state),
            currentTeamId: teamId,
            autocompleteGroups,
            priorityProfiles: getProfilesForThread(state, ownProps.rootId ?? ''),
        };
    };
};

const mapDispatchToProps = (dispatch: Dispatch) => ({
    actions: bindActionCreators<ActionCreatorsMapObject<Action>, TextboxProps['actions']>({
        autocompleteUsersInChannel,
        autocompleteChannels,
        searchAssociatedGroupsForReference,
    }, dispatch),
});

export {Textbox as TextboxClass};

export default connect(makeMapStateToProps, mapDispatchToProps, null, {forwardRef: true})(Textbox);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo, useCallback, useEffect, useMemo} from 'react';
import {FormattedMessage} from 'react-intl';
import {useDispatch, useSelector} from 'react-redux';

import {Post} from '@mattermost/types/posts';
import {threadIsSynthetic, UserThread} from '@mattermost/types/threads';

import {setThreadFollow, getThread as fetchThread} from 'mattermost-redux/actions/threads';
import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {makeGetThreadOrSynthetic} from 'mattermost-redux/selectors/entities/threads';
import {getPost} from 'mattermost-redux/selectors/entities/posts';

import {GlobalState} from 'types/store';

import {selectPost} from 'actions/views/rhs';
import {trackEvent} from 'actions/telemetry_actions';

import Avatars from 'components/widgets/users/avatars';
import Timestamp from 'components/timestamp';
import SimpleTooltip from 'components/widgets/simple_tooltip';
import Button from 'components/threading/common/button';
import FollowButton from 'components/threading/common/follow_button';
import {THREADING_TIME} from 'components/threading/common/options';

import './thread_footer.scss';

type Props = {
    threadId: UserThread['id'];
    replyClick?: React.EventHandler<React.MouseEvent>;
};

function ThreadFooter({
    threadId,
    replyClick,
}: Props) {
    const dispatch = useDispatch();
    const currentTeamId = useSelector(getCurrentTeamId);
    const currentUserId = useSelector(getCurrentUserId);
    const post = useSelector((state: GlobalState) => getPost(state, threadId));
    const getThreadOrSynthetic = useMemo(makeGetThreadOrSynthetic, [post.id]);
    const thread = useSelector((state: GlobalState) => getThreadOrSynthetic(state, post));

    useEffect(() => {
        if (threadIsSynthetic(thread) && thread.is_following && thread.reply_count > 0) {
            dispatch(fetchThread(currentUserId, currentTeamId, threadId));
        }
    }, []);

    const {
        participants,
        reply_count: totalReplies = 0,
        last_reply_at: lastReplyAt,
        is_following: isFollowing = false,
        post: {
            channel_id: channelId,
        },
    } = thread;
    const participantIds = useMemo(() => (participants || []).map(({id}) => id).reverse(), [participants]);

    const handleReply = useCallback((e) => {
        if (replyClick) {
            replyClick(e);
            return;
        }

        trackEvent('crt', 'replied_using_footer');
        e.stopPropagation();
        dispatch(selectPost({id: threadId, channel_id: channelId} as Post));
    }, [dispatch, replyClick, threadId, channelId]);

    const handleFollowing = useCallback((e) => {
        e.stopPropagation();
        dispatch(setThreadFollow(currentUserId, currentTeamId, threadId, !isFollowing));
    }, [isFollowing]);

    return (
        <div className='ThreadFooter'>
            {!isFollowing || threadIsSynthetic(thread) || !thread.unread_replies ? (
                <div className='indicator'/>
            ) : (
                <SimpleTooltip
                    id='threadFooterIndicator'
                    content={
                        <FormattedMessage
                            id='threading.numNewMessages'
                            defaultMessage='{newReplies, plural, =0 {no unread messages} =1 {one unread message} other {# unread messages}}'
                            values={{newReplies: thread.unread_replies}}
                        />
                    }
                >
                    <div
                        className='indicator'
                        tabIndex={0}
                    >
                        <div className='dot-unreads'/>
                    </div>
                </SimpleTooltip>
            )}

            {participantIds && participantIds.length > 0 ? (
                <Avatars
                    userIds={participantIds}
                    size='sm'
                />
            ) : null}

            {thread.reply_count > 0 && (
                <Button
                    onClick={handleReply}
                    className='ReplyButton separated'
                    prepend={
                        <span className='icon'>
                            <i className='icon-reply-outline'/>
                        </span>
                    }
                >
                    <FormattedMessage
                        id='threading.numReplies'
                        defaultMessage='{totalReplies, plural, =0 {Reply} =1 {# reply} other {# replies}}'
                        values={{totalReplies}}
                    />
                </Button>
            )}

            <FollowButton
                isFollowing={isFollowing}
                className='separated'
                onClick={handleFollowing}
            />

            {Boolean(lastReplyAt) && (
                <Timestamp
                    value={lastReplyAt}
                    {...THREADING_TIME}
                >
                    {({formatted}) => (
                        <span className='Timestamp separated alt-visible'>
                            <FormattedMessage
                                id='threading.footer.lastReplyAt'
                                defaultMessage='Last reply {formatted}'
                                values={{formatted}}
                            />
                        </span>
                    )}
                </Timestamp>
            )}
        </div>
    );
}

export default memo(ThreadFooter);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo, ButtonHTMLAttributes, ReactNode} from 'react';
import classNames from 'classnames';

import './button.scss';

type Props = {
    prepend?: ReactNode;
    append?: ReactNode;
    isActive?: boolean;
    hasDot?: boolean;
    allowTextOverflow?: boolean;
}

type Attrs = Exclude<ButtonHTMLAttributes<HTMLButtonElement>, Props>

function Button({
    prepend,
    append,
    children,
    isActive,
    hasDot,
    allowTextOverflow = false,
    ...attrs
}: Props & Attrs) {
    return (
        <button
            {...attrs}
            className={classNames('Button Button___transparent', {'is-active': isActive, allowTextOverflow}, attrs.className)}
        >
            {prepend && (
                <span className='Button_prepended'>
                    {prepend}
                </span>
            )}
            <span className='Button_label'>
                {children}
                {hasDot && <span className='dot'/>}
            </span>
            {append && (
                <span className='Button_appended'>
                    {append}
                </span>
            )}
        </button>
    );
}

export default memo(Button);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo, ComponentProps} from 'react';
import {useIntl} from 'react-intl';

import classNames from 'classnames';

import Button from '../button';
import {t} from 'utils/i18n';

type Props = {
    isFollowing: boolean | null | undefined;
}

function FollowButton({
    isFollowing,
    ...props
}: Props & Exclude<ComponentProps<typeof Button>, Props>) {
    const {formatMessage} = useIntl();
    return (
        <Button
            {...props}
            className={classNames(props.className, 'FollowButton')}
            disabled={Boolean(props.disabled)}
            isActive={isFollowing ?? false}
        >
            {formatMessage(isFollowing ? {
                id: t('threading.following'),
                defaultMessage: 'Following',
            } : {
                id: t('threading.notFollowing'),
                defaultMessage: 'Follow',
            })}
        </Button>
    );
}

export default memo(FollowButton);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ComponentProps} from 'react';

import Timestamp from 'components/timestamp';

export const THREADING_TIME: Partial<ComponentProps<typeof Timestamp>> = {
    units: [
        'now',
        'minute',
        'hour',
        'day',
        'week',
    ],
    useTime: false,
    day: 'numeric',
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo, useEffect, useCallback} from 'react';
import {FormattedMessage, useIntl} from 'react-intl';

import Constants from 'utils/constants';
import {isKeyPressed} from 'utils/utils';

import Toast from 'components/toast/toast';

import './new_replies_banner.scss';

type Props = {
    hasNewReplies: boolean;
    width: number;
    onClick: () => void;
    onDismiss: () => void;
    actions: {
        updateThreadToastStatus: (status: boolean) => void;
    };
}

function NewRepliesBanner({
    hasNewReplies,
    onClick,
    onDismiss,
    width,
    actions,
}: Props) {
    const intl = useIntl();
    const onClickMessage = intl.formatMessage({id: 'postlist.toast.scrollToLatest', defaultMessage: 'Jump to new messages'});

    useEffect(() => {
        actions.updateThreadToastStatus(hasNewReplies);
    }, [hasNewReplies]);

    const handleShortcut = useCallback((e) => {
        if (isKeyPressed(e, Constants.KeyCodes.ESCAPE)) {
            if (hasNewReplies) {
                onDismiss();
            }
        }
    }, [hasNewReplies]);

    useEffect(() => {
        document.addEventListener('keydown', handleShortcut);

        return () => {
            document.removeEventListener('keydown', handleShortcut);
        };
    }, [handleShortcut]);

    return (
        <div
            className='new-replies-banner'
            style={{width}}
        >
            <Toast
                show={hasNewReplies}
                showActions={true}
                onClick={onClick}
                onDismiss={onDismiss}
                onClickMessage={onClickMessage}
                overlayPlacement='top'
                width={156}
            >
                <FormattedMessage
                    id='rhs_thread.toast.newReplies'
                    defaultMessage='New Replies'
                />
            </Toast>
        </div>
    );
}

export default memo(NewRepliesBanner);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {bindActionCreators, Dispatch} from 'redux';
import {connect} from 'react-redux';

import {createSelector} from 'reselect';

import {Post} from '@mattermost/types/posts';
import {GenericAction} from 'mattermost-redux/types/actions';

import {makeGetPostsForThread} from 'mattermost-redux/selectors/entities/posts';
import {getCurrentUser} from 'mattermost-redux/selectors/entities/users';

import {updateThreadToastStatus} from 'actions/views/threads';

import {GlobalState} from 'types/store';

import NewRepliesBanner from './new_replies_banner';

type Props = {
    threadId: Post['id'];
    lastViewedBottom: number;
    canShow: boolean;
}

function makeGetHasNewRepliesSince(): (state: GlobalState, threadId: string, lastViewed: number) => boolean {
    const getPostsForThread = makeGetPostsForThread();

    return createSelector(
        'makeGetHasNewRepliesSince',
        getPostsForThread,
        getCurrentUser,
        (_state: GlobalState, _threadId: string, lastViewed: number) => lastViewed,
        (posts, currentUser, lastViewed) => posts.
            some((post) => post.create_at > lastViewed && post.user_id !== currentUser.id),
    );
}

function makeMapStateToProps() {
    const getHasNewRepliesSince = makeGetHasNewRepliesSince();

    return (state: GlobalState, ownProps: Props) => {
        const {threadId, lastViewedBottom, canShow} = ownProps;

        const hasNewReplies = canShow ? getHasNewRepliesSince(state, threadId, lastViewedBottom) : false;

        return {
            hasNewReplies,
        };
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            updateThreadToastStatus,
        }, dispatch),
    };
}

export default connect(makeMapStateToProps, mapDispatchToProps)(NewRepliesBanner);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

type Props = {
    onExited: () => void;
}

type State = {
    show: boolean;
}

export default class PostDeletedModal extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            show: true,
        };
    }

    private handleHide = () => {
        this.setState({show: false});
    }

    public render(): JSX.Element {
        return (
            <Modal
                dialogClassName='a11y__modal'
                show={this.state.show}
                onHide={this.handleHide}
                onExited={this.props.onExited}
                role='dialog'
                aria-labelledby='postDeletedModalLabel'
                data-testid='postDeletedModal'
            >
                <Modal.Header closeButton={true}>
                    <Modal.Title
                        componentClass='h1'
                        id='postDeletedModalLabel'
                    >
                        <FormattedMessage
                            id='post_delete.notPosted'
                            defaultMessage='Comment could not be posted'
                        />
                    </Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    <p>
                        <FormattedMessage
                            id='post_delete.someone'
                            defaultMessage='Someone deleted the message on which you tried to post a comment.'
                        />
                    </p>
                </Modal.Body>
                <Modal.Footer>
                    <button
                        type='button'
                        className='btn btn-primary'
                        autoFocus={true}
                        onClick={this.handleHide}
                        data-testid='postDeletedModalOkButton'
                    >
                        <FormattedMessage
                            id='post_delete.okay'
                            defaultMessage='Okay'
                        />
                    </button>
                </Modal.Footer>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/* eslint-disable max-lines */

import React from 'react';

import {ModalData} from 'types/actions.js';

import {sortFileInfos} from 'mattermost-redux/utils/file_utils';

import * as GlobalActions from 'actions/global_actions';

import Constants, {AdvancedTextEditor, Locations, ModalIdentifiers, Preferences} from 'utils/constants';
import {PreferenceType} from '@mattermost/types/preferences';
import * as UserAgent from 'utils/user_agent';
import * as Utils from 'utils/utils';
import {
    specialMentionsInText,
    postMessageOnKeyPress,
    shouldFocusMainTextbox,
    isErrorInvalidSlashCommand,
    splitMessageBasedOnCaretPosition,
    groupsMentionedInText,
    mentionsMinusSpecialMentionsInText,
} from 'utils/post_utils';
import {getTable, hasHtmlLink, formatMarkdownMessage, isGitHubCodeBlock, formatGithubCodePaste} from 'utils/paste';

import NotifyConfirmModal from 'components/notify_confirm_modal';
import {FileUpload as FileUploadClass} from 'components/file_upload/file_upload';
import PostDeletedModal from 'components/post_deleted_modal';
import {PostDraft} from 'types/store/draft';
import {Group, GroupSource} from '@mattermost/types/groups';
import {ChannelMemberCountsByGroup} from '@mattermost/types/channels';
import {FilePreviewInfo} from 'components/file_preview/file_preview';
import {Emoji} from '@mattermost/types/emojis';
import {ActionResult} from 'mattermost-redux/types/actions';
import {ServerError} from '@mattermost/types/errors';
import {FileInfo} from '@mattermost/types/files';
import EmojiMap from 'utils/emoji_map';
import {
    applyMarkdown,
    ApplyMarkdownOptions,
} from 'utils/markdown/apply_markdown';
import AdvanceTextEditor from '../advanced_text_editor/advanced_text_editor';
import {TextboxClass, TextboxElement} from '../textbox';

import FileLimitStickyBanner from '../file_limit_sticky_banner';

const KeyCodes = Constants.KeyCodes;

type Props = {
    currentTeamId: string;

    // The channel for which this comment is a part of
    channelId: string;

    // The id of the current user
    currentUserId: string;

    // The id of the parent post
    rootId: string;

    // The root message is deleted
    rootDeleted: boolean;

    // The number of channel members
    channelMembersCount: number;

    // The current history message selected
    messageInHistory?: string;

    // The current draft of the comment
    draft: PostDraft;

    // Determines if the submit button should be rendered
    enableAddButton?: boolean;

    // Force message submission on CTRL/CMD + ENTER
    codeBlockOnCtrlEnter?: boolean;

    // Set to force form submission on CTRL/CMD + ENTER instead of just ENTER
    ctrlSend?: boolean;

    // The id of the latest post in this channel
    latestPostId?: string;

    // The current user locale
    locale: string;

    // Error id, if the post creation fails
    createPostErrorId?: string;

    // Determines if the current user can edit the post
    canPost: boolean;

    // Determines if the user is allowed to upload files
    canUploadFiles: boolean;

    // Called to clear file uploads in progress
    clearCommentDraftUploads: () => void;

    // Called when comment draft needs to be updated
    onUpdateCommentDraft: (draft?: PostDraft, save?: boolean) => void;

    // Called when comment draft needs to be updated for a specific root ID
    updateCommentDraftWithRootId: (rootID: string, draft: PostDraft, save?: boolean) => void;

    // Called when submitting the comment
    onSubmit: (draft: PostDraft, options: {ignoreSlash: boolean}) => void;

    // Called when resetting comment message history index
    onResetHistoryIndex: () => void;

    // Called when navigating back through comment message history
    onMoveHistoryIndexBack: () => void;

    // Called when navigating forward through comment message history
    onMoveHistoryIndexForward: () => void;

    // Called to initiate editing the user's latest post
    onEditLatestPost: () => ActionResult;

    // Function to get the users timezones in the channel
    getChannelTimezones: (channelId: string) => Promise<ActionResult>;

    // Reset state of createPost request
    resetCreatePostRequest: () => void;

    // Determines if @channel should warn in this channel
    enableConfirmNotificationsToChannel: boolean;

    // Determines if the emoji picker is enabled
    enableEmojiPicker: boolean;

    // Determines if the gif picker is enabled.
    enableGifPicker: boolean;

    // Determines if the connection may be bad to warn user
    badConnection: boolean;

    // Determines the maximum length of a post
    maxPostSize: number;

    // Determines if the RHS is in expanded state
    rhsExpanded: boolean;

    // Determines if timezones are enabled on the server.
    isTimezoneEnabled: boolean;

    // The last time, if any, the selected post changed. Will be 0 if no post is selected.
    selectedPostFocussedAt: number;

    // Function to set or unset emoji picker for last message
    emitShortcutReactToLastPostFrom: (location: string) => void;

    // Determines if the current user can send special channel mentions
    useChannelMentions: boolean;

    // Determines if the current user can send LDAP group mentions
    useLDAPGroupMentions: boolean;

    // Set show preview for textbox
    setShowPreview: (showPreview: boolean) => void;

    // Determines if the preview should be shown
    shouldShowPreview: boolean;

    // Called when parent component should be scrolled to bottom
    scrollToBottom?: () => void;

    // Group member mention
    getChannelMemberCountsByGroup: (channelID: string, isTimezoneEnabled: boolean) => void;
    groupsWithAllowReference: Map<string, Group> | null;
    channelMemberCountsByGroup: ChannelMemberCountsByGroup;
    onHeightChange?: (height: number, maxHeight: number) => void;
    focusOnMount?: boolean;
    isThreadView?: boolean;
    openModal: <P>(modalData: ModalData<P>) => void;
    savePreferences: (userId: string, preferences: PreferenceType[]) => ActionResult;
    useCustomGroupMentions: boolean;
    emojiMap: EmojiMap;
    isFormattingBarHidden: boolean;
    searchAssociatedGroupsForReference: (prefix: string, teamId: string, channelId: string | undefined) => Promise<{ data: any }>;
}

type State = {
    showEmojiPicker: boolean;
    uploadsProgressPercent: {[clientID: string]: FilePreviewInfo};
    renderScrollbar: boolean;
    scrollbarWidth: number;
    draft?: PostDraft;
    rootId?: string;
    messageInHistory?: string;
    createPostErrorId?: string;
    caretPosition?: number;
    postError?: React.ReactNode;
    errorClass: string | null;
    serverError: (ServerError & {submittedMessage?: string}) | null;
    showFormat: boolean;
    isFormattingBarHidden: boolean;
};

function isDraftEmpty(draft: PostDraft): boolean {
    return !draft || (!draft.message && draft.fileInfos.length === 0);
}

class AdvancedCreateComment extends React.PureComponent<Props, State> {
    private lastBlurAt = 0;
    private draftsForPost: {[postID: string]: PostDraft | null} = {};
    private doInitialScrollToBottom = false;

    private saveDraftFrame?: number | null;

    private isDraftSubmitting = false;

    private readonly textboxRef: React.RefObject<TextboxClass>;
    private readonly fileUploadRef: React.RefObject<FileUploadClass>;

    static defaultProps = {
        focusOnMount: true,
    }

    static getDerivedStateFromProps(props: Props, state: State) {
        let updatedState: Partial<State> = {
            createPostErrorId: props.createPostErrorId,
            rootId: props.rootId,
            messageInHistory: props.messageInHistory,
            draft: state.draft || {...props.draft, caretPosition: props.draft.message.length, uploadsInProgress: []},
        };

        const rootChanged = props.rootId !== state.rootId;
        const messageInHistoryChanged = props.messageInHistory !== state.messageInHistory;
        if (rootChanged || messageInHistoryChanged || props.draft.remote) {
            updatedState = {...updatedState, draft: {...props.draft, uploadsInProgress: rootChanged ? [] : props.draft.uploadsInProgress}};
        }

        return updatedState;
    }

    constructor(props: Props) {
        super(props);

        this.state = {
            showEmojiPicker: false,
            uploadsProgressPercent: {},
            renderScrollbar: false,
            scrollbarWidth: 0,
            errorClass: null,
            serverError: null,
            showFormat: false,
            isFormattingBarHidden: props.isFormattingBarHidden,
        };

        this.textboxRef = React.createRef();
        this.fileUploadRef = React.createRef();
    }

    componentDidMount() {
        const {clearCommentDraftUploads, onResetHistoryIndex, setShowPreview, draft} = this.props;
        clearCommentDraftUploads();
        onResetHistoryIndex();
        setShowPreview(false);

        if (this.props.focusOnMount) {
            this.focusTextbox();
        }

        document.addEventListener('paste', this.pasteHandler);
        document.addEventListener('keydown', this.focusTextboxIfNecessary);
        window.addEventListener('beforeunload', this.saveDraftWithShow);
        this.getChannelMemberCountsByGroup();

        // When draft.message is not empty, set doInitialScrollToBottom to true so that
        // on next component update, the actual this.scrollToBottom() will be called.
        // This is made so that the this.scrollToBottom() will be called only once.
        if (draft.message !== '') {
            this.doInitialScrollToBottom = true;
        }
    }

    componentWillUnmount() {
        this.props.resetCreatePostRequest?.();
        document.removeEventListener('paste', this.pasteHandler);
        document.removeEventListener('keydown', this.focusTextboxIfNecessary);
        window.removeEventListener('beforeunload', this.saveDraftWithShow);
        this.saveDraftWithShow();
    }

    componentDidUpdate(prevProps: Props, prevState: State) {
        if (prevState.draft!.uploadsInProgress.length < this.state.draft!.uploadsInProgress.length && this.props.scrollToBottom) {
            this.props.scrollToBottom();
        }

        // Focus on textbox when emoji picker is closed
        if (prevState.showEmojiPicker && !this.state.showEmojiPicker) {
            this.focusTextbox();
        }

        // Focus on textbox when returned from preview mode
        if (prevProps.shouldShowPreview && !this.props.shouldShowPreview) {
            this.focusTextbox();
        }

        if (prevProps.rootId !== this.props.rootId || prevProps.selectedPostFocussedAt !== this.props.selectedPostFocussedAt) {
            this.getChannelMemberCountsByGroup();
            this.focusTextbox();
        }

        if (this.doInitialScrollToBottom) {
            if (this.props.scrollToBottom) {
                this.props.scrollToBottom();
            }
            this.doInitialScrollToBottom = false;
        }

        if (this.props.createPostErrorId === 'api.post.create_post.root_id.app_error' && this.props.createPostErrorId !== prevProps.createPostErrorId) {
            this.showPostDeletedModal();
        }
    }

    getChannelMemberCountsByGroup = () => {
        const {useLDAPGroupMentions, useCustomGroupMentions, channelId, isTimezoneEnabled, searchAssociatedGroupsForReference, getChannelMemberCountsByGroup, draft, currentTeamId} = this.props;

        if ((useLDAPGroupMentions || useCustomGroupMentions) && channelId) {
            const mentions = mentionsMinusSpecialMentionsInText(draft.message);

            if (mentions.length === 1) {
                searchAssociatedGroupsForReference(mentions[0], currentTeamId, channelId);
            } else if (mentions.length > 1) {
                getChannelMemberCountsByGroup(channelId, isTimezoneEnabled);
            }
        }
    }

    saveDraftWithShow = () => {
        this.setState((prev) => {
            if (prev.draft) {
                return {
                    draft: {
                        ...prev.draft,
                        show: !isDraftEmpty(prev.draft),
                        remote: false,
                    } as PostDraft,
                };
            }

            return {
                draft: prev.draft,
            };
        }, () => {
            this.saveDraft(true);
        });
    }

    saveDraft = (save = false) => {
        if (this.saveDraftFrame) {
            clearTimeout(this.saveDraftFrame);
            this.props.onUpdateCommentDraft(this.state.draft, save);
            this.saveDraftFrame = null;
        }
    }

    setShowPreview = (newPreviewValue: boolean) => {
        this.props.setShowPreview(newPreviewValue);
    }

    focusTextboxIfNecessary = (e: KeyboardEvent) => {
        // Should only focus if RHS is expanded or if thread view
        if (!this.props.isThreadView && !this.props.rhsExpanded) {
            return;
        }

        // A bit of a hack to not steal focus from the channel switch modal if it's open
        // This is a special case as the channel switch modal does not enforce focus like
        // most modals do
        if (document.getElementsByClassName('channel-switch-modal').length) {
            return;
        }

        if (shouldFocusMainTextbox(e, document.activeElement)) {
            this.focusTextbox();
            this.toggleAdvanceTextEditor();
        }
    }

    setCaretPosition = (newCaretPosition: number) => {
        const textbox = this.textboxRef.current && this.textboxRef.current.getInputBox();

        this.setState({
            caretPosition: newCaretPosition,
        }, () => {
            Utils.setCaretPosition(textbox, newCaretPosition);
        });
    }

    pasteHandler = (e: ClipboardEvent) => {
        // we need to cast the TextboxElement type onto the EventTarget here since the ClipboardEvent is not generic
        if (!e.clipboardData || !e.clipboardData.items || (e.target as TextboxElement).id !== 'reply_textbox') {
            return;
        }

        const {clipboardData} = e;
        const hasLinks = hasHtmlLink(clipboardData);
        let table = getTable(clipboardData);
        if (!table && !hasLinks) {
            return;
        }
        table = table as HTMLTableElement;

        e.preventDefault();

        const draft = this.state.draft!;
        let message = draft.message;

        const caretPosition = this.state.caretPosition || 0;
        if (table && isGitHubCodeBlock(table.className)) {
            const selectionStart = (e.target as any).selectionStart;
            const selectionEnd = (e.target as any).selectionEnd;
            const {formattedMessage, formattedCodeBlock} = formatGithubCodePaste({selectionStart, selectionEnd, message, clipboardData});
            const newCaretPosition = caretPosition + formattedCodeBlock.length;
            message = formattedMessage;
            this.setCaretPosition(newCaretPosition);
        } else {
            const originalSize = draft.message.length;
            message = formatMarkdownMessage(clipboardData, draft.message.trim(), this.state.caretPosition);
            const newCaretPosition = message.length - (originalSize - caretPosition);
            this.setCaretPosition(newCaretPosition);
        }

        const updatedDraft = {...draft, message};

        this.handleDraftChange(updatedDraft);
        this.setState({draft: updatedDraft});
    }

    handleNotifyAllConfirmation = () => {
        this.doSubmit();
    }

    showNotifyAllModal = (mentions: string[], channelTimezoneCount: number, memberNotifyCount: number) => {
        this.props.openModal({
            modalId: ModalIdentifiers.NOTIFY_CONFIRM_MODAL,
            dialogType: NotifyConfirmModal,
            dialogProps: {
                mentions,
                channelTimezoneCount,
                memberNotifyCount,
                onConfirm: () => this.handleNotifyAllConfirmation(),
            },
        });
    }

    toggleEmojiPicker = (e?: React.MouseEvent<HTMLButtonElement, MouseEvent>): void => {
        e?.stopPropagation();
        const showEmojiPicker = !this.state.showEmojiPicker;
        this.setState({showEmojiPicker});
    };

    hideEmojiPicker = () => {
        this.setState({showEmojiPicker: false});
    }

    handleEmojiClick = (emoji: Emoji) => {
        const emojiAlias = ('short_name' in emoji && emoji.short_name) || emoji.name;

        if (!emojiAlias) {
            //Oops... There went something wrong
            return;
        }

        const draft = this.state.draft!;

        let newMessage: string;
        if (draft.message === '') {
            newMessage = `:${emojiAlias}: `;
            this.setCaretPosition(newMessage.length);
        } else {
            const {message} = draft;
            const {firstPiece, lastPiece} = splitMessageBasedOnCaretPosition(this.state.caretPosition || 0, message);

            // check whether the first piece of the message is empty when cursor is placed at beginning of message and avoid adding an empty string at the beginning of the message
            newMessage = firstPiece === '' ? `:${emojiAlias}: ${lastPiece} ` : `${firstPiece} :${emojiAlias}: ${lastPiece} `;

            const newCaretPosition = firstPiece === '' ? `:${emojiAlias}: `.length : `${firstPiece} :${emojiAlias}: `.length;
            this.setCaretPosition(newCaretPosition);
        }

        const modifiedDraft = {
            ...draft,
            message: newMessage,
        };

        this.handleDraftChange(modifiedDraft);

        this.setState({
            showEmojiPicker: false,
            draft: modifiedDraft,
        });
    }

    handleGifClick = (gif: string) => {
        const draft = this.state.draft!;

        let newMessage: string;
        if (draft.message === '') {
            newMessage = gif;
        } else if ((/\s+$/).test(draft.message)) {
            // Check whether there is already a blank at the end of the current message
            newMessage = `${draft.message}${gif} `;
        } else {
            newMessage = `${draft.message} ${gif} `;
        }

        const modifiedDraft = {
            ...draft,
            message: newMessage,
        };

        this.handleDraftChange(modifiedDraft);

        this.setState({
            showEmojiPicker: false,
            draft: modifiedDraft,
        });

        this.focusTextbox();
    }

    handlePostError = (postError: React.ReactNode) => {
        this.setState({postError});
    }

    handleSubmit = async (e: React.FormEvent | React.MouseEvent) => {
        e.preventDefault();
        this.setShowPreview(false);
        this.isDraftSubmitting = true;

        const {
            channelMembersCount,
            enableConfirmNotificationsToChannel,
            useChannelMentions,
            isTimezoneEnabled,
            groupsWithAllowReference,
            channelMemberCountsByGroup,
            useLDAPGroupMentions,
            useCustomGroupMentions,
        } = this.props;
        const draft = this.state.draft!;
        const notificationsToChannel = enableConfirmNotificationsToChannel && useChannelMentions;
        let memberNotifyCount = 0;
        let channelTimezoneCount = 0;
        let mentions: string[] = [];

        const specialMentions = specialMentionsInText(draft.message);
        const hasSpecialMentions = Object.values(specialMentions).includes(true);

        if (enableConfirmNotificationsToChannel && !hasSpecialMentions && (useLDAPGroupMentions || useCustomGroupMentions)) {
            // Groups mentioned in users text
            const mentionGroups = groupsMentionedInText(draft.message, groupsWithAllowReference);
            if (mentionGroups.length > 0) {
                mentionGroups.
                    forEach((group) => {
                        if (group.source === GroupSource.Ldap && !useLDAPGroupMentions) {
                            return;
                        }
                        if (group.source === GroupSource.Custom && !useCustomGroupMentions) {
                            return;
                        }
                        const mappedValue = channelMemberCountsByGroup[group.id];
                        if (mappedValue && mappedValue.channel_member_count > Constants.NOTIFY_ALL_MEMBERS && mappedValue.channel_member_count > memberNotifyCount) {
                            memberNotifyCount = mappedValue.channel_member_count;
                            channelTimezoneCount = mappedValue.channel_member_timezones_count;
                        }
                        mentions.push(`@${group.name}`);
                    });
                mentions = [...new Set(mentions)];
            }
        }

        if (!useLDAPGroupMentions && !useCustomGroupMentions && mentions.length > 0) {
            const updatedDraft = {
                ...draft,
                props: {
                    ...draft.props,
                    disable_group_highlight: true,
                },
            };

            this.props.onUpdateCommentDraft(updatedDraft);
            this.setState({draft: updatedDraft});
        }

        if (notificationsToChannel &&
            channelMembersCount > Constants.NOTIFY_ALL_MEMBERS &&
            hasSpecialMentions) {
            memberNotifyCount = channelMembersCount - 1;
            for (const k in specialMentions) {
                if (specialMentions[k]) {
                    mentions.push('@' + k);
                }
            }

            if (isTimezoneEnabled) {
                const {data} = await this.props.getChannelTimezones(this.props.channelId);
                channelTimezoneCount = data ? data.length : 0;
            }
        }

        if (!useChannelMentions && hasSpecialMentions) {
            const updatedDraft = {
                ...draft,
                props: {
                    ...draft.props,
                    mentionHighlightDisabled: true,
                },
            };

            this.props.onUpdateCommentDraft(updatedDraft);
            this.setState({draft: updatedDraft});
        }

        if (memberNotifyCount > 0) {
            this.showNotifyAllModal(mentions, channelTimezoneCount, memberNotifyCount);
            this.isDraftSubmitting = false;
            return;
        }

        await this.doSubmit(e);
    }

    doSubmit = async (e?: React.FormEvent) => {
        if (e) {
            e.preventDefault();
        }

        const draft = this.state.draft!;
        const enableAddButton = this.shouldEnableAddButton();

        if (!enableAddButton) {
            this.isDraftSubmitting = false;
            return;
        }

        if (draft.uploadsInProgress.length > 0) {
            this.isDraftSubmitting = false;
            return;
        }

        if (this.state.postError) {
            this.setState({errorClass: 'animation--highlight'});
            setTimeout(() => {
                this.setState({errorClass: null});
            }, Constants.ANIMATION_TIMEOUT);
            this.isDraftSubmitting = false;
            return;
        }

        if (this.props.rootDeleted) {
            this.showPostDeletedModal();
            this.isDraftSubmitting = false;
            return;
        }

        const fasterThanHumanWillClick = 150;
        const forceFocus = (Date.now() - this.lastBlurAt < fasterThanHumanWillClick);
        this.focusTextbox(forceFocus);

        const serverError = this.state.serverError;
        let ignoreSlash = false;
        if (isErrorInvalidSlashCommand(serverError) && draft.message === serverError?.submittedMessage) {
            ignoreSlash = true;
        }

        const options = {ignoreSlash};

        try {
            await this.props.onSubmit(draft, options);

            this.setState({
                postError: null,
                serverError: null,
                showFormat: false,
            });
        } catch (err: any) {
            if (isErrorInvalidSlashCommand(err)) {
                this.props.onUpdateCommentDraft(draft);
            }
            err.submittedMessage = draft.message;
            this.setState({serverError: err});
            this.isDraftSubmitting = false;
            return;
        }

        if (this.saveDraftFrame) {
            clearTimeout(this.saveDraftFrame);
        }

        this.isDraftSubmitting = false;
        this.setState({draft: {...this.props.draft, uploadsInProgress: []}});
        this.draftsForPost[this.props.rootId] = null;
    }

    commentMsgKeyPress = (e: React.KeyboardEvent<TextboxElement>) => {
        const {ctrlSend, codeBlockOnCtrlEnter} = this.props;

        const {allowSending} = postMessageOnKeyPress(
            e,
            this.state.draft!.message,
            Boolean(ctrlSend),
            Boolean(codeBlockOnCtrlEnter),
            0,
            0,
            this.state.caretPosition,
        );

        if (allowSending) {
            e.persist?.();

            this.isDraftSubmitting = true;
            this.textboxRef.current?.blur();
            this.handleSubmit(e);

            this.setShowPreview(false);
            setTimeout(() => {
                this.focusTextbox();
            });
        }

        this.emitTypingEvent();
    }

    reactToLastMessage = (e: React.KeyboardEvent<TextboxElement>) => {
        e.preventDefault();

        const {emitShortcutReactToLastPostFrom} = this.props;

        // Here we are not handling conditions such as check for modals,  popups etc. as shortcut is only trigger on
        // textbox input focus. Since all of them will already be closed as soon as they loose focus.
        emitShortcutReactToLastPostFrom(Locations.RHS_ROOT);
    }

    emitTypingEvent = () => {
        const {channelId, rootId} = this.props;
        GlobalActions.emitLocalUserTypingEvent(channelId, rootId);
    }

    handleChange = (e: React.ChangeEvent<TextboxElement>) => {
        const message = e.target.value;

        let serverError = this.state.serverError;
        if (isErrorInvalidSlashCommand(serverError)) {
            serverError = null;
        }

        const draft = this.state.draft!;
        const show = isDraftEmpty(draft) ? false : draft.show;
        const updatedDraft = {...draft, message, show};

        this.handleDraftChange(updatedDraft);

        this.setState({draft: updatedDraft, serverError}, () => {
            if (this.props.scrollToBottom) {
                this.props.scrollToBottom();
            }
        });
        this.draftsForPost[this.props.rootId] = updatedDraft;
    }

    handleDraftChange = (draft: PostDraft, rootId?: string, save = false) => {
        if (this.saveDraftFrame) {
            clearTimeout(this.saveDraftFrame);
        }

        this.saveDraftFrame = window.setTimeout(() => {
            if (typeof rootId == 'undefined') {
                this.props.onUpdateCommentDraft(draft);
            } else {
                this.props.updateCommentDraftWithRootId(rootId, draft, save);
            }
        }, Constants.SAVE_DRAFT_TIMEOUT);
        this.draftsForPost[this.props.rootId] = draft;
    }

    handleMouseUpKeyUp = (e: React.MouseEvent | React.KeyboardEvent) => {
        this.setState({
            caretPosition: (e.target as TextboxElement).selectionStart || 0,
        });
    }

    handleSelect = (e: React.SyntheticEvent<TextboxElement>) => {
        Utils.adjustSelection(this.textboxRef.current?.getInputBox(), e);
    }

    handleKeyDown = (e: React.KeyboardEvent<TextboxElement>) => {
        const ctrlOrMetaKeyPressed = e.ctrlKey || e.metaKey;
        const lastMessageReactionKeyCombo = ctrlOrMetaKeyPressed && e.shiftKey && Utils.isKeyPressed(e, KeyCodes.BACK_SLASH);

        const ctrlKeyCombo = Utils.cmdOrCtrlPressed(e) && !e.altKey && !e.shiftKey;
        const ctrlAltCombo = Utils.cmdOrCtrlPressed(e, true) && e.altKey;
        const shiftAltCombo = !Utils.cmdOrCtrlPressed(e) && e.shiftKey && e.altKey;

        // listen for line break key combo and insert new line character
        if (Utils.isUnhandledLineBreakKeyCombo(e)) {
            this.setState({
                draft: {
                    ...this.state.draft!,
                    message: Utils.insertLineBreakFromKeyEvent(e as React.KeyboardEvent<HTMLTextAreaElement>),
                },
            });
            return;
        }

        if (
            (this.props.ctrlSend || this.props.codeBlockOnCtrlEnter) &&
            Utils.isKeyPressed(e, KeyCodes.ENTER) &&
            (e.ctrlKey || e.metaKey)
        ) {
            this.setShowPreview(false);
            this.commentMsgKeyPress(e);
            return;
        }

        const draft = this.state.draft!;
        const {message} = draft;

        if (Utils.isKeyPressed(e, KeyCodes.ESCAPE)) {
            this.textboxRef.current?.blur();
        }

        if (
            !e.ctrlKey &&
            !e.metaKey &&
            !e.altKey &&
            !e.shiftKey &&
            Utils.isKeyPressed(e, KeyCodes.UP) &&
            message === ''
        ) {
            e.preventDefault();
            if (this.textboxRef.current) {
                this.textboxRef.current.blur();
            }

            const {data: canEditNow} = this.props.onEditLatestPost();
            if (!canEditNow) {
                this.focusTextbox(true);
            }
        }

        const {
            selectionStart,
            selectionEnd,
            value,
        } = e.target as TextboxElement;

        if (ctrlKeyCombo) {
            if (Utils.isKeyPressed(e, KeyCodes.UP)) {
                e.preventDefault();
                this.props.onMoveHistoryIndexBack();
            } else if (Utils.isKeyPressed(e, KeyCodes.DOWN)) {
                e.preventDefault();
                this.props.onMoveHistoryIndexForward();
            } else if (Utils.isKeyPressed(e, KeyCodes.B)) {
                e.stopPropagation();
                e.preventDefault();
                this.applyMarkdown({
                    markdownMode: 'bold',
                    selectionStart,
                    selectionEnd,
                    message: value,
                });
            } else if (Utils.isKeyPressed(e, KeyCodes.I)) {
                e.stopPropagation();
                e.preventDefault();
                this.applyMarkdown({
                    markdownMode: 'italic',
                    selectionStart,
                    selectionEnd,
                    message: value,
                });
            }
        } else if (ctrlAltCombo) {
            if (Utils.isKeyPressed(e, KeyCodes.K)) {
                e.stopPropagation();
                e.preventDefault();
                this.applyMarkdown({
                    markdownMode: 'link',
                    selectionStart,
                    selectionEnd,
                    message: value,
                });
            } else if (Utils.isKeyPressed(e, KeyCodes.C)) {
                e.stopPropagation();
                e.preventDefault();
                this.applyMarkdown({
                    markdownMode: 'code',
                    selectionStart,
                    selectionEnd,
                    message: value,
                });
            } else if (Utils.isKeyPressed(e, KeyCodes.E)) {
                e.stopPropagation();
                e.preventDefault();
                this.toggleEmojiPicker();
            } else if (Utils.isKeyPressed(e, KeyCodes.T)) {
                e.stopPropagation();
                e.preventDefault();
                this.toggleAdvanceTextEditor();
            } else if (Utils.isKeyPressed(e, KeyCodes.P) && draft.message.length) {
                e.stopPropagation();
                e.preventDefault();
                this.setShowPreview(!this.props.shouldShowPreview);
            }
        } else if (shiftAltCombo) {
            if (Utils.isKeyPressed(e, KeyCodes.X)) {
                e.stopPropagation();
                e.preventDefault();
                this.applyMarkdown({
                    markdownMode: 'strike',
                    selectionStart,
                    selectionEnd,
                    message: value,
                });
            } else if (Utils.isKeyPressed(e, KeyCodes.SEVEN)) {
                e.preventDefault();
                this.applyMarkdown({
                    markdownMode: 'ol',
                    selectionStart,
                    selectionEnd,
                    message: value,
                });
            } else if (Utils.isKeyPressed(e, KeyCodes.EIGHT)) {
                e.preventDefault();
                this.applyMarkdown({
                    markdownMode: 'ul',
                    selectionStart,
                    selectionEnd,
                    message: value,
                });
            } else if (Utils.isKeyPressed(e, KeyCodes.NINE)) {
                e.preventDefault();
                this.applyMarkdown({
                    markdownMode: 'quote',
                    selectionStart,
                    selectionEnd,
                    message: value,
                });
            }
        }

        if (lastMessageReactionKeyCombo) {
            this.reactToLastMessage(e);
        }
    }

    applyMarkdown = (options: ApplyMarkdownOptions) => {
        const res = applyMarkdown(options);

        const draft = this.state.draft!;
        const modifiedDraft = {
            ...draft,
            message: res.message,
        };

        this.handleDraftChange(modifiedDraft);

        this.setState({
            draft: modifiedDraft,
        }, () => {
            const textbox = this.textboxRef.current?.getInputBox();
            Utils.setSelectionRange(textbox, res.selectionStart, res.selectionEnd);
        });
    }

    handleFileUploadChange = () => {
        this.focusTextbox();
    }

    handleUploadStart = (clientIds: string[]) => {
        const draft = this.state.draft!;
        const uploadsInProgress = [...draft.uploadsInProgress, ...clientIds];

        const modifiedDraft = {
            ...draft,
            uploadsInProgress,
        };
        this.props.onUpdateCommentDraft(modifiedDraft);
        this.setState({draft: modifiedDraft});
        this.draftsForPost[this.props.rootId] = modifiedDraft;

        // this is a bit redundant with the code that sets focus when the file input is clicked,
        // but this also resets the focus after a drag and drop
        this.focusTextbox();
    }

    handleUploadProgress = (filePreviewInfo: FilePreviewInfo) => {
        const uploadsProgressPercent = {...this.state.uploadsProgressPercent, [filePreviewInfo.clientId]: filePreviewInfo};
        this.setState({uploadsProgressPercent});
    }

    handleFileUploadComplete = (fileInfos: FileInfo[], clientIds: string[], _: string, rootId?: string) => {
        const draft = this.draftsForPost[rootId!]!;
        const uploadsInProgress = [...draft.uploadsInProgress];
        const newFileInfos = sortFileInfos([...draft.fileInfos, ...fileInfos], this.props.locale);

        // remove each finished file from uploads
        for (let i = 0; i < clientIds.length; i++) {
            const index = uploadsInProgress.indexOf(clientIds[i]);

            if (index !== -1) {
                uploadsInProgress.splice(index, 1);
            }
        }

        const modifiedDraft = {
            ...draft,
            fileInfos: newFileInfos,
            uploadsInProgress,
        };
        this.handleDraftChange(modifiedDraft, rootId!, true);
        if (this.props.rootId === rootId) {
            this.setState({draft: modifiedDraft});
        }
    }

    handleUploadError = (err: string | ServerError | null, clientId: string | number = -1, _?: string, rootId = '') => {
        if (clientId !== -1) {
            const draft = {...this.draftsForPost[rootId]!};
            const uploadsInProgress = [...draft.uploadsInProgress];

            const index = uploadsInProgress.indexOf(clientId as string);
            if (index !== -1) {
                uploadsInProgress.splice(index, 1);
            }

            const modifiedDraft = {
                ...draft,
                uploadsInProgress,
            };
            this.props.updateCommentDraftWithRootId(rootId, modifiedDraft, true);
            this.draftsForPost[rootId] = modifiedDraft;
            if (this.props.rootId === rootId) {
                this.setState({draft: modifiedDraft});
            }
        }

        let serverError = err;
        if (typeof serverError === 'string') {
            serverError = new Error(serverError);
        }

        this.setState({serverError}, () => {
            if (serverError && this.props.scrollToBottom) {
                this.props.scrollToBottom();
            }
        });
    }

    removePreview = (id: string) => {
        const draft = this.state.draft!;
        const fileInfos = [...draft.fileInfos];
        const uploadsInProgress = [...draft.uploadsInProgress];

        // Clear previous errors
        this.handleUploadError(null);

        // id can either be the id of an uploaded file or the client id of an in progress upload
        let index = fileInfos.findIndex((info) => info.id === id);
        if (index === -1) {
            index = uploadsInProgress.indexOf(id);

            if (index !== -1) {
                uploadsInProgress.splice(index, 1);

                if (this.fileUploadRef.current) {
                    this.fileUploadRef.current.cancelUpload(id);
                }
            }
        } else {
            fileInfos.splice(index, 1);
        }

        const modifiedDraft = {
            ...draft,
            fileInfos,
            uploadsInProgress,
        };

        this.props.onUpdateCommentDraft(modifiedDraft);
        this.setState({draft: modifiedDraft});
        this.draftsForPost[this.props.rootId] = modifiedDraft;

        this.handleFileUploadChange();

        if (this.saveDraftFrame) {
            clearTimeout(this.saveDraftFrame);
        }

        this.saveDraftFrame = window.setTimeout(() => {}, Constants.SAVE_DRAFT_TIMEOUT);
    }

    getFileUploadTarget = () => {
        return this.textboxRef.current?.getInputBox();
    }

    toggleAdvanceTextEditor = () => {
        this.setState({
            isFormattingBarHidden:
                !this.state.isFormattingBarHidden,
        });
        this.props.savePreferences(this.props.currentUserId, [{
            category: Preferences.ADVANCED_TEXT_EDITOR,
            user_id: this.props.currentUserId,
            name: AdvancedTextEditor.COMMENT,
            value: String(!this.state.isFormattingBarHidden),
        }]);
    }

    focusTextbox = (keepFocus = false) => {
        if (this.textboxRef.current && (keepFocus || !UserAgent.isMobile())) {
            this.textboxRef.current.focus();
        }
    }

    shouldEnableAddButton = () => {
        const {draft} = this.state;
        if (draft) {
            const message = draft.message ? draft.message.trim() : '';
            const fileInfos = draft.fileInfos ? draft.fileInfos : [];
            if (message.trim().length !== 0 || fileInfos.length !== 0) {
                return true;
            }
        }

        return isErrorInvalidSlashCommand(this.state.serverError);
    }

    showPostDeletedModal = () => {
        this.props.openModal({
            modalId: ModalIdentifiers.POST_DELETED_MODAL,
            dialogType: PostDeletedModal,
        });
    }

    handleBlur = () => {
        if (!this.isDraftSubmitting) {
            this.saveDraftWithShow();
        }
        this.lastBlurAt = Date.now();
    }

    render() {
        const draft = this.state.draft!;
        return (
            <form onSubmit={this.handleSubmit}>
                {
                    this.props.canPost &&
                    (this.props.draft.fileInfos.length > 0 || this.props.draft.uploadsInProgress.length > 0) &&
                    <FileLimitStickyBanner/>
                }
                <AdvanceTextEditor
                    location={Locations.RHS_COMMENT}
                    textboxRef={this.textboxRef}
                    currentUserId={this.props.currentUserId}
                    message={draft.message}
                    showEmojiPicker={this.state.showEmojiPicker}
                    uploadsProgressPercent={this.state.uploadsProgressPercent}
                    channelId={this.props.channelId}
                    postId={this.props.rootId}
                    errorClass={this.state.errorClass}
                    serverError={this.state.serverError}
                    isFormattingBarHidden={this.state.isFormattingBarHidden}
                    draft={this.props.draft}
                    handleSubmit={this.handleSubmit}
                    removePreview={this.removePreview}
                    setShowPreview={this.setShowPreview}
                    shouldShowPreview={this.props.shouldShowPreview}
                    maxPostSize={this.props.maxPostSize}
                    canPost={this.props.canPost}
                    applyMarkdown={this.applyMarkdown}
                    useChannelMentions={this.props.useChannelMentions}
                    badConnection={this.props.badConnection}
                    canUploadFiles={this.props.canUploadFiles}
                    enableEmojiPicker={this.props.enableEmojiPicker}
                    enableGifPicker={this.props.enableGifPicker}
                    handleBlur={this.handleBlur}
                    postError={this.state.postError}
                    handlePostError={this.handlePostError}
                    emitTypingEvent={this.emitTypingEvent}
                    handleMouseUpKeyUp={this.handleMouseUpKeyUp}
                    handleSelect={this.handleSelect}
                    handleKeyDown={this.handleKeyDown}
                    postMsgKeyPress={this.commentMsgKeyPress}
                    handleChange={this.handleChange}
                    toggleEmojiPicker={this.toggleEmojiPicker}
                    handleGifClick={this.handleGifClick}
                    handleEmojiClick={this.handleEmojiClick}
                    hideEmojiPicker={this.hideEmojiPicker}
                    toggleAdvanceTextEditor={this.toggleAdvanceTextEditor}
                    handleUploadProgress={this.handleUploadProgress}
                    handleUploadError={this.handleUploadError}
                    handleFileUploadComplete={this.handleFileUploadComplete}
                    handleUploadStart={this.handleUploadStart}
                    handleFileUploadChange={this.handleFileUploadChange}
                    getFileUploadTarget={this.getFileUploadTarget}
                    fileUploadRef={this.fileUploadRef}
                    isThreadView={this.props.isThreadView}
                />
            </form>
        );
    }
}

export default AdvancedCreateComment;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {GlobalState} from 'types/store/index.js';

import {ModalData} from 'types/actions.js';

import {ActionFunc, ActionResult, DispatchFunc} from 'mattermost-redux/types/actions.js';

import {PostDraft} from 'types/store/draft';

import {getCurrentUserId} from 'mattermost-redux/selectors/entities/common';

import {getConfig, getLicense} from 'mattermost-redux/selectors/entities/general';
import {haveIChannelPermission} from 'mattermost-redux/selectors/entities/roles';
import {getBool, isCustomGroupsEnabled} from 'mattermost-redux/selectors/entities/preferences';
import {getAllChannelStats, getChannelMemberCountsByGroup as selectChannelMemberCountsByGroup} from 'mattermost-redux/selectors/entities/channels';
import {makeGetMessageInHistoryItem} from 'mattermost-redux/selectors/entities/posts';
import {resetCreatePostRequest, resetHistoryIndex} from 'mattermost-redux/actions/posts';
import {getChannelTimezones, getChannelMemberCountsByGroup} from 'mattermost-redux/actions/channels';
import {Permissions, Preferences, Posts} from 'mattermost-redux/constants';
import {getAssociatedGroupsForReferenceByMention} from 'mattermost-redux/selectors/entities/groups';
import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {PreferenceType} from '@mattermost/types/preferences';
import {savePreferences} from 'mattermost-redux/actions/preferences';

import {connectionErrorCount} from 'selectors/views/system';

import {AdvancedTextEditor, Constants, StoragePrefixes} from 'utils/constants';
import {getCurrentLocale} from 'selectors/i18n';

import {
    clearCommentDraftUploads,
    updateCommentDraft,
    makeOnMoveHistoryIndex,
    makeOnSubmit,
    makeOnEditLatestPost,
} from 'actions/views/create_comment';
import {emitShortcutReactToLastPostFrom} from 'actions/post_actions';
import {getPostDraft, getIsRhsExpanded, getSelectedPostFocussedAt} from 'selectors/rhs';
import {showPreviewOnCreateComment} from 'selectors/views/textbox';
import {setShowPreviewOnCreateComment} from 'actions/views/textbox';
import {openModal} from 'actions/views/modals';
import {searchAssociatedGroupsForReference} from 'actions/views/group';

import {getEmojiMap} from 'selectors/emojis';
import {canUploadFiles} from 'utils/file_utils';

import AdvancedCreateComment from './advanced_create_comment';

type OwnProps = {
    rootId: string;
    channelId: string;
    latestPostId: string;
};

function makeMapStateToProps() {
    const getMessageInHistoryItem = makeGetMessageInHistoryItem(Posts.MESSAGE_TYPES.COMMENT as 'comment');

    return (state: GlobalState, ownProps: OwnProps) => {
        const err = state.requests.posts.createPost.error || {};

        const draft = getPostDraft(state, StoragePrefixes.COMMENT_DRAFT, ownProps.rootId);

        const channelMembersCount = getAllChannelStats(state)[ownProps.channelId] ? getAllChannelStats(state)[ownProps.channelId].member_count : 1;
        const messageInHistory = getMessageInHistoryItem(state);

        const channel = state.entities.channels.channels[ownProps.channelId] || {};

        const config = getConfig(state);
        const license = getLicense(state);
        const currentUserId = getCurrentUserId(state);
        const enableConfirmNotificationsToChannel = config.EnableConfirmNotificationsToChannel === 'true';
        const enableEmojiPicker = config.EnableEmojiPicker === 'true';
        const enableGifPicker = config.EnableGifPicker === 'true';
        const badConnection = connectionErrorCount(state) > 1;
        const isTimezoneEnabled = config.ExperimentalTimezone === 'true';
        const canPost = haveIChannelPermission(state, channel.team_id, channel.id, Permissions.CREATE_POST);
        const useChannelMentions = haveIChannelPermission(state, channel.team_id, channel.id, Permissions.USE_CHANNEL_MENTIONS);
        const isLDAPEnabled = license?.IsLicensed === 'true' && license?.LDAPGroups === 'true';
        const useCustomGroupMentions = isCustomGroupsEnabled(state) && haveIChannelPermission(state, channel.team_id, channel.id, Permissions.USE_GROUP_MENTIONS);
        const useLDAPGroupMentions = isLDAPEnabled && haveIChannelPermission(state, channel.team_id, channel.id, Permissions.USE_GROUP_MENTIONS);
        const channelMemberCountsByGroup = selectChannelMemberCountsByGroup(state, ownProps.channelId);
        const groupsWithAllowReference = useLDAPGroupMentions || useCustomGroupMentions ? getAssociatedGroupsForReferenceByMention(state, channel.team_id, channel.id) : null;
        const isFormattingBarHidden = getBool(state, Constants.Preferences.ADVANCED_TEXT_EDITOR, AdvancedTextEditor.COMMENT);
        const currentTeamId = getCurrentTeamId(state);

        return {
            currentTeamId,
            draft,
            messageInHistory,
            channelMembersCount,
            currentUserId,
            isFormattingBarHidden,
            codeBlockOnCtrlEnter: getBool(state, Preferences.CATEGORY_ADVANCED_SETTINGS, 'code_block_ctrl_enter', true),
            ctrlSend: getBool(state, Preferences.CATEGORY_ADVANCED_SETTINGS, 'send_on_ctrl_enter'),
            createPostErrorId: err.server_error_id,
            enableConfirmNotificationsToChannel,
            enableEmojiPicker,
            enableGifPicker,
            locale: getCurrentLocale(state),
            maxPostSize: parseInt(config.MaxPostSize || '', 10) || Constants.DEFAULT_CHARACTER_LIMIT,
            rhsExpanded: getIsRhsExpanded(state),
            badConnection,
            isTimezoneEnabled,
            selectedPostFocussedAt: getSelectedPostFocussedAt(state),
            canPost,
            useChannelMentions,
            shouldShowPreview: showPreviewOnCreateComment(state),
            groupsWithAllowReference,
            useLDAPGroupMentions,
            channelMemberCountsByGroup,
            useCustomGroupMentions,
            emojiMap: getEmojiMap(state),
            canUploadFiles: canUploadFiles(config),
        };
    };
}

function makeOnUpdateCommentDraft(rootId: string, channelId: string) {
    return (draft?: PostDraft, save = false) => updateCommentDraft(rootId, draft ? {...draft, channelId, remote: false} : draft, save);
}

function makeUpdateCommentDraftWithRootId(channelId: string) {
    return (rootId: string, draft?: PostDraft, save = false) => updateCommentDraft(rootId, draft ? {...draft, channelId, remote: false} : draft, save);
}

type Actions = {
    clearCommentDraftUploads: () => void;
    onUpdateCommentDraft: (draft?: PostDraft, save?: boolean) => void;
    updateCommentDraftWithRootId: (rootID: string, draft: PostDraft, save?: boolean) => void;
    onSubmit: (draft: PostDraft, options: {ignoreSlash: boolean}) => void;
    onResetHistoryIndex: () => void;
    onMoveHistoryIndexBack: () => void;
    onMoveHistoryIndexForward: () => void;
    onEditLatestPost: () => ActionResult;
    resetCreatePostRequest: () => void;
    getChannelTimezones: (channelId: string) => Promise<ActionResult>;
    emitShortcutReactToLastPostFrom: (location: string) => void;
    setShowPreview: (showPreview: boolean) => void;
    getChannelMemberCountsByGroup: (channelID: string, includeTimezones: boolean) => void;
    openModal: <P>(modalData: ModalData<P>) => void;
    savePreferences: (userId: string, preferences: PreferenceType[]) => ActionResult;
    searchAssociatedGroupsForReference: (prefix: string, teamId: string, channelId: string | undefined) => Promise<{ data: any }>;
};

function makeMapDispatchToProps() {
    let onUpdateCommentDraft: (draft?: PostDraft, save?: boolean) => void;
    let updateCommentDraftWithRootId: (rootID: string, draft: PostDraft, save?: boolean) => void;
    let onSubmit: (
        draft: PostDraft,
        options: {ignoreSlash: boolean},
    ) => (dispatch: DispatchFunc, getState: () => GlobalState) => Promise<ActionResult | ActionResult[]> | ActionResult;
    let onMoveHistoryIndexBack: () => (
        dispatch: DispatchFunc,
        getState: () => GlobalState,
    ) => Promise<ActionResult | ActionResult[]> | ActionResult;
    let onMoveHistoryIndexForward: () => (
        dispatch: DispatchFunc,
        getState: () => GlobalState,
    ) => Promise<ActionResult | ActionResult[]> | ActionResult;
    let onEditLatestPost: () => ActionFunc;

    function onResetHistoryIndex() {
        return resetHistoryIndex(Posts.MESSAGE_TYPES.COMMENT);
    }

    let rootId: string;
    let channelId: string;
    let latestPostId: string;

    return (dispatch: Dispatch, ownProps: OwnProps) => {
        if (rootId !== ownProps.rootId) {
            onUpdateCommentDraft = makeOnUpdateCommentDraft(ownProps.rootId, ownProps.channelId);
            onMoveHistoryIndexBack = makeOnMoveHistoryIndex(ownProps.rootId, -1);
            onMoveHistoryIndexForward = makeOnMoveHistoryIndex(ownProps.rootId, 1);
        }

        if (channelId !== ownProps.channelId) {
            updateCommentDraftWithRootId = makeUpdateCommentDraftWithRootId(ownProps.channelId);
        }

        if (rootId !== ownProps.rootId) {
            onEditLatestPost = makeOnEditLatestPost(ownProps.rootId);
        }

        if (rootId !== ownProps.rootId || channelId !== ownProps.channelId || latestPostId !== ownProps.latestPostId) {
            onSubmit = makeOnSubmit(ownProps.channelId, ownProps.rootId, ownProps.latestPostId);
        }

        rootId = ownProps.rootId;
        channelId = ownProps.channelId;
        latestPostId = ownProps.latestPostId;

        return bindActionCreators<ActionCreatorsMapObject<any>, Actions>(
            {
                clearCommentDraftUploads,
                onUpdateCommentDraft,
                updateCommentDraftWithRootId,
                onSubmit,
                onResetHistoryIndex,
                onMoveHistoryIndexBack,
                onMoveHistoryIndexForward,
                onEditLatestPost,
                resetCreatePostRequest,
                getChannelTimezones,
                emitShortcutReactToLastPostFrom,
                setShowPreview: setShowPreviewOnCreateComment,
                getChannelMemberCountsByGroup,
                openModal,
                savePreferences,
                searchAssociatedGroupsForReference,
            },
            dispatch,
        );
    };
}

export default connect(makeMapStateToProps, makeMapDispatchToProps, null, {forwardRef: true})(AdvancedCreateComment);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo, forwardRef, useMemo} from 'react';
import {useSelector} from 'react-redux';

import {ArchiveOutlineIcon} from '@mattermost/compass-icons/components';

import {makeGetChannel} from 'mattermost-redux/selectors/entities/channels';
import {getPost, getLimitedViews} from 'mattermost-redux/selectors/entities/posts';
import {UserProfile} from '@mattermost/types/users';
import {Post} from '@mattermost/types/posts';

import FormattedMarkdownMessage from 'components/formatted_markdown_message';
import Constants from 'utils/constants';
import {Posts} from 'mattermost-redux/constants';
import {GlobalState} from 'types/store';
import AdvancedCreateComment from 'components/advanced_create_comment';
import BasicSeparator from 'components/widgets/separator/basic-separator';

type Props = {
    focusOnMount: boolean;
    onHeightChange: (height: number, maxHeight: number) => void;
    teammate?: UserProfile;
    threadId: string;
    latestPostId: Post['id'];
    isThreadView?: boolean;
};

const CreateComment = forwardRef<HTMLDivElement, Props>(({
    focusOnMount,
    onHeightChange,
    teammate,
    threadId,
    latestPostId,
    isThreadView,
}: Props, ref) => {
    const getChannel = useMemo(makeGetChannel, []);
    const rootPost = useSelector((state: GlobalState) => getPost(state, threadId));
    const threadIsLimited = useSelector(getLimitedViews).threads[threadId];
    const channel = useSelector((state: GlobalState) => {
        if (threadIsLimited) {
            return null;
        }
        return getChannel(state, {id: rootPost.channel_id});
    });
    if (!channel || threadIsLimited) {
        return null;
    }
    const rootDeleted = (rootPost as Post).state === Posts.POST_DELETED;
    const isFakeDeletedPost = rootPost.type === Constants.PostTypes.FAKE_PARENT_DELETED;

    const channelType = channel.type;
    const channelIsArchived = channel.delete_at !== 0;

    if (channelType === Constants.DM_CHANNEL && teammate?.delete_at) {
        return (
            <div
                className='post-create-message'
            >
                <FormattedMarkdownMessage
                    id='create_post.deactivated'
                    defaultMessage='You are viewing an archived channel with a **deactivated user**. New messages cannot be posted.'
                />
            </div>
        );
    }

    if (isFakeDeletedPost) {
        return null;
    }

    if (channelIsArchived) {
        return (
            <div className='channel-archived-warning__container'>
                <BasicSeparator/>
                <div className='channel-archived-warning__content'>
                    <ArchiveOutlineIcon
                        size={20}
                        color={'rgba(var(--center-channel-color-rgb), 0.56)'}
                    />
                    <FormattedMarkdownMessage
                        id='threadFromArchivedChannelMessage'
                        defaultMessage='You are viewing a thread from an **archived channel**. New messages cannot be posted.'
                    />
                </div>
            </div>
        );
    }

    return (
        <div
            className='post-create__container'
            ref={ref}
        >
            <AdvancedCreateComment
                focusOnMount={focusOnMount}
                channelId={channel.id}
                latestPostId={latestPostId}
                onHeightChange={onHeightChange}
                rootDeleted={rootDeleted}
                rootId={threadId}
                isThreadView={isThreadView}
            />
        </div>
    );
});

export default memo(CreateComment);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {Posts} from 'mattermost-redux/constants';

import PostBodyAdditionalContent from 'components/post_view/post_body_additional_content';
import PostMessageView from 'components/post_view/post_message_view';

import {PluginsState} from 'types/store/plugins';

import {Post} from '@mattermost/types/posts';

type Props = {
    post: Post;
    isEmbedVisible?: boolean;
    pluginPostTypes?: PluginsState['postTypes'];
}

export default function MessageWithAdditionalContent({post, isEmbedVisible, pluginPostTypes}: Props) {
    const hasPlugin = post.type && pluginPostTypes?.hasOwnProperty(post.type);
    let msg;
    const messageWrapper = (
        <PostMessageView
            post={post}
            isRHS={true}
        />
    );
    if (post.state === Posts.POST_DELETED || hasPlugin) {
        msg = messageWrapper;
    } else {
        msg = (
            <PostBodyAdditionalContent
                post={post}
                isEmbedVisible={isEmbedVisible}
            >
                {messageWrapper}
            </PostBodyAdditionalContent>
        );
    }
    return msg;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import PropTypes from 'prop-types';
import React, {createRef} from 'react';
import {FormattedMessage} from 'react-intl';
import classNames from 'classnames';

import {Posts, Preferences} from 'mattermost-redux/constants';
import * as ReduxPostUtils from 'mattermost-redux/utils/post_utils';

import Constants, {Locations, A11yCustomEventTypes, AppEvents} from 'utils/constants';
import * as PostUtils from 'utils/post_utils';
import * as Utils from 'utils/utils';
import ActionsMenu from 'components/actions_menu';
import DotMenu from 'components/dot_menu';
import FileAttachmentListContainer from 'components/file_attachment_list';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import PostProfilePicture from 'components/post_profile_picture';
import PostAriaLabelDiv from 'components/post_view/post_aria_label_div';
import PostFlagIcon from 'components/post_view/post_flag_icon';
import ReactionList from 'components/post_view/reaction_list';
import PostTime from 'components/post_view/post_time';
import PostRecentReactions from 'components/post_view/post_recent_reactions';
import PostReaction from 'components/post_view/post_reaction';
import MessageWithAdditionalContent from 'components/message_with_additional_content';
import BotBadge from 'components/widgets/badges/bot_badge';
import InfoSmallIcon from 'components/widgets/icons/info_small_icon';
import PriorityLabel from 'components/post_priority/post_priority_label';

import UserProfile from 'components/user_profile';
import PostPreHeader from 'components/post_view/post_pre_header';
import CustomStatusEmoji from 'components/custom_status/custom_status_emoji';
import EditPost from 'components/edit_post';
import AutoHeightSwitcher, {AutoHeightSlots} from 'components/common/auto_height_switcher';
import PostAcknowledgements from 'components/post_view/acknowledgements';

export default class RhsRootPost extends React.PureComponent {
    static propTypes = {
        post: PropTypes.object.isRequired,
        teamId: PropTypes.string.isRequired,
        currentUserId: PropTypes.string.isRequired,
        compactDisplay: PropTypes.bool,
        colorizeUsernames: PropTypes.bool,
        commentCount: PropTypes.number.isRequired,
        isFlagged: PropTypes.bool.isRequired,
        previewCollapsed: PropTypes.string,
        previewEnabled: PropTypes.bool,
        isBusy: PropTypes.bool,
        isEmbedVisible: PropTypes.bool,
        enableEmojiPicker: PropTypes.bool.isRequired,
        enablePostUsernameOverride: PropTypes.bool.isRequired,
        isReadOnly: PropTypes.bool.isRequired,
        pluginPostTypes: PropTypes.object,
        channelIsArchived: PropTypes.bool.isRequired,
        isPostPriorityEnabled: PropTypes.bool.isRequired,
        handleCardClick: PropTypes.func.isRequired,
        isPostAcknowledgementsEnabled: PropTypes.bool,

        /**
         * To Check if the current post is last in the list of RHS
         */
        isLastPost: PropTypes.bool,

        /**
         * To check if the state of emoji for last message and from where it was emitted
         */
        shortcutReactToLastPostEmittedFrom: PropTypes.string,
        actions: PropTypes.shape({
            markPostAsUnread: PropTypes.func.isRequired,

            /**
             * Function to set or unset emoji picker for last message
             */
            emitShortcutReactToLastPostFrom: PropTypes.func,

            /**
             * Function to set viewed Actions Menu for first time
             */
            setActionsMenuInitialisationState: PropTypes.func,
        }),
        timestampProps: PropTypes.object,
        isBot: PropTypes.bool,
        collapsedThreadsEnabled: PropTypes.bool,
        shouldShowActionsMenu: PropTypes.bool,

        /**
        * true when want to show the Actions Menu with pulsating dot for tutorial
         */
        showActionsMenuPulsatingDot: PropTypes.bool,
        oneClickReactionsEnabled: PropTypes.bool,

        // e.g. import {Emoji} from '@mattermost/types/emojis';
        recentEmojis: PropTypes.arrayOf(PropTypes.object),

        isExpanded: PropTypes.bool,

        /**
         * check if the current post is being edited at the moment
         */
        isPostBeingEdited: PropTypes.bool,
        isMobileView: PropTypes.bool.isRequired,
    };

    static defaultProps = {
        commentCount: 0,
    };

    constructor(props) {
        super(props);

        this.state = {
            alt: false,
            showActionsMenu: false,
            showActionTip: false,
            showDotMenu: false,
            showEmojiPicker: false,
            testStateObj: true,
            fileDropdownOpened: false,
            hover: false,
            a11yActive: false,
        };

        this.postHeaderRef = createRef();
        this.dotMenuRef = createRef();
        this.postRef = createRef();
    }

    handleShortcutReactToLastPost = (isLastPost) => {
        if (isLastPost) {
            const {
                channelIsArchived,
                enableEmojiPicker,
                isMobileView,
                post,
                actions: {
                    emitShortcutReactToLastPostFrom,
                },
            } = this.props;

            // Setting the last message emoji action to empty to clean up the redux state
            emitShortcutReactToLastPostFrom(Locations.NO_WHERE);

            // Following are the types of posts on which adding reaction is not possible
            const isDeletedPost = post && post.state === Posts.POST_DELETED;
            const isEphemeralPost = post && Utils.isPostEphemeral(post);
            const isSystemMessage = post && PostUtils.isSystemMessage(post);
            const isFailedPost = post && post.failed;
            const isPostsFakeParentDeleted = post && post.type === Constants.PostTypes.FAKE_PARENT_DELETED;

            // Checking if rhs root comment is at scroll view of the user
            const boundingRectOfPostInfo = this.postHeaderRef.current.getBoundingClientRect();
            const isPostHeaderVisibleToUser = (boundingRectOfPostInfo.top - 110) > 0 &&
                boundingRectOfPostInfo.bottom < (window.innerHeight);

            if (isPostHeaderVisibleToUser) {
                if (!isEphemeralPost && !isSystemMessage && !isDeletedPost && !isFailedPost && !isMobileView &&
                    !channelIsArchived && !isPostsFakeParentDeleted && enableEmojiPicker) {
                    // As per issue in #2 of mattermost-webapp/pull/4478#pullrequestreview-339313236
                    // We are not not handling focus condition as we did for rhs_comment as the dot menu is already in dom and not visible
                    this.toggleEmojiPicker(isLastPost);
                }
            }
        }
    }

    componentDidMount() {
        if (this.postRef.current) {
            this.postRef.current.addEventListener(A11yCustomEventTypes.ACTIVATE, this.handleA11yActivateEvent);
            this.postRef.current.addEventListener(A11yCustomEventTypes.DEACTIVATE, this.handleA11yDeactivateEvent);
        }
    }
    componentWillUnmount() {
        if (this.state.show) {
            this.removeKeyboardListeners();
        }

        if (this.postRef.current) {
            this.postRef.current.removeEventListener(A11yCustomEventTypes.ACTIVATE, this.handleA11yActivateEvent);
            this.postRef.current.removeEventListener(A11yCustomEventTypes.DEACTIVATE, this.handleA11yDeactivateEvent);
        }
    }

    componentDidUpdate(prevProps) {
        const {shortcutReactToLastPostEmittedFrom, isLastPost} = this.props;

        if (this.state.a11yActive) {
            this.postRef.current.dispatchEvent(new Event(A11yCustomEventTypes.UPDATE));
        }

        const shortcutReactToLastPostEmittedFromRHS = prevProps.shortcutReactToLastPostEmittedFrom !== shortcutReactToLastPostEmittedFrom &&
            shortcutReactToLastPostEmittedFrom === Locations.RHS_ROOT;
        if (shortcutReactToLastPostEmittedFromRHS) {
            this.handleShortcutReactToLastPost(isLastPost);
        }
    }

    renderPostTime = (isEphemeral) => {
        const post = this.props.post;

        if (post.type === Constants.PostTypes.FAKE_PARENT_DELETED) {
            return null;
        }

        const isPermalink = !(isEphemeral ||
            Posts.POST_DELETED === post.state ||
            ReduxPostUtils.isPostPendingOrFailed(post));

        return (
            <PostTime
                isPermalink={isPermalink}
                eventTime={post.create_at}
                postId={post.id}
                location={Locations.RHS_ROOT}
                timestampProps={this.props.timestampProps}
            />
        );
    };

    toggleEmojiPicker = (e) => {
        if (e && e.stopPropagation) {
            e.stopPropagation();
        }

        const showEmojiPicker = !this.state.showEmojiPicker;
        this.setState({showEmojiPicker});
    };

    handleA11yActivateEvent = () => {
        this.setState({a11yActive: true});
    }

    handleA11yDeactivateEvent = () => {
        this.setState({a11yActive: false});
    }

    getClassName = (post, isSystemMessage, isMeMessage) => {
        let className = 'post post--root post--thread';
        if (this.props.currentUserId === post.user_id) {
            className += ' current--user';
        }

        if (this.props.isPostBeingEdited) {
            className += ' post--editing';
        }

        if (isSystemMessage || isMeMessage) {
            className += ' post--system';
        }

        if (this.props.compactDisplay) {
            className += ' post--compact';
        }

        if (this.state.showDotMenu ||
            this.state.showActionsMenu ||
            this.state.showActionTip ||
            this.state.fileDropdownOpened ||
            this.state.showEmojiPicker) {
            className += ' post--hovered';
        }

        if (this.state.alt && !this.props.channelIsArchived) {
            className += ' cursor--pointer';
        }

        return className;
    };

    setHover = (e) => {
        this.setState({
            hover: true,
            alt: e.altKey,
        });

        this.addKeyboardListeners();
    }

    unsetHover = () => {
        this.setState({
            hover: false,
            alt: false,
        });

        this.removeKeyboardListeners();
    }

    addKeyboardListeners = () => {
        document.addEventListener('keydown', this.handleAlt);
        document.addEventListener('keyup', this.handleAlt);
    }

    removeKeyboardListeners = () => {
        document.removeEventListener('keydown', this.handleAlt);
        document.removeEventListener('keyup', this.handleAlt);
    }

    handleAlt = (e) => {
        if (this.state.alt !== e.altKey) {
            this.setState({alt: e.altKey});
        }
    }

    handleActionsMenuOpened = (open) => {
        if (this.props.showActionsMenuPulsatingDot) {
            this.setState({showActionTip: true});
            return;
        }
        this.setState({showActionsMenu: open});
    };

    handleDotMenuOpened = (open) => {
        this.setState({showDotMenu: open});
    };

    handleActionsMenuTipOpened = () => {
        this.setState({showActionTip: true});
    };

    handleActionsMenuGotItClick = () => {
        this.props.actions.setActionsMenuInitialisationState?.(({[Preferences.ACTIONS_MENU_VIEWED]: true}));
        this.setState({showActionTip: false});
    };

    handleTipDismissed = () => {
        this.setState({showActionTip: false});
    };

    handleFileDropdownOpened = (open) => {
        this.setState({fileDropdownOpened: open});
    };

    handlePostClick = (e) => {
        if (this.props.channelIsArchived) {
            return;
        }

        if (e.altKey) {
            this.props.actions.markPostAsUnread(this.props.post, 'RHS_ROOT');
        }
    }

    getDotMenuRef = () => {
        return this.dotMenuRef.current;
    };

    render() {
        const {
            channelIsArchived,
            collapsedThreadsEnabled,
            isBot,
            isMobileView,
            isReadOnly,
            post,
            teamId,
            isPostBeingEdited,
        } = this.props;

        const isPostDeleted = post && post.state === Posts.POST_DELETED;
        const isEphemeral = Utils.isPostEphemeral(post);
        const isSystemMessage = PostUtils.isSystemMessage(post);
        const isMeMessage = ReduxPostUtils.isMeMessage(post);
        const colorize = this.props.compactDisplay && this.props.colorizeUsernames;

        const showRecentlyUsedReactions = (!isReadOnly && !isEphemeral && !post.failed && !isSystemMessage && !channelIsArchived && this.props.oneClickReactionsEnabled && this.props.enableEmojiPicker);
        let showRecentReacions;
        if (showRecentlyUsedReactions) {
            showRecentReacions = (
                <PostRecentReactions
                    channelId={post.channel_id}
                    postId={post.id}
                    teamId={this.props.teamId}
                    emojis={this.props.recentEmojis}
                    getDotMenuRef={this.getDotMenuRef}
                    size={this.props.isExpanded ? 3 : 1}
                />
            );
        }

        let postReaction;
        if (!isReadOnly && !isEphemeral && !post.failed && !isSystemMessage && this.props.enableEmojiPicker && !channelIsArchived) {
            postReaction = (
                <PostReaction
                    channelId={post.channel_id}
                    postId={post.id}
                    teamId={teamId}
                    getDotMenuRef={this.getDotMenuRef}
                    location={Locations.RHS_ROOT}
                    showEmojiPicker={this.state.showEmojiPicker}
                    toggleEmojiPicker={this.toggleEmojiPicker}
                />
            );
        }

        let fileAttachment = null;
        if (post.file_ids && post.file_ids.length > 0) {
            fileAttachment = (
                <FileAttachmentListContainer
                    post={post}
                    compactDisplay={this.props.compactDisplay}
                    handleFileDropdownOpened={this.handleFileDropdownOpened}
                />
            );
        }

        let userProfile;
        let botIndicator;
        if (isSystemMessage) {
            userProfile = (
                <UserProfile
                    overwriteName={
                        <FormattedMessage
                            id='post_info.system'
                            defaultMessage='System'
                        />
                    }
                    overwriteImage={Constants.SYSTEM_MESSAGE_PROFILE_IMAGE}
                    disablePopover={true}
                    colorize={colorize}
                />
            );
        } else if (PostUtils.isFromWebhook(post)) {
            if (post.props.override_username && this.props.enablePostUsernameOverride) {
                userProfile = (
                    <UserProfile
                        key={post.user_id}
                        userId={post.user_id}
                        hideStatus={true}
                        overwriteName={post.props.override_username}
                        disablePopover={true}
                        colorize={colorize}
                    />
                );
            } else {
                userProfile = (
                    <UserProfile
                        key={post.user_id}
                        userId={post.user_id}
                        hideStatus={true}
                        disablePopover={true}
                        colorize={colorize}
                    />
                );
            }

            botIndicator = <BotBadge/>;
        } else {
            userProfile = (
                <UserProfile
                    key={post.user_id}
                    userId={post.user_id}
                    isBusy={this.props.isBusy}
                    isRHS={true}
                    hasMention={true}
                    colorize={colorize}
                />
            );
        }

        const postClass = classNames('post__body--transition', {'post--edited': PostUtils.isEdited(this.props.post)});

        const actionsMenu = (
            <ActionsMenu
                post={this.props.post}
                location={Locations.RHS_ROOT}
                handleDropdownOpened={this.handleActionsMenuOpened}
                isMenuOpen={this.state.showActionsMenu}
                showPulsatingDot={this.props.showActionsMenuPulsatingDot}
                showTutorialTip={this.state.showActionTip}
                handleOpenTip={this.handleActionsMenuTipOpened}
                handleNextTip={this.handleActionsMenuGotItClick}
                handleDismissTip={this.handleTipDismissed}
            />
        );

        const dotMenu = (
            <DotMenu
                post={this.props.post}
                location={Locations.RHS_ROOT}
                isFlagged={this.props.isFlagged}
                handleDropdownOpened={this.handleDotMenuOpened}
                handleAddReactionClick={this.toggleEmojiPicker}
                commentCount={this.props.commentCount}
                isMenuOpen={this.state.showDotMenu}
                isReadOnly={isReadOnly || channelIsArchived}
                enableEmojiPicker={this.props.enableEmojiPicker}
            />
        );

        let postFlagIcon;
        const showFlagIcon = !isEphemeral && !post.failed && !isSystemMessage && !isMobileView;
        if (showFlagIcon) {
            postFlagIcon = (
                <PostFlagIcon
                    location={Locations.RHS_ROOT}
                    postId={post.id}
                    isFlagged={this.props.isFlagged}
                />
            );
        }

        let dotMenuContainer;
        if (!isPostDeleted && this.props.post.type !== Constants.PostTypes.FAKE_PARENT_DELETED) {
            dotMenuContainer = (
                <div
                    ref={this.dotMenuRef}
                    className='col post-menu'
                >
                    {!collapsedThreadsEnabled && !showRecentlyUsedReactions && dotMenu}
                    {showRecentReacions}
                    {postReaction}
                    {postFlagIcon}
                    {actionsMenu}
                    {(collapsedThreadsEnabled || showRecentlyUsedReactions) && dotMenu}
                </div>
            );
        }

        let postInfoIcon;
        if (this.props.post.props && this.props.post.props.card) {
            postInfoIcon = (
                <OverlayTrigger
                    delayShow={Constants.OVERLAY_TIME_DELAY}
                    placement='top'
                    overlay={
                        <Tooltip>
                            <FormattedMessage
                                id='post_info.info.view_additional_info'
                                defaultMessage='View additional info'
                            />
                        </Tooltip>
                    }
                >
                    <button
                        className='card-icon__container icon--show style--none'
                        onClick={(e) => {
                            e.preventDefault();
                            this.props.handleCardClick(this.props.post);
                        }}
                    >
                        <InfoSmallIcon
                            className='icon icon__info'
                            aria-hidden='true'
                        />
                    </button>
                </OverlayTrigger>
            );
        }

        let customStatus;
        if (!(isSystemMessage || post?.props?.from_webhook || isBot)) {
            customStatus = (
                <CustomStatusEmoji
                    userID={post.user_id}
                    showTooltip={true}
                    emojiStyle={{
                        marginLeft: 4,
                        marginTop: 2,
                    }}
                />
            );
        }

        let priority;
        if (post.metadata?.priority && this.props.isPostPriorityEnabled) {
            priority = <span className='d-flex mr-2 ml-1'><PriorityLabel priority={post.metadata.priority.priority}/></span>;
        }

        const message = (
            <MessageWithAdditionalContent
                post={post}
                previewCollapsed={this.props.previewCollapsed}
                previewEnabled={this.props.previewEnabled}
                isEmbedVisible={this.props.isEmbedVisible}
                pluginPostTypes={this.props.pluginPostTypes}
            />
        );

        const showSlot = isPostBeingEdited ? AutoHeightSlots.SLOT2 : AutoHeightSlots.SLOT1;

        return (
            <PostAriaLabelDiv
                ref={this.postRef}
                role='listitem'
                id={'rhsPost_' + post.id}
                tabIndex='-1'
                post={post}
                className={`thread__root a11y__section ${this.getClassName(post, isSystemMessage, isMeMessage)}`}
                onClick={this.handlePostClick}
                onMouseOver={this.setHover}
                onMouseLeave={this.unsetHover}
                data-a11y-sort-order='0'
            >
                <PostPreHeader
                    isFlagged={this.props.isFlagged}
                    isPinned={post.is_pinned}
                    channelId={post.channel_id}
                />
                <div
                    role='application'
                    className='post__content'
                >
                    <div className='post__img'>
                        <PostProfilePicture
                            compactDisplay={this.props.compactDisplay}
                            isBusy={this.props.isBusy}
                            isRHS={true}
                            post={post}
                            userId={post.user_id}
                            channelId={post.channel_id}
                        />
                    </div>
                    <div>
                        <div
                            className='post__header'
                            ref={this.postHeaderRef}
                        >
                            <div className='col__name'>
                                {userProfile}
                                {botIndicator}
                                {customStatus}
                            </div>
                            <div className='col d-flex align-items-center'>
                                {this.renderPostTime(isEphemeral)}
                                {priority}
                                {postInfoIcon}
                            </div>
                            {!isPostBeingEdited && dotMenuContainer}
                        </div>
                        <div className='post__body'>
                            <div className={postClass}>
                                <AutoHeightSwitcher
                                    showSlot={showSlot}
                                    shouldScrollIntoView={isPostBeingEdited}
                                    slot1={message}
                                    slot2={<EditPost/>}
                                    onTransitionEnd={() => document.dispatchEvent(new Event(AppEvents.FOCUS_EDIT_TEXTBOX))}
                                />
                            </div>
                            {fileAttachment}
                            <div className='post__body-reactions-acks'>
                                {this.props.isPostAcknowledgementsEnabled && post.metadata?.priority?.requested_ack && (
                                    <PostAcknowledgements postId={post.id}/>
                                )}
                                <ReactionList post={post}/>
                            </div>
                        </div>
                    </div>
                </div>
            </PostAriaLabelDiv>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {showActionsDropdownPulsatingDot} from 'selectors/actions_menu';
import {setActionsMenuInitialisationState} from 'mattermost-redux/actions/preferences';
import {getChannel} from 'mattermost-redux/selectors/entities/channels';
import {getConfig} from 'mattermost-redux/selectors/entities/general';

import {
    get,
    isCollapsedThreadsEnabled,
} from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {isPostPriorityEnabled, isPostAcknowledgementsEnabled} from 'mattermost-redux/selectors/entities/posts';
import {getUser} from 'mattermost-redux/selectors/entities/users';

import {GenericAction} from 'mattermost-redux/types/actions';

import {markPostAsUnread, emitShortcutReactToLastPostFrom} from 'actions/post_actions';

import {getShortcutReactToLastPostEmittedFrom, getOneClickReactionEmojis} from 'selectors/emojis';
import {getIsPostBeingEditedInRHS, isEmbedVisible} from 'selectors/posts';
import {getIsMobileView} from 'selectors/views/browser';

import {GlobalState} from 'types/store';

import {shouldShowActionsMenu} from 'utils/post_utils';
import {isArchivedChannel} from 'utils/channel_utils';
import {Preferences} from 'utils/constants';

import {Emoji} from '@mattermost/types/emojis';
import {Post} from '@mattermost/types/posts';

import RhsRootPost from './rhs_root_post.jsx';

interface OwnProps {
    post: Post ;
    teamId: string;
}

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const config = getConfig(state);
    const enableEmojiPicker = config.EnableEmojiPicker === 'true';
    const enablePostUsernameOverride = config.EnablePostUsernameOverride === 'true';
    const teamId = ownProps.teamId || getCurrentTeamId(state);
    const channel = getChannel(state, ownProps.post.channel_id);
    const shortcutReactToLastPostEmittedFrom = getShortcutReactToLastPostEmittedFrom(state);

    const user = getUser(state, ownProps.post.user_id);
    const isBot = Boolean(user && user.is_bot);
    const showActionsMenuPulsatingDot = showActionsDropdownPulsatingDot(state);

    let emojis: Emoji[] = [];
    const oneClickReactionsEnabled = get(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.ONE_CLICK_REACTIONS_ENABLED, Preferences.ONE_CLICK_REACTIONS_ENABLED_DEFAULT) === 'true';
    if (oneClickReactionsEnabled) {
        emojis = getOneClickReactionEmojis(state);
    }

    return {
        isBot,
        enableEmojiPicker,
        enablePostUsernameOverride,
        isEmbedVisible: isEmbedVisible(state, ownProps.post.id),
        isReadOnly: false,
        teamId,
        pluginPostTypes: state.plugins.postTypes,
        channelIsArchived: isArchivedChannel(channel),
        isFlagged: get(state, Preferences.CATEGORY_FLAGGED_POST, ownProps.post.id, null) != null,
        compactDisplay: get(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.MESSAGE_DISPLAY, Preferences.MESSAGE_DISPLAY_DEFAULT) === Preferences.MESSAGE_DISPLAY_COMPACT,
        colorizeUsernames: get(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.COLORIZE_USERNAMES, Preferences.COLORIZE_USERNAMES_DEFAULT) === 'true',
        shortcutReactToLastPostEmittedFrom,
        shouldShowActionsMenu: shouldShowActionsMenu(state, ownProps.post),
        showActionsMenuPulsatingDot,
        collapsedThreadsEnabled: isCollapsedThreadsEnabled(state),
        oneClickReactionsEnabled,
        recentEmojis: emojis,
        isExpanded: state.views.rhs.isSidebarExpanded,

        isPostBeingEdited: getIsPostBeingEditedInRHS(state, ownProps.post.id),
        isMobileView: getIsMobileView(state),
        isPostPriorityEnabled: isPostPriorityEnabled(state),
        isPostAcknowledgementsEnabled: isPostAcknowledgementsEnabled(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            markPostAsUnread,
            emitShortcutReactToLastPostFrom,
            setActionsMenuInitialisationState,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(RhsRootPost);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo} from 'react';

import {Post} from '@mattermost/types/posts';

import RhsRootPost from 'components/rhs_root_post';
import {Props as TimestampProps} from 'components/timestamp/timestamp';

type Props = {
    currentUserId: string;
    isLastPost: boolean;
    onCardClick: (post: Post) => void;
    post: Post;
    previewCollapsed: string;
    previewEnabled: boolean;
    teamId: string;
    timestampProps?: Partial<TimestampProps>;
}

function RootPost({
    currentUserId,
    isLastPost,
    onCardClick,
    post,
    previewCollapsed,
    previewEnabled,
    teamId,
    timestampProps,
}: Props) {
    return (
        <RhsRootPost
            commentCount={post.reply_count}
            currentUserId={currentUserId}
            handleCardClick={onCardClick}
            isLastPost={isLastPost}
            post={post}
            previewCollapsed={previewCollapsed}
            previewEnabled={previewEnabled}
            teamId={teamId}
            timestampProps={timestampProps}
        />
    );
}

export default memo(RootPost);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getPost} from 'mattermost-redux/selectors/entities/posts';
import {get, getBool} from 'mattermost-redux/selectors/entities/preferences';

import {Preferences} from 'utils/constants';

import {GlobalState} from 'types/store';

import RootPost from './root_post';

type OwnProps = {
    id: string;
}

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const previewCollapsed = get(
        state,
        Preferences.CATEGORY_DISPLAY_SETTINGS,
        Preferences.COLLAPSE_DISPLAY,
        Preferences.COLLAPSE_DISPLAY_DEFAULT,
    );

    const previewEnabled = getBool(
        state,
        Preferences.CATEGORY_DISPLAY_SETTINGS,
        Preferences.LINK_PREVIEW_DISPLAY,
        Preferences.LINK_PREVIEW_DISPLAY_DEFAULT === 'true',
    );

    return {
        post: getPost(state, ownProps.id),
        previewEnabled,
        previewCollapsed,
    };
}

export default connect(mapStateToProps)(RootPost);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode, RefObject} from 'react';
import {FormattedMessage} from 'react-intl';
import classNames from 'classnames';

import {Posts, Preferences} from 'mattermost-redux/constants/index';
import {
    isMeMessage as checkIsMeMessage,
    isPostEphemeral,
    isPostPendingOrFailed,
} from 'mattermost-redux/utils/post_utils';

import Constants, {A11yCustomEventTypes, AppEvents, Locations} from 'utils/constants';
import * as PostUtils from 'utils/post_utils';
import {isMobile} from 'utils/utils';

import {PostPluginComponent} from 'types/store/plugins';

import ActionsMenu from 'components/actions_menu';
import DotMenu from 'components/dot_menu';
import FileAttachmentListContainer from 'components/file_attachment_list';
import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import PostProfilePicture from 'components/post_profile_picture';
import FailedPostOptions from 'components/post_view/failed_post_options';
import PostAriaLabelDiv from 'components/post_view/post_aria_label_div';
import PostFlagIcon from 'components/post_view/post_flag_icon';
import PostTime from 'components/post_view/post_time';
import PostRecentReactions from 'components/post_view/post_recent_reactions';
import PostReaction from 'components/post_view/post_reaction';
import ReactionList from 'components/post_view/reaction_list';
import MessageWithAdditionalContent from 'components/message_with_additional_content';
import BotBadge from 'components/widgets/badges/bot_badge';
import Badge from 'components/widgets/badges/badge';
import InfoSmallIcon from 'components/widgets/icons/info_small_icon';
import PostPreHeader from 'components/post_view/post_pre_header';
import UserProfile from 'components/user_profile';
import CustomStatusEmoji from 'components/custom_status/custom_status_emoji';
import EditPost from 'components/edit_post';
import AutoHeightSwitcher, {AutoHeightSlots} from 'components/common/auto_height_switcher';
import {Props as TimestampProps} from 'components/timestamp/timestamp';

import {Emoji} from '@mattermost/types/emojis';
import {Post} from '@mattermost/types/posts';

type Props = {
    post: Post;
    teamId: string;
    currentUserId: string;
    compactDisplay?: boolean;
    colorizeUsernames?: boolean;
    isFlagged: boolean;
    isBusy?: boolean;
    removePost: (post: Post) => void;
    isEmbedVisible?: boolean;
    enableEmojiPicker: boolean;
    enablePostUsernameOverride: boolean;
    isReadOnly: boolean;
    pluginPostTypes?: {[postType: string]: PostPluginComponent};
    channelIsArchived?: boolean;
    isConsecutivePost?: boolean;
    handleCardClick?: (post: Post) => void;
    a11yIndex?: number;

    /**
     * If the user that made the post is a bot.
     */
    isBot: boolean;

    /**
     * To Check if the current post is last in the list of RHS
     */
    isLastPost?: boolean;

    /**
     * To check if the state of emoji for last message and from where it was emitted
     */
    shortcutReactToLastPostEmittedFrom?: string;
    actions: {
        markPostAsUnread: (post: Post, location: string) => void;

        /**
         * Function to set or unset emoji picker for last message
         */
        emitShortcutReactToLastPostFrom: (emittedFrom: 'CENTER' | 'RHS_ROOT' | 'NO_WHERE') => void;

        /**
         * Function to set viewed Actions Menu for first time
         */
        setActionsMenuInitialisationState: (initializationState: Record<string, boolean>) => void;
    };
    timestampProps?: Partial<TimestampProps>;
    collapsedThreadsEnabled?: boolean;

    shouldShowActionsMenu?: boolean;

    /**
     * true when want to show the Actions Menu with pulsating dot for tutorial
     */
    showActionsMenuPulsatingDot?: boolean;

    /**
     * To Check if the current post is to be highlighted and scrolled into center view of RHS
     */
    shouldHighlight?: boolean;

    oneClickReactionsEnabled?: boolean;
    recentEmojis: Emoji[];

    isExpanded?: boolean;

    /**
     * check if the current post is being edited at the moment
     */
    isPostBeingEdited?: boolean;
    isMobileView: boolean;
};

type State = {
    showEmojiPicker: boolean;
    showDotMenu: boolean;
    showActionsMenu: boolean;
    showActionTip: boolean;
    fileDropdownOpened: boolean;
    alt: boolean;
    hover: boolean;
    a11yActive: boolean;
    currentAriaLabel: string;
}

export default class RhsComment extends React.PureComponent<Props, State> {
    postRef: RefObject<HTMLDivElement>;
    dotMenuRef: RefObject<HTMLDivElement>;
    postHeaderRef: RefObject<HTMLDivElement>;

    constructor(props: Props) {
        super(props);

        this.postRef = React.createRef();
        this.dotMenuRef = React.createRef();

        this.state = {
            showEmojiPicker: false,
            showDotMenu: false,
            showActionsMenu: false,
            showActionTip: false,
            fileDropdownOpened: false,
            alt: false,
            hover: false,
            a11yActive: false,
            currentAriaLabel: '',
        };

        this.postHeaderRef = React.createRef();
    }

    componentDidMount() {
        if (this.postRef.current) {
            this.postRef.current.addEventListener(A11yCustomEventTypes.ACTIVATE, this.handleA11yActivateEvent);
            this.postRef.current.addEventListener(A11yCustomEventTypes.DEACTIVATE, this.handleA11yDeactivateEvent);
        }
    }

    componentWillUnmount() {
        if (this.state.hover) {
            this.removeKeyboardListeners();
        }

        if (this.postRef.current) {
            this.postRef.current.removeEventListener(A11yCustomEventTypes.ACTIVATE, this.handleA11yActivateEvent);
            this.postRef.current.removeEventListener(A11yCustomEventTypes.DEACTIVATE, this.handleA11yDeactivateEvent);
        }
    }

    componentDidUpdate(prevProps: Props) {
        const {shortcutReactToLastPostEmittedFrom, isLastPost} = this.props;

        if (this.state.a11yActive) {
            this.postRef.current?.dispatchEvent(new Event(A11yCustomEventTypes.UPDATE));
        }

        const shortcutReactToLastPostEmittedFromRHS = prevProps.shortcutReactToLastPostEmittedFrom !== shortcutReactToLastPostEmittedFrom &&
        shortcutReactToLastPostEmittedFrom === Locations.RHS_ROOT;
        if (shortcutReactToLastPostEmittedFromRHS) {
            // Opening the emoji picker when more than one post in rhs is present
            this.handleShortcutReactToLastPost(isLastPost);
        }
    }

    handleShortcutReactToLastPost = (isLastPost?: boolean) => {
        if (isLastPost) {
            const {
                channelIsArchived,
                enableEmojiPicker,
                isMobileView,
                isReadOnly,
                post,
                actions: {
                    emitShortcutReactToLastPostFrom,
                },
            } = this.props;

            // Setting the last message emoji action to empty to clean up the redux state
            emitShortcutReactToLastPostFrom(Locations.NO_WHERE);

            // Following are the types of posts on which adding reaction is not possible
            const isDeletedPost: boolean = post && post.state === Posts.POST_DELETED;
            const isEphemeralPost: boolean = post && isPostEphemeral(post);
            const isSystemMessage: boolean = post && PostUtils.isSystemMessage(post);
            const isAutoRespondersPost: boolean = post && PostUtils.fromAutoResponder(post);
            const isFailedPost: boolean | undefined = post && post.failed;

            // Checking if rhs comment is in scroll view of the user
            const boundingRectOfPostInfo: DOMRect | undefined = this.postHeaderRef.current?.getBoundingClientRect();

            let isPostHeaderVisibleToUser: boolean | null = null;
            if (boundingRectOfPostInfo) {
                isPostHeaderVisibleToUser = (boundingRectOfPostInfo.top - 110) > 0 &&
                    boundingRectOfPostInfo.bottom < (window.innerHeight);
            }

            if (isPostHeaderVisibleToUser && !isEphemeralPost && !isSystemMessage && !isReadOnly && !isFailedPost &&
                !isAutoRespondersPost && !isDeletedPost && !channelIsArchived && !isMobileView && enableEmojiPicker) {
                this.setState({hover: true}, () => {
                    this.toggleEmojiPicker();
                });
            }
        }
    }

    removePost = () => this.props.removePost(this.props.post);

    createRemovePostButton = () => {
        return (
            <button
                className='post__remove theme color--link style--none'
                type='button'
                onClick={this.removePost}
            >
                {''}
            </button>
        );
    };

    renderPostTime = () => {
        const post = this.props.post;

        const isPermalink = !(Posts.POST_DELETED === post.state || isPostPendingOrFailed(post));

        return (
            <PostTime
                isPermalink={isPermalink}
                eventTime={post.create_at}
                postId={post.id}
                location={Locations.RHS_COMMENT}
                timestampProps={{...this.props.timestampProps, style: this.props.isConsecutivePost && !this.props.compactDisplay ? 'narrow' : undefined}}
            />
        );
    };

    toggleEmojiPicker = (e?: React.MouseEvent<HTMLButtonElement, MouseEvent>): void => {
        e?.stopPropagation();
        const showEmojiPicker = !this.state.showEmojiPicker;
        this.setState({
            showEmojiPicker,
        });
    };

    getClassName = (post: Post, isSystemMessage: boolean, isMeMessage: boolean) => {
        const hovered = this.state.showDotMenu ||
            this.state.showActionsMenu ||
            this.state.showActionTip ||
            this.state.fileDropdownOpened ||
            this.state.showEmojiPicker;

        return classNames('a11y__section post post--thread same--root post--comment', {
            'post--highlight': this.props.shouldHighlight,
            'post--editing': this.props.isPostBeingEdited,
            'current--user': this.props.currentUserId === post.user_id,
            'post--system': isSystemMessage || isMeMessage,
            'post--compact': this.props.compactDisplay,
            'post--hovered': hovered,
            'same--user': this.props.isConsecutivePost,
            'cursor--pointer': this.state.alt && !this.props.channelIsArchived,
        });
    };

    handleAlt = (e: KeyboardEvent) => {
        if (this.state.alt !== e.altKey) {
            this.setState({alt: e.altKey});
        }
    }

    handleDotMenuOpened = (open: boolean) => this.setState({showDotMenu: open});

    handleFileDropdownOpened = (open: boolean) => this.setState({fileDropdownOpened: open});

    handleActionsMenuOpened = (open: boolean) => {
        if (this.props.showActionsMenuPulsatingDot) {
            this.setState({showActionTip: true});
            return;
        }
        this.setState({showActionsMenu: open});
    };

    handleActionsMenuTipOpened = () => this.setState({showActionTip: true});

    handleActionsMenuGotItClick = () => {
        this.props.actions.setActionsMenuInitialisationState?.(({[Preferences.ACTIONS_MENU_VIEWED]: true}));
        this.setState({showActionTip: false});
    };

    handleTipDismissed = () => this.setState({showActionTip: false});

    getDotMenuRef = () => this.dotMenuRef.current;

    setHover = (e: React.MouseEvent<HTMLDivElement>) => {
        this.setState({
            hover: true,
            alt: e.altKey,
        });

        this.addKeyboardListeners();
    }

    unsetHover = () => {
        this.setState({
            hover: false,
            alt: false,
        });

        this.removeKeyboardListeners();
    }

    addKeyboardListeners = () => {
        document.addEventListener('keydown', this.handleAlt);
        document.addEventListener('keyup', this.handleAlt);
    }

    removeKeyboardListeners = () => {
        document.removeEventListener('keydown', this.handleAlt);
        document.removeEventListener('keyup', this.handleAlt);
    }

    handleA11yActivateEvent = () => this.setState({a11yActive: true});

    handleA11yDeactivateEvent = () => this.setState({a11yActive: false});

    handlePostClick = (e: React.MouseEvent<HTMLDivElement>) => {
        if (this.props.channelIsArchived) {
            return;
        }

        if (e.altKey) {
            this.props.actions.markPostAsUnread(this.props.post, 'RHS_COMMENT');
        }
    }

    render() {
        const {
            channelIsArchived,
            collapsedThreadsEnabled,
            isConsecutivePost,
            isMobileView,
            isReadOnly,
            post,
            isPostBeingEdited,
        } = this.props;

        const isPostDeleted = post && post.state === Posts.POST_DELETED;
        const isEphemeral = isPostEphemeral(post);
        const isSystemMessage = PostUtils.isSystemMessage(post);
        const isMeMessage = checkIsMeMessage(post);
        const fromAutoResponder = PostUtils.fromAutoResponder(post);
        const colorize = this.props.compactDisplay && this.props.colorizeUsernames;

        let botIndicator: ReactNode;
        let profilePicture: ReactNode;
        let visibleMessage: ReactNode;

        let userProfile: ReactNode = null;
        if (this.props.compactDisplay || isMobileView) {
            userProfile = (
                <UserProfile
                    userId={post.user_id}
                    channelId={post.channel_id}
                    isBusy={this.props.isBusy}
                    isRHS={true}
                    hasMention={true}
                    colorize={colorize}
                />
            );
        }

        if (!isConsecutivePost) {
            userProfile = (
                <UserProfile
                    userId={post.user_id}
                    channelId={post.channel_id}
                    isBusy={this.props.isBusy}
                    isRHS={true}
                    hasMention={true}
                    colorize={colorize}
                />
            );

            profilePicture = (
                <PostProfilePicture
                    compactDisplay={this.props.compactDisplay}
                    isBusy={this.props.isBusy}
                    isRHS={true}
                    post={post}
                    userId={post.user_id}
                />
            );

            if (PostUtils.isFromWebhook(post)) {
                const overwriteName = post.props.override_username && this.props.enablePostUsernameOverride ? post.props.override_username : undefined;
                userProfile = (
                    <UserProfile
                        userId={post.user_id}
                        channelId={post.channel_id}
                        hideStatus={true}
                        overwriteName={overwriteName}
                        disablePopover={true}
                        colorize={colorize}
                    />
                );

                botIndicator = (<BotBadge className='col col__name'/>);
            } else if (fromAutoResponder) {
                userProfile = (
                    <span className='auto-responder'>
                        <UserProfile
                            userId={post.user_id}
                            channelId={post.channel_id}
                            hideStatus={true}
                            isBusy={this.props.isBusy}
                            isRHS={true}
                            hasMention={true}
                            colorize={colorize}
                        />
                    </span>
                );
                botIndicator = (
                    <Badge className='col col__name'>
                        <FormattedMessage
                            id='post_info.auto_responder'
                            defaultMessage='AUTOMATIC REPLY'
                        />
                    </Badge>
                );
            } else if (isSystemMessage && this.props.isBot) {
                userProfile = (
                    <UserProfile
                        userId={post.user_id}
                        channelId={post.channel_id}
                        hideStatus={true}
                        colorize={colorize}
                    />
                );

                visibleMessage = (
                    <span className='post__visibility'>
                        <FormattedMessage
                            id='post_info.message.visible'
                            defaultMessage='(Only visible to you)'
                        />
                    </span>
                );
            } else if (isSystemMessage) {
                userProfile = (
                    <UserProfile
                        overwriteName={
                            <FormattedMessage
                                id='post_info.system'
                                defaultMessage='System'
                            />
                        }
                        overwriteImage={Constants.SYSTEM_MESSAGE_PROFILE_IMAGE}
                        disablePopover={true}
                        channelId={post.channel_id}
                        colorize={colorize}
                    />
                );
                visibleMessage = (
                    <span className='post__visibility'>
                        <FormattedMessage
                            id='post_info.message.visible'
                            defaultMessage='(Only visible to you)'
                        />
                    </span>
                );
            }
        }

        const failedPostOptions = post.failed ? <FailedPostOptions post={this.props.post}/> : undefined;
        const postClass = classNames('post__body', {'post--edited': PostUtils.isEdited(this.props.post)});

        let fileAttachment: ReactNode = null;
        if (post.file_ids && post.file_ids.length > 0) {
            fileAttachment = (
                <FileAttachmentListContainer
                    post={post}
                    compactDisplay={this.props.compactDisplay}
                    handleFileDropdownOpened={this.handleFileDropdownOpened}
                />
            );
        }

        const showRecentlyUsedReactions = (!isReadOnly && !isEphemeral && !post.failed && !isSystemMessage && !channelIsArchived && this.props.oneClickReactionsEnabled && this.props.enableEmojiPicker);
        let showRecentReactions: ReactNode;
        if (showRecentlyUsedReactions) {
            showRecentReactions = (
                <PostRecentReactions
                    channelId={post.channel_id}
                    postId={post.id}
                    teamId={this.props.teamId}
                    emojis={this.props.recentEmojis}
                    getDotMenuRef={this.getDotMenuRef}
                    size={this.props.isExpanded ? 3 : 1}
                />
            );
        }

        let postReaction: ReactNode;
        if (!isReadOnly && !isEphemeral && !post.failed && !isSystemMessage && this.props.enableEmojiPicker && !channelIsArchived) {
            postReaction = (
                <PostReaction
                    channelId={post.channel_id}
                    postId={post.id}
                    teamId={this.props.teamId}
                    getDotMenuRef={this.getDotMenuRef}
                    location={Locations.RHS_COMMENT}
                    showEmojiPicker={this.state.showEmojiPicker}
                    toggleEmojiPicker={this.toggleEmojiPicker}
                />
            );
        }

        let flagIcon: ReactNode = null;
        if (!isMobileView && (!isEphemeral && !post.failed && !isSystemMessage)) {
            flagIcon = (
                <PostFlagIcon
                    location={Locations.RHS_COMMENT}
                    postId={post.id}
                    isFlagged={this.props.isFlagged}
                />
            );
        }

        let options: ReactNode;
        if (isEphemeral) {
            options = (
                <div className='col col__remove'>
                    {this.createRemovePostButton()}
                </div>
            );
        } else if (isPostDeleted) {
            options = null;
        } else if (!isSystemMessage &&
            (isMobileView ||
            this.state.hover ||
            this.state.a11yActive ||
            this.state.showDotMenu ||
            this.state.showActionsMenu ||
            this.state.showActionTip ||
            this.state.showEmojiPicker)) {
            const showActionsMenuIcon = this.props.shouldShowActionsMenu && (isMobile || this.state.hover);
            const actionsMenu = showActionsMenuIcon && (
                <ActionsMenu
                    post={post}
                    location={Locations.RHS_COMMENT}
                    handleDropdownOpened={this.handleActionsMenuOpened}
                    isMenuOpen={this.state.showActionsMenu}
                    showPulsatingDot={this.props.showActionsMenuPulsatingDot}
                    showTutorialTip={this.state.showActionTip}
                    handleOpenTip={this.handleActionsMenuTipOpened}
                    handleNextTip={this.handleActionsMenuGotItClick}
                    handleDismissTip={this.handleTipDismissed}
                />
            );
            const dotMenu = (
                <DotMenu
                    post={this.props.post}
                    location={Locations.RHS_COMMENT}
                    isFlagged={this.props.isFlagged}
                    handleDropdownOpened={this.handleDotMenuOpened}
                    handleAddReactionClick={this.toggleEmojiPicker}
                    isReadOnly={isReadOnly || channelIsArchived}
                    isMenuOpen={this.state.showDotMenu}
                    enableEmojiPicker={this.props.enableEmojiPicker}
                />
            );

            options = (
                <div
                    ref={this.dotMenuRef}
                    data-testid={`post-menu-${this.props.post.id}`}
                    className='col post-menu'
                >
                    {!collapsedThreadsEnabled && !showRecentlyUsedReactions && dotMenu}
                    {showRecentReactions}
                    {postReaction}
                    {flagIcon}
                    {actionsMenu}
                    {(collapsedThreadsEnabled || showRecentlyUsedReactions) && dotMenu}
                </div>
            );
        }

        const postTime = this.renderPostTime();

        let postInfoIcon: ReactNode;
        if (post.props && post.props.card) {
            postInfoIcon = (
                <OverlayTrigger
                    delayShow={Constants.OVERLAY_TIME_DELAY}
                    placement='top'
                    overlay={
                        <Tooltip>
                            <FormattedMessage
                                id='post_info.info.view_additional_info'
                                defaultMessage='View additional info'
                            />
                        </Tooltip>
                    }
                >
                    <button
                        className='card-icon__container icon--show style--none'
                        onClick={(e) => {
                            e.preventDefault();
                            this.props.handleCardClick?.(this.props.post);
                        }}
                    >
                        <InfoSmallIcon
                            className='icon icon__info'
                            aria-hidden='true'
                        />
                    </button>
                </OverlayTrigger>
            );
        }

        let customStatus: ReactNode;
        if (!isSystemMessage) {
            customStatus = (
                <CustomStatusEmoji
                    userID={post.user_id}
                    showTooltip={true}
                    emojiStyle={{
                        marginLeft: 4,
                        marginTop: 2,
                    }}
                />
            );
        }

        const message = (
            <MessageWithAdditionalContent
                post={post}
                isEmbedVisible={this.props.isEmbedVisible}
                pluginPostTypes={this.props.pluginPostTypes}
            />
        );

        const showSlot = isPostBeingEdited ? AutoHeightSlots.SLOT2 : AutoHeightSlots.SLOT1;

        return (
            <PostAriaLabelDiv
                ref={this.postRef}
                role='listitem'
                id={'rhsPost_' + post.id}
                tabIndex={-1}
                post={post}
                className={this.getClassName(post, isSystemMessage, isMeMessage)}
                onClick={this.handlePostClick}
                onMouseOver={this.setHover}
                onMouseLeave={this.unsetHover}
                data-a11y-sort-order={this.props.a11yIndex}
            >
                <PostPreHeader
                    isFlagged={this.props.isFlagged}
                    isPinned={post.is_pinned}
                    channelId={post.channel_id}
                />
                <div
                    role='application'
                    className='post__content'
                >
                    <div className='post__img'>
                        {profilePicture}
                    </div>
                    <div>
                        <div
                            className='post__header'
                            ref={this.postHeaderRef}
                        >
                            <div className='col col__name'>
                                {userProfile}
                                {botIndicator}
                                {customStatus}
                            </div>
                            <div className='col'>
                                {postTime}
                                {postInfoIcon}
                                {visibleMessage}
                            </div>
                            {!isPostBeingEdited && options}
                        </div>
                        <div className={postClass} >
                            {failedPostOptions}
                            <AutoHeightSwitcher
                                showSlot={showSlot}
                                shouldScrollIntoView={isPostBeingEdited}
                                slot1={message}
                                slot2={<EditPost/>}
                                onTransitionEnd={() => document.dispatchEvent(new Event(AppEvents.FOCUS_EDIT_TEXTBOX))}
                            />
                            {fileAttachment}
                            <ReactionList
                                post={post}
                            />
                        </div>
                    </div>
                </div>
            </PostAriaLabelDiv>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {showActionsDropdownPulsatingDot} from 'selectors/actions_menu';
import {setActionsMenuInitialisationState} from 'mattermost-redux/actions/preferences';
import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getPost} from 'mattermost-redux/selectors/entities/posts';

import {
    get,
    isCollapsedThreadsEnabled,
} from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {getUser} from 'mattermost-redux/selectors/entities/users';

import {GenericAction} from 'mattermost-redux/types/actions';
import {Emoji} from '@mattermost/types/emojis';
import {Post} from '@mattermost/types/posts';

import {markPostAsUnread, emitShortcutReactToLastPostFrom} from 'actions/post_actions';

import {getShortcutReactToLastPostEmittedFrom, getOneClickReactionEmojis} from 'selectors/emojis';
import {getIsPostBeingEditedInRHS, isEmbedVisible} from 'selectors/posts';
import {getHighlightedPostId} from 'selectors/rhs';
import {getIsMobileView} from 'selectors/views/browser';

import {GlobalState} from 'types/store';

import {isArchivedChannel} from 'utils/channel_utils';
import {areConsecutivePostsBySameUser, shouldShowActionsMenu} from 'utils/post_utils';
import {Preferences} from 'utils/constants';

import RhsComment from './rhs_comment';

interface OwnProps {
    post: Post;
    previousPostId: string;
    teamId: string;
}

function isConsecutivePost(state: GlobalState, ownProps: OwnProps) {
    const post = ownProps.post;
    const previousPost = ownProps.previousPostId && getPost(state, ownProps.previousPostId);

    let consecutivePost = false;

    if (previousPost) {
        consecutivePost = areConsecutivePostsBySameUser(post, previousPost);
    }
    return consecutivePost;
}

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const config = getConfig(state);
    const enableEmojiPicker = config.EnableEmojiPicker === 'true';
    const enablePostUsernameOverride = config.EnablePostUsernameOverride === 'true';
    const teamId = ownProps.teamId || getCurrentTeamId(state);
    const channel = state.entities.channels.channels[ownProps.post.channel_id];
    const shortcutReactToLastPostEmittedFrom = getShortcutReactToLastPostEmittedFrom(state);

    const user = getUser(state, ownProps.post.user_id);
    const isBot = Boolean(user && user.is_bot);
    const highlightedPostId = getHighlightedPostId(state);
    const showActionsMenuPulsatingDot = showActionsDropdownPulsatingDot(state);

    let emojis: Emoji[] = [];
    const oneClickReactionsEnabled = get(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.ONE_CLICK_REACTIONS_ENABLED, Preferences.ONE_CLICK_REACTIONS_ENABLED_DEFAULT) === 'true';
    if (oneClickReactionsEnabled) {
        emojis = getOneClickReactionEmojis(state);
    }

    return {
        enableEmojiPicker,
        enablePostUsernameOverride,
        isEmbedVisible: isEmbedVisible(state, ownProps.post.id),
        isReadOnly: false,
        teamId,
        pluginPostTypes: state.plugins.postTypes,
        channelIsArchived: isArchivedChannel(channel),
        isConsecutivePost: isConsecutivePost(state, ownProps),
        isFlagged: get(state, Preferences.CATEGORY_FLAGGED_POST, ownProps.post.id, null) != null,
        compactDisplay: get(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.MESSAGE_DISPLAY, Preferences.MESSAGE_DISPLAY_DEFAULT) === Preferences.MESSAGE_DISPLAY_COMPACT,
        colorizeUsernames: get(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.COLORIZE_USERNAMES, Preferences.COLORIZE_USERNAMES_DEFAULT) === 'true',
        shouldShowActionsMenu: shouldShowActionsMenu(state, ownProps.post),
        showActionsMenuPulsatingDot,
        shortcutReactToLastPostEmittedFrom,
        isBot,
        collapsedThreadsEnabled: isCollapsedThreadsEnabled(state),
        shouldHighlight: highlightedPostId === ownProps.post.id,
        oneClickReactionsEnabled,
        recentEmojis: emojis,
        isExpanded: state.views.rhs.isSidebarExpanded,

        isPostBeingEdited: getIsPostBeingEditedInRHS(state, ownProps.post.id),
        isMobileView: getIsMobileView(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            markPostAsUnread,
            emitShortcutReactToLastPostFrom,
            setActionsMenuInitialisationState,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(RhsComment);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo, useCallback} from 'react';

import {useDispatch} from 'react-redux';

import {removePost} from 'mattermost-redux/actions/posts';

import RhsComment from 'components/rhs_comment';
import {Props as TimestampProps} from 'components/timestamp/timestamp';

import {Post} from '@mattermost/types/posts';

type Props = {
    a11yIndex: number;
    currentUserId: string;
    isLastPost: boolean;
    onCardClick: (post: Post) => void;
    post: Post;
    previousPostId: string;
    teamId: string;
    timestampProps?: Partial<TimestampProps>;
}

function Reply({
    a11yIndex,
    currentUserId,
    isLastPost,
    onCardClick,
    post,
    previousPostId,
    teamId,
    timestampProps,
}: Props) {
    const dispatch = useDispatch();

    const handleRemovePost = useCallback((post: Post) => {
        dispatch(removePost(post));
    }, []);

    return (
        <RhsComment
            a11yIndex={a11yIndex}
            currentUserId={currentUserId}
            handleCardClick={onCardClick}
            isLastPost={isLastPost}
            post={post}
            previousPostId={previousPostId}
            removePost={handleRemovePost}
            teamId={teamId}
            timestampProps={timestampProps}
        />
    );
}

export default memo(Reply);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getPost} from 'mattermost-redux/selectors/entities/posts';
import {get, getBool} from 'mattermost-redux/selectors/entities/preferences';

import {Preferences} from 'utils/constants';

import {GlobalState} from 'types/store';

import Reply from './reply';

type OwnProps = {
    id: string;
}

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const previewCollapsed = get(
        state,
        Preferences.CATEGORY_DISPLAY_SETTINGS,
        Preferences.COLLAPSE_DISPLAY,
        Preferences.COLLAPSE_DISPLAY_DEFAULT,
    );
    const previewEnabled = getBool(
        state,
        Preferences.CATEGORY_DISPLAY_SETTINGS,
        Preferences.LINK_PREVIEW_DISPLAY,
        Preferences.LINK_PREVIEW_DISPLAY_DEFAULT === 'true',
    );

    return {
        post: getPost(state, ownProps.id),
        previewEnabled,
        previewCollapsed,
    };
}

export default connect(mapStateToProps)(Reply);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo} from 'react';

import * as PostListUtils from 'mattermost-redux/utils/post_list';
import {Post} from '@mattermost/types/posts';

import CombinedUserActivityPost from 'components/post_view/combined_user_activity_post';
import DateSeparator from 'components/post_view/date_separator';
import NewMessageSeparator from 'components/post_view/new_message_separator/new_message_separator';
import {Props as TimestampProps} from 'components/timestamp/timestamp';

import RootPost from './root_post';
import Reply from './reply';

type Props = {
    a11yIndex: number;
    currentUserId: string;
    isRootPost: boolean;
    isLastPost: boolean;
    listId: string;
    onCardClick: (post: Post) => void;
    onCardClickPost: (post: Post) => void;
    previousPostId: string;
    teamId: string;
    timestampProps?: Partial<TimestampProps>;
};

function noop() {}
function ThreadViewerRow({
    a11yIndex,
    currentUserId,
    isRootPost,
    isLastPost,
    listId,
    onCardClick,
    onCardClickPost,
    previousPostId,
    teamId,
    timestampProps,
}: Props) {
    switch (true) {
    case PostListUtils.isDateLine(listId): {
        const date = PostListUtils.getDateForDateLine(listId);
        return (
            <DateSeparator
                key={date}
                date={date}
            />
        );
    }

    case PostListUtils.isStartOfNewMessages(listId):
        return <NewMessageSeparator separatorId={listId}/>;

    case isRootPost:
        return (
            <RootPost
                currentUserId={currentUserId}
                id={listId}
                isLastPost={isLastPost}
                onCardClick={onCardClick}
                teamId={teamId}
                timestampProps={timestampProps}
            />
        );
    case PostListUtils.isCombinedUserActivityPost(listId): {
        return (
            <CombinedUserActivityPost
                combinedId={listId}
                previousPostId={previousPostId}
                isLastPost={isLastPost}
                shouldHighlight={false}
                togglePostMenu={noop}
            />
        );
    }
    default:
        return (
            <Reply
                a11yIndex={a11yIndex}
                currentUserId={currentUserId}
                id={listId}
                isLastPost={isLastPost}
                onCardClick={onCardClickPost}
                previousPostId={previousPostId}
                teamId={teamId}
                timestampProps={timestampProps}
            />
        );
    }
}

export default memo(ThreadViewerRow);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {PureComponent, RefObject} from 'react';
import AutoSizer from 'react-virtualized-auto-sizer';
import {DynamicSizeList, OnScrollArgs, OnItemsRenderedArgs} from 'dynamic-virtualized-list';

import {Channel} from '@mattermost/types/channels';
import {Post} from '@mattermost/types/posts';
import {UserProfile} from '@mattermost/types/users';

import {isDateLine, isStartOfNewMessages, isCreateComment} from 'mattermost-redux/utils/post_list';

import DelayedAction from 'utils/delayed_action';
import * as Utils from 'utils/utils';
import Constants from 'utils/constants';
import {FakePost} from 'types/store/rhs';
import {getNewMessageIndex, getPreviousPostId, getLatestPostId} from 'utils/post_utils';

import NewRepliesBanner from 'components/new_replies_banner';
import FloatingTimestamp from 'components/post_view/floating_timestamp';
import {THREADING_TIME as BASE_THREADING_TIME} from 'components/threading/common/options';

import CreateComment from './create_comment';
import Row from './thread_viewer_row';

type Props = {
    channel: Channel;
    currentUserId: string;
    directTeammate: UserProfile | undefined;
    highlightedPostId?: Post['id'];
    selectedPostFocusedAt?: number;
    lastPost: Post;
    onCardClick: (post: Post) => void;
    onCardClickPost: (post: Post) => void;
    replyListIds: string[];
    selected: Post | FakePost;
    teamId: string;
    useRelativeTimestamp: boolean;
    isThreadView: boolean;
}

type State = {
    createCommentHeight: number;
    isMobile: boolean;
    isScrolling: boolean;
    topRhsPostId?: string;
    userScrolled: boolean;
    userScrolledToBottom: boolean;
    lastViewedBottom: number;
    visibleStartIndex?: number;
    visibleStopIndex?: number;
    overscanStartIndex?: number;
    overscanStopIndex?: number;
}

const virtListStyles = {
    position: 'absolute',
    top: '0',
    height: '100%',
    willChange: 'auto',
};

const innerStyles = {
    paddingTop: '28px',
};

const CREATE_COMMENT_BUTTON_HEIGHT = 81;

const THREADING_TIME: typeof BASE_THREADING_TIME = {
    ...BASE_THREADING_TIME,
    units: [
        'now',
        'minute',
        'hour',
        'day',
        'week',
        'month',
        'year',
    ],
};

const OFFSET_TO_SHOW_TOAST = -50;
const OVERSCAN_COUNT_FORWARD = 80;
const OVERSCAN_COUNT_BACKWARD = 80;

class ThreadViewerVirtualized extends PureComponent<Props, State> {
    private mounted = false;
    private scrollStopAction: DelayedAction;
    private scrollShortCircuit = 0;
    postCreateContainerRef: RefObject<HTMLDivElement>;
    listRef: RefObject<DynamicSizeList>;
    innerRef: RefObject<HTMLDivElement>;
    initRangeToRender: number[];

    constructor(props: Props) {
        super(props);

        const postIndex = this.getInitialPostIndex();
        const isMobile = Utils.isMobile();

        this.initRangeToRender = [
            Math.max(postIndex - 30, 0),
            Math.max(postIndex + 30, Math.min(props.replyListIds.length - 1, 50)),
        ];

        this.listRef = React.createRef();
        this.innerRef = React.createRef();
        this.postCreateContainerRef = React.createRef();
        this.scrollStopAction = new DelayedAction(this.handleScrollStop);

        this.state = {
            createCommentHeight: 0,
            isMobile,
            isScrolling: false,
            userScrolled: false,
            userScrolledToBottom: false,
            topRhsPostId: undefined,
            lastViewedBottom: Date.now(),
            visibleStartIndex: undefined,
            visibleStopIndex: undefined,
            overscanStartIndex: undefined,
            overscanStopIndex: undefined,
        };
    }

    componentDidMount() {
        this.mounted = true;
        window.addEventListener('resize', this.handleWindowResize);
    }

    componentWillUnmount() {
        this.mounted = false;
        window.removeEventListener('resize', this.handleWindowResize);
    }

    componentDidUpdate(prevProps: Props) {
        const {highlightedPostId, selectedPostFocusedAt, lastPost, currentUserId} = this.props;

        if ((highlightedPostId && prevProps.highlightedPostId !== highlightedPostId) ||
            prevProps.selectedPostFocusedAt !== selectedPostFocusedAt) {
            this.scrollToHighlightedPost();
        } else if (
            prevProps.lastPost.id !== lastPost.id &&
            (lastPost.user_id === currentUserId || this.state.userScrolledToBottom)
        ) {
            this.scrollToBottom();
        }
    }

    canLoadMorePosts() {
        return Promise.resolve();
    }

    handleWindowResize = () => {
        const isMobile = Utils.isMobile();
        if (isMobile !== this.state.isMobile) {
            this.setState({
                isMobile,
            });
        }
    }

    initScrollToIndex = (): {index: number; position: string; offset?: number} => {
        const {highlightedPostId, replyListIds} = this.props;

        if (highlightedPostId) {
            const index = replyListIds.indexOf(highlightedPostId);
            return {
                index,
                position: 'center',
            };
        }

        const newMessagesSeparatorIndex = getNewMessageIndex(replyListIds);
        if (newMessagesSeparatorIndex > 0) {
            return {
                index: newMessagesSeparatorIndex,
                position: 'start',
                offset: OFFSET_TO_SHOW_TOAST,
            };
        }

        return {
            index: 0,
            position: 'end',
        };
    }

    handleScroll = ({scrollHeight, scrollUpdateWasRequested, scrollOffset, clientHeight}: OnScrollArgs) => {
        if (scrollHeight <= 0) {
            return;
        }
        const {createCommentHeight} = this.state;

        const updatedState: Partial<State> = {};

        const userScrolledToBottom = scrollHeight - scrollOffset - createCommentHeight <= clientHeight;

        if (!scrollUpdateWasRequested) {
            this.scrollShortCircuit = 0;

            updatedState.userScrolled = true;
            updatedState.userScrolledToBottom = userScrolledToBottom;

            if (this.state.isMobile) {
                if (!this.state.isScrolling) {
                    updatedState.isScrolling = true;
                }

                if (this.scrollStopAction) {
                    this.scrollStopAction.fireAfter(Constants.SCROLL_DELAY);
                }
            }
        }

        if (userScrolledToBottom) {
            updatedState.lastViewedBottom = Date.now();
        }

        this.setState(updatedState as State);
    }

    updateFloatingTimestamp = (visibleTopItem: number) => {
        if (!this.props.replyListIds) {
            return;
        }

        this.setState({
            topRhsPostId: getLatestPostId(this.props.replyListIds.slice(visibleTopItem)),
        });
    }

    onItemsRendered = ({
        visibleStartIndex,
        visibleStopIndex,
        overscanStartIndex,
        overscanStopIndex,
    }: OnItemsRenderedArgs) => {
        if (this.state.isMobile) {
            this.updateFloatingTimestamp(visibleStartIndex);
        }
        this.setState({
            visibleStartIndex,
            visibleStopIndex,
            overscanStartIndex,
            overscanStopIndex,
        });
    }

    getInitialPostIndex = (): number => {
        let postIndex = 0;

        if (this.props.highlightedPostId) {
            postIndex = this.props.replyListIds.findIndex((postId) => postId === this.props.highlightedPostId);
        } else {
            postIndex = getNewMessageIndex(this.props.replyListIds);
        }

        return postIndex === -1 ? 0 : postIndex;
    }

    handleScrollToFailed = (index: number) => {
        if (index < 0 || index >= this.props.replyListIds.length) {
            return;
        }
        const {overscanStopIndex, overscanStartIndex} = this.state;

        if (overscanStartIndex != null && index < overscanStartIndex) {
            this.scrollToItemCorrection(index, Math.max(overscanStartIndex + 1, 0));
        }

        if (overscanStopIndex != null && index > overscanStopIndex) {
            this.scrollToItemCorrection(index, Math.min(overscanStopIndex - 1, this.props.replyListIds.length - 1));
        }
    }

    scrollToItemCorrection = (index: number, nearIndex: number) => {
        // stop after 10 times so we won't end up in an infinite loop
        if (this.scrollShortCircuit > 10) {
            return;
        }

        this.scrollShortCircuit++;

        // this should not trigger a failure to scroll
        // it should always be an index in between rendered items (overscanStartIndex < nearIndex < overscanStopIndex)
        this.scrollToItem(nearIndex, 'start');

        window.requestAnimationFrame(() => {
            this.scrollToItem(index, 'start');
        });
    }

    scrollToItem = (index: number, position: string, offset?: number) => {
        if (this.listRef.current) {
            this.listRef.current.scrollToItem(index, position, offset);
        }
    }

    scrollToBottom = () => {
        this.scrollToItem(0, 'end');
    }

    handleToastDismiss = () => {
        this.setState({lastViewedBottom: Date.now()});
    }

    handleToastClick = () => {
        const index = getNewMessageIndex(this.props.replyListIds);
        if (index >= 0) {
            this.scrollToItem(index, 'start', OFFSET_TO_SHOW_TOAST);
        } else {
            this.scrollToBottom();
        }
    }

    scrollToHighlightedPost = () => {
        const {highlightedPostId, replyListIds} = this.props;

        if (highlightedPostId) {
            this.setState({userScrolledToBottom: false}, () => {
                this.scrollToItem(replyListIds.indexOf(highlightedPostId), 'center');
            });
        }
    }

    handleScrollStop = () => {
        if (this.mounted) {
            this.setState({isScrolling: false});
        }
    }

    handleCreateCommentHeightChange = (height: number, maxHeight: number) => {
        let createCommentHeight = height > maxHeight ? maxHeight : height;
        createCommentHeight += CREATE_COMMENT_BUTTON_HEIGHT;

        if (createCommentHeight !== this.state.createCommentHeight) {
            this.setState({createCommentHeight});
            if (this.state.userScrolledToBottom) {
                this.scrollToBottom();
            }
        }
    }

    renderRow = ({data, itemId, style}: {data: any; itemId: any; style: any}) => {
        const index = data.indexOf(itemId);
        let className = '';
        let a11yIndex = 0;
        const basePaddingClass = 'post-row__padding';
        const previousItemId = (index !== -1 && index < data.length - 1) ? data[index + 1] : '';
        const nextItemId = (index > 0 && index < data.length) ? data[index - 1] : '';

        if (isDateLine(nextItemId) || isStartOfNewMessages(nextItemId)) {
            className += basePaddingClass + ' bottom';
        }

        if (isDateLine(previousItemId) || isStartOfNewMessages(previousItemId)) {
            if (className.includes(basePaddingClass)) {
                className += ' top';
            } else {
                className += basePaddingClass + ' top';
            }
        }

        const isLastPost = itemId === this.props.lastPost.id;
        const isRootPost = itemId === this.props.selected.id;

        if (!isDateLine(itemId) && !isStartOfNewMessages(itemId) && !isCreateComment(itemId) && !isRootPost) {
            a11yIndex++;
        }

        if (isCreateComment(itemId)) {
            return (
                <CreateComment
                    focusOnMount={!this.props.isThreadView && (this.state.userScrolledToBottom || (!this.state.userScrolled && this.getInitialPostIndex() === 0))}
                    isThreadView={this.props.isThreadView}
                    latestPostId={this.props.lastPost.id}
                    onHeightChange={this.handleCreateCommentHeightChange}
                    ref={this.postCreateContainerRef}
                    teammate={this.props.directTeammate}
                    threadId={this.props.selected.id}
                />
            );
        }

        return (
            <div
                style={style}
                className={className}
            >
                <Row
                    a11yIndex={a11yIndex}
                    currentUserId={this.props.currentUserId}
                    isRootPost={isRootPost}
                    isLastPost={isLastPost}
                    listId={itemId}
                    onCardClick={this.props.onCardClick}
                    onCardClickPost={this.props.onCardClickPost}
                    previousPostId={getPreviousPostId(data, index)}
                    teamId={this.props.teamId}
                    timestampProps={this.props.useRelativeTimestamp ? THREADING_TIME : undefined}
                />
            </div>
        );
    };

    getInnerStyles = (): React.CSSProperties|undefined => {
        if (!this.props.useRelativeTimestamp) {
            return innerStyles;
        }

        return undefined;
    }

    isNewMessagesVisible = (): boolean => {
        const {visibleStopIndex} = this.state;
        const newMessagesSeparatorIndex = getNewMessageIndex(this.props.replyListIds);
        if (visibleStopIndex != null) {
            return visibleStopIndex < newMessagesSeparatorIndex;
        }
        return false;
    }

    renderToast = (width: number) => {
        const {visibleStopIndex, lastViewedBottom, userScrolledToBottom} = this.state;
        const canShow =
            visibleStopIndex !== 0 &&
            !this.isNewMessagesVisible() &&
            !userScrolledToBottom;

        return (
            <NewRepliesBanner
                threadId={this.props.selected.id}
                lastViewedBottom={lastViewedBottom}
                canShow={canShow}
                onDismiss={this.handleToastDismiss}
                width={width}
                onClick={this.handleToastClick}
            />
        );
    }

    render() {
        const {isMobile, topRhsPostId} = this.state;

        return (
            <>
                {isMobile && topRhsPostId && !this.props.useRelativeTimestamp && (
                    <FloatingTimestamp
                        isRhsPost={true}
                        isScrolling={this.state.isScrolling}
                        postId={topRhsPostId}
                    />
                )}
                <div
                    role='application'
                    aria-label={Utils.localizeMessage('accessibility.sections.rhsContent', 'message details complimentary region')}
                    className='post-right__content a11y__region'
                    style={{height: '100%'}}
                    data-a11y-sort-order='3'
                    data-a11y-focus-child={true}
                    data-a11y-order-reversed={true}
                >
                    <AutoSizer>
                        {({width, height}) => (
                            <>
                                <DynamicSizeList
                                    canLoadMorePosts={this.canLoadMorePosts}
                                    height={height}
                                    initRangeToRender={this.initRangeToRender}
                                    initScrollToIndex={this.initScrollToIndex}
                                    innerListStyle={this.getInnerStyles()}
                                    innerRef={this.innerRef}
                                    itemData={this.props.replyListIds}
                                    scrollToFailed={this.handleScrollToFailed}
                                    onItemsRendered={this.onItemsRendered}
                                    onScroll={this.handleScroll}
                                    overscanCountBackward={OVERSCAN_COUNT_BACKWARD}
                                    overscanCountForward={OVERSCAN_COUNT_FORWARD}
                                    ref={this.listRef}
                                    style={virtListStyles}
                                    width={width}
                                    className={'post-list__dynamic--RHS'}
                                >
                                    {this.renderRow}
                                </DynamicSizeList>
                                {this.renderToast(width)}
                            </>
                        )}
                    </AutoSizer>
                </div>
            </>
        );
    }
}

export default ThreadViewerVirtualized;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getPost} from 'mattermost-redux/selectors/entities/posts';
import {getDirectTeammate} from 'mattermost-redux/selectors/entities/channels';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/common';
import {isCollapsedThreadsEnabled} from 'mattermost-redux/selectors/entities/preferences';

import {Channel} from '@mattermost/types/channels';
import {Post} from '@mattermost/types/posts';

import {FakePost} from 'types/store/rhs';

import {makePrepareReplyIdsForThreadViewer, makeGetThreadLastViewedAt} from 'selectors/views/threads';

import {GlobalState} from 'types/store';

import ThreadViewerVirtualized from './virtualized_thread_viewer';

type OwnProps = {
    channel: Channel;
    postIds: Array<Post['id'] | FakePost['id']>;
    selected: Post | FakePost;
    useRelativeTimestamp: boolean;
}

function makeMapStateToProps() {
    const getRepliesListWithSeparators = makePrepareReplyIdsForThreadViewer();
    const getThreadLastViewedAt = makeGetThreadLastViewedAt();

    return (state: GlobalState, ownProps: OwnProps) => {
        const {postIds, useRelativeTimestamp, selected, channel} = ownProps;

        const collapsedThreads = isCollapsedThreadsEnabled(state);
        const currentUserId = getCurrentUserId(state);
        const lastViewedAt = getThreadLastViewedAt(state, selected.id);
        const directTeammate = getDirectTeammate(state, channel.id);

        const lastPost = getPost(state, postIds[0]);

        const replyListIds = getRepliesListWithSeparators(state, {
            postIds,
            showDate: !useRelativeTimestamp,
            lastViewedAt: collapsedThreads ? lastViewedAt : undefined,
        });

        return {
            currentUserId,
            directTeammate,
            lastPost,
            replyListIds,
            teamId: channel.team_id,
        };
    };
}

export default connect(makeMapStateToProps)(ThreadViewerVirtualized);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {HTMLAttributes} from 'react';
import classNames from 'classnames';

import {ActionFunc} from 'mattermost-redux/types/actions';
import {ExtendedPost} from 'mattermost-redux/actions/posts';

import deferComponentRender from 'components/deferComponentRender';
import FileUploadOverlay from 'components/file_upload_overlay';
import LoadingScreen from 'components/loading_screen';

import {FakePost} from 'types/store/rhs';

import {Channel} from '@mattermost/types/channels';
import {Post} from '@mattermost/types/posts';
import {UserThread} from '@mattermost/types/threads';

import ThreadViewerVirtualized from '../virtualized_thread_viewer';

import './thread_viewer.scss';

const DeferredThreadViewerVirt = deferComponentRender(ThreadViewerVirtualized);

type Attrs = Pick<HTMLAttributes<HTMLDivElement>, 'className' | 'id'>;

export type Props = Attrs & {
    isCollapsedThreadsEnabled: boolean;
    appsEnabled: boolean;
    userThread?: UserThread | null;
    channel: Channel | null;
    selected: Post | FakePost;
    previousRhsState?: string;
    currentUserId: string;
    currentTeamId: string;
    socketConnectionStatus: boolean;
    actions: {
        fetchRHSAppsBindings: (channelId: string, rootID: string) => unknown;
        getNewestPostThread: (rootId: string) => Promise<any>|ActionFunc;
        getPostThread: (rootId: string, fetchThreads: boolean) => Promise<any>|ActionFunc;
        getThread: (userId: string, teamId: string, threadId: string, extended: boolean) => Promise<any>|ActionFunc;
        removePost: (post: ExtendedPost) => void;
        selectPostCard: (post: Post) => void;
        updateThreadLastOpened: (threadId: string, lastViewedAt: number) => unknown;
        updateThreadRead: (userId: string, teamId: string, threadId: string, timestamp: number) => unknown;
    };
    useRelativeTimestamp?: boolean;
    postIds: string[];
    highlightedPostId?: Post['id'];
    selectedPostFocusedAt?: number;
    isThreadView?: boolean;
};

type State = {
    isLoading: boolean;
}

export default class ThreadViewer extends React.PureComponent<Props, State> {
    public constructor(props: Props) {
        super(props);

        this.state = {
            isLoading: false,
        };
    }

    public componentDidMount() {
        if (this.props.isCollapsedThreadsEnabled && this.props.userThread !== null) {
            this.markThreadRead();
        }

        this.onInit();

        if (this.props.appsEnabled) {
            this.props.actions.fetchRHSAppsBindings(this.props.channel?.id || '', this.props.selected.id);
        }
    }

    public componentDidUpdate(prevProps: Props) {
        const reconnected = this.props.socketConnectionStatus && !prevProps.socketConnectionStatus;

        if (!this.props.selected) {
            return;
        }

        const selectedChanged = this.props.selected.id !== prevProps.selected.id;

        if (reconnected || selectedChanged) {
            this.onInit(reconnected);
        }

        if (
            this.props.isCollapsedThreadsEnabled &&
            this.props.userThread?.id !== prevProps.userThread?.id
        ) {
            this.markThreadRead();
        }

        if (this.props.appsEnabled && (
            this.props.channel?.id !== prevProps.channel?.id || this.props.selected.id !== prevProps.selected.id
        )) {
            this.props.actions.fetchRHSAppsBindings(this.props.channel?.id || '', this.props.selected.id);
        }
    }

    public morePostsToFetch(): boolean {
        const replyCount = this.getReplyCount();
        return this.props.selected && this.props.postIds.length < (replyCount + 1);
    }

    public getReplyCount(): number {
        return (this.props.selected as Post)?.reply_count || this.props.userThread?.reply_count || 0;
    }

    fetchThread() {
        const {
            actions: {
                getThread,
            },
            currentUserId,
            currentTeamId,
            selected,
        } = this.props;

        if (selected && this.getReplyCount() && (this.props.selected as Post)?.is_following) {
            return getThread(
                currentUserId,
                currentTeamId,
                selected.id,
                true,
            );
        }

        return Promise.resolve({data: true});
    }

    markThreadRead() {
        if (this.props.userThread) {
            // update last viewed at for thread before marking as read.
            this.props.actions.updateThreadLastOpened(
                this.props.userThread.id,
                this.props.userThread.last_viewed_at,
            );

            if (
                this.props.userThread.last_viewed_at < this.props.userThread.last_reply_at ||
                this.props.userThread.unread_mentions ||
                this.props.userThread.unread_replies
            ) {
                this.props.actions.updateThreadRead(
                    this.props.currentUserId,
                    this.props.currentTeamId,
                    this.props.selected.id,
                    Date.now(),
                );
            }
        }
    }

    // called either after mount, socket reconnected, or selected thread changed
    // fetches the thread/posts if needed and
    // scrolls to either bottom or new messages line
    private onInit = async (reconnected = false): Promise<void> => {
        this.setState({isLoading: !reconnected});
        if (reconnected || this.morePostsToFetch()) {
            await this.props.actions.getPostThread(this.props.selected.id, !reconnected);
        } else {
            await this.props.actions.getNewestPostThread(this.props.selected.id);
        }

        if (
            this.props.isCollapsedThreadsEnabled &&
            this.props.userThread == null
        ) {
            await this.fetchThread();
        }

        this.setState({isLoading: false});
    }

    private handleCardClick = (post: Post) => {
        if (!post) {
            return;
        }

        this.props.actions.selectPostCard(post);
    }

    private handleCardClickPost = (post: Post) => {
        if (!post) {
            return;
        }

        this.props.actions.selectPostCard(post);
    }

    public render(): JSX.Element {
        if (this.props.postIds == null || this.props.selected == null || !this.props.channel) {
            return (
                <span/>
            );
        }

        if (this.state.isLoading && this.props.postIds.length < 2) {
            return (
                <LoadingScreen
                    style={{
                        display: 'grid',
                        placeContent: 'center',
                        flex: '1',
                    }}
                />
            );
        }

        return (
            <>
                <div className={classNames('ThreadViewer', this.props.className)}>
                    <div className='post-right-comments-container'>
                        <>
                            <FileUploadOverlay overlayType='right'/>
                            {this.props.selected && (
                                <DeferredThreadViewerVirt
                                    key={this.props.selected.id}
                                    channel={this.props.channel}
                                    onCardClick={this.handleCardClick}
                                    onCardClickPost={this.handleCardClickPost}
                                    postIds={this.props.postIds}
                                    selected={this.props.selected}
                                    useRelativeTimestamp={this.props.useRelativeTimestamp || false}
                                    highlightedPostId={this.props.highlightedPostId}
                                    selectedPostFocusedAt={this.props.selectedPostFocusedAt}
                                    isThreadView={Boolean(this.props.isCollapsedThreadsEnabled && this.props.isThreadView)}
                                />
                            )}
                        </>
                    </div>
                </div>
            </>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {makeGetChannel} from 'mattermost-redux/selectors/entities/channels';
import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {getPost, makeGetPostIdsForThread} from 'mattermost-redux/selectors/entities/posts';
import {getThread} from 'mattermost-redux/selectors/entities/threads';
import {isCollapsedThreadsEnabled} from 'mattermost-redux/selectors/entities/preferences';
import {appsEnabled} from 'mattermost-redux/selectors/entities/apps';

import {removePost, getNewestPostThread, getPostThread} from 'mattermost-redux/actions/posts';
import {getThread as fetchThread, updateThreadRead} from 'mattermost-redux/actions/threads';

import {GenericAction} from 'mattermost-redux/types/actions';
import {UserThread} from '@mattermost/types/threads';
import {Channel} from '@mattermost/types/channels';

import {getSocketStatus} from 'selectors/views/websocket';
import {selectPostCard} from 'actions/views/rhs';
import {getHighlightedPostId, getSelectedPostFocussedAt} from 'selectors/rhs';
import {updateThreadLastOpened} from 'actions/views/threads';
import {GlobalState} from 'types/store';

import {fetchRHSAppsBindings} from 'mattermost-redux/actions/apps';

import ThreadViewer from './thread_viewer';

type OwnProps = {
    rootPostId: string;
};

function makeMapStateToProps() {
    const getPostIdsForThread = makeGetPostIdsForThread();
    const getChannel = makeGetChannel();

    return function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
        const currentUserId = getCurrentUserId(state);
        const currentTeamId = getCurrentTeamId(state);
        const selected = getPost(state, ownProps.rootPostId);
        const socketStatus = getSocketStatus(state);
        const highlightedPostId = getHighlightedPostId(state);
        const selectedPostFocusedAt = getSelectedPostFocussedAt(state);

        let postIds: string[] = [];
        let userThread: UserThread | null = null;
        let channel: Channel | null = null;

        if (selected) {
            postIds = getPostIdsForThread(state, selected.id);
            userThread = getThread(state, selected.id);
            channel = getChannel(state, {id: selected.channel_id});
        }

        return {
            isCollapsedThreadsEnabled: isCollapsedThreadsEnabled(state),
            appsEnabled: appsEnabled(state),
            currentUserId,
            currentTeamId,
            userThread,
            selected,
            postIds,
            socketConnectionStatus: socketStatus.connected,
            channel,
            highlightedPostId,
            selectedPostFocusedAt,
        };
    };
}

function mapDispatchToProps(dispatch: Dispatch<GenericAction>) {
    return {
        actions: bindActionCreators({
            fetchRHSAppsBindings,
            getNewestPostThread,
            getPostThread,
            getThread: fetchThread,
            removePost,
            selectPostCard,
            updateThreadLastOpened,
            updateThreadRead,
        }, dispatch),
    };
}

export default connect(makeMapStateToProps, mapDispatchToProps)(ThreadViewer);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

type ResolvableFunction<TVal, TArg, TArg2> = (arg: TArg, arg2: TArg2) => TVal;

export type Resolvable<TVal, TArg = undefined, TArg2 = undefined> = ResolvableFunction<TVal, TArg, TArg2> | TVal;

export function resolve<TVal, TArg = undefined, TArg2 = undefined>(
    prop: Resolvable<TVal, TArg, TArg2>,
    arg: TArg,
    arg2: TArg2,
): TVal {
    return typeof prop === 'function' ? (prop as ResolvableFunction<TVal, TArg, TArg2>)(arg, arg2) : prop;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {FC, ReactNode, memo, TimeHTMLAttributes} from 'react';

export type Props = {
    value: Date;
    children?: ReactNode;
} & TimeHTMLAttributes<HTMLTimeElement>;

const SemanticTime: FC<Props> = ({
    value,
    children,
    'aria-label': label = value.toLocaleString(),
    ...props
}: Props) => {
    return (
        <time
            {...props}
            aria-label={label}
            dateTime={value.toISOString()}
        >
            {children}
        </time>
    );
};

export default memo(SemanticTime);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {RangeDescriptor} from './timestamp';

export const TODAY_YESTERDAY: RangeDescriptor = {
    within: ['day', -1],
    display: ['day'],
};

export const TODAY_TITLE_CASE: RangeDescriptor = {
    equals: ['day', 0],
    display: (
        <FormattedMessage
            id='date_separator.today'
            defaultMessage='Today'
        />
    ),
};

export const YESTERDAY_TITLE_CASE: RangeDescriptor = {
    equals: ['day', -1],
    display: (
        <FormattedMessage
            id='date_separator.yesterday'
            defaultMessage='Yesterday'
        />
    ),
};

export const TOMORROW_TITLE_CASE: RangeDescriptor = {
    equals: ['day', 1],
    display: (
        <FormattedMessage
            id='date_separator.tomorrow'
            defaultMessage='Tomorrow'
        />
    ),
};

export const STANDARD_UNITS: {[key: string]: RangeDescriptor} = {
    now: {within: ['second', -45], display: ['second', 0]},
    second: {within: ['second', -59], display: ['second']},
    minute: {within: ['minute', -59], display: ['minute']},
    hour: {within: ['hour', -23.75], display: ['hour']},
    'today-yesterday': TODAY_YESTERDAY,
    Today: TODAY_TITLE_CASE,
    Yesterday: YESTERDAY_TITLE_CASE,
    day: {within: ['day', -6], display: ['day']},
    week: {within: ['week', -3], display: ['week']},
    month: {within: ['month', -11], display: ['month']},
    quarter: {within: ['quarter', -3], display: ['quarter']},
    year: {within: ['year', -1000], display: ['year']},
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {PureComponent, ReactNode} from 'react';
import {
    injectIntl,
    IntlShape,
    FormatDateOptions,
    FormatRelativeTimeOptions,
    FormattedMessage,
} from 'react-intl';
import {isValidElementType} from 'react-is';
import moment, {Moment} from 'moment-timezone';
import {capitalize as caps, isArray} from 'lodash';

import {isSameYear, isWithin, isEqual, getDiff} from 'utils/datetime';
import {Resolvable, resolve} from 'utils/resolvable';
import {RequireOnlyOne} from 'utils/conditional_types';

import SemanticTime from './semantic_time';

import {STANDARD_UNITS} from './relative_ranges';

// Feature test the browser for support of hourCycle.
// Note that Intl.DateTimeFormatOptions typings are stale and do not have definitions of hourCycle, dateStyle, etc..
// See https://github.com/microsoft/TypeScript/issues/34399
export const supportsHourCycle = Boolean(((new Intl.DateTimeFormat('en-US', {hour: 'numeric'})).resolvedOptions() as DateTimeOptions).hourCycle);

export type DateTimeOptions = FormatDateOptions & {
    hourCycle?: string;
}

function is12HourTime(hourCycle: DateTimeOptions['hourCycle'], hour12?: DateTimeOptions['hour12']) {
    return hour12 ?? !(hourCycle === 'h23' || hourCycle === 'h24');
}

export type RelativeOptions = FormatRelativeTimeOptions & {
    unit: Intl.RelativeTimeFormatUnit;
    relNearest?: number;
    truncateEndpoints?: boolean;
    updateIntervalInSeconds?: number;
    capitalize?: boolean;
}

function isRelative(format: ResolvedFormats['relative']): format is RelativeOptions {
    return Boolean((format as RelativeOptions)?.unit);
}

export type SimpleRelativeOptions = {
    message: ReactNode;
    updateIntervalInSeconds?: number;
}

function isSimpleRelative(format: unknown): format is SimpleRelativeOptions {
    return (format as SimpleRelativeOptions)?.message != null;
}

const defaultRefreshIntervals = new Map<Intl.RelativeTimeFormatUnit, number /* seconds */>([
    ['hour', 60 * 5],
    ['minute', 15],
    ['second', 1],
]);

type UnitDescriptor = [Intl.RelativeTimeFormatUnit, number?, boolean?];

function isUnitDescriptor(unit: unknown): unit is UnitDescriptor {
    return isArray(unit) && typeof unit[0] === 'string';
}

type Breakpoint = RequireOnlyOne<{
    within: UnitDescriptor;
    equals: UnitDescriptor;
}>

type DisplayAs = {
    display: UnitDescriptor | ReactNode;
    updateIntervalInSeconds?: number;
    capitalize?: boolean;
}

export type RangeDescriptor = Breakpoint & DisplayAs;

function normalizeRangeDescriptor(unit: NonNullable<Props['units']>[number]): RangeDescriptor {
    if (typeof unit === 'string' || typeof unit === 'number') {
        return STANDARD_UNITS[unit];
    }
    if (isUnitDescriptor(unit)) {
        const [u, n] = unit;
        return {within: [u, n], display: [u]};
    }
    return unit;
}

export type ResolvedFormats = {
    relative: RelativeOptions | SimpleRelativeOptions | false;
    date: DateTimeOptions | false;
    time: DateTimeOptions | false;
}

type FormattedParts = {
    relative?: ReactNode;
    date?: ReactNode;
    time?: ReactNode;
}

type FormatOptions = DateTimeOptions & Partial<RelativeOptions>;

export type Props = FormatOptions & {
    value?: ConstructorParameters<typeof Date>[0];

    useRelative?: Resolvable<ResolvedFormats['relative'], {value: Date}, FormatOptions>;
    units?: Array<RangeDescriptor | UnitDescriptor | Intl.RelativeTimeFormatUnit | keyof typeof STANDARD_UNITS>;
    ranges?: Props['units'];
    useDate?: Resolvable<Exclude<ResolvedFormats['date'], 'timeZone'> | false, {value: Date}, FormatOptions>;
    useTime?: Resolvable<Exclude<ResolvedFormats['time'], 'timeZone' | 'hourCycle' | 'hour12'> | false, {value: Date}, FormatOptions>;

    children?: Resolvable<ReactNode, {value: Date; timeZone: DateTimeOptions['timeZone']; formatted: ReactNode} & FormattedParts, ResolvedFormats>;
    className?: string;
    label?: string;
    useSemanticOutput?: boolean;

    intl: IntlShape;
}

type State = {
    now: Date;
    prevValue: Props['value'];
}

/**
 * A feature-rich, react-intl oriented wrapper around Intl.DateTimeFormat and Intl.RelativeTimeFormat.
 *
 * If (for some odd reason) Intl.DateTimeFormat does not support the specified timezone, Moment will be used as a fallback formatter.
 * This fallback implementation only supports the following non-localized formats:
 *
 * TIME:
 * - `h:mm A`
 * - `HH:mm`
 *
 * DATE:
 * - `dddd`
 * - `MMMM DD`
 * - `MMMM DD, YYYY`
 * - `dddd, MMMM DD, YYYY`
 *
 * `DateTimeOptions.hourCycle` is preferred over `DateTimeOptions.hour12`.
 *
 * `hour12` will override the specified `hourCycle` and will defer to the default locale `hourCycle`.
 * This might result in `H24` behavior. (See https://github.com/formatjs/formatjs/issues/1577)
 *
 * @remarks Fallback-formatting should be rare, as `Intl.DateTimeFormat` (in Chrome, Safari, FF, and Edge) supports all timezones that are supported by `moment-timezone`.
 */
class Timestamp extends PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);
        this.state = {
            now: new Date(),
            prevValue: props.value,
        };
    }

    static defaultProps: Partial<Props> = {

        // relative
        numeric: 'auto',
        style: 'long',
        relNearest: 1,

        // fixed
        year: 'numeric',
        month: 'long',
        day: '2-digit',
        weekday: 'long',
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric',
        hourCycle: 'h12',
        timeZoneName: 'short',
    }
    nextUpdate: ReturnType<typeof setTimeout> | null = null;
    mounted = false;

    componentDidMount() {
        this.mounted = true;
    }

    formatParts(value: Date, {relative: relFormat, date: dateFormat, time: timeFormat}: ResolvedFormats): FormattedParts {
        try {
            let relative: FormattedParts['relative'];
            let date: FormattedParts['date'];
            let time: FormattedParts['time'];

            if (isSimpleRelative(relFormat)) {
                relative = relFormat.message;
            } else if (isRelative(relFormat)) {
                relative = this.formatRelative(value, relFormat);

                if (relFormat.unit !== 'day' || !timeFormat) {
                    return {relative};
                }
            }

            if (relative == null && dateFormat) {
                date = this.formatDateTime(value, dateFormat);
            }

            if (timeFormat) {
                const {
                    hourCycle,
                    hour12 = supportsHourCycle ? undefined : is12HourTime(hourCycle),
                } = this.props;

                time = this.formatDateTime(value, {hourCycle, hour12, ...timeFormat});
            }

            return {relative, date, time};
        } catch {
            // fallback to moment for unsupported timezones
            const {timeZone, hourCycle, hour12} = this.props;

            const momentValue = moment.utc(value.getTime());

            if (timeZone) {
                momentValue.tz(timeZone);
            }

            return {
                date: dateFormat && Timestamp.momentDate(momentValue, {...dateFormat}),
                time: timeFormat && Timestamp.momentTime(momentValue, {hourCycle, hour12, ...timeFormat}),
            };
        }
    }

    formatRelative(value: Date, {unit, relNearest, truncateEndpoints, ...format}: RelativeOptions): string {
        let diff: number;

        if (relNearest === 0) {
            diff = 0;
        } else {
            diff = getDiff(value, this.state.now, this.props.timeZone, unit, truncateEndpoints);
            if (relNearest != null) {
                diff = Math.round(diff / relNearest) * relNearest;
            }
        }

        if (diff === 0) {
            diff = value <= this.state.now ? -0 : +0;
        }

        const rel = this.props.intl.formatRelativeTime(diff, unit, format);
        return format.capitalize ? caps(rel) : rel;
    }

    formatDateTime(value: Date, format: DateTimeOptions): string {
        const {timeZone, intl: {locale}} = this.props;

        return (new Intl.DateTimeFormat(locale, {timeZone, ...format} as any)).format(value); // TODO remove any when React-Intl is next updated
    }

    static momentTime(value: Moment, {hour, minute, hourCycle, hour12}: DateTimeOptions): string | undefined {
        if (hour && minute) {
            return value.format(is12HourTime(hourCycle, hour12) ? 'h:mm A' : 'HH:mm');
        }
        return undefined;
    }

    static momentDate(value: Moment, {weekday, day, month, year}: DateTimeOptions): string | undefined {
        if (weekday && day && month && year) {
            return value.format('dddd, MMMM DD, YYYY');
        } else if (day && month && year) {
            return value.format('MMMM DD, YYYY');
        } else if (day && month) {
            return value.format('MMMM DD');
        } else if (weekday) {
            return value.format('dddd');
        }
        return undefined;
    }

    autoRange(value: Date, units: Props['units'] = (this.props.units || this.props.ranges)): DisplayAs {
        return units?.map(normalizeRangeDescriptor).find(({equals, within}) => {
            if (equals != null) {
                return isEqual(value, this.state.now, this.props.timeZone, ...equals);
            }
            if (within != null) {
                return isWithin(value, this.state.now, this.props.timeZone, ...within);
            }
            return false;
        }) ?? {
            display: [this.props.unit],
            updateIntervalInSeconds: this.props.updateIntervalInSeconds,
        };
    }

    private getFormats(value: Date): ResolvedFormats {
        const {
            numeric,
            style,
            useRelative = (): ResolvedFormats['relative'] => {
                const {
                    display,
                    updateIntervalInSeconds = this.props.updateIntervalInSeconds,
                    capitalize = this.props.capitalize,
                } = this.autoRange(value);

                if (display) {
                    if (isValidElementType(display) || !Array.isArray(display)) {
                        return {
                            message: display,
                            updateIntervalInSeconds,
                        };
                    }

                    const [
                        unit,
                        relNearest = this.props.relNearest,
                        truncateEndpoints = this.props.truncateEndpoints,
                    ] = display as UnitDescriptor;

                    if (unit) {
                        return {
                            unit,
                            relNearest,
                            truncateEndpoints,
                            numeric,
                            style,
                            updateIntervalInSeconds: updateIntervalInSeconds ?? defaultRefreshIntervals.get(unit),
                            capitalize,
                        };
                    }
                }

                return false;
            },
            year,
            month,
            day,
            weekday,
            hour,
            minute,
            timeZone,
            useDate = (): ResolvedFormats['date'] => {
                if (isWithin(value, this.state.now, timeZone, 'day', -6)) {
                    return {weekday};
                }
                if (isSameYear(value)) {
                    return {day, month};
                }

                return {year, month, day};
            },
            useTime = {hour, minute},
        } = this.props;

        const relative = resolve(useRelative, {value}, this.props);
        const date = !relative && resolve(useDate, {value}, this.props);
        const time = resolve(useTime, {value}, this.props);

        return {relative, date, time};
    }

    componentWillUnmount() {
        this.mounted = false;
        if (this.nextUpdate) {
            clearTimeout(this.nextUpdate);
            this.nextUpdate = null;
        }
    }

    static getDerivedStateFromProps(props: Props, state: State) {
        if (props.value !== state.prevValue) {
            return ({now: new Date(), prevValue: props.value});
        }

        return null;
    }

    private maybeUpdate(relative: ResolvedFormats['relative']): ReturnType<typeof setTimeout> | null {
        if (!relative ||
            !relative.updateIntervalInSeconds) {
            return null;
        }
        return setTimeout(() => {
            if (this.mounted) {
                this.setState({now: new Date()});
            }
        }, relative.updateIntervalInSeconds * 1000);
    }

    static format({relative, date, time}: FormattedParts): ReactNode {
        return (relative || date) && time ? (
            <FormattedMessage
                id='timestamp.datetime'
                defaultMessage='{relativeOrDate} at {time}'
                values={{
                    relativeOrDate: relative || date,
                    time,
                }}
            />
        ) : relative || date || time;
    }

    static formatLabel(value: Date, timeZone?: string) {
        const momentValue = moment(value);

        if (timeZone) {
            momentValue.tz(timeZone);
        }

        return momentValue.toString() + (timeZone ? ` (${momentValue.tz()})` : '');
    }

    render() {
        const {
            value: unparsed = this.state.now,
            children,
            useSemanticOutput = true,
            timeZone,
            label,
            className,
        } = this.props;

        const value = unparsed instanceof Date ? unparsed : new Date(unparsed);
        const formats = this.getFormats(value);
        const parts = this.formatParts(value, formats);
        let formatted = Timestamp.format(parts);

        if (useSemanticOutput) {
            formatted = (
                <SemanticTime
                    value={value}
                    aria-label={label ?? Timestamp.formatLabel(value, timeZone)}
                    className={className}
                >
                    {formatted}
                </SemanticTime>
            );
        }

        this.nextUpdate = this.maybeUpdate(formats.relative);

        if (children) {
            return resolve(children, {value, timeZone, formatted, ...parts}, formats);
        }

        return formatted;
    }
}

export default injectIntl(Timestamp);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {makeGetUserTimezone} from 'mattermost-redux/selectors/entities/timezone';
import {getUserCurrentTimezone} from 'mattermost-redux/utils/timezone_utils';
import {getBool} from 'mattermost-redux/selectors/entities/preferences';
import {UserTimezone} from '@mattermost/types/users';

import {areTimezonesEnabledAndSupported} from 'selectors/general';

import {GlobalState} from 'types/store';

import {Preferences} from 'utils/constants';

import Timestamp, {Props as TimestampProps, supportsHourCycle} from './timestamp';

type Props = {
    userTimezone?: UserTimezone;
    hour12?: TimestampProps['hour12'];
    timeZone?: TimestampProps['timeZone'];
    hourCycle?: TimestampProps['hourCycle'];
}

export function makeMapStateToProps() {
    const getUserTimezone = makeGetUserTimezone();

    return (state: GlobalState, ownProps: Props) => {
        const currentUserId = getCurrentUserId(state);

        let timeZone: TimestampProps['timeZone'];
        let hourCycle: TimestampProps['hourCycle'];
        let hour12: TimestampProps['hour12'];

        if (areTimezonesEnabledAndSupported(state)) {
            timeZone = getUserCurrentTimezone(ownProps.userTimezone ?? getUserTimezone(state, currentUserId)) ?? undefined;
        }

        const useMilitaryTime = getBool(state, Preferences.CATEGORY_DISPLAY_SETTINGS, Preferences.USE_MILITARY_TIME, false);

        if (supportsHourCycle) {
            hourCycle = ownProps.hourCycle || (useMilitaryTime ? 'h23' : 'h12');
        } else {
            hour12 = ownProps.hour12 ?? (!useMilitaryTime);
        }

        return {timeZone: ownProps.timeZone || timeZone, hourCycle, hour12};
    };
}

export default connect(makeMapStateToProps)(Timestamp);

export {default as SemanticTime} from './semantic_time';
import * as RelativeRanges from './relative_ranges';
export {RelativeRanges};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function UnreadAboveIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span
            {...props}
        >
            {/* TODO: should replace transform css to svg */}
            <svg
                style={{transform: 'scaleY(-1)'}}
                xmlns='http://www.w3.org/2000/svg'
                width='16'
                height='16'
                viewBox='0 0 16 16'
                role='img'
                aria-label={formatMessage({id: 'generic_icons.arrow.up', defaultMessage: 'Up Arrow Icon'})}
            >
                <path d='M8.696 2H7.184V11L3.062 6.878L2 7.94L7.94 13.88L13.88 7.94L12.818 6.878L8.696 11V2Z'/>
            </svg>
        </span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode, MouseEventHandler} from 'react';

import {FormattedMessage} from 'react-intl';
import {OverlayTriggerProps} from 'react-bootstrap';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';
import UnreadBelowIcon from 'components/widgets/icons/unread_below_icon';
import UnreadAboveIcon from 'components/widgets/icons/unread_above_icon';
import CloseIcon from 'components/widgets/icons/close_icon';
import Constants from 'utils/constants';

import './toast.scss';

export type Props = {
    onClick?: MouseEventHandler<HTMLDivElement>;
    onClickMessage?: string;
    onDismiss?: () => void;
    children?: ReactNode;
    show: boolean;
    showActions?: boolean; //used for showing jump actions
    width: number;
    extraClasses?: string;
    overlayPlacement?: OverlayTriggerProps['placement'];
    jumpDirection?: 'up' | 'down';
}

export default class Toast extends React.PureComponent<Props> {
    private mounted!: boolean;

    static defaultProps = {
        overlayPlacement: 'bottom',
        jumpDirection: 'down',
    }

    componentDidMount() {
        this.mounted = true;
    }

    componentWillUnmount() {
        this.mounted = false;
    }

    handleDismiss = () => {
        if (typeof this.props.onDismiss == 'function') {
            this.props.onDismiss();
        }
    }

    render() {
        let toastClass = 'toast';
        const {show, extraClasses, showActions, width, overlayPlacement, jumpDirection} = this.props;

        if (extraClasses) {
            toastClass += ` ${extraClasses}`;
        }

        if (show) {
            toastClass += ' toast__visible';
        }

        let toastActionClass = 'toast__message';
        if (showActions) {
            toastActionClass += ' toast__pointer';
        }

        const jumpSection = () => {
            return (
                <div
                    className='toast__jump'
                >
                    {jumpDirection === 'down' ? <UnreadBelowIcon/> : <UnreadAboveIcon/>}
                    {width > Constants.MOBILE_SCREEN_WIDTH && this.props.onClickMessage}
                </div>
            );
        };

        let closeTooltip = (<div/>);
        if (showActions && show) {
            closeTooltip = (
                <Tooltip id='toast-close__tooltip'>
                    <FormattedMessage
                        id='general_button.close'
                        defaultMessage='Close'
                    />
                    <div className='tooltip__shortcut--txt'>
                        <FormattedMessage
                            id='general_button.esc'
                            defaultMessage='esc'
                        />
                    </div>
                </Tooltip>
            );
        }

        return (
            <div className={toastClass}>
                <div
                    className={toastActionClass}
                    onClick={showActions ? this.props.onClick : undefined}
                >
                    {showActions && jumpSection()}
                    {this.props.children}
                </div>
                <OverlayTrigger
                    delayShow={Constants.OVERLAY_TIME_DELAY}
                    placement={overlayPlacement}
                    overlay={closeTooltip}
                >
                    <div
                        className='toast__dismiss'
                        onClick={this.handleDismiss}
                        data-testid={extraClasses ? `dismissToast-${extraClasses}` : 'dismissToast'}
                    >
                        <CloseIcon
                            className='close-btn'
                            id='dismissToast'
                        />
                    </div>
                </OverlayTrigger>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ComponentType, MouseEvent, ReactNode} from 'react';
import {useIntl} from 'react-intl';

import {ModalData} from 'types/actions';

type Props = {
    ariaLabel?: string;
    children: ReactNode;
    modalId: string;
    dialogType: ComponentType<any>;
    dialogProps?: Record<string, any>;
    onClick?: () => void;
    className?: string;
    showUnread?: boolean;
    disabled?: boolean;
    id?: string;
    role?: string;
    actions: {
        openModal: <P>(modalData: ModalData<P>) => void;
    };
};

const ToggleModalButton = ({ariaLabel, children, modalId, dialogType, dialogProps = {}, onClick, className = '', showUnread, disabled, id, actions, role}: Props) => {
    const intl = useIntl();

    const show = (e: MouseEvent<HTMLButtonElement>) => {
        if (e) {
            e.preventDefault();
        }

        const modalData = {
            modalId,
            dialogProps,
            dialogType,
        };

        actions.openModal(modalData);
    };

    const ariaLabelElement = ariaLabel ? intl.formatMessage({
        id: 'accessibility.button.dialog',
        defaultMessage: '{dialogName} dialog',
    }, {
        dialogName: ariaLabel,
    }) : undefined;

    const badge = showUnread ? <span className={'unread-badge'}/> : null;

    // allow callers to provide an onClick which will be called before the modal is shown
    const clickHandler = (e: MouseEvent<HTMLButtonElement>) => {
        onClick?.();
        show(e);
    };

    return (
        <button
            className={'style--none ' + className}
            aria-label={ariaLabelElement}
            onClick={clickHandler}
            id={id}
            disabled={disabled}
            role={role}
        >
            {children}
            {badge}
        </button>
    );
};

export default ToggleModalButton;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch} from 'redux';

import {openModal} from 'actions/views/modals';

import ToggleModalButton from './toggle_modal_button';

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators({
            openModal,
        }, dispatch),
    };
}

export default connect(null, mapDispatchToProps)(ToggleModalButton);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {CSSProperties} from 'react';
import {Tooltip as RBTooltip} from 'react-bootstrap';

type Props = {
    id?: string;
    className?: string;
    style?: CSSProperties;
    children?: React.ReactNode;
    positionLeft?: number;
    placement?: string;
};

export default function Tooltip(props: Props) {
    return (
        <RBTooltip
            id={props.id}
            className={props.className}
            positionLeft={props.positionLeft}
            style={props.style}
            placement={props.placement}
        >
            {props.children}
        </RBTooltip>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

export const FINISHED = 999;
export const SKIPPED = 999;

export const ChannelsTourTelemetryPrefix = 'channels-tour';
const AutoStatusSuffix = '_auto_tour_status';

export const AutoTourStatus = {
    ENABLED: 1,
    DISABLED: 0,
};

// this should be used as for the tours related to channels
export const ChannelsTour = 'channels_tour';

export const OtherToolsTour = 'other_tools_tour';

export const TutorialTourName = {
    ONBOARDING_TUTORIAL_STEP: 'tutorial_step',
    ONBOARDING_TUTORIAL_STEP_FOR_GUESTS: 'tutorial_step_for_guest',
    CRT_TUTORIAL_STEP: 'crt_tutorial_step',
    CRT_THREAD_PANE_STEP: 'crt_thread_pane_step',
    AUTO_TOUR_STATUS: 'auto_tour_status',
    EXPLORE_OTHER_TOOLS: 'explore_tools',
};

export const OnboardingTourSteps = {
    CHANNELS_AND_DIRECT_MESSAGES: 0,
    CREATE_AND_JOIN_CHANNELS: 1,
    INVITE_PEOPLE: 2,
    SEND_MESSAGE: 3,
    CUSTOMIZE_EXPERIENCE: 4,
    FINISHED,
};

export const OnboardingTourStepsForGuestUsers = {
    SEND_MESSAGE: 0,
    CUSTOMIZE_EXPERIENCE: 1,
    FINISHED,
};

export const ExploreOtherToolsTourSteps = {
    BOARDS_TOUR: 0,
    PLAYBOOKS_TOUR: 1,
    FINISHED,
};

export const CrtTutorialSteps = {
    WELCOME_POPOVER: 0,
    LIST_POPOVER: 1,
    UNREAD_POPOVER: 2,
    FINISHED,
};

export const CrtTutorialTriggerSteps = {
    START: 0,
    STARTED: 1,
    FINISHED,
};

export const TTNameMapToATStatusKey = {
    [TutorialTourName.ONBOARDING_TUTORIAL_STEP]: TutorialTourName.ONBOARDING_TUTORIAL_STEP + AutoStatusSuffix,
    [TutorialTourName.CRT_TUTORIAL_STEP]: 'crt_tutorial_auto_tour_status',
    [TutorialTourName.CRT_THREAD_PANE_STEP]: TutorialTourName.CRT_THREAD_PANE_STEP + AutoStatusSuffix,
    [TutorialTourName.EXPLORE_OTHER_TOOLS]: TutorialTourName.EXPLORE_OTHER_TOOLS + AutoStatusSuffix,
};

export const TTNameMapToTourSteps = {
    [TutorialTourName.ONBOARDING_TUTORIAL_STEP]: OnboardingTourSteps,
    [TutorialTourName.ONBOARDING_TUTORIAL_STEP_FOR_GUESTS]: OnboardingTourStepsForGuestUsers,
    [TutorialTourName.CRT_TUTORIAL_STEP]: CrtTutorialSteps,
    [TutorialTourName.EXPLORE_OTHER_TOOLS]: ExploreOtherToolsTourSteps,
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {FINISHED} from './constant';

export type ActionType = 'next' | 'prev' | 'dismiss' | 'jump' | 'skipped'

export interface ChannelsTourTipManager {
    show: boolean;
    currentStep: number;
    tourSteps: Record<string, number>;
    handleOpen: (e: React.MouseEvent) => void;
    handleSkip: (e: React.MouseEvent) => void;
    handleDismiss: (e: React.MouseEvent) => void;
    handlePrevious: (e: React.MouseEvent) => void;
    handleNext: (e: React.MouseEvent) => void;
    handleJump: (e: React.MouseEvent, jumpStep: number) => void;
}

export const KeyCodes: Record<string, [string, number]> = {
    ENTER: ['Enter', 13],
    COMPOSING: ['Composing', 229],
};

// This is extracted from utils file to remove dependency on utils file of webapp
export function isKeyPressed(event: KeyboardEvent, key: [string, number]): boolean {
    // There are two types of keyboards
    // 1. English with different layouts(Ex: Dvorak)
    // 2. Different language keyboards(Ex: Russian)

    if (event.keyCode === KeyCodes.COMPOSING[1]) {
        return false;
    }

    // checks for event.key for older browsers and also for the case of different English layout keyboards.
    if (typeof event.key !== 'undefined' && event.key !== 'Unidentified' && event.key !== 'Dead') {
        const isPressedByCode = event.key === key[0] || event.key === key[0].toUpperCase();
        if (isPressedByCode) {
            return true;
        }
    }

    // used for different language keyboards to detect the position of keys
    return event.keyCode === key[1];
}

export const getLastStep = (Steps: Record<string, number>) => {
    return Object.values(Steps).reduce((maxStep, candidateMaxStep) => {
        // ignore the "opt out" FINISHED step as the max step.
        if (candidateMaxStep > maxStep && candidateMaxStep !== FINISHED) {
            return candidateMaxStep;
        }
        return maxStep;
    }, Number.MIN_SAFE_INTEGER);
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useEffect, useState} from 'react';

import {useDispatch, useSelector} from 'react-redux';

import {getInt} from 'mattermost-redux/selectors/entities/preferences';

import {savePreferences as storeSavePreferences} from 'mattermost-redux/actions/preferences';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/common';
import {trackEvent as trackEventAction} from 'actions/telemetry_actions';
import {
    generateTelemetryTag,
} from 'components/onboarding_tasks';

import {
    ActionType,
    ChannelsTourTipManager,
    getLastStep,
    isKeyPressed,
    KeyCodes,
    useGetTourSteps,
    useHandleNavigationAndExtraActions,
} from 'components/tours';

import {GlobalState} from '@mattermost/types/store';

import {
    AutoTourStatus,
    ChannelsTour,
    FINISHED,
    SKIPPED,
    TTNameMapToATStatusKey,
} from './constant';

export const useTourTipManager = (tourCategory: string): ChannelsTourTipManager => {
    const [show, setShow] = useState(false);
    const tourSteps = useGetTourSteps(tourCategory);

    // Function to save the tutorial step in redux store start here which needs to be modified
    const dispatch = useDispatch();
    const currentUserId = useSelector(getCurrentUserId);
    const currentStep = useSelector((state: GlobalState) => getInt(state, tourCategory, currentUserId, 0));
    const autoTourStatus = useSelector((state: GlobalState) => getInt(state, tourCategory, TTNameMapToATStatusKey[tourCategory], 0));
    const isAutoTourEnabled = autoTourStatus === AutoTourStatus.ENABLED;
    const handleActions = useHandleNavigationAndExtraActions(tourCategory);

    const handleSaveDataAndTrackEvent = useCallback(
        (stepValue: number, eventSource: ActionType, autoTour = true, trackEvent = true) => {
            const preferences = [
                {
                    user_id: currentUserId,
                    category: tourCategory,
                    name: currentUserId,
                    value: stepValue.toString(),
                },
                {
                    user_id: currentUserId,
                    category: tourCategory,
                    name: TTNameMapToATStatusKey[tourCategory],
                    value: (autoTour && !(eventSource === 'skipped' || eventSource === 'dismiss') ? AutoTourStatus.ENABLED : AutoTourStatus.DISABLED).toString(),
                },
            ];
            dispatch(storeSavePreferences(currentUserId, preferences));
            if (trackEvent) {
                const eventSuffix = `${stepValue}--${eventSource}`;
                const telemetryTag = generateTelemetryTag(ChannelsTour, tourCategory, eventSuffix);
                trackEventAction(tourCategory, telemetryTag);
            }
        },
        [currentUserId],
    );

    // Function to save the tutorial step in redux store end here

    const handleEventPropagationAndDefault = (e: React.MouseEvent | KeyboardEvent) => {
        e.stopPropagation();
        e.preventDefault();
    };

    useEffect(() => {
        if (isAutoTourEnabled) {
            setShow(true);
        }
    }, [isAutoTourEnabled]);

    const handleHide = useCallback((): void => {
        setShow(false);
    }, []);

    const handleOpen = useCallback((e: React.MouseEvent): void => {
        handleEventPropagationAndDefault(e);
        setShow(true);
    }, [isAutoTourEnabled]);

    const handleSavePreferences = useCallback((nextStep: boolean | number): void => {
        let stepValue = currentStep;
        let type: ActionType;
        if (nextStep === true) {
            stepValue += 1;
            type = 'next';
        } else if (nextStep === false) {
            stepValue -= 1;
            type = 'prev';
        } else {
            stepValue = nextStep;
            type = 'jump';
        }
        handleHide();
        handleSaveDataAndTrackEvent(stepValue, type);
        handleActions(stepValue, currentStep);
    }, [currentStep, handleHide, handleSaveDataAndTrackEvent, handleActions]);

    const handleDismiss = useCallback((e: React.MouseEvent): void => {
        handleEventPropagationAndDefault(e);
        handleHide();
        handleSaveDataAndTrackEvent(currentStep, 'dismiss', false);
    }, [handleSaveDataAndTrackEvent, handleHide]);

    const handlePrevious = useCallback((e: React.MouseEvent): void => {
        handleEventPropagationAndDefault(e);
        handleSavePreferences(false);
    }, [handleSavePreferences]);

    const handleNext = useCallback((e?: React.MouseEvent): void => {
        if (e) {
            handleEventPropagationAndDefault(e);
        }
        if (getLastStep(tourSteps) === currentStep) {
            handleSavePreferences(FINISHED);
        } else {
            handleSavePreferences(true);
        }
    }, [handleSavePreferences]);

    const handleJump = useCallback((e: React.MouseEvent, jumpStep: number): void => {
        if (e) {
            handleEventPropagationAndDefault(e);
        }
        handleSavePreferences(jumpStep);
    }, [handleSavePreferences]);

    const handleSkip = useCallback((e: React.MouseEvent): void => {
        handleEventPropagationAndDefault(e);
        handleHide();
        handleSaveDataAndTrackEvent(SKIPPED, 'skipped', false);
        handleActions(SKIPPED, currentStep);
    }, [handleSaveDataAndTrackEvent, handleHide]);

    useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent): void => {
            if (isKeyPressed(e, KeyCodes.ENTER) && show) {
                handleNext();
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () =>
            window.removeEventListener('keydown', handleKeyDown);
    }, [handleNext, show]);

    return {
        show,
        currentStep,
        tourSteps,
        handleOpen,
        handleDismiss,
        handleNext,
        handleJump,
        handlePrevious,
        handleSkip,
    };
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {Placement} from 'tippy.js';

import {TourTip, PunchOutCoordsHeightAndWidth} from '@mattermost/components';

import {getLastStep} from './utils';
import {useTourTipManager} from './tour_manager';

export type ChannelsTourTipProps = {
    screen: JSX.Element;
    title: JSX.Element;
    imageURL?: string;
    overlayPunchOut: PunchOutCoordsHeightAndWidth | null;
    singleTip?: boolean;
    placement?: Placement;
    pulsatingDotPlacement?: Omit<Placement, 'auto'| 'auto-end'>;
    pulsatingDotTranslate?: {x: number; y: number};
    offset?: [number, number];
    width?: string | number;
    tourCategory: string;
}

export const ChannelsTourTip = ({
    title,
    screen,
    imageURL,
    overlayPunchOut,
    singleTip,
    pulsatingDotTranslate,
    pulsatingDotPlacement,
    offset = [-18, 4],
    placement = 'right-start',
    width = 320,
    tourCategory,
}: ChannelsTourTipProps) => {
    const {
        show,
        currentStep,
        tourSteps,
        handleOpen,
        handleDismiss,
        handleNext,
        handlePrevious,
        handleSkip,
        handleJump,
    } = useTourTipManager(tourCategory);

    const prevBtn = (
        <>
            <i className='icon icon-chevron-left'/>
            <FormattedMessage
                id='generic.previous'
                defaultMessage='Previous'
            />
        </>
    );

    const nextBtn = (): JSX.Element => {
        let buttonText = (
            <>
                <FormattedMessage
                    id={'tutorial_tip.ok'}
                    defaultMessage={'Next'}
                />
                <i className='icon icon-chevron-right'/>
            </>
        );
        if (singleTip) {
            buttonText = (
                <FormattedMessage
                    id={'tutorial_tip.got_it'}
                    defaultMessage={'Got it'}
                />
            );
            return buttonText;
        }

        const lastStep = getLastStep(tourSteps);
        if (currentStep === lastStep) {
            buttonText = (
                <FormattedMessage
                    id={'tutorial_tip.done'}
                    defaultMessage={'Done'}
                />
            );
        }
        return buttonText;
    };

    return (
        <TourTip
            show={show}
            tourSteps={tourSteps}
            title={title}
            screen={screen}
            singleTip={singleTip}
            imageURL={imageURL}
            overlayPunchOut={overlayPunchOut}
            nextBtn={nextBtn()}
            prevBtn={singleTip ? undefined : prevBtn}
            step={currentStep}
            placement={placement}
            pulsatingDotPlacement={pulsatingDotPlacement}
            pulsatingDotTranslate={pulsatingDotTranslate}
            width={width}
            offset={offset}
            handleOpen={handleOpen}
            handleDismiss={handleDismiss}
            handleNext={handleNext}
            handlePrevious={handlePrevious}
            handleSkip={handleSkip}
            handleJump={handleJump}
        />
    );
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useCallback} from 'react';

import {useDispatch, useSelector} from 'react-redux';

import {getCurrentUserId, isCurrentUserGuestUser} from 'mattermost-redux/selectors/entities/users';
import {getCurrentRelativeTeamUrl} from 'mattermost-redux/selectors/entities/teams';

import {savePreferences} from 'mattermost-redux/actions/preferences';
import {close as closeLhs, open as openLhs} from 'actions/views/lhs';
import {setAddChannelDropdown} from 'actions/views/add_channel_dropdown';
import {switchToChannels} from 'actions/views/onboarding_tasks';
import {getHistory} from 'utils/browser_history';
import {GlobalState} from 'types/store';

import {OnboardingTaskCategory, OnboardingTaskList, OnboardingTasksName} from '../onboarding_tasks';

import {setProductMenuSwitcherOpen} from '../../actions/views/product_menu';

import {
    CrtTutorialSteps,
    ExploreOtherToolsTourSteps,
    FINISHED,
    OnboardingTourSteps,
    TTNameMapToTourSteps,
    TutorialTourName,
} from './constant';

export const useGetTourSteps = (tourCategory: string) => {
    const isGuestUser = useSelector((state: GlobalState) => isCurrentUserGuestUser(state));
    const pluginsList = useSelector((state: GlobalState) => state.plugins.plugins);

    let tourSteps: Record<string, number> = TTNameMapToTourSteps[tourCategory];

    if (tourCategory === TutorialTourName.EXPLORE_OTHER_TOOLS) {
        const boards = pluginsList.focalboard;
        const playbooks = pluginsList.playbooks;
        const steps: Record<string, number> = tourSteps as typeof ExploreOtherToolsTourSteps;
        if (!playbooks) {
            delete steps.PLAYBOOKS_TOUR;
        }

        if (!boards) {
            delete steps.BOARDS_TOUR;
        }
        tourSteps = steps;
    } else if (tourCategory === TutorialTourName.ONBOARDING_TUTORIAL_STEP && isGuestUser) {
        // restrict the 'learn more about messaging' tour when user is guest (townSquare, channel creation and user invite are restricted to guests)
        tourSteps = TTNameMapToTourSteps[TutorialTourName.ONBOARDING_TUTORIAL_STEP_FOR_GUESTS];
    }
    return tourSteps;
};
export const useHandleNavigationAndExtraActions = (tourCategory: string) => {
    const dispatch = useDispatch();
    const currentUserId = useSelector(getCurrentUserId);
    const teamUrl = useSelector((state: GlobalState) => getCurrentRelativeTeamUrl(state));

    const nextStepActions = useCallback((step: number) => {
        if (tourCategory === TutorialTourName.ONBOARDING_TUTORIAL_STEP) {
            switch (step) {
            case OnboardingTourSteps.CHANNELS_AND_DIRECT_MESSAGES : {
                dispatch(openLhs());
                break;
            }
            case OnboardingTourSteps.CREATE_AND_JOIN_CHANNELS : {
                dispatch(setAddChannelDropdown(true));
                break;
            }
            case OnboardingTourSteps.INVITE_PEOPLE : {
                dispatch(setAddChannelDropdown(true));
                break;
            }
            case OnboardingTourSteps.SEND_MESSAGE : {
                dispatch(switchToChannels());
                break;
            }
            case OnboardingTourSteps.FINISHED: {
                let preferences = [
                    {
                        user_id: currentUserId,
                        category: OnboardingTaskCategory,
                        name: OnboardingTasksName.CHANNELS_TOUR,
                        value: FINISHED.toString(),
                    },
                ];
                preferences = [...preferences,
                    {
                        user_id: currentUserId,
                        category: OnboardingTaskCategory,
                        name: OnboardingTaskList.ONBOARDING_TASK_LIST_OPEN,
                        value: 'true',
                    },
                ];
                dispatch(savePreferences(currentUserId, preferences));
                break;
            }
            default:
            }
        } else if (tourCategory === TutorialTourName.CRT_TUTORIAL_STEP) {
            switch (step) {
            case CrtTutorialSteps.WELCOME_POPOVER : {
                dispatch(openLhs());
                break;
            }
            case CrtTutorialSteps.LIST_POPOVER : {
                const nextUrl = `${teamUrl}/threads`;
                getHistory().push(nextUrl);
                break;
            }
            case CrtTutorialSteps.UNREAD_POPOVER : {
                break;
            }
            default:
            }
        } else if (tourCategory === TutorialTourName.EXPLORE_OTHER_TOOLS) {
            switch (step) {
            case ExploreOtherToolsTourSteps.FINISHED : {
                dispatch(setProductMenuSwitcherOpen(false));
                let preferences = [
                    {
                        user_id: currentUserId,
                        category: OnboardingTaskCategory,
                        name: OnboardingTasksName.EXPLORE_OTHER_TOOLS,
                        value: FINISHED.toString(),
                    },
                ];
                preferences = [...preferences,
                    {
                        user_id: currentUserId,
                        category: OnboardingTaskCategory,
                        name: OnboardingTaskList.ONBOARDING_TASK_LIST_OPEN,
                        value: 'true',
                    },
                ];
                dispatch(savePreferences(currentUserId, preferences));
                break;
            }
            default:
            }
        }
    }, [currentUserId, teamUrl, tourCategory]);

    const lastStepActions = useCallback((lastStep: number) => {
        if (tourCategory === TutorialTourName.ONBOARDING_TUTORIAL_STEP) {
            switch (lastStep) {
            case OnboardingTourSteps.CREATE_AND_JOIN_CHANNELS : {
                dispatch(setAddChannelDropdown(false));
                break;
            }
            case OnboardingTourSteps.INVITE_PEOPLE : {
                dispatch(setAddChannelDropdown(false));
                break;
            }
            default:
            }
        } else if (tourCategory === TutorialTourName.CRT_TUTORIAL_STEP) {
            switch (lastStep) {
            case CrtTutorialSteps.WELCOME_POPOVER : {
                dispatch(closeLhs());
                break;
            }
            default:
            }
        }
    }, [currentUserId, tourCategory]);

    return useCallback((step: number, lastStep: number) => {
        lastStepActions(lastStep);
        nextStepActions(step);
    }, [nextStepActions, lastStepActions]);
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useSelector} from 'react-redux';

import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';

import {GlobalState} from 'types/store';
import {getInt} from 'mattermost-redux/selectors/entities/preferences';

import {TutorialTourName} from '../constant';

export const useShowOnboardingTutorialStep = (stepToShow: number): boolean => {
    const currentUserId = useSelector(getCurrentUserId);
    const boundGetInt = (state: GlobalState) => getInt(state, TutorialTourName.ONBOARDING_TUTORIAL_STEP, currentUserId, 0);
    const step = useSelector<GlobalState, number>(boundGetInt);
    return step === stepToShow;
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {ChannelsTourTip, ChannelsTourTipProps, TutorialTourName} from 'components/tours';

const OnboardingTourTip = (props: Omit<ChannelsTourTipProps, 'tourCategory'>) => {
    return (
        <ChannelsTourTip
            {...props}
            tourCategory={TutorialTourName.ONBOARDING_TUTORIAL_STEP}
        />
    );
};

export default OnboardingTourTip;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {useMeasurePunchouts} from '@mattermost/components';

import OnboardingTourTip from './onboarding_tour_tip';

const translate = {x: 0, y: 18};

export const CreateAndJoinChannelsTour = () => {
    const title = (
        <FormattedMessage
            id='onboardingTour.CreateAndJoinChannels.title'
            defaultMessage={'Create and join channels'}
        />
    );
    const screen = (
        <p>
            <FormattedMessage
                id='onboardingTour.CreateAndJoinChannels.Description'
                defaultMessage={'Create new channels or browse available channels to see what your team is discussing. As you join channels, organize them into  categories based on how you work.'}
            />
        </p>
    );

    const overlayPunchOut = useMeasurePunchouts(['showMoreChannels', 'invitePeople'], [], {y: -8, height: 16, x: 0, width: 0});

    return (
        <OnboardingTourTip
            title={title}
            screen={screen}
            placement='right-start'
            pulsatingDotPlacement='right-start'
            pulsatingDotTranslate={translate}
            width={352}
            overlayPunchOut={overlayPunchOut}
        />
    );
};


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import {useMeasurePunchouts} from '@mattermost/components';

import OnboardingTourTip from './onboarding_tour_tip';

const translate = {x: 0, y: -18};

export const InvitePeopleTour = () => {
    const title = (
        <FormattedMessage
            id='onboardingTour.invitePeople.title'
            defaultMessage={'Invite people to the team'}
        />
    );
    const screen = (
        <p>
            <FormattedMessage
                id='onboardingTour.invitePeople.Description'
                defaultMessage={'Invite members of your organization or external guests to the team and start collaborating with them.'}
            />
        </p>
    );

    const overlayPunchOut = useMeasurePunchouts(['showMoreChannels', 'invitePeople'], [], {y: -8, height: 16, x: 0, width: 0});

    return (
        <OnboardingTourTip
            title={title}
            screen={screen}
            placement='right-start'
            pulsatingDotPlacement='right-end'
            pulsatingDotTranslate={translate}
            width={352}
            overlayPunchOut={overlayPunchOut}
        />
    );
};

export default __webpack_public_path__ + "files/f0ed40c1c7c4d880a63ee27219899038.svg";
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';
import {useSelector} from 'react-redux';

import {getChannelsNameMapInCurrentTeam} from 'mattermost-redux/selectors/entities/channels';
import {GlobalState} from 'types/store';
import Constants from 'utils/constants';
import ChannelsImg from 'images/channels_and_direct_tour_tip.svg';

import {useMeasurePunchouts} from '@mattermost/components';

import OnboardingTourTip from './onboarding_tour_tip';

type Props = {
    firstChannelName?: string;
}

const FirstChannel = ({firstChannelName}: {firstChannelName: string}) => {
    return (
        <FormattedMessage
            id='onboardingTour.ChannelsAndDirectMessagesTour.firstChannel'
            defaultMessage='Hey look, theres your **{firstChannelName}** channel! '
            values={{firstChannelName}}
        />
    );
};

export const ChannelsAndDirectMessagesTour = ({firstChannelName}: Props) => {
    const channelsByName = useSelector((state: GlobalState) => getChannelsNameMapInCurrentTeam(state));
    const townSquareDisplayName = channelsByName[Constants.DEFAULT_CHANNEL]?.display_name || Constants.DEFAULT_CHANNEL_UI_NAME;
    const offTopicDisplayName = channelsByName[Constants.OFFTOPIC_CHANNEL]?.display_name || Constants.OFFTOPIC_CHANNEL_UI_NAME;

    const title = (
        <FormattedMessage
            id='onboardingTour.ChannelsAndDirectMessagesTour.title'
            defaultMessage={'Channels and direct messages'}
        />
    );
    const screen = (
        <>
            <p>
                {firstChannelName && <FirstChannel firstChannelName={firstChannelName}/>}
                <FormattedMessage
                    id='onboardingTour.ChannelsAndDirectMessagesTour.channels'
                    defaultMessage={'Channels are where you can communicate with your team about a topic or project.'}
                />
            </p>
            <p>
                <FormattedMessage
                    id='onboardingTour.ChannelsAndDirectMessagesTour.townSquare'
                    defaultMessage='Weve also added the <b>{townSquare}</b> and <b>{offTopic}</b> channels for everyone on your team.'
                    values={{townSquare: townSquareDisplayName, offTopic: offTopicDisplayName, b: (value: string) => <b>{value}</b>}}
                />
            </p>
            <p>
                <FormattedMessage
                    id='onboardingTour.ChannelsAndDirectMessagesTour.directMessages'
                    defaultMessage='<b>Direct messages</b> are for private conversations between individuals or small groups.'
                    values={{b: (value: string) => <b>{value}</b>}}
                />
            </p>
        </>
    );

    const overlayPunchOut = useMeasurePunchouts(['sidebar-droppable-categories'], []);

    return (
        <OnboardingTourTip
            title={title}
            screen={screen}
            imageURL={ChannelsImg}
            placement='right-start'
            pulsatingDotPlacement='right'
            width={352}
            overlayPunchOut={overlayPunchOut}
        />
    );
};


export default __webpack_public_path__ + "files/18f795b7373cd6fac75715c68e96a3fe.gif";
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import CustomImg from 'images/Customize-Your-Experience.gif';

import {useMeasurePunchouts} from '@mattermost/components';

import OnboardingTourTip from './onboarding_tour_tip';

const translate = {x: 20, y: -6};
const offset: [number, number] = [18, 4];

export const CustomizeYourExperienceTour = () => {
    const title = (
        <FormattedMessage
            id='onboardingTour.customizeYourExperience.title'
            defaultMessage={'Customize your experience'}
        />
    );
    const screen = (
        <p>
            <FormattedMessage
                id='onboardingTour.customizeYourExperience.Description'
                defaultMessage={'Set your availability, add a custom status, and access Settings and your Profile to configure your experience, including notification preferences and custom theme colors.'}
            />
        </p>
    );

    const overlayPunchOut = useMeasurePunchouts(['RightControlsContainer'], [], {y: 6, height: -6, x: 64, width: 0});

    return (
        <OnboardingTourTip
            title={title}
            screen={screen}
            imageURL={CustomImg}
            placement='bottom-start'
            pulsatingDotPlacement='bottom'
            pulsatingDotTranslate={translate}
            offset={offset}
            width={352}
            overlayPunchOut={overlayPunchOut}
        />
    );
};


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useMemo, memo} from 'react';
import {useIntl} from 'react-intl';
import styled from 'styled-components';

import {trackEvent} from 'actions/telemetry_actions';

import {Channel} from '@mattermost/types/channels';

import {t} from 'utils/i18n';

import Chip from '../common/chip/chip';

type Props = {
    prefillMessage: (msg: string, shouldFocus: boolean) => void;
    currentChannel: Channel;
    currentUserId: string;
    currentChannelTeammateUsername?: string;
}

const UsernameMention = styled.span`
    margin-left: 5px;
    color: var(--link-color);
`;

const ChipContainer = styled.div`
    display: flex;
    flex-wrap: wrap;
`;

const PrewrittenChips = ({currentChannel, currentUserId, currentChannelTeammateUsername, prefillMessage}: Props) => {
    const {formatMessage} = useIntl();

    const chips = useMemo(() => {
        const customChip = {
            event: 'prefilled_message_selected_custom',
            messageId: '',
            message: '',
            displayId: t('create_post.prewritten.custom'),
            display: 'Custom message...',
            leadingIcon: '',
        };

        if (currentChannel.type === 'O' || currentChannel.type === 'P' || currentChannel.type === 'G') {
            return [
                {
                    event: 'prefilled_message_selected_team_hi',
                    messageId: t('create_post.prewritten.tip.team_hi_message'),
                    message: ':wave: Hi team!',
                    displayId: t('create_post.prewritten.tip.team_hi'),
                    display: 'Hi team!',
                    leadingIcon: 'wave',
                },
                {
                    event: 'prefilled_message_selected_team_excited',
                    messageId: t('create_post.prewritten.tip.team_excited_message'),
                    message: ':raised_hands: Excited to be here!',
                    displayId: t('create_post.prewritten.tip.team_excited'),
                    display: 'Excited to be here!',
                    leadingIcon: 'raised_hands',
                },
                {
                    event: 'prefilled_message_selected_team_hey',
                    messageId: t('create_post.prewritten.tip.team_hey_message'),
                    message: ':smile: Hey everyone!',
                    displayId: t('create_post.prewritten.tip.team_hey'),
                    display: 'Hey everyone!',
                    leadingIcon: 'smile',
                },
                customChip,
            ];
        }

        if (currentChannel.teammate_id === currentUserId) {
            return [
                {
                    event: 'prefilled_message_selected_self_note',
                    messageId: t('create_post.prewritten.tip.self_note'),
                    message: 'Note to self...',
                    displayId: t('create_post.prewritten.tip.self_note'),
                    display: 'Note to self...',
                    leadingIcon: '',
                },
                {
                    event: 'prefilled_message_selected_self_should',
                    messageId: t('create_post.prewritten.tip.self_should'),
                    message: 'Tomorrow I should...',
                    displayId: t('create_post.prewritten.tip.self_should'),
                    display: 'Tomorrow I should...',
                    leadingIcon: '',
                },
                customChip,
            ];
        }

        return [
            {
                event: 'prefilled_message_selected_dm_hey',
                messageId: t('create_post.prewritten.tip.dm_hey_message'),
                message: ':wave: Hey @{username}',
                displayId: t('create_post.prewritten.tip.dm_hey'),
                display: 'Hey',
                leadingIcon: 'wave',
            },
            {
                event: 'prefilled_message_selected_dm_hello',
                messageId: t('create_post.prewritten.tip.dm_hello_message'),
                message: ':v: Oh hello',
                displayId: t('create_post.prewritten.tip.dm_hello'),
                display: 'Oh hello',
                leadingIcon: 'v',
            },
            customChip,
        ];
    }, [currentChannel, currentUserId]);

    return (
        <ChipContainer>
            {chips.map(({event, messageId, message, displayId, display, leadingIcon}) => {
                const values = {username: currentChannelTeammateUsername};
                const messageToPrefill = messageId ? formatMessage(
                    {id: messageId, defaultMessage: message},
                    values,
                ) : message;

                const additionalMarkup = displayId === 'create_post.prewritten.tip.dm_hey' ? (
                    <UsernameMention>
                        {'@'}{currentChannelTeammateUsername}
                    </UsernameMention>
                ) : null;

                return (
                    <Chip
                        key={displayId}
                        id={displayId}
                        defaultMessage={display}
                        additionalMarkup={additionalMarkup}
                        values={values}
                        onClick={() => {
                            if (event) {
                                trackEvent('ui', event);
                            }
                            prefillMessage(messageToPrefill, true);
                        }}
                        otherOption={!messageId}
                        leadingIcon={leadingIcon}
                    />
                );
            })}
        </ChipContainer>
    );
};

export default memo(PrewrittenChips);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import PrewrittenChips from 'components/advanced_create_post/prewritten_chips';

import {Channel} from '@mattermost/types/channels';

import {useMeasurePunchouts} from '@mattermost/components';

import OnboardingTourTip from './onboarding_tour_tip';

type Props = {
    prefillMessage: (msg: string, shouldFocus: boolean) => void;
    currentChannel: Channel;
    currentUserId: string;
    currentChannelTeammateUsername?: string;
}

const translate = {x: -6, y: -6};

export const SendMessageTour = ({
    prefillMessage,
    currentChannel,
    currentUserId,
    currentChannelTeammateUsername,
}: Props) => {
    const chips = (
        <PrewrittenChips
            prefillMessage={prefillMessage}
            currentChannel={currentChannel}
            currentUserId={currentUserId}
            currentChannelTeammateUsername={currentChannelTeammateUsername}
        />
    );

    const title = (
        <FormattedMessage
            id='onboardingTour.sendMessage.title'
            defaultMessage={'Send messages'}
        />
    );

    const screen = (
        <>
            <p>
                <FormattedMessage
                    id='onboardingTour.sendMessage.Description'
                    defaultMessage={'Start collaborating with others by typing or selecting one of the messages below. You can also drag and drop attachments into the text field or upload them using the paperclip icon.'}
                />
            </p>
            <div>
                {chips}
            </div>
        </>
    );
    const overlayPunchOut = useMeasurePunchouts(['post-create'], [], {y: -11, height: 11, x: 0, width: 0});

    return (
        <OnboardingTourTip
            title={title}
            screen={screen}
            placement='top-start'
            pulsatingDotPlacement='top-start'
            pulsatingDotTranslate={translate}
            width={400}
            overlayPunchOut={overlayPunchOut}
        />
    );
};


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

type SvgProps = {
    width: number;
    height: number;
}

const PersonWithChecklistSvg = (props: SvgProps) => (
    <svg
        width={props.width ? props.width.toString() : '230'}
        height={props.height ? props.height.toString() : '220'}
        viewBox='0 0 230 220'
        fill='none'
        xmlns='http://www.w3.org/2000/svg'
    >
        <g clipPath='url(#clip0_715_435373)'>
            <path
                d='M85.235 40.9879L85.6705 28.0413L84.6808 22.9142C86.4919 18.2522 89.1542 18.5789 90.7872 18.4304C94.5084 18.0939 96.9926 16.0549 98.7047 17.8563C99.635 18.9352 100.684 23.3398 100.852 26.7645C100.971 28.5758 101.605 30.1199 100.259 31.0305C99.3307 31.5366 98.3604 31.9606 97.3587 32.2975L97.8536 41.9876L85.235 40.9879Z'
                fill='#AD831F'
            />
            <path
                d='M99.7042 22.6667C100.937 23.5192 102.063 24.5161 103.059 25.6361C103.366 26.9921 99.6349 27.685 99.6349 27.685L99.7042 22.6667Z'
                fill='#AD831F'
            />
            <path
                d='M93.3999 32.8121C94.7197 32.9561 96.0549 32.7901 97.2993 32.3271C97.7644 32.1391 96.4382 32.9804 95.9632 33.1487C95.3525 33.4621 94.6689 33.6057 93.9838 33.5644C93.5087 33.4852 92.8951 32.7725 93.3999 32.8121Z'
                fill='#7A5600'
            />
            <path
                d='M103.722 16.3122C103.563 15.9235 103.266 15.6074 102.888 15.4247C102.51 15.242 102.077 15.2055 101.674 15.3224C98.1603 15.9063 98.8234 12.8479 93.6473 13.7189C90.0449 14.3227 86.2444 13.7189 83.0576 15.55C81.6989 16.2098 80.5986 17.3033 79.9302 18.658C79.618 19.3389 79.5539 20.1076 79.7492 20.8308C79.9444 21.554 80.3866 22.186 80.9991 22.6172C81.2168 22.7459 81.4741 22.8548 81.583 23.0824C81.6527 23.3191 81.6315 23.5732 81.5236 23.7951C81.0782 25.1313 80.6824 26.7645 81.682 27.7543C82.2362 28.3085 83.1665 28.5659 83.3842 29.3182C83.503 29.7339 83.3842 30.1793 83.4337 30.6148C83.6415 31.763 85.4131 31.951 86.2543 31.1394C87 30.2174 87.3898 29.0583 87.3529 27.873C87.442 26.8337 87.4717 25.6361 86.6997 24.9036C86.3434 24.5671 85.8387 24.3691 85.6506 23.9138C85.5751 23.6385 85.589 23.3463 85.6904 23.0794C85.7918 22.8125 85.9755 22.5848 86.2148 22.4291C86.5354 22.2032 86.9009 22.0486 87.2864 21.976C87.6719 21.9034 88.0685 21.9145 88.4494 22.0083C88.8303 22.1021 89.1866 22.2766 89.4943 22.5199C89.802 22.7633 90.0538 23.0699 90.2329 23.4189C90.5199 24.0722 90.609 24.9334 91.2226 25.2501C92.0243 25.646 92.9348 24.7552 93.0436 23.8743C93.0326 22.9839 92.9432 22.0963 92.7764 21.2216C92.7764 20.3308 93.2317 19.242 94.1224 19.242C94.4168 19.2573 94.7072 19.3173 94.9834 19.4201C96.7319 19.9132 98.576 19.9609 100.348 19.5587C101.227 19.4303 102.063 19.0907 102.782 18.5689C103.13 18.3141 103.401 17.9691 103.566 17.5714C103.732 17.1737 103.786 16.7383 103.722 16.3122Z'
                fill='#4A2407'
            />
            <path
                d='M96.933 21.8353L96.9825 21.7363C94.34 21.4987 91.0443 21.2909 88.7878 21.3206C86.5313 21.3502 85.4922 21.667 84.3144 23.6961C84.1165 24.0425 84.6905 24.29 84.8984 23.9436C85.1324 23.3878 85.5165 22.9083 86.0077 22.5587C86.4989 22.209 87.0778 22.0031 87.6794 21.964C88.8274 21.8749 90.0151 21.964 91.1532 21.964C92.6081 21.964 94.8646 22.1718 96.745 22.3499C96.8044 22.1718 96.8637 22.0035 96.933 21.8353Z'
                fill='white'
            />
            <path
                d='M97.2796 23.7654C96.9872 23.5504 96.7621 23.2565 96.6306 22.9182C96.4992 22.5799 96.4668 22.2111 96.5373 21.8551C96.6759 20.8158 97.4478 20.0636 98.2495 20.1725C98.6801 20.2952 99.0461 20.5809 99.2696 20.9689C99.4932 21.357 99.5568 21.8168 99.447 22.251C99.3085 23.2408 98.5365 24.0426 97.7349 23.9337C97.5725 23.9119 97.4171 23.8545 97.2796 23.7654ZM98.4672 20.796C98.3848 20.7399 98.2894 20.7058 98.1901 20.697C97.6458 20.6178 97.1212 21.182 97.0124 21.9541C96.9035 22.7261 97.2598 23.419 97.8041 23.4982C98.3485 23.5774 98.8631 23.0032 98.972 22.2312C99.0388 21.9629 99.0268 21.681 98.9372 21.4193C98.8477 21.1577 98.6845 20.9275 98.4672 20.7564V20.796Z'
                fill='white'
            />
            <path
                d='M92.4102 40.1466C118.142 40.3446 118.073 37.9295 120.656 68.2867C123.239 98.6439 123.279 99.7425 97.8337 101.415C80.8704 102.534 70.8547 109.334 69.9739 100.01C69.0831 90.5077 68.519 90.7848 67.0048 74.6412C63.5705 38.9192 64.1545 39.9289 92.4102 40.1466Z'
                fill='#AD831F'
            />
            <path
                d='M103.97 62.5854C111.313 70.9195 127.901 77.3631 140.717 77.3631C142.548 77.3745 144.372 77.1415 146.141 76.6703C147.227 76.3767 148.284 75.9823 149.298 75.4924C159.848 70.3355 162.985 54.4195 165.281 48.9558C168.112 42.2351 165.172 46.4121 167.083 42.5717C167.765 41.1958 169.448 40.305 169.992 39.6023C170.774 38.6125 169.28 37.2762 163.638 41.0968C154.731 47.0356 155.721 59.0024 146.952 60.2594C145.851 60.3988 144.737 60.3988 143.637 60.2594C142.652 60.1535 141.677 59.9782 140.717 59.7348C125.07 55.8746 123.744 41.0869 108.344 40.4831C108.344 40.4435 96.6164 54.1919 103.97 62.5854Z'
                fill='#AD831F'
            />
            <path
                d='M23.5177 51.4699C23.2208 52.3013 24.5074 56.4189 24.8538 60.1901C25.7049 69.2764 28.4959 83.2227 41.4608 88.5478C43.1038 89.2059 44.8484 89.5743 46.6171 89.6366C47.7413 89.6868 48.8676 89.6337 49.9821 89.4782C57.8996 88.4884 66.599 82.7179 70.9141 73.7206C76.8522 61.2986 79.2671 40.2257 79.2671 40.2257C73.5467 40.2257 59.4732 39.1271 54.3565 61.7341C54.0363 63.4975 53.3298 65.1681 52.2877 66.6261C51.2457 68.0841 49.8939 69.2934 48.3293 70.1672C47.3487 70.6848 46.2824 71.0202 45.1821 71.157C43.6876 71.3487 42.169 71.1325 40.7874 70.5313C39.4057 69.9301 38.2124 68.9664 37.3338 67.7422C29.6538 57.4582 28.7037 46.3922 23.1713 45.3034C17.6389 44.2146 24.9626 47.4216 23.5177 51.4699Z'
                fill='#AD831F'
            />
            <path
                d='M108.344 40.4435C123.744 41.0473 125.07 55.835 140.717 59.6952C142.35 60.1284 144.035 60.3349 145.725 60.3088C146.447 65.5845 146.972 70.8898 147.477 76.205C145.304 76.9618 143.018 77.3401 140.717 77.3235C127.901 77.3235 111.313 70.8799 103.97 62.5359C96.6263 54.1919 108.344 40.4435 108.344 40.4435Z'
                fill='#1E325C'
            />
            <path
                d='M47.0031 70.7314C50.3087 69.613 53.2778 66.5644 54.3565 61.7342C59.4337 39.1271 73.5467 40.2159 79.2572 40.2258C79.2572 40.2258 76.872 61.2987 70.9141 73.7207C66.1042 83.7374 55.9103 89.706 47.3 89.6466C48.1318 83.3613 48.0317 76.9875 47.0031 70.7314Z'
                fill='#1E325C'
            />
            <path
                d='M121.804 85.9645C136.808 129.951 137.718 148.015 136.323 163.169C134.927 178.323 123.873 193.912 109.453 205.325C106.414 207.482 102.614 209.007 105.019 214.886C108.513 223.438 99.3183 212.204 97.0222 206.611C94.7261 201.019 119.073 191.289 113.451 161.427C107.83 131.565 92.7467 119.35 83.3149 98.2182C73.8832 77.086 121.804 85.9645 121.804 85.9645Z'
                fill='#1C58D9'
            />
            <path
                d='M121.804 85.9645C136.808 129.951 137.718 148.015 136.323 163.169C134.927 178.323 123.873 193.912 109.453 205.325C106.414 207.482 102.614 209.007 105.019 214.886C108.513 223.438 99.3183 212.204 97.0222 206.611C94.7261 201.019 119.073 191.289 113.451 161.427C107.83 131.565 92.7467 119.35 83.3149 98.2182C73.8832 77.086 121.804 85.9645 121.804 85.9645Z'
                fill='black'
                fillOpacity='0.16'
            />
            <mask
                id='mask0_715_435373'
                style={{maskType: 'alpha'}}
                maskUnits='userSpaceOnUse'
                x='82'
                y='84'
                width='55'
                height='134'
            >
                <path
                    d='M121.804 85.9645C136.808 129.951 137.718 148.015 136.323 163.169C134.927 178.323 123.872 193.912 109.453 205.325C106.414 207.482 102.614 209.007 105.019 214.886C108.512 223.438 99.3182 212.204 97.0221 206.611C94.726 201.019 119.072 191.289 113.451 161.427C107.83 131.565 92.7466 119.35 83.3148 98.2182C73.883 77.086 121.804 85.9645 121.804 85.9645Z'
                    fill='#1452BD'
                />
            </mask>
            <g mask='url(#mask0_715_435373)'>
                <rect
                    x='75.9232'
                    y='76.573'
                    width='39.6883'
                    height='110.592'
                    fill='url(#pattern0)'
                />
            </g>
            <path
                d='M102.515 121.528C103.841 124.052 105.365 126.754 106.969 129.545L106.424 129.991C104.752 127.021 103.158 124.191 101.941 121.865C101.743 121.488 102.307 121.152 102.515 121.528Z'
                fill='#1E325C'
            />
            <path
                d='M110.69 193.11C109.7 194.209 108.71 195.298 107.77 196.387L107.355 195.931C108.344 194.872 109.275 193.803 110.215 192.724L110.69 193.11Z'
                fill='#1E325C'
            />
            <path
                d='M104.287 88.8943C106.108 138.186 101.387 160.863 80.0391 176.808C58.6914 192.754 42.1437 193.328 41.5004 201.365C40.8571 209.403 38.9272 207.562 38.1751 199.317C37.1854 188.122 32.514 196.436 57.3256 177.293C82.1372 158.151 70.4193 107.71 69.2019 92.7644C67.9846 77.8184 104.287 88.8943 104.287 88.8943Z'
                fill='#1C58D9'
            />
            <path
                d='M41.1936 193.16C53.6439 187.023 66.5891 180.184 72.3689 166.782C78.8019 151.865 76.0605 135.108 75.6547 119.449C75.4172 110.007 75.6547 100.554 76.2683 91.1312C76.2683 90.7056 76.9611 90.7056 76.9314 91.1312C76.4069 99.792 76.1298 108.463 76.2782 117.143C76.4267 125.824 77.2679 134.504 77.2679 143.205C77.2184 150.737 76.397 158.378 73.6753 165.455C71.1709 171.891 67.0128 177.552 61.6209 181.866C55.5738 186.815 48.5371 190.309 41.5796 193.744C41.1441 193.922 40.8076 193.348 41.1936 193.16Z'
                fill='#1E325C'
            />
            <path
                d='M114.876 188.003C114.461 188.557 114.035 189.102 113.6 189.646C112.966 190.438 112.313 191.21 111.62 191.982L111.145 191.606C112.224 190.349 113.273 189.062 114.263 187.736L114.876 188.003Z'
                fill='#1E325C'
            />
            <path
                d='M118.142 182.975C117.405 184.281 116.602 185.55 115.737 186.776L115.163 186.518C116.005 185.311 116.796 184.074 117.519 182.787L118.142 182.975Z'
                fill='#1E325C'
            />
            <path
                d='M119.993 177.224L120.636 177.382C120.164 178.841 119.578 180.261 118.884 181.629L118.251 181.441C118.657 180.619 119.053 179.788 119.389 178.917C119.617 178.392 119.805 177.788 119.993 177.224Z'
                fill='#1E325C'
            />
            <path
                d='M121.824 164.624C121.955 165.94 122.018 167.261 122.012 168.583L121.359 168.514C121.362 167.215 121.296 165.916 121.161 164.624H121.824Z'
                fill='#1E325C'
            />
            <path
                d='M120.518 157.606C120.656 158.121 120.785 158.596 120.903 159.121C121.22 160.457 121.468 161.823 121.656 163.189H120.983C120.717 161.373 120.343 159.575 119.864 157.804L120.518 157.606Z'
                fill='#1E325C'
            />
            <path
                d='M118.805 152.44C119.28 153.677 119.726 154.914 120.102 156.131L119.449 156.359C119.073 155.112 118.647 153.885 118.192 152.667L118.805 152.44Z'
                fill='#1E325C'
            />
            <path
                d='M116.311 146.718C117.004 148.173 117.657 149.629 118.291 151.074L117.697 151.301C117.103 149.817 116.45 148.332 115.767 146.926L116.311 146.718Z'
                fill='#1E325C'
            />
            <path
                d='M110.086 134.979C111.016 136.603 111.937 138.252 112.847 139.928L112.293 140.334C111.422 138.77 110.482 137.107 109.512 135.385L110.086 134.979Z'
                fill='#1E325C'
            />
            <path
                d='M107.721 130.882C108.255 131.812 108.8 132.752 109.344 133.712L108.78 134.138C108.245 133.208 107.701 132.257 107.176 131.327L107.721 130.882Z'
                fill='#1E325C'
            />
            <path
                d='M113.55 141.245C114.282 142.611 114.985 143.98 115.658 145.353L115.074 145.56C114.777 144.967 114.48 144.373 114.174 143.799C113.867 143.224 113.421 142.393 113.016 141.641L113.55 141.245Z'
                fill='#1E325C'
            />
            <path
                d='M121.953 170.098C121.85 172.073 121.548 174.033 121.052 175.947L120.409 175.799C120.9 173.91 121.198 171.977 121.299 170.028L121.953 170.098Z'
                fill='#1E325C'
            />
            <path
                d='M106.781 197.505C106.028 198.356 105.276 199.198 104.544 200.069C104.395 199.91 104.247 199.752 104.089 199.604C104.831 198.742 105.593 197.891 106.355 197.05C106.494 197.198 106.642 197.347 106.781 197.505Z'
                fill='#1E325C'
            />
            <path
                d='M103.119 200.742L103.584 201.217C102.762 202.207 101.961 203.197 101.189 204.236C100.941 204.572 100.367 204.236 100.615 203.899C101.416 202.82 102.307 201.781 103.119 200.742Z'
                fill='#1E325C'
            />
            <path
                d='M85.2845 40.0972C85.9076 41.1371 86.8577 41.9411 87.9863 42.3836C92.0539 44.0564 97.23 44.0563 99.5063 40.1664C118.212 40.1664 118.38 40.9979 120.696 68.2867C121.863 82.0053 122.507 89.7456 120.527 94.269C110.205 98.733 98.3385 100.208 87.5212 102.306C82.8102 103.217 78.0795 103.989 73.3389 104.672C71.4188 104.207 70.2807 102.87 70.0135 100.01C69.1228 90.5077 68.5586 90.7848 67.0444 74.6412C63.8873 42.2351 64.0753 40.0576 85.2845 40.0972Z'
                fill='white'
            />
            <path
                d='M85.2845 40.0972C85.9076 41.1371 86.8577 41.9411 87.9863 42.3836C92.0539 44.0564 97.23 44.0563 99.5063 40.1664C118.212 40.1664 118.38 40.9979 120.696 68.2867C121.863 82.0053 122.507 89.7456 120.527 94.269C110.205 98.733 98.3385 100.208 87.5212 102.306C82.8102 103.217 78.0795 103.989 73.3389 104.672C71.4188 104.207 70.2807 102.87 70.0135 100.01C69.1228 90.5077 68.5586 90.7848 67.0444 74.6412C63.8873 42.2351 64.0753 40.0576 85.2845 40.0972Z'
                fill='#3F4350'
                fillOpacity='0.08'
            />
            <mask
                id='mask1_715_435373'
                style={{maskType: 'alpha'}}
                maskUnits='userSpaceOnUse'
                x='65'
                y='40'
                width='57'
                height='65'
            >
                <path
                    d='M85.2845 40.0972C85.9076 41.1371 86.8577 41.9411 87.9863 42.3836C92.0539 44.0564 97.23 44.0563 99.5063 40.1664C118.212 40.1664 118.38 40.9979 120.696 68.2867C121.863 82.0053 122.507 89.7456 120.527 94.269C110.205 98.733 98.3385 100.208 87.5212 102.306C82.8102 103.217 78.0795 103.989 73.3389 104.672C71.4188 104.207 70.2807 102.87 70.0135 100.01C69.1228 90.5077 68.5586 90.7848 67.0444 74.6412C63.8873 42.2351 64.0753 40.0576 85.2845 40.0972Z'
                    fill='white'
                />
            </mask>
            <g mask='url(#mask1_715_435373)'>
                <rect
                    opacity='0.7'
                    x='64.3289'
                    y='47.5872'
                    width='49.4989'
                    height='58.4176'
                    fill='url(#pattern1)'
                />
            </g>
            <path
                d='M110.433 92.1112C107.572 86.8932 105.349 81.3501 103.812 75.6013C100.951 63.9723 99.1428 52.1096 98.4078 40.1565C118.202 40.1565 120.181 39.434 122.586 67.2474C122.705 68.5935 121.141 71.0086 121.596 72.3844C125.426 83.1337 139.144 94.1601 138.015 96.6346C136.442 100.178 130.434 103.959 122.873 106.928C120.894 107.433 118.865 107.839 116.836 108.156C115.188 102.626 113.045 97.2559 110.433 92.1112Z'
                fill='#1E325C'
            />
            <path
                d='M66.8465 94.5956C66.2823 101.178 65.5401 106.81 66.0052 111.848C70.35 111.125 74.7145 110.67 79.0989 110.363C83.8148 100.344 86.6911 89.5583 87.5904 78.5211C88.1644 71.939 89.936 46.6594 89.5005 42.8883C89.2234 40.3544 86.0663 42.4924 85.423 40.0773C64.0852 40.0773 61.799 41.661 64.9264 74.1363C65.0749 75.7596 67.2621 77.8184 67.3314 79.3526C67.5095 84.4387 67.3475 89.5311 66.8465 94.5956Z'
                fill='#1E325C'
            />
            <path
                d='M99.7735 38.8895C101.238 40.0674 100.971 39.7407 99.9715 41.5917C98.9719 43.4426 98.4671 45.1154 97.6457 42.8686C96.8242 40.6217 96.7154 40.978 97.7842 39.6418C98.8531 38.3056 99.0313 38.2858 99.7735 38.8895Z'
                fill='#1C58D9'
            />
            <path
                d='M87.5211 39.2657C90.8366 40.7207 89.6193 40.3842 90.2527 42.5716C91.6283 47.2732 89.7083 44.7789 85.0073 42.0668C81.8106 40.2159 82.1867 39.9288 83.305 38.8004C84.4234 37.6721 84.0869 37.7216 87.343 39.2657C90.5991 40.8098 84.1957 37.8404 87.5211 39.2657Z'
                fill='#1C58D9'
            />
            <path
                d='M45.2217 71.355C46.8269 77.3078 47.3003 83.5091 46.6172 89.6366C47.7413 89.6868 48.8677 89.6337 49.9821 89.4782C50.6158 83.1022 50.0927 76.6641 48.4382 70.474C48.4168 70.3671 48.3802 70.2637 48.3294 70.1672C47.3488 70.6848 46.2824 71.0202 45.1821 71.157C45.191 71.2238 45.2042 71.2899 45.2217 71.355Z'
                fill='#1C58D9'
            />
            <path
                d='M143.637 60.2197C144.244 65.7296 145.078 71.1999 146.141 76.6306C147.227 76.337 148.284 75.9427 149.298 75.4528C148.308 70.3949 147.526 65.3271 146.952 60.2098C145.852 60.3525 144.738 60.3559 143.637 60.2197Z'
                fill='#1C58D9'
            />
            <path
                d='M105.336 208.482C104.197 209.888 103.762 211.768 105.019 214.837C108.512 223.388 99.3182 212.154 97.0222 206.562C96.458 205.176 97.517 203.543 99.3479 201.415C101.397 203.731 103.376 206.107 105.336 208.482Z'
                fill='#1E325C'
            />
            <path
                d='M41.0451 189.032C41.1837 189.369 41.3222 189.696 41.4509 190.022C42.4406 192.259 43.3313 194.496 44.321 196.713C43.5341 197.233 42.8704 197.919 42.3764 198.723C41.8823 199.527 41.5698 200.428 41.4608 201.365C40.8274 209.393 38.8876 207.562 38.1354 199.317C37.4526 191.863 35.1763 193.051 41.0451 189.032Z'
                fill='#1E325C'
            />
            <path
                d='M50.4389 1.30575L4.36272 1.30575C4.30693 1.31392 4.25001 1.30875 4.19656 1.29068C4.1431 1.2726 4.0946 1.24212 4.05496 1.20168C4.01533 1.16124 3.98566 1.11195 3.96836 1.05783C3.95106 1.00371 3.9466 0.946279 3.95535 0.890104C3.94447 0.767772 3.98073 0.645915 4.05659 0.549834C4.13244 0.453753 4.24208 0.390819 4.36272 0.374115L50.4389 0.374115C50.5604 0.389696 50.6712 0.452142 50.748 0.548347C50.8249 0.644552 50.8618 0.767045 50.851 0.890104C50.8589 0.946546 50.8537 1.00406 50.8357 1.05812C50.8178 1.11218 50.7877 1.16129 50.7477 1.20159C50.7078 1.2419 50.6591 1.27228 50.6055 1.29036C50.5519 1.30843 50.4948 1.31371 50.4389 1.30575ZM50.4389 6.49422C50.5613 6.47864 50.6728 6.41549 50.7498 6.31823C50.8268 6.22098 50.8631 6.09728 50.851 5.97344C50.8579 5.91719 50.852 5.86011 50.8337 5.8065C50.8155 5.7529 50.7853 5.70419 50.7456 5.66411C50.7058 5.62403 50.6576 5.59363 50.6044 5.5752C50.5513 5.55678 50.4946 5.55083 50.4389 5.5578L4.36272 5.5578C4.30712 5.55065 4.25064 5.55654 4.19765 5.57497C4.14467 5.59341 4.09661 5.62391 4.05721 5.66411C4.0178 5.70432 3.98811 5.75312 3.97045 5.80677C3.95278 5.86041 3.94762 5.91745 3.95535 5.97344C3.94318 6.09655 3.97884 6.21962 4.05482 6.31675C4.1308 6.41388 4.24118 6.4775 4.36272 6.49422L50.4389 6.49422ZM50.4389 11.5776C50.4948 11.5855 50.5519 11.5803 50.6055 11.5622C50.6591 11.5441 50.7078 11.5137 50.7477 11.4734C50.7877 11.4331 50.8178 11.384 50.8357 11.33C50.8537 11.2759 50.8589 11.2184 50.851 11.1619C50.8631 11.0381 50.8268 10.9144 50.7498 10.8171C50.6728 10.7199 50.5613 10.6567 50.4389 10.6412L4.36272 10.6412C4.24118 10.6579 4.1308 10.7215 4.05482 10.8186C3.97884 10.9157 3.94318 11.0388 3.95535 11.1619C3.9466 11.2181 3.95106 11.2755 3.96836 11.3297C3.98566 11.3838 4.01533 11.4331 4.05496 11.4735C4.0946 11.514 4.1431 11.5444 4.19656 11.5625C4.25001 11.5806 4.30693 11.5858 4.36272 11.5776L50.4389 11.5776ZM50.4389 16.7613C50.7089 16.7613 50.851 16.5893 50.851 16.2453C50.8589 16.1888 50.8537 16.1313 50.8357 16.0773C50.8178 16.0232 50.7877 15.9741 50.7477 15.9338C50.7078 15.8935 50.6591 15.8631 50.6055 15.845C50.5519 15.8269 50.4948 15.8217 50.4389 15.8296L4.36272 15.8296C4.08798 15.8296 3.95535 15.9825 3.95535 16.3074C3.95535 16.6323 4.08798 16.7852 4.36272 16.7852L50.4389 16.7613ZM50.4389 21.8446C50.4948 21.8526 50.5519 21.8473 50.6055 21.8292C50.6591 21.8112 50.7078 21.7808 50.7477 21.7405C50.7877 21.7002 50.8178 21.6511 50.8357 21.597C50.8537 21.5429 50.8589 21.4854 50.851 21.429C50.8618 21.3059 50.8249 21.1834 50.748 21.0872C50.6712 20.991 50.5604 20.9286 50.4389 20.913L4.36272 20.913C4.24208 20.9297 4.13244 20.9926 4.05659 21.0887C3.98073 21.1848 3.94447 21.3067 3.95535 21.429C3.9466 21.4852 3.95106 21.5426 3.96836 21.5967C3.98566 21.6509 4.01533 21.7001 4.05496 21.7406C4.0946 21.781 4.1431 21.8115 4.19656 21.8296C4.25001 21.8476 4.30693 21.8528 4.36272 21.8446L50.4389 21.8446ZM50.4389 27.0331C50.4948 27.0411 50.5519 27.0358 50.6055 27.0177C50.6591 26.9997 50.7078 26.9693 50.7477 26.929C50.7877 26.8887 50.8178 26.8395 50.8357 26.7855C50.8537 26.7314 50.8589 26.6739 50.851 26.6175C50.851 26.2687 50.7089 26.0967 50.4389 26.0967L4.36272 26.0967C4.08798 26.0967 3.95535 26.2543 3.95535 26.5744C3.95535 26.8945 4.08798 27.0522 4.36272 27.0522L50.4389 27.0331ZM50.4389 32.2168C50.5613 32.2012 50.6728 32.1381 50.7498 32.0408C50.8268 31.9436 50.8631 31.8199 50.851 31.696C50.8581 31.64 50.8523 31.583 50.834 31.5295C50.8157 31.4761 50.7854 31.4276 50.7456 31.3879C50.7057 31.3482 50.6573 31.3182 50.6041 31.3004C50.5509 31.2826 50.4944 31.2774 50.4389 31.2852L4.36272 31.2852C4.30738 31.2772 4.25096 31.2823 4.19792 31.3001C4.14488 31.318 4.09669 31.348 4.05716 31.3878C4.01763 31.4277 3.98785 31.4763 3.97017 31.5298C3.9525 31.5833 3.94743 31.6402 3.95535 31.696C3.94318 31.8192 3.97884 31.9422 4.05482 32.0393C4.1308 32.1365 4.24118 32.2001 4.36272 32.2168L50.4389 32.2168ZM50.4389 37.3002C50.4948 37.3081 50.5519 37.3029 50.6055 37.2848C50.6591 37.2667 50.7078 37.2363 50.7477 37.196C50.7877 37.1557 50.8178 37.1066 50.8357 37.0525C50.8537 36.9985 50.8589 36.9409 50.851 36.8845C50.851 36.5405 50.7089 36.3638 50.4389 36.3638L4.36272 36.3638C4.08798 36.3638 3.95535 36.5214 3.95535 36.8415C3.95535 37.1616 4.08798 37.3193 4.36272 37.3193L50.4389 37.3002ZM50.4389 42.4839C50.5604 42.4683 50.6712 42.4058 50.748 42.3096C50.8249 42.2134 50.8618 42.0909 50.851 41.9679C50.8589 41.9114 50.8537 41.8539 50.8357 41.7999C50.8178 41.7458 50.7877 41.6967 50.7477 41.6564C50.7078 41.6161 50.6591 41.5857 50.6055 41.5676C50.5519 41.5495 50.4948 41.5443 50.4389 41.5522L4.36272 41.5522C4.30693 41.5441 4.25001 41.5492 4.19656 41.5673C4.1431 41.5854 4.0946 41.6159 4.05496 41.6563C4.01533 41.6967 3.98566 41.746 3.96836 41.8001C3.95106 41.8542 3.9466 41.9117 3.95535 41.9679C3.94447 42.0902 3.98073 42.2121 4.05659 42.3081C4.13244 42.4042 4.24208 42.4672 4.36272 42.4839L50.4389 42.4839Z'
                fill='#3F4350'
                fillOpacity='0.24'
            />
            <path
                d='M6.31924 46.7407C6.20014 46.9344 6.03315 47.0934 5.83466 47.2023C5.63617 47.3112 5.41302 47.3662 5.18711 47.3618C5.00939 47.366 4.83298 47.3301 4.67078 47.2567C4.52071 47.1907 4.38532 47.0949 4.27264 46.9751C4.15997 46.8553 4.07231 46.7139 4.01487 46.5593C3.95743 46.4046 3.93139 46.2399 3.93828 46.0749C3.94517 45.91 3.98486 45.7481 4.05498 45.5988L17.4273 18.5242C17.5115 18.3672 17.6282 18.2304 17.7697 18.1232C17.9111 18.016 18.0739 17.9409 18.2468 17.9031C18.6029 17.8371 18.9706 17.9105 19.2747 18.1086L26.0628 23.0916L44.0631 7.01024C44.1729 6.89438 44.3073 6.80511 44.4562 6.74917C44.6051 6.69322 44.7647 6.67206 44.9229 6.68723C45.081 6.7024 45.2338 6.75351 45.3696 6.83676C45.5053 6.92002 45.6206 7.03322 45.7068 7.16788C45.8206 7.27881 45.911 7.4117 45.9728 7.55862C46.0346 7.70554 46.0664 7.8635 46.0664 8.02308C46.0664 8.18267 46.0346 8.3406 45.9728 8.48752C45.911 8.63444 45.8206 8.76733 45.7068 8.87826L26.887 25.6811C26.6648 25.8508 26.3936 25.9426 26.1149 25.9426C25.8361 25.9426 25.565 25.8508 25.3428 25.6811L18.9668 21.0134L6.31924 46.7407Z'
                fill='#D24B4E'
            />
            <path
                d='M194.674 132.536C193.011 135.07 189.256 135.435 186.335 133.383L153.362 110.265C152.286 109.542 151.532 108.434 151.257 107.171C150.982 105.908 151.208 104.588 151.887 103.487L180.893 59.3722C181.694 58.2874 182.841 57.5068 184.147 57.1591C185.453 56.8115 186.839 56.9176 188.077 57.4599L225.508 73.8541C228.819 75.3078 230.193 78.5182 228.545 81.0912L194.674 132.536Z'
                fill='#FFBC1F'
            />
            <path
                d='M189.427 129.535L155.439 106.402L185.336 60.9424L223.212 78.1606L189.427 129.535Z'
                fill='white'
            />
            <path
                d='M210.946 74.9346C210.655 75.2987 210.247 75.5516 209.79 75.6508C209.334 75.7499 208.857 75.6891 208.44 75.4787L194.143 68.7936C193.958 68.7264 193.791 68.6188 193.653 68.4786C193.515 68.3385 193.41 68.1694 193.347 67.9838C193.283 67.7981 193.262 67.6007 193.285 67.4059C193.308 67.2111 193.375 67.0238 193.48 66.858L195.721 63.4454C195.985 63.0963 196.363 62.8486 196.789 62.7438C197.216 62.6391 197.666 62.6837 198.063 62.8702L212.547 69.2755C212.748 69.3397 212.932 69.4481 213.085 69.5926C213.238 69.7372 213.356 69.9143 213.431 70.1107C213.506 70.307 213.536 70.5177 213.518 70.7271C213.5 70.9364 213.435 71.1391 213.328 71.3199L210.946 74.9346Z'
                fill='#8D93A5'
            />
            <path
                d='M208.213 70.5038L199 66.3372L201.272 62.878C201.542 62.5356 201.919 62.2923 202.343 62.1867C202.767 62.0812 203.214 62.1193 203.614 62.295L209.744 64.938C209.943 64.9985 210.125 65.1032 210.278 65.2442C210.43 65.3852 210.548 65.5588 210.623 65.7519C210.699 65.9451 210.729 66.1527 210.712 66.3591C210.694 66.5655 210.63 66.7653 210.524 66.9435L208.213 70.5038Z'
                fill='#2D3039'
            />
            <path
                d='M208.885 89.2455L189.763 79.4743L190.763 77.9507L209.955 87.6209L208.885 89.2455Z'
                fill='#3DB887'
            />
            <path
                d='M183.735 78.4793C183.691 78.5081 183.64 78.5265 183.587 78.533C183.534 78.5395 183.48 78.5338 183.43 78.5166C183.38 78.4994 183.334 78.471 183.296 78.4335C183.258 78.3961 183.23 78.3506 183.212 78.3004L182.041 74.849C182.026 74.7973 182.022 74.7429 182.03 74.6896C182.038 74.6363 182.058 74.5854 182.087 74.5404C182.117 74.4953 182.156 74.4572 182.202 74.4286C182.248 74.4001 182.3 74.3817 182.353 74.3749L182.798 74.2816C182.914 74.2574 183.035 74.2735 183.14 74.3272C183.245 74.381 183.328 74.4692 183.376 74.577L184.001 76.3804C184.017 76.4304 184.045 76.4758 184.082 76.5133C184.119 76.5508 184.164 76.5793 184.214 76.5965C184.264 76.6138 184.317 76.6195 184.369 76.613C184.422 76.6065 184.472 76.5881 184.516 76.5592L188.061 74.5692C188.171 74.5137 188.296 74.4958 188.418 74.5183C188.539 74.5407 188.65 74.6024 188.732 74.6936L189.013 75.0279C189.051 75.0685 189.078 75.1171 189.093 75.17C189.109 75.2228 189.112 75.2785 189.102 75.3327C189.092 75.3869 189.07 75.438 189.037 75.4822C189.004 75.5264 188.961 75.5625 188.912 75.5875L183.735 78.4793Z'
                fill='#3DB887'
            />
            <path
                d='M202.631 98.7525L183.884 88.4138L184.891 86.8824L203.7 97.1278L202.631 98.7525Z'
                fill='#BABEC9'
            />
            <path
                d='M180.292 88.7714L174.764 85.6775L177.95 80.8191L183.548 83.8197L180.292 88.7714Z'
                fill='#BABEC9'
            />
            <path
                d='M196.377 108.267L178.012 97.3454L179.012 95.814L197.446 106.642L196.377 108.267Z'
                fill='#BABEC9'
            />
            <path
                d='M174.467 97.6331L169.049 94.3605L172.242 89.5021L177.731 92.6814L174.467 97.6331Z'
                fill='#BABEC9'
            />
            <path
                d='M190.122 117.774L172.141 106.277L173.14 104.754L191.192 116.149L190.122 117.774Z'
                fill='#BABEC9'
            />
            <path
                d='M168.643 106.487L163.333 103.043L166.534 98.1928L171.906 101.535L168.643 106.487Z'
                fill='#BABEC9'
            />
            <ellipse
                cx='104.011'
                cy='217.944'
                rx='43.3171'
                ry='2.19225'
                fill='black'
                fillOpacity='0.12'
            />
        </g>
        <defs>
            <pattern
                id='pattern0'
                patternContentUnits='objectBoundingBox'
                width='1'
                height='1'
            >
                <use
                    xlinkHref='#image0_715_435373'
                    transform='scale(0.011236 0.00403226)'
                />
            </pattern>
            <pattern
                id='pattern1'
                patternContentUnits='objectBoundingBox'
                width='1'
                height='1'
            >
                <use
                    xlinkHref='#image1_715_435373'
                    transform='scale(0.00900901 0.00763359)'
                />
            </pattern>
            <clipPath id='clip0_715_435373'>
                <rect
                    width='228.037'
                    height='220'
                    fill='white'
                    transform='translate(0.98175)'
                />
            </clipPath>
            <image
                id='image0_715_435373'
                width='89'
                height='248'
                xlinkHref='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFkAAAD4CAYAAACHS0rkAAAgAElEQVR4Xu19z3Mcx5Xmy6wCCNOOIbx/wLC9EbYAOtZs7V4niGbDZxGjvROwYg4aDdCA9AeIlPZsEgDpmTmsKVL3lUjt1QSbijlujKiJMAHZMWFw/oA1GLEiQXRV5saXWa87O1HVVQ02qrvp5kUKdP386uXL9+N77wma/Dt1BMSp32FyA5qAXIIQTECegFwCAiXcYiLJE5BLQKCEW0wkeQJyCQiUcIuJJE9ALgGBEm4xkeQJyCUgUMItJpI8AbkEBEq4xUSSJyCXgEAJt5hI8gTkEhAo4RYTSZ6AXAICJdxiIskTkEtAoIRbTCR5AnIJCJRwi4kkT0AuAYESbjGR5AnIJSBQwi0mkjwBuQQESrjFRJInIJeAQAm3mEjyBOQSECjhFhNJnoBcAgIl3GIiyROQS0CghFtMJHkCcgkIlHCLiSRPQC4BgRJuMZHkCcglIFDCLSaSPAG5BARKuMVEkicgl4BACbcYqiTP1TYqRFFlr3m7WcK7Du0WQwW5WtuYPaKjytPmPz4ZGgIl3HioIJfwfiNxi5EE2aoRquw1N98INXKqIM/VNmonAepNUyOnDPJq7bQ2tfnLa492H926PBL6IOchThXk0wRgrvZ+Za/5z/uneY9BXXsoIEMdvKKottu8fX9QLzLK1xkKyD4gF2ofVF/Q9P5+c/NglME66bONBMjz9bUNrVr33eU/98vVGkXy/F5z+95JX25UzusbZGteqYXTfvms+8zVVmskRWVv59bdUQEx7zn6Bvkk5tWF2ka1RUf0xzfcs8sCu2+Q874aJFAE0ZXdh7e3+Fj87ZDoADp3rr62kiaFF+qNa0od3WOVMVdbWyES+rRXTN77DOL3gYPc70PN1VevH6pwE+f12viwOSpSB+Nitrk4nDrIUC+HUm3s7Wxfz/sAldrG7AwdzqYB+dPaB9UgB+SfLa4uHcVhc9SslIGBPFdrLGctbWxWRTy/oqFPs/kRkX/N+drqkqboyahJ+8BAxnLuJ2Rpl7+cLQK+o9tPFAvJW0Gn/fvAQE570PnaxtJuc7PLq5uvNzZ3d7Y3cDxcYyuR1j0G8FEgK394mO4JQmX4FgqkPyaa/WNz8wkkXATy4u7D7fame9oAFrn+iUA2brGMV3Z3bpkNK+sfANhrbu7jvyqIqj54WZuZVRuHJILpKzo+eoCPwNfy74VneRFEtawPUwSE0z7mRCCz1LnqAVJ0SOGTIptOWrzYD/jYTZBm8ZFwv/n62pe7O7f+tl9AigpEv9ft5/gTg+zfpIhO5o2NKNxnrxFgzhIRVkYs9H6eRALslyr4VZYVkvbyuEeRj98PcP0cOzCQU3XyYmMd+nF+sbGuY/UtjlFEs39wom/WIqADbIBWfQRVolZTyunlpzvbn7jXdVXDXH3ts72dW7/y79vLDOwHmEEeOzCQff1q7GNSV2DW+b/BnoXE2r9PQyU08SFexvJevxLng3oSq2WQgKZda2Ag99wATUSNiAJ5fu9hJ6oGKRak9qHb3SXNaSt8qJbU136/s/VhloT2sxecNphZ1z8VkE2YUncANaaVlEsw3eYXV5d0bNWD+1DsSEiSs0oG60LpB1AjvJmyxXFIMwczFFV9tcPXGrb+PTVJhmWAl89a6njxMzJeeaWCu3wMVIYkeQ6SzcC4ph67yNNBVIOrzBtdnleHwNIhBffTnsVEEGV882mKLj9NKR+IJOe5zQjKv3QA5hfiv/9AqutnlLz+KlDLrJfZLrYxC2yGQZPNORcQ+3u252idlaPZYYZZ+wI5a6mnSQEv76w4wly9cZ2UbBId7rseH/Tz3GJjWRDNktY13za2oVR1pR+vbtgqpC+Qiywpjhdjl8fxWfEMLHuSskaC/hSTegZrAxZGFMvHgYyrhyq4fzaDwsWOig/2XH39s72drWNmXZHnPs1jBg9ybW1lr3k8NQQJlHQ0q4LwIlsY1n62bjNeEuBBdbxU8voPArWsNf3YSDTp/TMquHso45uHKvjQBP8h0VJtaHW06Z7PujgrOXCaYJZqXfDN3A3R2s1RFWYcxUePAQxAhbRyptrq13Bpr7l93Y1VADBSrSYsDy3DFQ4w8X042z0j1Oahlhv2I4wOL2Ngkpxmx9oUUqvJgNr0E3Tx0d1Omgmx4aitl9ub4uXGXS3pEaSe7Wk3MwLgldAHMqYDIlHh+4yiKTcwkPN0MACPKX7i7vI/rW1UEaJ0rI0vhQzvPv3dzQdIvr4g6uJiAFghxDnW4XOXG3eljjbT9P7PaqtLrvuOe+CaURClhlJx7Vh1P9+gVMvAQM57oPaSTtJLsCCkpp88ddJSkNiXZNNH4Lq91MHfso5mPYz7tCNztdUlsJDg/ChNs3nBJdb7aTa0m+zNe5d+fy8N5Pn6+k2tXm0pCqtHCZB42DxHBrr8JcUrmvR+KIJrTx9tvZ1wL5bdAJHnlo8Ug//UQIbHpmO1n+cEuHrbgL7YWKZYPhMUzbJU4+9pwXnf/uXNji2ZXukwWDb92Nr9Sq97/KmB7AKQ5gxgicdReBCE0axQYh0xYl7Glraln/hJAEjwDIVPYKUg9uF/II7u4QXTPrIb+M/zUl8HVP/cvkHGso+UuOduWHkPhA0q1tGmL9UMvquLLQdOVEgSBrjOcoqLzbiOdwhWEhE/h/972ocdlufXN8i5gCZ5vV7H+UsVIEcU7gMwlwbGzomJ3l1ee6QF7UMPX6ivfRkJfU/GnfS/CS5RVPUtiqzgft57DPL3wYNcb1w/VHKzV/DdT4pi6cYUHrirgx0VLcIvX2r59ozj7bFbzcnZ182GwHbPe+bXAX3gIBd5GLyU1ME3Tx/dfMCbGrIoJLVAzMKaa6s1xIwDIsIG6Of02uHReuM61EqsVFMSHJNon2iGiOKaDOT604dbb7vPZBKrgbq++9DSEsr4d+ogG1dZButY5vj/UAY1rYL7ICAiG+0WS/JmZOO+akORhnowFFmOE8/IeAkutpBTS8c4zQmVAHo7jX1qPlxQzJ4eJPinDrLvALibD4B4AsdjcXWJSJ53Taos9r2laHWy3bBE0vgf84trj3Qc/AqOC6wKrVofwkaXQ6BxlQKyLxUWKBuv8DMdfmTOxKUDtUAxrA31PA6Igjikl0RdxEK4zDpQK6wG7KaZT8AZpMRmXWtIIFuGUFra3zgSUi2/UHLLhDtj+QAbHFsSJhstwyVSqglb2XykwKax8pif87W1jd1mNuvptNJTpYBsnQa9z8lTk99zzC9XAjhODLONdTT4cwjuI6BvOG/1tRXeICGxON9ulp2oX56E+nY1H38aIdJSQD6uLjrMe/4tWwdvVATi0FIss1fIzstMoK64FAN3g2QT0qdpnQaIeR90KCCnPZTLn7hQX/tMqdYnRDNgfe4jESpIVnjTYktjmqKau5G50unSxrqDR41lKbujf1mEyDzwiv4+cJCzHIM8h+Gt+tqGUOLPYBxBt/6QpveZOQq7mpn6AFKSOA8Kl5+s5c0OcQ/jkjdv309zpX3eXpGKLnz4k1IJBg5yFls+jz5lNjAprvj8NgT2W37wPmH1m/ApqW9J6X1J6sDGMmzvDFgbiqJZIcW6IDpQQjQN8CfkLhchVI6UdZEXoXMflu3gxKmpZtXvuWYhn29INRSvBBQ3kUfkDZIzMlmc56JqoOhxA5fkIjfmTe6HUl+LlX7Sq4yMWZ9M8+Lrs1fYlVkp2DkA1goy4ki8Cknf+ETHQRPLhwKyK2mwAtgFBm1WivDPJOK3XfC6TDzk+Uhe3N3Z+pBd9ljFWyKQlSAmgh5mB0dQWC1aqHOaVkepIAPM7+mo4seV/TiDq/+YdksUVohkbYbk5mHCwPc3NTdR6u4Nri2dtdLeGJCLqpK0MgkEk8AYMoTxh9v3mOOGa4YiuKl161eGEZrw4tzsM0w+SfETHYQrWutzvLkiLv30BCUSRd7DPaZUSe734dqOSr1xfVrJzUMZLwklqi9JmsJLN/xpvb2giTiH+QgJv0PI6Y1YqGagZU0rdT+rpC0va/I66aqRBrm9QZmQ6KEpReNlPQ/yi5bXuWbb1fOIebibmbHRkxBpFgEyLZpnU2G2KDOtvK2o0AwNZMMQTfjJ/LA+xdblLYMqh+Ng+3KKybrM6roW9A3F8jFJtUJK3kXAXki64jJCfXON+c8zYVSVNHUOhBp+Dpd000vCi5qAQwMZL+S/QK80vc1gg6F/666bePU3NXhmL5iUeLlxVwg6wHlE8q4MxUUGs1Nj2F1C3I+LXTRtNVSQiyy3tMDRW7W1DUH6CegBr2T8GZFYIk33tFZ3TRVVfe2zaRV8iOwKTEH3Q7ANLGN5Dva565q/denvfvLd1//zT2nPlaeze73LUEDOC3W6jPoi4UsU8hwSGXeaGZ1cXgELQim9xWmnrKYoSSwZq6DN/+jyPGvrN3ebWx8WEQz/mKGA3OtBmSjo1mB3OSPIlMgYXQIWYIpxUAjlEh232VJwD0l29dGYqzeugQEaq9ZWO8aBZiagGiTs0aLOSz9gjxzI/sMzV44BbG+SSQFmTOpgSpw5H+mWkFJWYxXdZwCNGWf+6fP4IGklFtxCwv3NZSL1A2bWsSMLsu0ggNS+WiDSIot/nFZ4A5BCLS8iHJpZFOSw/GGqyUgdZHSGAUb6dcAeOZB5d5exrIJx775cWkzaqgt97aUSn7S5dE4pMet0CsPKYWQL7ItuYlZ/6y9a1Poojzg5chuf+0AmyyxjVDn1bOuAc0yuD2Il6BvEhlGvXbQpSVd5RFLrh+TgYUoKqxdgRT+Qe42RkOR+Hpxb4yBI73ZF5HoTIWkWYUxrZTSWJclvSaorXAzvs/tN4pbiJTeLzcekMUOzkhIjLclFdF0WgYXPzcrn8e+GFqai+8icgMHkrpoknVVxQ6sX6uufPd3ZMpaLv+EWed6RN+HSXiIv9eMGb9haMNVWjir4eX39JgrhmSpmStYCdSWOo2/9Ll18v0EF70dCXbjU2SyQ/conTkOxlHO2e4biJa4jdNJMNSHVEtSIbWBiy4xNyZsUFeZwpN27H1U2kiZcP42m3Y3Lley2nZt0TmQLRAVhVcZi1sQ66qtfaBV+BE+S9SzqsUnKq6TU53BQXkTRg//4l3/6cwZQr2XGjYQkp72YyyRKc1DadYAOmwjHZZLBk9bv+Ago0PRtYpQMx0psBUQHbsE7TMBAyotQNW0dX7DPHR8/siD32mBcIowfTHc7wEANmRK02vsVQWfWtVTfQjXMEKHuG9nrClFccXuC+pE11ssoMsrrsDiS6iJvp/YBtJtWuIIMh5CiylYClxSzzXyh3rieWAuiWts4x7NMOqA3lonkY1PrTdMHQsZLfK3544Gg11IVeMexlGRWC9CxYB6hWQn+hgA8ZzKMJyjUZqTlJpMUsVn65iDOD1TczOxmUF+/8VKJT7OalBRxZsYK5AJ2a1vqPGK5mLdgdVzvDPJ4TzVlyuLUgetiF8mOjBXIaS/kqhRYEbs7t9/1gYJzoVR8DwQZTfoJqWAfutiv9fbjJL4jUqQIM+0jjQ3IWfZqWhYZQXyiiLvSGr2Ml0fxzyHJB2CDcp6wU8WKCiwrpWyhaMJmZ1tD5OwfPfX2SIHcy7Nz83p+/IEBMCpCiwoKf0yP0HrjWkBils0vfCg4I25vzy5v0WSnu9pCtMF769LqT777+vax1FQRdv7YgOxKEncQYIqXCxpLfMfb6+7dzOmnIzUjfiTVnzgPaDZTr9Xaz+urX/w+UT8Xams7ilrvpVEK8thHIwVynkmX9XubOpC0ZECphJDhDSLxNXfx+tnixtIfHm6aPkda6+dS0NWnD2/V/ToTF7BBuNTjbcItNpYR3Emr10ZzvsRmFj+tfXDR6tnG8gzJB67UIzstw7PrWtE3yFy3M9laVmeU3HTbF8Pz83sr9Qp72ipbq+PHQpLTcnOQkO4YhqnvI2StO82eGncQm3AD+4kaQXNWbeq1Nd3zm/XZ++WPqsvKfFs7vlNGNxYgGwlzLILMWAfp9ZfUsYXTjkM2PJDBAjodhFJf3d3Z+siw8gPV7vI1qBDnWMcu8nS3r0vduYBp3ccBKoZO+V5dAZ1cyOUeC0nOA9V3IpBY1Qr5P1uXDXLi7qPtFX8ZW5JNCFKMmWLpmolGHXViIEY1+ZE7JkTmtSMeO5AxWUcIrY/i+Ktk0+uSJqNPpfp4b2f7PTc0if/3kq7mPIAXq6PnLj3LBJykWidFgh0RXNdnkBal044dyAxcspSfz9dX/9dLFb4HJ4NZ/C51AOAEUq/HKn5gy4TtxAib+db7SqGtMy34ZPAsVeFKd48V1vXhxxbktBfsUG27y3/tTm/HznU4z/EXlDgXnTYPagMJ19cdf4RgVKTE59wkZWRBLhLdcqXabzqCrlyHsXzQNucSb05qWlfq6N00z80SZdR1n5F/0sDQyFsXaca/K71sMdhgELIcUQXdt1ywuxpIJcxPDg5Z+m3rPupMwN8AE18oeTGi1r02l84pvE9TH0U5GCMryXkWhWFoKnkPbRrOxmHze6IK8nOc7XA7wtjMiR1i4Ol004ZHyOAd2Mu+g8PH+i0puUvBDyiqxUTkNhMc61BnHuju7708MWvGgcw4hZKHWdRh7zVvP2ZSocvozCLV+Kosb9WNrST3A/pf/83f//jsdHgFvYvAFEXfZfTT4EzLjNQ3pZT3TSPWS++//fTrf/7GlXj8f54t3Ot5xhJkQxcI9aXd3219jpdjk43kVM2vvTY6W6o2v4IHxfy/o9b22VCfc+dKWbUSf7HXvFXHdaG3pSQqQoZ800A2mQ7XDfa9MZ+z7G5aTFgkIVckBV+ibRrMOnQUdydM9HI0+iWJj5ski/na+o28IBAHlHhDQuTtVfTq2X/8yz9ho1uwUicqMQVP0ObhBzL+LFLBJwHFVTecmcaHTtsc0z6I+2HHDWR/VRrPyg0AubqUu2mBsCKI3iHSz1Dbxxsa1wGiYjWt97LbR85vsu3270hLm7n8jZEHmZe3T/Y2RBeaWkZFUpok5TQxEZUkuWobANrG19wuDZYHJPp4NK8zojQrcvcXYcK5nbbcF+bxGpLiWiDpIql4C0MImDBuNrpLqz95JUNDOjxLBL7cRbat7aaIDxLXoGb66bo78pJcxFRz6wLdZepKIv+/bZsTV6UUl5RSn8NLtARE0LXUF7s72//V2tKrtRdR/C0zPYtG3P4iJNnVyczeVMFMFUnUFNv3+YXaBxd1EC5g3on5XU6vdJpKNe5wyLRXIiBPEMZektNiCmZDC9QyN3Vyu3El/D9TMmZNN/3ELV/zA/fgchjX2Qz5oiqC+yzpRYuCxhLk+cXV9d2Ht7eYzQlzjE2vJGjflkZjcqHqVB3dM47H5cZdDHyBlKOGBG113IHi/obZ7rKYEGfgmPSrOsYS5LzlybYs9CzPYuVzoL8DLSqoGUFZA5H4ay30A7RycDuJIwC1t7P9SZpeN5LskQ+zNlxjkRd54HE8JpG2xx3ehR3rHMZqPyJZAReOAz2GkEjqMSmh/c5evZKp3Z6kHR/9Rm98adwMn9DNGRJF6vlhFD/uWA52+BdzlFkvw4BmAnmW91dEAMdWkn++uPYxJ1OZrTMtp5aZXNhr+UJyifRFLegeRhy5kysBGqJ2nQ9gHRAAjw3wD83bsEL6qrUeW5BTs8fJtLO01JJb8sDnshTOSLUhlD7QFNyHSgmUvLH7aPs/43dXJVg3XN/Z3dk6xoHuJdFjC3KRZeomUNOOtw2vA4z//MXvDZPog2oUyNQBXIXu98vVGrp9+aHRNxpkYwsvNtZFHD02Y0FrKMhRz8zUHanWYxU96OTzGssvotZXZ8PgIs6DDQzJfSnjFUFilh0UH2y/fU/aRjm2IL/1y3+48t3vftPugOW9fC/6lP9bQnJZ2yFJz/z2vYW65eYMIxhbkHstX9+qYOmyOjW6A94yxmcgFSVJ33lB4l0eRQczLLt04mSTg8cCZJNRDugivLwiutE9BnFgNFDV9GqrM80SNIK47SXy8caCCIhgSyfm3HEKWNIEsJ/nGAuQi74QdwZQJJ8jIGQl9/gYDC6aZJcb5EQeS8eboWl8LcUyq4+snvtFnm1sQfZ1ZadbAAjcasH33JjDhvO4Y7ixPqSouMlXDH7hAQU8VQJAShksv1DCTBpmYNP6H71RHp+fmUhrceZWSblBnU5s2dJhiaYXeJgAGve1VNxuaeaD5kfperndCalmY2wl2X95pl05erdCUn+8t7PVptCawE69ce3FUWsbHp3R14bgIv6M+j5QtTBB2I3K8X1YXYA1hKJ4/nsBovibGyBib83m8GzHWgMyeilLuaBIP+PxcH6NCAguOpxasGHNTl7P/7Bp9C8+xmRrkoav4yrJvexgvGf7d0jaFFHFz8l1R9CsRANUn+DiA5tVqOkfN+6UAAHidyzocz+NbyJlYVQViD0kuTrj9SV9L7pMuyQe3KLp/amkBTz3/GzTbVOkOK/p1Buz8VnLYnqWU0Gd3d6Sv61bnKgHDBpQ+iCJoLV1KSJtMjyj2QnB6CMt4T7bOhO/h4a/4fmNpHqZcuOqLnqap0g3cR84jrhxuUOQfBzbSdy2AkbRZBD+8GM20cDpwBgkBPZtHDmq+pOHe+lj/+HeFJCPeWYpWQpzjEmeSnVfqKDxUon3oCpCGVzTKviQ++E7IHVd16ygIGzX+7mbXJpFwr+PNci8uaS0tDHRNwTkobctXzn+YpqCd19JtePqa1fq/E3SnffUa8M7zld+v+LGtEceZNPLM9S/YJqsCwoY8F1TzDqlts/A/GR2va9P7WZoByBCN/+n8Izmmmv3g6HuxE56gK5H/7jeU4xZl/uu/MiDzPZuFgk7zRlA24SnCccY5x+n1nZsX55rnU4atN24sjaArB4Yb5ROtpvP4ayfburlhXFXF5JywQwViPVzcDastKJd8/GMtcsa5dbDUEMXFtd20M6h5y48jpQA2ylFrfM8Pi5NcFsfuDUc7sQyeH6gYWHZcyZahXIWKSMifUkr+W+dCtRO6wXfNu6n/I09o7wPMXK/u40/DIU2CBfS5uxBF5Okq6hYtbw4aWiy9p9tg8MmGg9sIZomeIdMAUA7yjTucj+gjIVO9l8oJygj5mob57taQfIGVlutoe+yNgPK7cwSrADEjVsq2HJdb6vHwzZ1th9Qx0onpxFKnF6cqfyH+XrjX18qafSk8ebqaytK6QNYIaZHvoyvYbTclAyX0AWRrxdQsFBkxEW/9SIjry6ypMnO4QsbbicAV3q6R8bZDiokp03nAOYyxyRnA5o2xZU4t3ty2kZN0tEBOx742O2P5jVDzVhVXU7MyKuLucW1j+M4+KoXsz2NouUDk7jFz21hTrRvByLSAQ95cTczfMQpM2dq+sC0A/bscfeDpjlC3BB7bDy+FPK1md7OZhs2N0FqH4CYSe1azMYqfmJBkrPY0NqeYae5CAtXm27Fo47QaNVyli33wo2DuCHUtGIgBtVvYTbykuxtImKutrbsTnN36Vo9u1vVG9eVUE9kTAfY6LSSB1k62GyGYuocavzcj5z0+/zUTHXwarV7bYxjBTK7ub28QDe5aUBPhiB26+wPqtDBbq6vlZhuOM5UvAbqyknHL4+VdZFmusHetZSr1RqHH7mxnpFAwuSboKoCfYDuAehbzz3i3HiGAdMQFPU+4hJYHdYSCGc10ROoHt8+Lti15ZhQj5Ukpy1Jt70YT/k1gz2JDjjekXiJN5Q6+hT9LexHSidtpwWT3GG4RetE3Gcde5Bd1eGnmfwhim7cwcwe0cE3kWwJV2KTer2qCqLZ5O9ivrZ6peB0s9Tc49BBLpqYTJNirutw+9jzrKcXkXjeJnIngPobmdW/71fslGB1AIulU+wjz6Pt5KFUN3x7HBbHCyW3fKKLDOI7aQGjoYPsbmZ4aUNXDVsLPmPTlo1Fy2l8OExW2NvZSkbBRRVLjdU3XM4FUvvgViTAiLna++etmYbhtqZ7yxUMHC/iPqclZnttxkMHuchLFTmGa7AlhQdKxlUkRJNxc6axHn/AQ4qXYAtjo4MzYruCR+2Akbey2svfLyvzagN7PuJIg4wX06E+50s1B9hdHZuqTpI2OOY3w3nbvv5f/ubvfxyF0x/DRmYqrVa0zRtap26vsS40YaZfFwOpyAcfKxMuvavgRkXI6AZ61/Nk9bTJCrCBz0q1EUcv7gXyR+d4HF1W3/teTKGTAPvGWBe+GcZVSzYIJGYxGMBmosV9Znmyy2uKJkmeJ62FGbbllPSm2ed+37l+gB85dcFDu9Nyei7tlV+yi7lZX79DpL4WhOKY7Q12OIQQ53Yfbm+b3pxmUoP4BC3NzAaZ4h4jiteiI3IbYBchFmYBP3Igp6kIfniYbFJFDxz1IObqjd92Nz81DVE7lf6mI3d4MCX1Os/Y6za9Op4jB4CYlsvSa1uy22BTuu631a5ZGZShg8wucT/Lr8exJisCErgK1HN+aTdHZzpkERFPknQZRhg0LnR4F/Y07oFjFcVNlmieXllgJEbXIw4d5PnL61d3H9nWY8m/Y17TW4ur698l9SLt9pFJSgnnwBlRLfWVDOTN3UfbS/hbWvkBZ1rYPmaPkFvtkFToUZQ7q7VfgRg6yN4Diwv1xm+zzCYLhlzYbd7ecnkSiSWxo5T6CEF4HYf7Zt6TE0Ri4NFAJImumaEC7jhPNyqH47lwMs9UzAN95EBGS7IiuTZkTCjWX0NPdsUkEKaU8VLSHjJDh66tSKKrLQo+Qssyf5PlaB4Puu21T+QBjN9HBmTjGJC+RhQ/7sHaYVVinvtCff2OXyzjvrSdwxeaEZ2OGjB62+/qnQaWm8IqAuZYWBc+J9hsPour6yKmb+Eua6mvhkdH/6M1FX6x9+jWZbaTra6lqqC4qql1H/EI235MPpghOmAzDcdLGV9D2Zi/4SK2jFnYXZOAU1qsnwTskZHkvIe3qaVuq6Ft2tnfVtz+825rXz6O24bkvAoAAAeqSURBVI6ZuVBe1rkfldCvzVwGyKkx1mKgRhWrc23GA+d01eAh1Z/8YzYQD9AyPSxkvIROsyIIr7jROzc0mvccab9zODWt5UPa8acKspEcLx6bWbfst0d3lqpjSQi0GMOGhJexpQidfvVMDXAbm+I4t3TBmHzt2alJ+YOcqsWqu6Gez/JEDLml5IN+mu65NulJPuaJz+m3ExXfCO5zINUV1OCdDafeITp6PBWJ5/H0FMiHZl4e62EkQXUMGpad53Qk1U5LRe/5c6KYo+y/jMuP499OwhwaGsjeC6WpEvdvTjzXsteZaCJpZhaRNVxvd+cWCts1rAlIMWr3wAyCTYxeFzgmyevV3NlQ3bq6nXBNHdyS1+27l9SdqrrIEXfTptezicWF+vpvXyjx0X5z8/l8fe3/7O7c+m9Z10Fs+NWZYGFK09VY0Tay1+g0y+Ph/KIaV1W9zvLvdxkPE+TUZ+1khmcMhSRjcxHzi40GwpToqtJS0X3U452heMWNNXD2gnNyrMfx3zRmfb/gFT2+dJDzaK9ZnarcBKcIhUYNCRMSOXfncuLQBVFqWvhehe+1a/U686m71FQ3kx4b6bERRkXxTD2ubJDTVIR5MMNpk/LXLSX/O+/gcBDAa7NDC1driEvIWJ5jUC8srjVUHPybomgWNXe8CuDl2cnrhlvxzP9wTBLkECbMw6y51Qlqzt6QzkoaVZ3c9VxpEg4QoAac2IKYv9z490jLd90PgdH1LK3shEBFoFkIyeASzxDhrEjiIXYVtvtgupvikVQ3OGhly9Usi6moeJ+qJGNHDsTU//39oxtfZT1QGtHbPdZnSOL46SCqcaQNH6LTEavTqdD9aEnWmtxx9mnc5zQabFEgR0aSrePQNbLY8Cx8yWAXGnauiTfQ0axXS22CPDpsXXQz2S6Hw6oa62CgjIxIPMtqO+ZSYgcBqn+NU5Vk/2aQbEX6gAdzZ72QF7+FWXdHa3qktfiapFoWQh2cicN7/jRIHh8ED+9MKM4HMqiCUMgDYfl+CA6Ba8GZk5/X12+g+d5pAIxrlgqydSTgiaXnyvglO9JrqVO+vmbzywTrPf1oz43vRKS33c3QNQX99H+/AZ9+P0apIPuZCqtfqYbOVx1vLapC8vAiAYUYivUJ/j8ltivm6mvLaGfD+tlZ9nmeZNr1+sWu8PGlguw/lct7QyY6VvJBQNGs3/aAo3CxEOe/e/SbB9zlirMi3BEAFaIqbr0n6EzX1F8bv4hv+t0LC6P0mgcOE2TPIUD7MHmV0/t+5I1Zl2ag99TMOxy6dJc6/3/a8u/Hwxu0+igF5BQzTczX13/N9mtbFzvhTpxzRkU/DqbEb5mOyq3SEZtAnwr0o8e5Lt8Bjf41yXOYKnkS1o/bUOQ1Bbh9+kBBTjPRcCfeyHoZ8OwSz9DMAVNkEd50E522liNCAN6wgXBtt6G0q7t5GAu6zOLv7mbrb3zoTy+VrHHIdFDg8nUGCvJJH86WIWB+tA0IsTs8v7jaYLXAH1CrUMiQfh0p9ekfm//47YXa2kNknf1geq/QpM+hQyCpSC+Lk77fMEAulI7CsicR/BUCQez1uSsCOjYOxflX0dRjuNRpSdiOSdip+Dcrq9647jomWaTuk4I6ZGdkoyJIr+fxKhjMWMnnQoZai9bFV3rqMefsXNs5LWNhVobTGWtQYJ30OsOQ5NxnNbqXoipJ+XGk5HtQBW6Vk0lFkbpoWj9SVFXIhATyHFrZ8B6QNo4iL06S+2AnPKA0kNPMoq4gDqb3kn7Gfdn8PJsBPtSXvj88+t/I8R3rKluzBZDdpbmW3MJkGS55yPM4T4hl5mmlgJxmXRhem5j6hUs2hNutiXlsx1v0wpL40ZS89PRRu836Mf2OSBoaUsNKQesc1PRlDVnxUTEfshPYHxjWpYBc9GlNF1ghFQPv1owAgEDqBgI5dma1euw6L35I1K+q6kVFYDVzklhxkXcbFZCLWBxmGuQxcmAyW8Sf9HvMFq6trRySDe4XAWaQxwwFZM+BaNNlWfpSavlMFlupV59y3Z0W+tx3j37zFfpXmI0ve0JCkQ84SEyPXWtgIBdt7o80fjw1/bunj7ZMqt+1b3sRwtmBMJ5hUvlvbGndxdg0L8ijOmGVXKg37gyiTOx1vsLAQH6dh0g7F8UxJFXDB8hQbIV+h/V2XjAn7/dBP3fa9coEudCyhaRyJywXIID7fdLn2H+RNCBfh1Y1aODLArlnmYLzUma6elrXQnYyQJ8FD87NdPTqETRowE5yvbJA7poGlvWgXr8fyhk9dJL3LfQcJ7pwj5NKA7nIg/vLPiXldOwy/ehc22mgM6C2yDMN4pihgYyhhXHc+txZ9sfYRX63WH5hrkJN68btr4ZBgPS61xgayEUkMKvE4MLlf7jiuNZdGPjXTWt387qg9Xv+0EDu90FPerzlu1lqwUmv8brnjSTI8PyQo3M5cJxu8jqwvO77l3L+SILsLXkzVwT9LXohgnPShraUgmLOTUYS5CLAuERDHI9NEi17c2qjCzlERe7fzzFjC7KfDM17aRsr1utFmznlXa+f38cW5H5eEscWoSX0e82ix//FgFwUkNM4bmRBHlbS8y8KZDgRSmgNguFpvHiZ1/z/acEnILQ1wrcAAAAASUVORK5CYII='
            />
            <image
                id='image1_715_435373'
                width='111'
                height='131'
                xlinkHref='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG8AAACDCAYAAACDQ0WZAAASuklEQVR4Xu1dy5XbxhIlwc9WfmvbxDACyxFIikByBJIisF4EGkdgOQLLEUiOwHIEliPAcOS99bbiZ965dar6FArdAMhpfMnZaERiGo2+qOr63KqeTi4/g12B6WBnfpn45ALegF+CC3gX8Aa8AgOe+kXyLuANeAUGPPWL5F3AG/AKDHjqF8m7gBdvBbIs+2q9Xn+ON+J4R+qV5GVZdoWlXq/XN+Nd8nhP1ivw4j3WeYw0WPCgXieTCVTs2UrpkMGDigV4H89DzopPOVjwzhUw/dyjB2/M1mtn4GFRZ7PZ69Vq9V/9NtnFzrLsxXq9fnuqpGVZ9nCsqrUz8ACGXVj8n/exD6eCdU5/1yl457TQTTxrL8DLsuzxer2ulDZ2D3Dte7sYY1aPIeAbBa+usZBl2TMfIE28rWMas1Hw/vnnn+fffPPNb/ddMIA7mUxgeFzLXjmZTG7OPQbaKHhVoLGB8tkXJTkVeMRHfePBal0sFncxXqaq52rr+07Bi/2QHNg+m6hL6+BBAiaTyYeAdOR8MgYDnxUMFAG+7r4a+0Xpw3hdgIeAMtI+lLNj1Un7F+9tHwPAvppMJm/1PsfWJ2KcNNa5BalbB89j4hfchNvb219Xq9VL39sNtwJg6aiJgGg+I1DHbNS0Dl6VT5dlGSSM1CSHz15qH66ummT1DGk8ObTWB9VYNod7g8dvPfaloJOtF1zHKuVz7efxPgeL8YN8ry1PgLter9+YeGjOwhSw6wLdd5Aac9JrgucNDmdZ9ma9Xr9S0gaViJdAwPOa/TaQzT6ge3nqRls+ffr047fffvvL2YIX48H5BcBQFPoS1ap9Nt7rYMw4ctLt7e3PNisRYz5DGePeavOUBw050sr8d5LKexcAA93hZjabATCvMVM2lzH6gF2BV5mju729/SNJkrfb7fbPMjcgtK+dA8elE/C0hACk1Wr1xDrd2A8Xi8Vfh8PhsUiaGC4eAyfnEsheVmXZnqI1+vQ3rYB3e3v7br/fvwz5XFjsJEluvv766999jjqrzvfKsc/5hmzw5Bz4Pi1yU3NpBDyxIkMhrE+fPr3e7Xa/w6lm9QbznzIG+NlsNpA4SOPD5XL5AKByNMaRchlkRGaIPabVJH8HHy8YVmtqQdsctxHwKgwHcFd+1ZIoBowAybFPZ/oz2H/DhZjP53c+8z4UB63rNrS56LHu1Tp4MnGoyt1u97d27hWIQYOGVSjio1CjN0xkOskCjbWIXY3TGXjG0UayVSQNjrmoQoTK8DnSPPS91DNApbKEOr/v1BxgV4t/3/v2AjzfQ+jQGZx39vMAIPw9DbCrKmK1e42ojfYZddbdGj/3XcAu/74x8FhCYIi4hTTSpo0PlylQ0RZIFgwSqkXgCAt+/Tibzd7BvcC1i8Xiqc6Oc4oJxopI74W3eewbVkJHoMXkRQZoiPq7ghEGD2oUvhtCZdjfkMBFaKwQ/JbvbbD62PkO8frGJC+gCgEWVF4hTRNikCkjBpLo5bsMceFjzLl18Kx1qROmOtTF1ij8O1ie14Ek7MP5fP5Iuw4AG/HPsqBAjIXrwxitgmcfGAudJMkfaZqueV+jfY6vw++URWBAftzv9wATKhXRFKheSil5xj2L0uhOwJMQmK2vYzBfHQ6H94vFIoUhIgYIJGy32/0WCrEJjZDTSk4ts8Riz4QVOqpCzGjgsQkOSQkWO5qMuuOYCGeFLVTx2yS35zLn6ntyFSB57Kwj647fAVBlM4I6c+2DWqyaQ0zwyBfTb7cOMvvM+oowGtQmfgAGcTGlimg2m0GFojRMWGOVgHnclMGTk6KBV/WW4Htkvvf7/U+8jxWsR09tHtwEcdAhqeB7EkVw7EHnOuvZKngq6gGjw2UE1OfXi8Ui2263v7PFCOkCaLRXWZWI/UyyDiyVuNbL+1T3qEwE11m4PlzTCXhsWTpyUZZl2KvgDhAhl39gZEA6YU3ic8eclvwdf+7o7WyVImPxQ5lhM5ZK2dbBq2BFi5qUSApRCsVQMSxrctirKPFjVrGNg2cXV8UoARTtYSJqyAowZ8XFROGsT6fTzxK/FKoh/D2mDV4tFotHoeqfKrJTH9TfqXNoBDzNHQkRgSytz0ZekiR5dzgcsOcRyPP5HBzLn1hlAnQJPJeCd+rCDOHvmgKvViTfSoXseWKNKoDIh+MFlX1R74EwVNz/TyHTDpFd3Qh4dd5azoC/nk6nNxKblIIRqMTlcvmXcFeUpfgY9QsctyQL1MOHwccu36f+NtgxqWrfrPM8XVzTGnhSoxAgDuVqHaSGT0uTWKhsfQI4Up0malMIFPDfkbVqgwhdLHjMe7YGXtmk2YgRX64Qf2SJhOpEIPqjyjhgWCRkv1MGTaisORisHipBtxfgaWtTgfBssVg8uLu7u2JDhbr8mRSSi74olwJpohTkJg5SO0ph6AXSlUkxJaPpsRoHT6dtZE8LOcnGSiViraVFCHgeprV2+knKfEYIq+2ci9L0Ijc1fhvgFdRVXTWlmGKfpU+Zpwxa4p2iVkvTPkO0KkPgNw4erEGoPT0BhMM4BkkcFVWPnpMIk/Khv2HDg3gvMEDm8/lzZl8j2gIA8R2k0JWKNfXmdz1u4+BV7DMTiY74+ksH1J7sczK0WJGFPKK1bLte7Nj3jwreMSqp6lokaPf7/UbXMPgeXnw03gvLSqu9mYzYC9rmeLHBg1TgJ9etwT6Qj9lsy7F8uT0prGTAENuk2nTeQ3Fvkb6q3i1CJRx0i+Oo4FW9dZvN5m2api94b8LCS4Yc0Q8KRqv0kFibmpxLWQfez2wTAeF6ioUqyV4vQGOwOlsFzxgtrju7WJ9cPYRMu24OIE1yqG5BEZNIesRwYWIu0eHrEI18e2zVy9e377sET0tUKCpCqlB8NpZO6fwHSSPwVAD7GRx0WwLGUgZVXtnTs28Alc2ncfBCpcUqL0fmv11Y+d5XAsb7HHE2OTD9i9AmfBl0SFlZzm9IgOm5Ng6e3KzKujQq9aHEKwUcgMIxzT+VpLnyZo6PIs75gPmeoyfetgketaUqaQr3fj6fP4XK8zRHdb0ydXaCDRcyTCTuKXRAMLGRzFUxT2rMo14m8Q+Pog32SUpbA6/OopnYJu2DJuWjrc1cZEarXl9dA6vaUTWT6wI8WXSvJJomcZAO7IdEXzcNdXQNXi7Rei7dIaKCV9VlKLTvbTabN2mawsdDs4FCfTlT+nCABjoAwkVAlwcASySkPqmyNucSGzzhV4aKIF1bfaMOAQQFk5V6BUjw2eB0C1DXm80mOxwOaF8lfuLbYxhixxhObQJxyr2igld3AmyQAEiSGk08QsOd1Wr1gwJRF5poqYOhIdxNicYQG1osT9WMwO2dxxSk1H2erq7rBDwxHlS9ea72QCVgiepuWhMDQCl5Jun0FLhAKqWSiBz9UxvOdQVMnfs2Ap5OmJZNwtfghiUDf4bYJ4ov36Vp+h87jo8JzXlCOO+DNf/rgCbXNAUeha5MuZevQ63b14yTTtYjS5VuNkBSB0d8t9u9uru7e2KBKuvBGYr2WOf/mAXs8tpGwPM9kGQLKiQRoE+m0+nzq6sr2vfsEWzCmGZnHBIGY0a6SlCayNY2qH21wOeU74Yora2BFwJNjAuhLUggWhksVEHkkUx8JE53Lu3DahtSCl8w50qMqRdZZ+D5JFE4K5JUVdkEws4YLg85GI2ziryHbAQ0QC0qfpfqsO69Wwevpvp8sVwu//3y5QuC0J+5Xyc63r4VwlGdw36FnMthttFV07YOnlF/RKyVLIAqYYaqfKb8NRgtFCJDNOZwOEgQAP/mztMLncFwjCNf983v+rrWwGNCEZ0Pq4okdULWpYGsH6i6RcACpYz6bDZ7zk0FXqAH5263A1kJdD+yascUSQm9JI2AJ/XhJtwFycHCC4vLF0LTLGmXoFW9pQE2DBE00aGoyXQ6fXd1daV7VEtvM4rG2LOHbKO5rqXnPvePDl6dsw6qLD4OPlNcM2R0sKsgh2e4/azG2AXKxaXE64hXSKk2IRfZhgFSVOJO5sqyDJILSYJqhOuAIDYVnnB2QbgtuQy6CYAHK4iGKJHRJe8IDOGAX6OIElalLYjU6SEJhZXR9WDczOfz76R+XdJTqi7vA1utYKcNmq/ZaHisCkDJ34VU4nK5TLlNv+xfIqH2uBorZTlGmu8ItjpqvWr+ffm+FcmDxIhLUBJpse2GrQvgVKlq45hjPuu9S6eZ+rLYsefRCni++KHn7AVqlqOa6UiHW6R/YPqTK7HdbjFnWKzY8yBpVBUkZFy+F7GnebzRnq0QBTwfqfWYTuuyl7EBIjk8aZBDDd6wXyVJ8n673SI9RC2LQ6xndX4eqVtEZYZ81Fqjfl4gil87hmh7skg5sh5X1fG5fU1LtK9gU9W6D77Dnw/AKJJXpss3m83rNE3R/KZAuwvVz93c3MDx/kEki7PgjhqBkmaOruDW8PHQtwz7H9Ru7lTL2PtMn8ZrHDx5WH14oS8LrrkrzBb7EQcbSgdbS9bl9o9oGkCUCBMzLbTs79Oix5pLa+CVWZmGMCtnDYHtjH2PmGXChFZVQjn1WbUg7NhTWK3q2qF83wl4vD/RyV3apJc9SlI4UINJklylaSrd3amt/ylBZ6hVpJlsV6WhANXJnmdvqit2eE+j1vtsfOBfIhCpThCFKlfeK4njos4YwnFt5NwPGZBj5t6J5FU56ty6caPLo23AWbq+c80eUR7E4mQ1i7joqOrx7LpFBU/7XXqxBQx99rlHImElwvhwqpQrfZDukQITSsiytYn2IIXad1X3V6tC9pg3vW/XxgYPxgUdl6YPo5dGcLyXFSiALDUFv1AB8RW3pPofHPQkSX5N0/T7OouprVXpDj8WiYwKXp3FZKAKlqLpbOQYY5pIixdiuVxmX758wQkosEpTLj7xdVmiHpwcYfnuEmGpi07Jdaxa5cg1b9zRdEVyXeDFF1ThNNwJ2fSf2al3OT/j9+UOCI7wGL0YoivJk0bg0s1B1+BBRVIsUtSc5nIGaO7SgwXjuv4svVjhBifROHgmskIcFEuiVeeauxbEUjwiPqFU/CC1tN1usfdRldFms7mGH4g1KguGj6F1R3Rrs6r1/THNapjqQAc2qU7vRIWw9xHnvi59QbokjekklHtLXhXhx+MSFIpQzP7kWF92jwv10CzxGyszG0OWyHuDF0Ol+1jUInnq4Asq2+IG4VCblKSV+/P1OLobfaeFu1mocwi8TJDuwSVto4Fn6XOhciprBVpHm7MFqD/A3kh16kmSYF/D/vbv4XB4whl1AkrGC9Q+OCmuUu8xXsK2x4gJnqtGLXsI3c/ZSAva7j+H32YAFkoDsgHkYuj2jBY0Q/Vz3d7rvExtL/597xcNvKqJ4M2fzWaP9vv9L7hWH6HNERndzUgAA1D4nDgsqlkOJWCP3U+r5ji071sDr8So0Gznx6arH8ArNPOGdImVycWWuc5KcthUkiQvOJ00ylZWrYFnc3C+niu6j4t2MfTB9YiTLhaLO7wMXF0E31Fo7/S7r0BTUk1Dk66y+TYOnioScfuPHCEjnR70vqVCX9LNIVf146EMkmOvcoCjJBv5QIwKns8h92W9A58JOxrmvz5uxmUqfA8ASZxOp0+lhn1MklX1LLHBqxUA1qdsiQmvQ1taTeIBLC+0DhsaY8jBwENsFlAFHL6PDR6xnOvS72yjb0xIRVV8aR6SQtxjuVy+43oG70H3DDoBaN0PWRjbbanOgvXpmqjgyYIZ51laTkkOr+wcdWrLodpxSAb9jXA5+R65itpTq36ODe31CbjokhfYkwpd2j3+GbkIOKWZM/EIROfa/AtpV4wTO4acLVRWgdS3xb/vfKJLXp0JKdVIZj+fE5uzEhWZiD6XSqPtdgti0tH8FHkZxkKBaEvyCu2AVbREyLTSZph8NPbVsOehChbRltzpzT71rF8a1YCglgFV54Xr4zWdSJ6qWtWZAoTN4CK4Umd9MqU0TN3v93SoFM5gWK1WTzw1eYVOgX1c+BhzahW8QJcIyZ5LpEQ3TJUaPXwGoMlQ4azC957WVO6gjRiL0/cxGgWvKtEpZCRpkCM+3Ww2e8qsMFGZV/P5/JHnsAsvjZDHcc3EQyAMPU3UBnjBcJVOD+kFVpYl9WJR5wvl0k62q1HVYVIeK9fbHaLvEifziwKez9mWGzAvhQ7q9UmE7cQOY2M6nX7c7XZTfUqXil1KaumljZyorhE5UOQAqqGAUneeUcCrczPLtSwrtWKGNaROelBT44AkSR4dDgdk2W3fFp0LxHegP4y+63ub4AUPpAB9L0mSOzmeVGfYlQRLdoEaquJHeCdK4rzn015im3XEq+Y1Om+nVamhN0jUhaqFpAaCr5fTTq7n8/m/aJyz3W5RJQtgwZqmsjB2zCGVlcdt15x6ry77P2pkWVZ5c4r2AAAAAElFTkSuQmCC'
            />
        </defs>
    </svg>
);

export default PersonWithChecklistSvg;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import TrialBenefitsModalStepMore from './trial_benefits_modal_step_more';

import './trial_benefits_modal_step.scss';

export type TrialBenefitsModalStepProps = {
    id: string;
    title: string;
    description: string | JSX.Element;
    svgWrapperClassName: string;
    svgElement: React.ReactNode;
    bottomLeftMessage?: string;
    buttonLabel?: string;
    pageURL?: string;
    isCloud?: boolean;
    onClose?: () => void;
}

const TrialBenefitsModalStep = (
    {
        id,
        title,
        description,
        svgWrapperClassName,
        svgElement,
        bottomLeftMessage,
        buttonLabel,
        pageURL,
        onClose,
    }: TrialBenefitsModalStepProps) => {
    return (
        <div
            id={`trialBenefitsModalStep-${id}`}
            className='TrialBenefitsModalStep slide-container'
        >
            <div className='title'>
                {title}
            </div>
            <div className='description'>
                {description}
            </div>
            {(pageURL && buttonLabel) && (
                <TrialBenefitsModalStepMore
                    id={id}
                    route={pageURL}
                    message={buttonLabel}
                    onClick={onClose}
                />
            )}
            <div className={`${svgWrapperClassName} svg-wrapper`}>
                {svgElement}
            </div>
            {bottomLeftMessage && (
                <div className='bottom-text-left-message'>
                    {bottomLeftMessage}
                </div>
            )}
        </div>
    );
};

export default TrialBenefitsModalStep;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useEffect, useMemo} from 'react';
import {useSelector} from 'react-redux';
import {FormattedMessage, useIntl} from 'react-intl';

import {matchPath, useLocation} from 'react-router-dom';

import moment from 'moment';

import {trackEvent} from 'actions/telemetry_actions';

import {ConsolePages, ModalIdentifiers, TELEMETRY_CATEGORIES} from 'utils/constants';

import {getLicense} from 'mattermost-redux/selectors/entities/general';

import {isModalOpen} from 'selectors/views/modals';
import {GlobalState} from 'types/store';

import Carousel from 'components/common/carousel/carousel';
import GenericModal from 'components/generic_modal';
import HandsSvg from 'components/common/svg_images_components/hands_svg';
import GuestAccessSvg from 'components/common/svg_images_components/guest_access_svg';
import MonitorImacLikeSVG from 'components/common/svg_images_components/monitor_imaclike_svg';
import SystemRolesSVG from 'components/admin_console/feature_discovery/features/images/system_roles_svg';
import PersonWithChecklistSvg from 'components/common/svg_images_components/person_with_checklist';
import BlockableLink from 'components/admin_console/blockable_link';
import useOpenInvitePeopleModal from 'components/common/hooks/useOpenInvitePeopleModal';

import TrialBenefitsModalStep, {TrialBenefitsModalStepProps} from './trial_benefits_modal_step';

import './trial_benefits_modal.scss';

export type Props = {
    onClose?: () => void;
    onExited: () => void;
    trialJustStarted?: boolean;
}

const TrialBenefitsModal = ({
    onClose,
    onExited,
    trialJustStarted,
}: Props): JSX.Element | null => {
    const {formatMessage} = useIntl();

    const license = useSelector((state: GlobalState) => getLicense(state));
    const show = useSelector((state: GlobalState) => isModalOpen(state, ModalIdentifiers.TRIAL_BENEFITS_MODAL));

    // determine if the modal will be open from admin console so the action button must be close instead of the invite people CTA
    // since console is team/channel agnostic
    const {pathname} = useLocation();
    const inAdminConsole = matchPath(pathname, {path: '/admin_console'}) != null;

    const isCloud = license?.Cloud === 'true';

    const openInvitePeopleModal = useOpenInvitePeopleModal();

    useEffect(() => {
        if (!trialJustStarted) {
            trackEvent(
                TELEMETRY_CATEGORIES.SELF_HOSTED_START_TRIAL_MODAL,
                'benefits_modal_post_enterprise_view',
            );
        }
    }, []);

    // by default all licence last 30 days plus 8 hours. We use this value as a fallback for the trial license duration information shown in the modal
    const trialLicenseDuration = (1000 * 60 * 60 * 24 * 30) + (1000 * 60 * 60 * 8);
    const trialEndDate = moment.unix((Number(license?.ExpiresAt) || new Date(Date.now()).getTime() + trialLicenseDuration) / 1000).format('MMMM,DD,YYYY');

    const buttonLabel = formatMessage({id: 'learn_more_trial_modal_step.learnMoreAboutFeature', defaultMessage: 'Learn more about this feature.'});

    const steps: TrialBenefitsModalStepProps[] = useMemo(() => [
        {
            id: 'useSso',
            title: formatMessage({id: 'trial_benefits.modal.useSsoTitle', defaultMessage: 'Use SSO (with OpenID, SAML, Google, O365)'}),
            description: formatMessage({id: 'trial_benefits.modal.useSsoDescription', defaultMessage: 'Sign on quickly and easily with our SSO feature that works with OpenID, SAML, Google, and O365.'}),
            svgWrapperClassName: 'guestAccessSvg',
            svgElement: (
                <GuestAccessSvg
                    width={400}
                    height={180}
                />
            ),
            pageURL: 'https://docs.mattermost.com/onboard/sso-saml.html',
            buttonLabel,
        },
        {
            id: 'ldap',
            title: formatMessage({id: 'trial_benefits.modal.ldapTitle', defaultMessage: 'Synchronize your Active Directory/LDAP groups'}),
            description: formatMessage({id: 'trial_benefits.modal.ldapDescription', defaultMessage: 'Use AD/LDAP groups to organize and apply actions to multiple users at once. Manage team and channel memberships, permissions and more.'}),
            svgWrapperClassName: 'personMacSvg',
            svgElement: (
                <MonitorImacLikeSVG
                    width={400}
                    height={180}
                />
            ),
            pageURL: 'https://docs.mattermost.com/onboard/ad-ldap.html',
            buttonLabel,
        },
        {
            id: 'systemConsole',
            title: formatMessage({id: 'trial_benefits.modal.systemConsoleTitle', defaultMessage: 'Provide controlled access to the System Console'}),
            description: formatMessage({id: 'trial_benefits.modal.systemConsoleDescription', defaultMessage: 'Use System Roles to give designated users read and/or write access to select sections of System Console.'}),
            svgWrapperClassName: 'personBoxSvg',
            svgElement: (
                <SystemRolesSVG
                    width={400}
                    height={180}
                />
            ),
            pageURL: ConsolePages.LICENSE,
            buttonLabel,
        },
        {
            id: 'playbooks',
            title: formatMessage({id: 'trial_benefits.modal.playbooksTitle', defaultMessage: 'Playbooks get superpowers'}),
            description: formatMessage({id: 'trial_benefits.modal.playbooksDescription', defaultMessage: 'Create private playbooks, manage granular permissions schemes, and track custom metrics with a dedicated dashboard.'}),
            svgWrapperClassName: 'personSheetSvg',
            svgElement: (
                <PersonWithChecklistSvg
                    width={250}
                    height={200}
                />
            ),
            pageURL: '/playbooks/start',
            buttonLabel: formatMessage({id: 'trial_benefits.modal.playbooksButton', defaultMessage: 'Open Playbooks'}),
        },
    ], []);

    let trialJustStartedTitle = formatMessage({id: 'trial_benefits.modal.trialStartTitle', defaultMessage: 'Your trial has started! Explore the benefits of Enterprise'});

    if (isCloud) {
        trialJustStartedTitle = formatMessage({id: 'trial_benefits.modal.trialStartTitleCloud', defaultMessage: 'Your trial has started!'});
    }

    // declares the content shown just after the trial has started
    const trialJustStartedDeclaration = {
        id: 'trialStart',
        title: trialJustStartedTitle,
        description: (
            <>
                <FormattedMessage
                    id='trial_benefits.modal.trialStartedDescriptionIntro'
                    defaultMessage='Welcome to your Mattermost Enterprise trial! It expires on {trialExpirationDate}. '
                    values={{
                        trialExpirationDate: trialEndDate,
                    }}
                />
                <FormattedMessage
                    id='trial_benefits.modal.trialStartedDescriptionBody'
                    defaultMessage='You now have access to <guestAccountsLink>guest accounts</guestAccountsLink>, <autoComplianceReportsLink>automated compliance reports</autoComplianceReportsLink>, and <mobileSecureNotificationsLink>mobile secure-ID push notifications</mobileSecureNotificationsLink>, among many other features.'
                    values={{
                        guestAccountsLink: (text: string) => (
                            <BlockableLink
                                to={ConsolePages.GUEST_ACCOUNTS}
                                onClick={handleOnClose}
                            >
                                {text}
                            </BlockableLink>
                        ),
                        autoComplianceReportsLink: (text: string) => (
                            <BlockableLink
                                to={ConsolePages.COMPLIANCE_EXPORT}
                                onClick={handleOnClose}
                            >
                                {text}
                            </BlockableLink>
                        ),
                        mobileSecureNotificationsLink: (text: string) => (
                            <BlockableLink
                                to={ConsolePages.PUSH_NOTIFICATION_CENTER}
                                onClick={handleOnClose}
                            >
                                {text}
                            </BlockableLink>
                        ),
                    }}
                />
            </>
        ),
        svgWrapperClassName: 'handsSvg',
        svgElement: (
            <HandsSvg
                width={200}
                height={100}
            />
        ),
        bottomLeftMessage: formatMessage({id: 'trial_benefits.modal.onlyVisibleToAdmins', defaultMessage: 'Only visible to admins'}),
        isCloud,
    };

    const handleOnClose = useCallback(() => {
        if (onClose) {
            onClose();
        }

        onExited();
    }, [onClose, onExited]);

    const invitePeople = () => {
        openInvitePeopleModal();
        handleOnClose();
    };

    const handleOnPrevNextSlideClick = useCallback((slideIndex: number) => {
        const slideId = steps[slideIndex - 1]?.id;

        if (slideId) {
            trackEvent(
                TELEMETRY_CATEGORIES.SELF_HOSTED_START_TRIAL_MODAL,
                'benefits_modal_slide_shown_' + slideId,
            );
        }
    }, [steps]);

    const getSlides = useCallback(() => steps.map(({id, ...rest}) => (
        <TrialBenefitsModalStep
            {...rest}
            id={id}
            key={id}
            onClose={handleOnClose}
        />
    )), [steps, handleOnClose]);

    const trialJustStartedScreen = ({
        id,
        title,
        description,
        svgWrapperClassName,
        svgElement,
        bottomLeftMessage,
        isCloud,
    }: TrialBenefitsModalStepProps) => {
        // when we are in cloud, ommit the cta to go to the system console, this because the license changes take some time to get applied (see MM-44463)
        // also, the design of the modal changes a little bit by placing the svg image on top and the title changes too.
        let actionButton = (
            <a
                className={`${isCloud ? 'primary-button' : 'tertiary-button'}`}
                onClick={handleOnClose}
            >
                <FormattedMessage
                    id='trial_benefits_modal.trial_just_started.buttons.close'
                    defaultMessage='Close'
                />
            </a>
        );

        if (isCloud && !inAdminConsole) {
            actionButton = (
                <a
                    className='primary-button'
                    onClick={invitePeople}
                >
                    <FormattedMessage
                        id='trial_benefits_modal.trial_just_started.buttons.invitePeople'
                        defaultMessage='Invite people'
                    />
                </a>
            );
        }
        return (
            <div
                id={`trialBenefitsModalStarted-${id}`}
                className='TrialBenefitsModalStep trial-just-started slide-container'
            >
                {isCloud && <div className={`${svgWrapperClassName} svg-wrapper`}>
                    {svgElement}
                </div>}
                <div className='title'>
                    {title}
                </div>
                <div className='description'>
                    {description}
                </div>
                {!isCloud && <div className={`${svgWrapperClassName} svg-wrapper`}>
                    {svgElement}
                </div>}
                <div className='buttons-section-wrapper'>
                    {actionButton}
                    {!isCloud &&
                        <BlockableLink
                            className='primary-button'
                            to={ConsolePages.GUEST_ACCOUNTS}
                            onClick={handleOnClose}
                        >
                            <FormattedMessage
                                id='trial_benefits_modal.trial_just_started.buttons.setUp'
                                defaultMessage='Set up system console'
                            />
                        </BlockableLink>
                    }
                </div>
                {bottomLeftMessage && (
                    <div className='bottom-text-left-message'>
                        {bottomLeftMessage}
                    </div>
                )}
            </div>
        );
    };

    const content = () => {
        if (trialJustStarted) {
            return trialJustStartedScreen(trialJustStartedDeclaration);
        }
        return (
            <Carousel
                dataSlides={getSlides()}
                id={'trialBenefitsModalCarousel'}
                infiniteSlide={false}
                onNextSlideClick={handleOnPrevNextSlideClick}
                onPrevSlideClick={handleOnPrevNextSlideClick}
            />
        );
    };

    return (
        <GenericModal
            className='TrialBenefitsModal'
            show={show}
            id='trialBenefitsModal'
            onExited={handleOnClose}
        >
            {content()}
        </GenericModal>
    );
};

export default TrialBenefitsModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useDispatch} from 'react-redux';

import {trackEvent} from 'actions/telemetry_actions';
import {openModal} from 'actions/views/modals';
import {ModalIdentifiers} from 'utils/constants';
import InvitationModal from 'components/invitation_modal';

export default function useOpenInvitePeopleModal() {
    const dispatch = useDispatch();
    return () => {
        trackEvent('invite_people', 'click_open_invite_people_modal');
        dispatch(openModal({
            modalId: ModalIdentifiers.INVITATION,
            dialogType: InvitationModal,
        }));
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback} from 'react';
import {useHistory} from 'react-router-dom';

import {trackEvent} from 'actions/telemetry_actions';

import {TELEMETRY_CATEGORIES} from 'utils/constants';

import './trial_benefits_modal_step_more.scss';

export type TrialBenefitsModalStepMoreProps = {
    id: string;
    route: string;
    message: string;
    telemetryId?: string;
    onClick?: () => void;
    styleLink?: boolean; // show as a anchor link
}

const TrialBenefitsModalStepMore = (
    {
        id,
        route,
        message,
        onClick,
        styleLink = false,
        telemetryId = 'benefits_modal',
    }: TrialBenefitsModalStepMoreProps) => {
    const history = useHistory();

    const redirect = useCallback(() => {
        if (route.indexOf('http://') === 0 || route.indexOf('https://') === 0) {
            window.open(route);
        } else {
            history.push(route);
        }

        if (onClick) {
            onClick();
        }

        trackEvent(
            TELEMETRY_CATEGORIES.SELF_HOSTED_START_TRIAL_MODAL,
            telemetryId + '_section_opened_' + id,
        );
    }, [route, onClick]);

    return (
        <a
            className={`TrialBenefitsModalStepMore ${styleLink ? '' : 'learn-more-button'}`}
            onClick={redirect}
        >
            {message}
        </a>
    );
};

export default TrialBenefitsModalStepMore;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback} from 'react';

import {FormattedMessage} from 'react-intl';

import {Group, GroupPermissions} from '@mattermost/types/groups';

import NoResultsIndicator from 'components/no_results_indicator';
import {NoResultsVariant} from 'components/no_results_indicator/types';
import LoadingScreen from 'components/loading_screen';
import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import Menu from 'components/widgets/menu/menu';

import * as Utils from 'utils/utils';
import {ActionResult} from 'mattermost-redux/types/actions';
import {ModalData} from 'types/actions';
import {ModalIdentifiers} from 'utils/constants';
import ViewUserGroupModal from 'components/view_user_group_modal';

export type Props = {
    groups: Group[];
    searchTerm: string;
    loading: boolean;
    groupPermissionsMap: Record<string, GroupPermissions>;
    onScroll: () => void;
    onExited: () => void;
    backButtonAction: () => void;
    actions: {
        archiveGroup: (groupId: string) => Promise<ActionResult>;
        openModal: <P>(modalData: ModalData<P>) => void;
    };
}

const UserGroupsList = React.forwardRef((props: Props, ref?: React.Ref<HTMLDivElement>) => {
    const {
        groups,
        searchTerm,
        loading,
        groupPermissionsMap,
        onScroll,
        backButtonAction,
        onExited,
        actions,
    } = props;

    const archiveGroup = useCallback(async (groupId: string) => {
        await actions.archiveGroup(groupId);
    }, [actions.archiveGroup]);

    const goToViewGroupModal = useCallback((group: Group) => {
        actions.openModal({
            modalId: ModalIdentifiers.VIEW_USER_GROUP,
            dialogType: ViewUserGroupModal,
            dialogProps: {
                groupId: group.id,
                backButtonCallback: backButtonAction,
                backButtonAction: () => {
                    goToViewGroupModal(group);
                },
            },
        });
        onExited();
    }, [actions.openModal, onExited, backButtonAction]);

    return (
        <div
            className='user-groups-modal__content user-groups-list'
            onScroll={onScroll}
            ref={ref}
        >
            {(groups.length === 0 && searchTerm) &&
                <NoResultsIndicator
                    variant={NoResultsVariant.ChannelSearch}
                    titleValues={{channelName: `"${searchTerm}"`}}
                />
            }
            {groups.map((group) => {
                return (
                    <div
                        className='group-row'
                        key={group.id}
                        onClick={() => {
                            goToViewGroupModal(group);
                        }}
                    >
                        <span className='group-display-name'>
                            {group.display_name}
                        </span>
                        <span className='group-name'>
                            {'@'}{group.name}
                        </span>
                        <div className='group-member-count'>
                            <FormattedMessage
                                id='user_groups_modal.memberCount'
                                defaultMessage='{member_count} {member_count, plural, one {member} other {members}}'
                                values={{
                                    member_count: group.member_count,
                                }}
                            />
                        </div>
                        <div className='group-action'>
                            <MenuWrapper
                                isDisabled={false}
                                stopPropagationOnToggle={true}
                                id={`customWrapper-${group.id}`}
                            >
                                <button className='action-wrapper'>
                                    <i className='icon icon-dots-vertical'/>
                                </button>
                                <Menu
                                    openLeft={true}
                                    openUp={false}
                                    className={'group-actions-menu'}
                                    ariaLabel={Utils.localizeMessage('admin.user_item.menuAriaLabel', 'User Actions Menu')}
                                >
                                    <Menu.Group>
                                        <Menu.ItemAction
                                            onClick={() => {
                                                goToViewGroupModal(group);
                                            }}
                                            icon={<i className='icon-account-multiple-outline'/>}
                                            text={Utils.localizeMessage('user_groups_modal.viewGroup', 'View Group')}
                                            disabled={false}
                                        />
                                    </Menu.Group>
                                    <Menu.Group>
                                        <Menu.ItemAction
                                            show={groupPermissionsMap[group.id].can_delete}
                                            onClick={() => {
                                                archiveGroup(group.id);
                                            }}
                                            icon={<i className='icon-archive-outline'/>}
                                            text={Utils.localizeMessage('user_groups_modal.archiveGroup', 'Archive Group')}
                                            disabled={false}
                                            isDangerous={true}
                                        />
                                    </Menu.Group>
                                </Menu>
                            </MenuWrapper>
                        </div>
                    </div>
                );
            })}
            {
                (loading) &&
                <LoadingScreen/>
            }
        </div>
    );
});

export default React.memo(UserGroupsList);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';

import {ActionFunc, ActionResult, GenericAction} from 'mattermost-redux/types/actions';

import {GlobalState} from 'types/store';

import {archiveGroup} from 'mattermost-redux/actions/groups';
import {ModalData} from 'types/actions';
import {openModal} from 'actions/views/modals';
import {getGroupListPermissions} from 'mattermost-redux/selectors/entities/roles';

import UserGroupsList from './user_groups_list';

type Actions = {
    openModal: <P>(modalData: ModalData<P>) => void;
    archiveGroup: (groupId: string) => Promise<ActionResult>;
};

function mapStateToProps(state: GlobalState) {
    const groupPermissionsMap = getGroupListPermissions(state);
    return {
        groupPermissionsMap,
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc | GenericAction>, Actions>({
            openModal,
            archiveGroup,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps, null, {forwardRef: true})(UserGroupsList);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback} from 'react';

import {Modal} from 'react-bootstrap';

import {FormattedMessage} from 'react-intl';

import CreateUserGroupsModal from 'components/create_user_groups_modal';
import {ModalData} from 'types/actions';
import {ModalIdentifiers} from 'utils/constants';

export type Props = {
    canCreateCustomGroups: boolean;
    onExited: () => void;
    backButtonAction: () => void;
    actions: {
        openModal: <P>(modalData: ModalData<P>) => void;
    };
}

const UserGroupsModalHeader = (props: Props) => {
    const goToCreateModal = useCallback(() => {
        props.actions.openModal({
            modalId: ModalIdentifiers.USER_GROUPS_CREATE,
            dialogType: CreateUserGroupsModal,
            dialogProps: {
                backButtonCallback: props.backButtonAction,
            },
        });
        props.onExited();
    }, [props.actions.openModal, props.backButtonAction, props.onExited]);

    return (
        <Modal.Header closeButton={true}>
            <Modal.Title
                componentClass='h1'
                id='userGroupsModalLabel'
            >
                <FormattedMessage
                    id='user_groups_modal.title'
                    defaultMessage='User Groups'
                />
            </Modal.Title>
            {
                props.canCreateCustomGroups &&
                <button
                    className='user-groups-create btn btn-md btn-primary'
                    onClick={goToCreateModal}
                >
                    <FormattedMessage
                        id='user_groups_modal.createNew'
                        defaultMessage='Create Group'
                    />
                </button>
            }
        </Modal.Header>
    );
};

export default React.memo(UserGroupsModalHeader);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';

import {ActionFunc, GenericAction} from 'mattermost-redux/types/actions';

import {GlobalState} from 'types/store';

import {ModalData} from 'types/actions';
import {Permissions} from 'mattermost-redux/constants';
import {openModal} from 'actions/views/modals';
import {haveISystemPermission} from 'mattermost-redux/selectors/entities/roles';

import UserGroupsModalHeader from './user_groups_modal_header';

type Actions = {
    openModal: <P>(modalData: ModalData<P>) => void;
};

function mapStateToProps(state: GlobalState) {
    const canCreateCustomGroups = haveISystemPermission(state, {permission: Permissions.CREATE_CUSTOM_GROUP});

    return {
        canCreateCustomGroups,
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc | GenericAction>, Actions>({
            openModal,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(UserGroupsModalHeader);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect, useState} from 'react';
import {useDispatch, useSelector} from 'react-redux';
import moment from 'moment';
import {useIntl} from 'react-intl';

import StartTrialBtn from 'components/learn_more_trial_modal/start_trial_btn';
import useOpenSalesLink from 'components/common/hooks/useOpenSalesLink';

import {isAdmin} from 'mattermost-redux/utils/user_utils';
import {getCurrentUser} from 'mattermost-redux/selectors/entities/users';
import {getPrevTrialLicense} from 'mattermost-redux/actions/admin';
import {getLicense} from 'mattermost-redux/selectors/entities/general';
import {checkHadPriorTrial, isCurrentLicenseCloud, getSubscriptionProduct as selectSubscriptionProduct} from 'mattermost-redux/selectors/entities/cloud';
import {getBrowserTimezone} from 'utils/timezone';

import {CloudProducts, LicenseLinks, LicenseSkus} from 'utils/constants';

import CloudStartTrialButton from 'components/cloud_start_trial/cloud_start_trial_btn';

import {GlobalState} from '@mattermost/types/store';

function ADLDAPUpsellBanner() {
    const [show, setShow] = useState(true);
    const [confirmed, setConfirmed] = useState(false);

    const dispatch = useDispatch();
    const {formatMessage} = useIntl();
    const openSalesLink = useOpenSalesLink();

    useEffect(() => {
        dispatch(getPrevTrialLicense());
    }, []);

    const isAdminUser = isAdmin(useSelector(getCurrentUser).roles);
    const isCloud = useSelector(isCurrentLicenseCloud);
    const currentLicense = useSelector(getLicense);
    const prevTrialLicense = useSelector((state: GlobalState) => state.entities.admin.prevTrialLicense);
    const product = useSelector(selectSubscriptionProduct);

    const prevCloudTrialed = useSelector(checkHadPriorTrial);
    const prevSelfHostedTrialed = prevTrialLicense?.IsLicensed === 'true';
    const prevTrialed = prevSelfHostedTrialed || prevCloudTrialed;

    const isSelfHostedProfessional = currentLicense?.SkuShortName === LicenseSkus.Professional;
    const isCloudProfessional = product?.sku === CloudProducts.PROFESSIONAL;
    const isProfessional = isSelfHostedProfessional || isCloudProfessional;

    if (!show) {
        return null;
    }

    const currentLicenseEndDate = new Date(parseInt(currentLicense?.ExpiresAt, 10));

    const openLink = () => {
        if (isCloud) {
            openSalesLink();
        } else {
            window.open(LicenseLinks.CONTACT_SALES, '_blank');
        }
    };

    const confirmBanner = (
        <div className='ad_ldap_upsell_confirm'>
            <div className='upsell-confirm-backdrop'/>
            <div className='upsell-confirm-foreground'>
                <p className='title'>{formatMessage({id: 'adldap_upsell_banner.confirm.title', defaultMessage: 'Your trial has started!'})}</p>
                <p className='subtitle'>{formatMessage({id: 'adldap_upsell_banner.confirm.license_trial', defaultMessage: 'Welcome to your Mattermost Enterprise trial! It expires on {endDate}. You now have access to high-security Enterprise features, for free.'}, {endDate: moment(currentLicenseEndDate).tz(getBrowserTimezone()).format('MMMM Do YYYY')})}</p>
                <div className='btns-container'>
                    <button
                        className='confrim-btn learn-more'
                        onClick={openLink}
                    >
                        {formatMessage({id: 'adldap_upsell_banner.confirm.learn_more', defaultMessage: 'Learn more'})}
                    </button>
                    <button
                        className='confrim-btn continue'
                        onClick={() => setShow(false)}
                    >
                        {formatMessage({id: 'adldap_upsell_banner.confirm.continue', defaultMessage: 'Continue'})}
                    </button>
                </div>
            </div>
        </div>
    );

    if (confirmed) {
        return confirmBanner;
    }

    if (!isAdminUser) {
        return null;
    }

    if (!isProfessional) {
        return null;
    }

    let btn = (
        <StartTrialBtn
            btnClass='ad-ldap-banner-btn'
            message={formatMessage({id: 'adldap_upsell_banner.trial_btn', defaultMessage: 'Try free for 30 days'})}
            telemetryId={'start_self-hosted_trial_from_adldap_upsell_banner'}
            renderAsButton={true}
            onClick={() => setConfirmed(true)}
        />);

    if (isCloud) {
        btn = (
            <CloudStartTrialButton
                extraClass='ad-ldap-banner-btn'
                message={formatMessage({id: 'adldap_upsell_banner.trial_btn', defaultMessage: 'Try free for 30 days'})}
                telemetryId={'start_cloud_trial_from_adldap_upsell_banner'}
                onClick={() => setConfirmed(true)}
            />
        );
    }

    if (prevTrialed) {
        btn = (
            <button
                className='ad-ldap-banner-btn'
                onClick={openLink}
            >
                {formatMessage({id: 'adldap_upsell_banner.sales_btn', defaultMessage: 'Contact sales to use'})}
            </button>
        );
    }

    return (
        <div
            id='ad_ldap_upsell_banner'
            className='ad_ldap_upsell_banner'
        >
            <div className='message'>
                <i className='icon icon-information-outline'/>
                {formatMessage({id: 'adldap_upsell_banner.banner_message', defaultMessage: 'AD/LDAP group sync creates groups faster'})}
            </div>
            <div className='btn-container'>
                {btn}
                <button
                    type='button'
                    aria-label='Close'
                    className='banner-close'
                    onClick={() => setShow(false)}
                >
                    <span aria-hidden='true'>{''}</span>
                    <span className='sr-only'>{'Close'}</span>
                </button>
            </div>
        </div>
    );
}

export default ADLDAPUpsellBanner;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {createRef, RefObject} from 'react';

import {Modal} from 'react-bootstrap';

import Constants from 'utils/constants';

import * as Utils from 'utils/utils';
import {Group, GroupSearachParams} from '@mattermost/types/groups';

import './user_groups_modal.scss';
import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import Menu from 'components/widgets/menu/menu';
import {debounce} from 'mattermost-redux/actions/helpers';
import Input from 'components/widgets/inputs/input/input';
import NoResultsIndicator from 'components/no_results_indicator';
import {NoResultsVariant} from 'components/no_results_indicator/types';

import UserGroupsList from './user_groups_list';
import UserGroupsModalHeader from './user_groups_modal_header';
import ADLDAPUpsellBanner from './ad_ldap_upsell_banner';

const GROUPS_PER_PAGE = 60;

export type Props = {
    onExited: () => void;
    groups: Group[];
    myGroups: Group[];
    searchTerm: string;
    currentUserId: string;
    backButtonAction: () => void;
    actions: {
        getGroups: (
            filterAllowReference?: boolean,
            page?: number,
            perPage?: number,
            includeMemberCount?: boolean
        ) => Promise<{data: Group[]}>;
        setModalSearchTerm: (term: string) => void;
        getGroupsByUserIdPaginated: (
            userId: string,
            filterAllowReference?: boolean,
            page?: number,
            perPage?: number,
            includeMemberCount?: boolean
        ) => Promise<{data: Group[]}>;
        searchGroups: (
            params: GroupSearachParams,
        ) => Promise<{data: Group[]}>;
    };
}

type State = {
    page: number;
    myGroupsPage: number;
    loading: boolean;
    show: boolean;
    selectedFilter: string;
    allGroupsFull: boolean;
    myGroupsFull: boolean;
}

export default class UserGroupsModal extends React.PureComponent<Props, State> {
    divScrollRef: RefObject<HTMLDivElement>;
    private searchTimeoutId: number

    constructor(props: Props) {
        super(props);
        this.divScrollRef = createRef();
        this.searchTimeoutId = 0;

        this.state = {
            page: 0,
            myGroupsPage: 0,
            loading: true,
            show: true,
            selectedFilter: 'all',
            allGroupsFull: false,
            myGroupsFull: false,
        };
    }

    doHide = () => {
        this.setState({show: false});
    }

    async componentDidMount() {
        const {
            actions,
        } = this.props;
        await Promise.all([
            actions.getGroups(false, this.state.page, GROUPS_PER_PAGE, true),
            actions.getGroupsByUserIdPaginated(this.props.currentUserId, false, this.state.myGroupsPage, GROUPS_PER_PAGE, true),
        ]);
        this.loadComplete();
    }

    componentWillUnmount() {
        this.props.actions.setModalSearchTerm('');
    }

    componentDidUpdate(prevProps: Props) {
        if (prevProps.searchTerm !== this.props.searchTerm) {
            clearTimeout(this.searchTimeoutId);
            const searchTerm = this.props.searchTerm;

            if (searchTerm === '') {
                this.loadComplete();
                this.searchTimeoutId = 0;
                return;
            }

            const searchTimeoutId = window.setTimeout(
                async () => {
                    const params: GroupSearachParams = {
                        q: searchTerm,
                        filter_allow_reference: true,
                        page: this.state.page,
                        per_page: GROUPS_PER_PAGE,
                        include_member_count: true,
                    };
                    if (this.state.selectedFilter === 'all') {
                        await prevProps.actions.searchGroups(params);
                    } else {
                        params.user_id = this.props.currentUserId;
                        await prevProps.actions.searchGroups(params);
                    }
                },
                Constants.SEARCH_TIMEOUT_MILLISECONDS,
            );

            this.searchTimeoutId = searchTimeoutId;
        }
    }

    startLoad = () => {
        this.setState({loading: true});
    }

    loadComplete = () => {
        this.setState({loading: false});
    }

    handleSearch = (e: React.ChangeEvent<HTMLInputElement>) => {
        const term = e.target.value;
        this.props.actions.setModalSearchTerm(term);
    }

    scrollGetGroups = debounce(
        async () => {
            const {page} = this.state;
            const newPage = page + 1;

            this.setState({page: newPage});
            this.getGroups(newPage);
        },
        500,
        false,
        (): void => {},
    );
    scrollGetMyGroups = debounce(
        async () => {
            const {myGroupsPage} = this.state;
            const newPage = myGroupsPage + 1;

            this.setState({myGroupsPage: newPage});
            this.getMyGroups(newPage);
        },
        500,
        false,
        (): void => {},
    );

    onScroll = () => {
        const scrollHeight = this.divScrollRef.current?.scrollHeight || 0;
        const scrollTop = this.divScrollRef.current?.scrollTop || 0;
        const clientHeight = this.divScrollRef.current?.clientHeight || 0;

        if ((scrollTop + clientHeight + 30) >= scrollHeight) {
            if (this.state.selectedFilter === 'all' && this.state.loading === false && !this.state.allGroupsFull) {
                this.scrollGetGroups();
            }
            if (this.state.selectedFilter !== 'all' && this.props.myGroups.length % GROUPS_PER_PAGE === 0 && this.state.loading === false) {
                this.scrollGetMyGroups();
            }
        }
    }

    getMyGroups = async (page: number) => {
        const {actions} = this.props;

        this.startLoad();
        const data = await actions.getGroupsByUserIdPaginated(this.props.currentUserId, false, page, GROUPS_PER_PAGE, true);
        if (data.data.length === 0) {
            this.setState({myGroupsFull: true});
        }
        this.loadComplete();
        this.setState({selectedFilter: 'my'});
    }

    getGroups = async (page: number) => {
        const {actions} = this.props;

        this.startLoad();
        const data = await actions.getGroups(false, page, GROUPS_PER_PAGE, true);
        if (data.data.length === 0) {
            this.setState({allGroupsFull: true});
        }
        this.loadComplete();
        this.setState({selectedFilter: 'all'});
    }

    render() {
        const groups = this.state.selectedFilter === 'all' ? this.props.groups : this.props.myGroups;

        return (
            <Modal
                dialogClassName='a11y__modal user-groups-modal'
                show={this.state.show}
                onHide={this.doHide}
                onExited={this.props.onExited}
                role='dialog'
                aria-labelledby='userGroupsModalLabel'
                id='userGroupsModal'
            >
                <ADLDAPUpsellBanner/>
                <UserGroupsModalHeader
                    onExited={this.props.onExited}
                    backButtonAction={this.props.backButtonAction}
                />
                <Modal.Body>
                    {(groups.length === 0 && !this.props.searchTerm) ?
                        <NoResultsIndicator
                            variant={NoResultsVariant.UserGroups}
                        /> :
                        <>
                            <div className='user-groups-search'>
                                <Input
                                    type='text'
                                    placeholder={Utils.localizeMessage('user_groups_modal.searchGroups', 'Search Groups')}
                                    onChange={this.handleSearch}
                                    value={this.props.searchTerm}
                                    data-testid='searchInput'
                                    className={'user-group-search-input'}
                                    inputPrefix={<i className={'icon icon-magnify'}/>}
                                />
                            </div>
                            <div className='more-modal__dropdown'>
                                <MenuWrapper id='groupsFilterDropdown'>
                                    <a>
                                        <span>{this.state.selectedFilter === 'all' ? Utils.localizeMessage('user_groups_modal.showAllGroups', 'Show: All Groups') : Utils.localizeMessage('user_groups_modal.showMyGroups', 'Show: My Groups')}</span>
                                        <span className='icon icon-chevron-down'/>
                                    </a>
                                    <Menu
                                        openLeft={false}
                                        ariaLabel={Utils.localizeMessage('user_groups_modal.filterAriaLabel', 'Groups Filter Menu')}
                                    >
                                        <Menu.ItemAction
                                            id='groupsDropdownAll'
                                            buttonClass='groups-filter-btn'
                                            onClick={() => {
                                                this.getGroups(0);
                                            }}
                                            text={Utils.localizeMessage('user_groups_modal.allGroups', 'All Groups')}
                                            rightDecorator={this.state.selectedFilter === 'all' && <i className='icon icon-check'/>}
                                        />
                                        <Menu.ItemAction
                                            id='groupsDropdownMy'
                                            buttonClass='groups-filter-btn'
                                            onClick={() => {
                                                this.getMyGroups(0);
                                            }}
                                            text={Utils.localizeMessage('user_groups_modal.myGroups', 'My Groups')}
                                            rightDecorator={this.state.selectedFilter !== 'all' && <i className='icon icon-check'/>}
                                        />
                                    </Menu>
                                </MenuWrapper>
                            </div>
                            <UserGroupsList
                                groups={groups}
                                searchTerm={this.props.searchTerm}
                                loading={this.state.loading}
                                onScroll={this.onScroll}
                                ref={this.divScrollRef}
                                onExited={this.props.onExited}
                                backButtonAction={this.props.backButtonAction}
                            />
                        </>
                    }
                </Modal.Body>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';

import {ActionFunc, GenericAction} from 'mattermost-redux/types/actions';

import {GlobalState} from 'types/store';

import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {getAllAssociatedGroupsForReference, getMyAllowReferencedGroups, searchAllowReferencedGroups, searchMyAllowReferencedGroups} from 'mattermost-redux/selectors/entities/groups';
import {getGroups, getGroupsByUserIdPaginated, searchGroups} from 'mattermost-redux/actions/groups';
import {Group, GroupSearachParams} from '@mattermost/types/groups';
import {ModalIdentifiers} from 'utils/constants';
import {isModalOpen} from 'selectors/views/modals';
import {setModalSearchTerm} from 'actions/views/search';

import UserGroupsModal from './user_groups_modal';

type Actions = {
    getGroups: (
        filterAllowReference?: boolean,
        page?: number,
        perPage?: number,
        includeMemberCount?: boolean
    ) => Promise<{data: Group[]}>;
    setModalSearchTerm: (term: string) => void;
    getGroupsByUserIdPaginated: (
        userId: string,
        filterAllowReference?: boolean,
        page?: number,
        perPage?: number,
        includeMemberCount?: boolean
    ) => Promise<{data: Group[]}>;
    searchGroups: (
        params: GroupSearachParams,
    ) => Promise<{data: Group[]}>;
};

function mapStateToProps(state: GlobalState) {
    const searchTerm = state.views.search.modalSearch;

    let groups: Group[] = [];
    let myGroups: Group[] = [];
    if (searchTerm) {
        groups = searchAllowReferencedGroups(state, searchTerm);
        myGroups = searchMyAllowReferencedGroups(state, searchTerm);
    } else {
        groups = getAllAssociatedGroupsForReference(state);
        myGroups = getMyAllowReferencedGroups(state);
    }

    return {
        showModal: isModalOpen(state, ModalIdentifiers.USER_GROUPS),
        groups,
        searchTerm,
        myGroups,
        currentUserId: getCurrentUserId(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc | GenericAction>, Actions>({
            getGroups,
            setModalSearchTerm,
            getGroupsByUserIdPaginated,
            searchGroups,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(UserGroupsModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getUser, makeGetDisplayName} from 'mattermost-redux/selectors/entities/users';
import {getTheme} from 'mattermost-redux/selectors/entities/preferences';

import {GlobalState} from '@mattermost/types/store';

import UserProfile from './user_profile';

type OwnProps = {
    userId: string;
}

function makeMapStateToProps() {
    const getDisplayName = makeGetDisplayName();

    return (state: GlobalState, ownProps: OwnProps) => {
        const user = getUser(state, ownProps.userId);
        const theme = getTheme(state);

        return {
            displayName: getDisplayName(state, ownProps.userId, true),
            user,
            theme,
            isShared: Boolean(user && user.remote_id),
        };
    };
}

export default connect(makeMapStateToProps)(UserProfile);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import ColorHash from 'color-hash';
import ColorContrastChecker from 'color-contrast-checker';

const cachedColors = new Map<string, string>();

export function generateColor(username: string, background: string): string {
    const cacheKey = `${username}-${background}`;
    const cachedColor = cachedColors.get(cacheKey);
    if (cachedColor) {
        return cachedColor;
    }

    let userColor = background;
    let userAndSalt = username;
    const checker = new ColorContrastChecker();
    const colorHash = new ColorHash();

    let tries = 3;
    while (!checker.isLevelCustom(userColor, background, 4.5) && tries > 0) {
        userColor = colorHash.hex(userAndSalt);
        userAndSalt += 'salt';
        tries--;
    }

    cachedColors.set(cacheKey, userColor);
    return userColor;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {PureComponent} from 'react';

import {UserProfile as UserProfileType} from '@mattermost/types/users';

import {Theme} from 'mattermost-redux/selectors/entities/preferences';
import {isGuest} from 'mattermost-redux/utils/user_utils';

import {imageURLForUser, isMobile} from 'utils/utils';

import OverlayTrigger, {BaseOverlayTrigger} from 'components/overlay_trigger';
import ProfilePopover from 'components/profile_popover';
import BotBadge from 'components/widgets/badges/bot_badge';
import GuestBadge from 'components/widgets/badges/guest_badge';
import SharedUserIndicator from 'components/shared_user_indicator';

import {generateColor} from './utils';

export type UserProfileProps = {
    userId: string;
    displayName?: string;
    isBusy?: boolean;
    isShared?: boolean;
    overwriteName?: React.ReactNode;
    overwriteIcon?: string;
    user?: UserProfileType;
    disablePopover?: boolean;
    displayUsername?: boolean;
    colorize?: boolean;
    hasMention?: boolean;
    hideStatus?: boolean;
    isRHS?: boolean;
    overwriteImage?: React.ReactNode;
    channelId?: string;
    theme?: Theme;
}

export default class UserProfile extends PureComponent<UserProfileProps> {
    private overlay?: BaseOverlayTrigger;

    static defaultProps: Partial<UserProfileProps> = {
        disablePopover: false,
        displayUsername: false,
        hasMention: false,
        hideStatus: false,
        isRHS: false,
        overwriteImage: '',
        overwriteName: '',
        colorize: false,
    }

    hideProfilePopover = (): void => {
        if (this.overlay) {
            this.overlay.hide();
        }
    }

    setOverlaynRef = (ref: BaseOverlayTrigger): void => {
        this.overlay = ref;
    }

    render(): React.ReactNode {
        const {
            disablePopover,
            displayName,
            displayUsername,
            isBusy,
            isRHS,
            isShared,
            hasMention,
            hideStatus,
            overwriteName,
            overwriteIcon,
            user,
            userId,
            channelId,
            colorize,
            theme,
        } = this.props;

        let name: React.ReactNode;
        if (user && displayUsername) {
            name = `@${(user.username)}`;
        } else {
            name = overwriteName || displayName || '...';
        }

        const ariaName: string = typeof name === 'string' ? name.toLowerCase() : '';

        let userColor = '#000000';
        if (user && theme) {
            userColor = generateColor(user.username, theme.centerChannelBg);
        }

        let userStyle;
        if (colorize) {
            userStyle = {color: userColor};
        }

        if (disablePopover) {
            return (
                <div
                    className='user-popover'
                    style={userStyle}
                >{name}</div>
            );
        }

        let placement = 'right';
        if (isRHS && !isMobile()) {
            placement = 'left';
        }

        let profileImg = '';
        if (user) {
            profileImg = imageURLForUser(user.id, user.last_picture_update);
        }

        let sharedIcon;
        if (isShared) {
            sharedIcon = (
                <SharedUserIndicator
                    className='shared-user-icon'
                    withTooltip={true}
                />
            );
        }

        return (
            <React.Fragment>
                <OverlayTrigger
                    ref={this.setOverlaynRef}
                    trigger={['click']}
                    placement={placement}
                    rootClose={true}
                    overlay={
                        <ProfilePopover
                            className='user-profile-popover'
                            userId={userId}
                            channelId={channelId}
                            src={profileImg}
                            isBusy={isBusy}
                            hide={this.hideProfilePopover}
                            hideStatus={hideStatus}
                            isRHS={isRHS}
                            hasMention={hasMention}
                            overwriteName={overwriteName}
                            overwriteIcon={overwriteIcon}
                        />
                    }
                >
                    <button
                        aria-label={ariaName}
                        className='user-popover style--none'
                        style={userStyle}
                    >
                        {name}
                    </button>
                </OverlayTrigger>
                {sharedIcon}
                <BotBadge
                    show={Boolean(user && user.is_bot)}
                    className='badge-popoverlist'
                />
                <GuestBadge
                    show={Boolean(user && isGuest(user.roles))}
                    className='badge-popoverlist'
                />
            </React.Fragment>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal} from 'react-bootstrap';
import {Provider} from 'react-redux';
import ReactDOM from 'react-dom';
import {
    defineMessages,
    FormattedMessage,
    injectIntl,
    IntlShape,
} from 'react-intl';

import {UserProfile} from '@mattermost/types/users';
import {StatusOK} from '@mattermost/types/client4';
import store from 'stores/redux_store.jsx';
import Constants from 'utils/constants';
import * as Utils from 'utils/utils';
import {t} from 'utils/i18n';
import ConfirmModal from 'components/confirm_modal';

const UserSettings = React.lazy(() => import(/* webpackPrefetch: true */ 'components/user_settings'));
const SettingsSidebar = React.lazy(() => import(/* webpackPrefetch: true */ '../../settings_sidebar'));

const holders = defineMessages({
    profile: {
        id: t('user.settings.modal.profile'),
        defaultMessage: 'Profile',
    },
    security: {
        id: t('user.settings.modal.security'),
        defaultMessage: 'Security',
    },
    notifications: {
        id: t('user.settings.modal.notifications'),
        defaultMessage: 'Notifications',
    },
    display: {
        id: t('user.settings.modal.display'),
        defaultMessage: 'Display',
    },
    sidebar: {
        id: t('user.settings.modal.sidebar'),
        defaultMessage: 'Sidebar',
    },
    advanced: {
        id: t('user.settings.modal.advanced'),
        defaultMessage: 'Advanced',
    },
    checkEmail: {
        id: 'user.settings.general.checkEmail',
        defaultMessage: 'Check your email at {email} to verify the address. Cannot find the email?',
    },
    confirmTitle: {
        id: t('user.settings.modal.confirmTitle'),
        defaultMessage: 'Discard Changes?',
    },
    confirmMsg: {
        id: t('user.settings.modal.confirmMsg'),
        defaultMessage: 'You have unsaved changes, are you sure you want to discard them?',
    },
    confirmBtns: {
        id: t('user.settings.modal.confirmBtns'),
        defaultMessage: 'Yes, Discard',
    },
});

export type Props = {
    currentUser: UserProfile;
    onExited: () => void;
    intl: IntlShape;
    isContentProductSettings: boolean;
    actions: {
        sendVerificationEmail: (email: string) => Promise<{
            data: StatusOK;
            error: {
                err: string;
            };
        }>;
    };
}

type State = {
    active_tab?: string;
    active_section: string;
    showConfirmModal: boolean;
    enforceFocus?: boolean;
    show: boolean;
    resendStatus: string;
}

class UserSettingsModal extends React.PureComponent<Props, State> {
    private requireConfirm: boolean;
    private customConfirmAction: ((handleConfirm: () => void) => void) | null;
    private modalBodyRef: React.RefObject<Modal>;
    private afterConfirm: (() => void) | null;

    constructor(props: Props) {
        super(props);

        this.state = {
            active_tab: props.isContentProductSettings ? 'notifications' : 'profile',
            active_section: '',
            showConfirmModal: false,
            enforceFocus: true,
            show: true,
            resendStatus: '',
        };

        this.requireConfirm = false;

        // Used when settings want to override the default confirm modal with their own
        // If set by a child, it will be called in place of showing the regular confirm
        // modal. It will be passed a function to call on modal confirm
        this.customConfirmAction = null;
        this.afterConfirm = null;

        this.modalBodyRef = React.createRef();
    }

    handleResend = (email: string) => {
        this.setState({resendStatus: 'sending'});

        this.props.actions.sendVerificationEmail(email).then(({data, error: err}) => {
            if (data) {
                this.setState({resendStatus: 'success'});
            } else if (err) {
                this.setState({resendStatus: 'failure'});
            }
        });
    }

    componentDidMount() {
        document.addEventListener('keydown', this.handleKeyDown);
    }

    componentWillUnmount() {
        document.removeEventListener('keydown', this.handleKeyDown);
    }

    componentDidUpdate(prevProps: Props, prevState: State) {
        if (this.state.active_tab !== prevState.active_tab) {
            const el = ReactDOM.findDOMNode(this.modalBodyRef.current) as any;
            el.scrollTop = 0;
        }
    }

    handleKeyDown = (e: KeyboardEvent) => {
        if (Utils.cmdOrCtrlPressed(e) && e.shiftKey && Utils.isKeyPressed(e, Constants.KeyCodes.A)) {
            e.preventDefault();
            this.handleHide();
        }
    }

    // Called when the close button is pressed on the main modal
    handleHide = () => {
        if (this.requireConfirm) {
            this.showConfirmModal(() => this.handleHide());
            return;
        }

        this.setState({
            show: false,
        });
    }

    // called after the dialog is fully hidden and faded out
    handleHidden = () => {
        this.setState({
            active_tab: this.props.isContentProductSettings ? 'notifications' : 'profile',
            active_section: '',
        });
        this.props.onExited();
    }

    // Called to hide the settings pane when on mobile
    handleCollapse = () => {
        const el = ReactDOM.findDOMNode(this.modalBodyRef.current) as HTMLDivElement;
        el.closest('.modal-dialog')!.classList.remove('display--content');

        this.setState({
            active_tab: '',
            active_section: '',
        });
    }

    handleConfirm = () => {
        this.setState({
            showConfirmModal: false,
            enforceFocus: true,
        });

        this.requireConfirm = false;
        this.customConfirmAction = null;

        if (this.afterConfirm) {
            this.afterConfirm();
            this.afterConfirm = null;
        }
    }

    handleCancelConfirmation = () => {
        this.setState({
            showConfirmModal: false,
            enforceFocus: true,
        });

        this.afterConfirm = null;
    }

    showConfirmModal = (afterConfirm: () => void) => {
        if (afterConfirm) {
            this.afterConfirm = afterConfirm;
        }

        if (this.customConfirmAction) {
            this.customConfirmAction(this.handleConfirm);
            return;
        }

        this.setState({
            showConfirmModal: true,
            enforceFocus: false,
        });
    }

    // Called by settings tabs when their close button is pressed
    closeModal = () => {
        if (this.requireConfirm) {
            this.showConfirmModal(this.closeModal);
        } else {
            this.handleHide();
        }
    }

    // Called by settings tabs when their back button is pressed
    collapseModal = () => {
        if (this.requireConfirm) {
            this.showConfirmModal(this.collapseModal);
        } else {
            this.handleCollapse();
        }
    }

    updateTab = (tab?: string, skipConfirm?: boolean) => {
        if (!skipConfirm && this.requireConfirm) {
            this.showConfirmModal(() => this.updateTab(tab, true));
        } else {
            this.setState({
                active_tab: tab,
                active_section: '',
            });
        }
    }

    updateSection = (section?: string, skipConfirm?: boolean) => {
        if (!skipConfirm && this.requireConfirm) {
            this.showConfirmModal(() => this.updateSection(section, true));
        } else {
            this.setState({
                active_section: section!,
            });
        }
    }

    render() {
        const {formatMessage} = this.props.intl;
        if (this.props.currentUser == null) {
            return (<div/>);
        }
        const tabs = [];
        if (this.props.isContentProductSettings) {
            tabs.push({name: 'notifications', uiName: formatMessage(holders.notifications), icon: 'icon fa fa-exclamation-circle', iconTitle: Utils.localizeMessage('user.settings.notifications.icon', 'Notification Settings Icon')});
            tabs.push({name: 'display', uiName: formatMessage(holders.display), icon: 'icon fa fa-eye', iconTitle: Utils.localizeMessage('user.settings.display.icon', 'Display Settings Icon')});
            tabs.push({name: 'sidebar', uiName: formatMessage(holders.sidebar), icon: 'icon fa fa-columns', iconTitle: Utils.localizeMessage('user.settings.sidebar.icon', 'Sidebar Settings Icon')});
            tabs.push({name: 'advanced', uiName: formatMessage(holders.advanced), icon: 'icon fa fa-list-alt', iconTitle: Utils.localizeMessage('user.settings.advance.icon', 'Advanced Settings Icon')});
        } else {
            tabs.push({name: 'profile', uiName: formatMessage(holders.profile), icon: 'icon fa fa-gear', iconTitle: Utils.localizeMessage('user.settings.profile.icon', 'Profile Settings Icon')});
            tabs.push({name: 'security', uiName: formatMessage(holders.security), icon: 'icon fa fa-lock', iconTitle: Utils.localizeMessage('user.settings.security.icon', 'Security Settings Icon')});
        }

        return (
            <Modal
                id='accountSettingsModal'
                dialogClassName='a11y__modal settings-modal'
                show={this.state.show}
                onHide={this.handleHide}
                onExited={this.handleHidden}
                enforceFocus={this.state.enforceFocus}
                role='dialog'
                aria-labelledby='accountSettingsModalLabel'
            >
                <Modal.Header
                    id='accountSettingsHeader'
                    closeButton={true}
                >
                    <Modal.Title
                        componentClass='h1'
                        id='accountSettingsModalLabel'
                    >
                        {this.props.isContentProductSettings ? (
                            <FormattedMessage
                                id='global_header.productSettings'
                                defaultMessage='Settings'
                            />
                        ) : (
                            <FormattedMessage
                                id='user.settings.modal.title'
                                defaultMessage='Profile'
                            />
                        )}
                    </Modal.Title>
                </Modal.Header>
                <Modal.Body ref={this.modalBodyRef}>
                    <div className='settings-table'>
                        <div className='settings-links'>
                            <React.Suspense fallback={null}>
                                <Provider store={store}>
                                    <SettingsSidebar
                                        tabs={tabs}
                                        activeTab={this.state.active_tab}
                                        updateTab={this.updateTab}
                                    />
                                </Provider>
                            </React.Suspense>
                        </div>
                        <div className='settings-content minimize-settings'>
                            <React.Suspense fallback={null}>
                                <Provider store={store}>
                                    <UserSettings
                                        activeTab={this.state.active_tab}
                                        activeSection={this.state.active_section}
                                        updateSection={this.updateSection}
                                        updateTab={this.updateTab}
                                        closeModal={this.closeModal}
                                        collapseModal={this.collapseModal}
                                        setEnforceFocus={(enforceFocus?: boolean) => this.setState({enforceFocus})}
                                        setRequireConfirm={
                                            (requireConfirm?: boolean, customConfirmAction?: () => () => void) => {
                                                this.requireConfirm = requireConfirm!;
                                                this.customConfirmAction = customConfirmAction!;
                                            }
                                        }
                                    />
                                </Provider>
                            </React.Suspense>
                        </div>
                    </div>
                </Modal.Body>
                <ConfirmModal
                    title={formatMessage(holders.confirmTitle)}
                    message={formatMessage(holders.confirmMsg)}
                    confirmButtonText={formatMessage(holders.confirmBtns)}
                    show={this.state.showConfirmModal}
                    onConfirm={this.handleConfirm}
                    onCancel={this.handleCancelConfirmation}
                />
            </Modal>
        );
    }
}

export default injectIntl(UserSettingsModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';

import {sendVerificationEmail} from 'mattermost-redux/actions/users';
import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getCurrentUser} from 'mattermost-redux/selectors/entities/users';
import {GlobalState} from 'types/store';
import {Action} from 'mattermost-redux/types/actions';

import UserSettingsModal, {Props} from './user_settings_modal';

function mapStateToProps(state: GlobalState) {
    const config = getConfig(state);

    const sendEmailNotifications = config.SendEmailNotifications === 'true';
    const requireEmailVerification = config.RequireEmailVerification === 'true';

    return {
        currentUser: getCurrentUser(state),
        sendEmailNotifications,
        requireEmailVerification,
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, Props['actions']>({
            sendVerificationEmail,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(UserSettingsModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState, useCallback, useMemo} from 'react';

import {Modal} from 'react-bootstrap';

import {FormattedMessage} from 'react-intl';

import {UserProfile} from '@mattermost/types/users';

import {localizeMessage} from 'utils/utils';
import {Group} from '@mattermost/types/groups';

import 'components/user_groups_modal/user_groups_modal.scss';
import {ModalData} from 'types/actions';
import AddUserToGroupMultiSelect from 'components/add_user_to_group_multiselect';
import {ActionResult} from 'mattermost-redux/types/actions';

import LocalizedIcon from 'components/localized_icon';
import {t} from 'utils/i18n';

export type Props = {
    onExited: () => void;
    groupId: string;
    group: Group;
    backButtonCallback: () => void;
    actions: {
        addUsersToGroup: (groupId: string, userIds: string[]) => Promise<ActionResult>;
        openModal: <P>(modalData: ModalData<P>) => void;
    };
}

const AddUsersToGroupModal = (props: Props) => {
    const [show, setShow] = useState(true);
    const [saving, setSaving] = useState(false);
    const [usersToAdd, setUsersToAdd] = useState<UserProfile[]>([]);
    const [showUnknownError, setShowUnknownError] = useState(false);

    const doHide = useCallback(() => {
        setShow(false);
    }, []);

    const isSaveEnabled = useCallback(() => {
        return usersToAdd.length > 0;
    }, [usersToAdd]);

    const addUserCallback = useCallback((users: UserProfile[]): void => {
        setUsersToAdd(users);
    }, []);

    const deleteUserCallback = useCallback((users: UserProfile[]): void => {
        setUsersToAdd(users);
    }, []);

    const goBack = useCallback(() => {
        props.backButtonCallback();
        props.onExited();
    }, [props.backButtonCallback, props.onExited]);

    const addUsersToGroup = useCallback(async (users?: UserProfile[]) => {
        setSaving(true);
        if (!users || users.length === 0) {
            setSaving(false);
            return;
        }
        const userIds = users.map((user) => {
            return user.id;
        });

        const data = await props.actions.addUsersToGroup(props.groupId, userIds);

        if (data?.error) {
            setShowUnknownError(true);
            setSaving(false);
        } else {
            goBack();
        }
    }, [goBack, props.actions.addUsersToGroup, props.groupId]);

    const searchOptions = useMemo(() => {
        return {
            not_in_group_id: props.groupId,
        };
    }, [props.groupId]);

    const titleValue = useMemo(() => {
        return {
            group: props.group.display_name,
        };
    }, [props.group.display_name]);

    return (
        <Modal
            dialogClassName='a11y__modal user-groups-modal-create'
            show={show}
            onHide={doHide}
            onExited={props.onExited}
            role='dialog'
            aria-labelledby='createUserGroupsModalLabel'
            id='addUsersToGroupsModal'
        >
            <Modal.Header closeButton={true}>
                <button
                    type='button'
                    className='modal-header-back-button btn-icon'
                    aria-label='Close'
                    onClick={goBack}
                >
                    <LocalizedIcon
                        className='icon icon-arrow-left'
                        ariaLabel={{id: t('user_groups_modal.goBackLabel'), defaultMessage: 'Back'}}
                    />
                </button>
                <Modal.Title
                    componentClass='h1'
                    id='addUsersToGroupsModalLabel'
                >
                    <FormattedMessage
                        id='user_groups_modal.addPeopleTitle'
                        defaultMessage='Add people to {group}'
                        values={titleValue}
                    />
                </Modal.Title>
            </Modal.Header>
            <Modal.Body
                className='overflow--visible'
            >
                <div className='user-groups-modal__content'>
                    <form role='form'>
                        <div className='group-add-user'>
                            <AddUserToGroupMultiSelect
                                multilSelectKey={'addUsersToGroupKey'}
                                onSubmitCallback={addUsersToGroup}
                                focusOnLoad={false}
                                savingEnabled={isSaveEnabled()}
                                addUserCallback={addUserCallback}
                                deleteUserCallback={deleteUserCallback}
                                groupId={props.groupId}
                                searchOptions={searchOptions}
                                buttonSubmitText={localizeMessage('multiselect.addPeopleToGroup', 'Add People')}
                                buttonSubmitLoadingText={localizeMessage('multiselect.adding', 'Adding...')}
                                backButtonClick={goBack}
                                backButtonClass={'multiselect-back'}
                                saving={saving}
                            />
                        </div>
                        {
                            showUnknownError &&
                            <div className='Input___error group-error'>
                                <i className='icon icon-alert-outline'/>
                                <FormattedMessage
                                    id='user_groups_modal.unknownError'
                                    defaultMessage='An unknown error has occurred.'
                                />
                            </div>
                        }
                    </form>
                </div>
            </Modal.Body>
        </Modal>
    );
};

export default React.memo(AddUsersToGroupModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {Action, ActionResult} from 'mattermost-redux/types/actions';

import {GlobalState} from 'types/store';

import {addUsersToGroup} from 'mattermost-redux/actions/groups';
import {getGroup} from 'mattermost-redux/selectors/entities/groups';
import {ModalData} from 'types/actions';
import {openModal} from 'actions/views/modals';

import AddUsersToGroupModal from './add_users_to_group_modal';

type Actions = {
    addUsersToGroup: (groupId: string, userIds: string[]) => Promise<ActionResult>;
    openModal: <P>(modalData: ModalData<P>) => void;
}

type OwnProps = {
    groupId: string;
}

function mapStateToProps(state: GlobalState, props: OwnProps) {
    const group = getGroup(state, props.groupId);

    return {
        group,
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, Actions>({
            addUsersToGroup,
            openModal,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(AddUsersToGroupModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useEffect, useState} from 'react';

import {Modal} from 'react-bootstrap';

import {FormattedMessage} from 'react-intl';

import * as Utils from 'utils/utils';
import {CustomGroupPatch, Group} from '@mattermost/types/groups';

import 'components/user_groups_modal/user_groups_modal.scss';
import './update_user_group_modal.scss';
import {ModalData} from 'types/actions';
import Input from 'components/widgets/inputs/input/input';
import {ActionResult} from 'mattermost-redux/types/actions';
import LocalizedIcon from 'components/localized_icon';
import {t} from 'utils/i18n';

import SaveButton from 'components/save_button';
import Constants, {ItemStatus} from 'utils/constants';

export type Props = {
    onExited: () => void;
    groupId: string;
    group: Group;
    backButtonCallback: () => void;
    actions: {
        patchGroup: (groupId: string, group: CustomGroupPatch) => Promise<ActionResult>;
        openModal: <P>(modalData: ModalData<P>) => void;
    };
}

const UpdateUserGroupModal = (props: Props) => {
    const [hasUpdated, setHasUpdated] = useState(false);
    const [name, setName] = useState(props.group.display_name);
    const [mention, setMention] = useState(`@${props.group.name}`);
    const [saving, setSaving] = useState(false);
    const [show, setShow] = useState(true);
    const [mentionInputErrorText, setMentionInputErrorText] = useState('');
    const [nameInputErrorText, setNameInputErrorText] = useState('');
    const [showUnknownError, setShowUnknownError] = useState(false);
    const [mentionUpdatedManually, setMentionUpdatedManually] = useState(false);

    const doHide = useCallback(() => {
        setShow(false);
    }, []);

    const isSaveEnabled = useCallback(() => {
        return name.length > 0 && mention.length > 0 && hasUpdated && !saving;
    }, [name, mention, hasUpdated, saving]);

    const handleKeyDown = useCallback((e: KeyboardEvent) => {
        if (Utils.isKeyPressed(e, Constants.KeyCodes.ENTER) && isSaveEnabled()) {
            patchGroup();
        }
    }, [name, mention, hasUpdated, saving]);

    useEffect(() => {
        document.addEventListener('keydown', handleKeyDown);
        return () => document.removeEventListener('keydown', handleKeyDown);
    }, [handleKeyDown]);

    const updateNameState = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
        const value = e.target.value;
        let newMention = mention;
        if (!mentionUpdatedManually) {
            newMention = value.replace(/[^A-Za-z0-9.\-_@]/g, '').toLowerCase();
            if (newMention.substring(0, 1) !== '@') {
                newMention = `@${newMention}`;
            }
        }
        setName(value);
        setHasUpdated(true);
        setMention(newMention);
    }, [mention]);

    const updateMentionState = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
        const value = e.target.value;
        setHasUpdated(true);
        setMention(value);
        setMentionUpdatedManually(true);
    }, []);

    const goBack = useCallback(() => {
        props.backButtonCallback();
        props.onExited();
    }, [props.backButtonCallback, props.onExited]);

    const patchGroup = useCallback(async () => {
        setSaving(true);
        let newMention = mention;
        const displayName = name;

        if (!displayName || !displayName.trim()) {
            setNameInputErrorText(Utils.localizeMessage('user_groups_modal.nameIsEmpty', 'Name is a required field.'));
            setSaving(false);
            return;
        }

        if (newMention.substring(0, 1) === '@') {
            newMention = newMention.substring(1, newMention.length);
        }

        if (newMention.length < 1) {
            setMentionInputErrorText(Utils.localizeMessage('user_groups_modal.mentionIsEmpty', 'Mention is a required field.'));
            setSaving(false);
            return;
        }

        if (Constants.SPECIAL_MENTIONS.includes(newMention.toLowerCase())) {
            setMentionInputErrorText(Utils.localizeMessage('user_groups_modal.mentionReservedWord', 'Mention contains a reserved word.'));
            setSaving(false);
            return;
        }

        const mentionRegEx = new RegExp(/^[a-z0-9.\-_]+$/);
        if (!mentionRegEx.test(newMention)) {
            setMentionInputErrorText(Utils.localizeMessage('user_groups_modal.mentionInvalidError', 'Invalid character in mention.'));
            setSaving(false);
            return;
        }

        const group: CustomGroupPatch = {
            name: newMention,
            display_name: displayName,
        };
        const data = await props.actions.patchGroup(props.groupId, group);
        if (data?.error) {
            if (data.error?.server_error_id === 'app.custom_group.unique_name') {
                setMentionInputErrorText(Utils.localizeMessage('user_groups_modal.mentionNotUnique', 'Mention needs to be unique.'));
                setSaving(false);
            } else if (data.error?.server_error_id === 'app.group.username_conflict') {
                setMentionInputErrorText(Utils.localizeMessage('user_groups_modal.mentionUsernameConflict', 'A username already exists with this name. Mention must be unique.'));
                setSaving(false);
            } else {
                setShowUnknownError(true);
                setSaving(false);
            }
        } else {
            goBack();
        }
    }, [name, mention, goBack, props.groupId, props.actions.patchGroup]);

    return (
        <Modal
            dialogClassName='a11y__modal user-groups-modal-update'
            show={show}
            onHide={doHide}
            onExited={props.onExited}
            role='dialog'
            aria-labelledby='createUserGroupsModalLabel'
            id='createUserGroupsModal'
        >
            <Modal.Header closeButton={true}>
                <button
                    type='button'
                    className='modal-header-back-button btn-icon'
                    aria-label='Close'
                    onClick={goBack}
                >
                    <LocalizedIcon
                        className='icon icon-arrow-left'
                        ariaLabel={{id: t('user_groups_modal.goBackLabel'), defaultMessage: 'Back'}}
                    />
                </button>
                <Modal.Title
                    componentClass='h1'
                    id='updateGroupsModalTitle'
                >
                    <FormattedMessage
                        id='user_groups_modal.editGroupTitle'
                        defaultMessage='Edit Group Details'
                    />
                </Modal.Title>
            </Modal.Header>
            <Modal.Body
                className='overflow--visible'
            >
                <div className='user-groups-modal__content'>
                    <div className='group-name-input-wrapper'>
                        <Input
                            type='text'
                            placeholder={Utils.localizeMessage('user_groups_modal.name', 'Name')}
                            onChange={updateNameState}
                            value={name}
                            data-testid='nameInput'
                            autoFocus={true}
                            customMessage={{type: ItemStatus.ERROR, value: nameInputErrorText}}
                        />
                    </div>
                    <div className='group-mention-input-wrapper'>
                        <Input
                            type='text'
                            placeholder={Utils.localizeMessage('user_groups_modal.mention', 'Mention')}
                            onChange={updateMentionState}
                            value={mention}
                            data-testid='nameInput'
                            customMessage={{type: ItemStatus.ERROR, value: mentionInputErrorText}}
                        />
                    </div>
                    <div className='update-buttons-wrapper'>
                        {
                            showUnknownError &&
                            <div className='Input___error group-error'>
                                <i className='icon icon-alert-outline'/>
                                <FormattedMessage
                                    id='user_groups_modal.unknownError'
                                    defaultMessage='An unknown error has occurred.'
                                />
                            </div>
                        }
                        <button
                            onClick={(e: React.MouseEvent<HTMLButtonElement>) => {
                                e.preventDefault();
                                goBack();
                            }}
                            className='btn update-group-back'
                        >
                            {Utils.localizeMessage('multiselect.backButton', 'Back')}
                        </button>
                        <SaveButton
                            id='saveItems'
                            saving={saving}
                            disabled={!isSaveEnabled()}
                            onClick={(e) => {
                                e.preventDefault();
                                patchGroup();
                            }}
                            defaultMessage={Utils.localizeMessage('multiselect.saveDetailsButton', 'Save Details')}
                            savingMessage={Utils.localizeMessage('multiselect.savingDetailsButton', 'Saving...')}
                        />
                    </div>
                </div>
            </Modal.Body>
        </Modal>
    );
};

export default React.memo(UpdateUserGroupModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {ActionCreatorsMapObject, bindActionCreators, Dispatch} from 'redux';

import {Action, ActionResult} from 'mattermost-redux/types/actions';

import {GlobalState} from 'types/store';

import {CustomGroupPatch} from '@mattermost/types/groups';
import {patchGroup} from 'mattermost-redux/actions/groups';
import {ModalData} from 'types/actions';
import {openModal} from 'actions/views/modals';
import {getGroup} from 'mattermost-redux/selectors/entities/groups';

import UpdateUserGroupModal from './update_user_group_modal';

type OwnProps = {
    groupId: string;
}

function makeMapStateToProps(state: GlobalState, props: OwnProps) {
    const group = getGroup(state, props.groupId);

    return {
        group,
    };
}

type Actions = {
    patchGroup: (groupId: string, group: CustomGroupPatch) => Promise<ActionResult>;
    openModal: <P>(modalData: ModalData<P>) => void;
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<Action>, Actions>({
            patchGroup,
            openModal,
        }, dispatch),
    };
}

export default connect(makeMapStateToProps, mapDispatchToProps)(UpdateUserGroupModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback} from 'react';

import {ModalData} from 'types/actions';
import LocalizedIcon from 'components/localized_icon';
import {t} from 'utils/i18n';
import {Group} from '@mattermost/types/groups';
import {ModalIdentifiers} from 'utils/constants';
import MenuWrapper from 'components/widgets/menu/menu_wrapper';
import Menu from 'components/widgets/menu/menu';
import * as Utils from 'utils/utils';
import {ActionResult} from 'mattermost-redux/types/actions';
import UpdateUserGroupModal from 'components/update_user_group_modal';

export type Props = {
    group: Group;
    onExited: () => void;
    backButtonCallback: () => void;
    backButtonAction: () => void;
    permissionToEditGroup: boolean;
    permissionToJoinGroup: boolean;
    permissionToLeaveGroup: boolean;
    permissionToArchiveGroup: boolean;
    isGroupMember: boolean;
    currentUserId: string;
    incrementMemberCount: () => void;
    decrementMemberCount: () => void;
    actions: {
        openModal: <P>(modalData: ModalData<P>) => void;
        removeUsersFromGroup: (groupId: string, userIds: string[]) => Promise<ActionResult>;
        addUsersToGroup: (groupId: string, userIds: string[]) => Promise<ActionResult>;
        archiveGroup: (groupId: string) => Promise<ActionResult>;
    };
}

const ViewUserGroupHeaderSubMenu = (props: Props) => {
    const {
        group,
        isGroupMember,
        currentUserId,
        decrementMemberCount,
        incrementMemberCount,
        backButtonCallback,
        backButtonAction,
        onExited,
        actions,
    } = props;

    const goToEditGroupModal = useCallback(() => {
        actions.openModal({
            modalId: ModalIdentifiers.EDIT_GROUP_MODAL,
            dialogType: UpdateUserGroupModal,
            dialogProps: {
                groupId: group.id,
                backButtonCallback: backButtonAction,
            },
        });
        onExited();
    }, [actions.openModal, group.id, backButtonAction, onExited]);

    const leaveGroup = useCallback(async () => {
        await actions.removeUsersFromGroup(group.id, [currentUserId]).then(() => {
            decrementMemberCount();
        });
    }, [group.id, actions.removeUsersFromGroup, decrementMemberCount, currentUserId]);

    const joinGroup = useCallback(async () => {
        await actions.addUsersToGroup(group.id, [currentUserId]).then(() => {
            incrementMemberCount();
        });
    }, [group.id, actions.addUsersToGroup, incrementMemberCount, currentUserId]);

    const archiveGroup = useCallback(async () => {
        await actions.archiveGroup(group.id).then(() => {
            backButtonCallback();
            onExited();
        });
    }, [group.id, actions.archiveGroup, backButtonCallback, onExited]);

    return (
        <div className='details-action'>
            <MenuWrapper
                isDisabled={false}
                stopPropagationOnToggle={false}
                id={`detailsCustomWrapper-${group.id}`}
            >
                <button className='action-wrapper btn-icon'>
                    <LocalizedIcon
                        className='icon icon-dots-vertical'
                        ariaLabel={{id: t('user_groups_modal.goBackLabel'), defaultMessage: 'Back'}}
                    />
                </button>
                <Menu
                    openLeft={false}
                    openUp={false}
                    ariaLabel={Utils.localizeMessage('admin.user_item.menuAriaLabel', 'User Actions Menu')}
                >
                    <Menu.ItemAction
                        show={props.permissionToEditGroup}
                        onClick={goToEditGroupModal}
                        text={Utils.localizeMessage('user_groups_modal.editDetails', 'Edit Details')}
                        disabled={false}
                    />
                    <Menu.ItemAction
                        show={props.permissionToJoinGroup && !isGroupMember}
                        onClick={joinGroup}
                        text={Utils.localizeMessage('user_groups_modal.joinGroup', 'Join Group')}
                        disabled={false}
                    />
                    <Menu.ItemAction
                        show={props.permissionToLeaveGroup && isGroupMember}
                        onClick={leaveGroup}
                        text={Utils.localizeMessage('user_groups_modal.leaveGroup', 'Leave Group')}
                        disabled={false}
                        isDangerous={true}
                    />
                    <Menu.ItemAction
                        show={props.permissionToArchiveGroup}
                        onClick={archiveGroup}
                        text={Utils.localizeMessage('user_groups_modal.archiveGroup', 'Archive Group')}
                        disabled={false}
                        isDangerous={true}
                    />
                </Menu>
            </MenuWrapper>
        </div>
    );
};

export default React.memo(ViewUserGroupHeaderSubMenu);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';

import {ActionFunc, ActionResult, GenericAction} from 'mattermost-redux/types/actions';

import {GlobalState} from 'types/store';
import {ModalData} from 'types/actions';
import {openModal} from 'actions/views/modals';
import {addUsersToGroup, archiveGroup, removeUsersFromGroup} from 'mattermost-redux/actions/groups';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';

import ViewUserGroupHeaderSubMenu from './view_user_group_header_sub_menu';

type Actions = {
    openModal: <P>(modalData: ModalData<P>) => void;
    removeUsersFromGroup: (groupId: string, userIds: string[]) => Promise<ActionResult>;
    addUsersToGroup: (groupId: string, userIds: string[]) => Promise<ActionResult>;
    archiveGroup: (groupId: string) => Promise<ActionResult>;
};

function mapStateToProps(state: GlobalState) {
    return {
        currentUserId: getCurrentUserId(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc | GenericAction>, Actions>({
            openModal,
            removeUsersFromGroup,
            addUsersToGroup,
            archiveGroup,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(ViewUserGroupHeaderSubMenu);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Modal} from 'react-bootstrap';
import {FormattedMessage} from 'react-intl';

import {ModalData} from 'types/actions';
import LocalizedIcon from 'components/localized_icon';
import {t} from 'utils/i18n';
import {Group} from '@mattermost/types/groups';
import {ModalIdentifiers} from 'utils/constants';
import AddUsersToGroupModal from 'components/add_users_to_group_modal';
import ViewUserGroupHeaderSubMenu from '../view_user_group_header_sub_menu';
import {ActionResult} from 'mattermost-redux/types/actions';

export type Props = {
    groupId: string;
    group: Group;
    onExited: () => void;
    backButtonCallback: () => void;
    backButtonAction: () => void;
    permissionToEditGroup: boolean;
    permissionToJoinGroup: boolean;
    permissionToLeaveGroup: boolean;
    permissionToArchiveGroup: boolean;
    isGroupMember: boolean;
    currentUserId: string;
    incrementMemberCount: () => void;
    decrementMemberCount: () => void;
    actions: {
        openModal: <P>(modalData: ModalData<P>) => void;
        removeUsersFromGroup: (groupId: string, userIds: string[]) => Promise<ActionResult>;
        addUsersToGroup: (groupId: string, userIds: string[]) => Promise<ActionResult>;
        archiveGroup: (groupId: string) => Promise<ActionResult>;
    };
}

const ViewUserGroupModalHeader = (props: Props) => {
    const goToAddPeopleModal = () => {
        const {actions, groupId} = props;

        actions.openModal({
            modalId: ModalIdentifiers.ADD_USERS_TO_GROUP,
            dialogType: AddUsersToGroupModal,
            dialogProps: {
                groupId,
                backButtonCallback: props.backButtonAction,
            },
        });
        props.onExited();
    };

    const showSubMenu = (source: string) => {
        const {permissionToEditGroup, permissionToJoinGroup, permissionToLeaveGroup, permissionToArchiveGroup} = props;

        return source.toLowerCase() !== 'ldap' &&
            (
                permissionToEditGroup ||
                permissionToJoinGroup ||
                permissionToLeaveGroup ||
                permissionToArchiveGroup
            );
    };

    const modalTitle = () => {
        const {group} = props;

        if (group) {
            return (
                <Modal.Title
                    componentClass='h1'
                    id='userGroupsModalLabel'
                >
                    {group.display_name}
                </Modal.Title>
            );
        }
        return (<></>);
    };

    const addPeopleButton = () => {
        const {group, permissionToJoinGroup} = props;

        if (group?.source.toLowerCase() !== 'ldap' && permissionToJoinGroup) {
            return (
                <button
                    className='user-groups-create btn btn-md btn-primary'
                    onClick={goToAddPeopleModal}
                >
                    <FormattedMessage
                        id='user_groups_modal.addPeople'
                        defaultMessage='AddPeople'
                    />
                </button>
            );
        }
        return (<></>);
    };

    const subMenuButton = () => {
        const {group} = props;

        if (group && showSubMenu(group?.source)) {
            return (
                <ViewUserGroupHeaderSubMenu
                    group={group}
                    isGroupMember={props.isGroupMember}
                    decrementMemberCount={props.decrementMemberCount}
                    incrementMemberCount={props.incrementMemberCount}
                    backButtonCallback={props.backButtonCallback}
                    backButtonAction={props.backButtonAction}
                    onExited={props.onExited}
                    permissionToEditGroup={props.permissionToEditGroup}
                    permissionToJoinGroup={props.permissionToJoinGroup}
                    permissionToLeaveGroup={props.permissionToLeaveGroup}
                    permissionToArchiveGroup={props.permissionToArchiveGroup}
                />
            );
        }
        return null;
    };

    return (
        <Modal.Header closeButton={true}>
            <button
                type='button'
                className='modal-header-back-button btn-icon'
                aria-label='Close'
                onClick={() => {
                    props.backButtonCallback();
                    props.onExited();
                }}
            >
                <LocalizedIcon
                    className='icon icon-arrow-left'
                    ariaLabel={{id: t('user_groups_modal.goBackLabel'), defaultMessage: 'Back'}}
                />
            </button>
            {modalTitle()}
            {addPeopleButton()}
            {subMenuButton()}
        </Modal.Header>
    );
};

export default React.memo(ViewUserGroupModalHeader);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';

import {ActionFunc, ActionResult, GenericAction} from 'mattermost-redux/types/actions';

import {GlobalState} from 'types/store';
import {ModalData} from 'types/actions';
import {openModal} from 'actions/views/modals';
import {getGroup as getGroupById, isMyGroup} from 'mattermost-redux/selectors/entities/groups';
import {addUsersToGroup, archiveGroup, removeUsersFromGroup} from 'mattermost-redux/actions/groups';
import {haveIGroupPermission} from 'mattermost-redux/selectors/entities/roles';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {Permissions} from 'mattermost-redux/constants';

import ViewUserGroupModalHeader from './view_user_group_modal_header';

type Actions = {
    openModal: <P>(modalData: ModalData<P>) => void;
    removeUsersFromGroup: (groupId: string, userIds: string[]) => Promise<ActionResult>;
    addUsersToGroup: (groupId: string, userIds: string[]) => Promise<ActionResult>;
    archiveGroup: (groupId: string) => Promise<ActionResult>;
};

type OwnProps = {
    groupId: string;
};

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const isGroupMember = isMyGroup(state, ownProps.groupId);
    const group = getGroupById(state, ownProps.groupId);

    const permissionToEditGroup = haveIGroupPermission(state, ownProps.groupId, Permissions.EDIT_CUSTOM_GROUP);
    const permissionToJoinGroup = haveIGroupPermission(state, ownProps.groupId, Permissions.MANAGE_CUSTOM_GROUP_MEMBERS);
    const permissionToLeaveGroup = haveIGroupPermission(state, ownProps.groupId, Permissions.MANAGE_CUSTOM_GROUP_MEMBERS);
    const permissionToArchiveGroup = haveIGroupPermission(state, ownProps.groupId, Permissions.DELETE_CUSTOM_GROUP);

    return {
        permissionToEditGroup,
        permissionToJoinGroup,
        permissionToLeaveGroup,
        permissionToArchiveGroup,
        isGroupMember,
        group,
        currentUserId: getCurrentUserId(state),
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc | GenericAction>, Actions>({
            openModal,
            removeUsersFromGroup,
            addUsersToGroup,
            archiveGroup,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(ViewUserGroupModalHeader);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback} from 'react';

import {Group, GroupSource} from '@mattermost/types/groups';
import {UserProfile} from '@mattermost/types/users';

import Avatar from 'components/widgets/users/avatar';
import * as Utils from 'utils/utils';
import LocalizedIcon from 'components/localized_icon';
import {t} from 'utils/i18n';
import {ActionResult} from 'mattermost-redux/types/actions';

export type Props = {
    groupId: string;
    user: UserProfile;
    group: Group;
    decrementMemberCount: () => void;
    permissionToLeaveGroup: boolean;
    actions: {
        removeUsersFromGroup: (groupId: string, userIds: string[]) => Promise<ActionResult>;
    };
}

const ViewUserGroupListItem = (props: Props) => {
    const {
        user,
        group,
        groupId,
    } = props;

    const removeUserFromGroup = useCallback(async () => {
        const {actions, decrementMemberCount} = props;

        await actions.removeUsersFromGroup(groupId, [user.id]).then((data) => {
            if (!data.error) {
                decrementMemberCount();
            }
        });
    }, [user.id, groupId, props.decrementMemberCount, props.actions.removeUsersFromGroup]);

    return (
        <div
            key={user.id}
            className='group-member-row'
        >
            <>
                <Avatar
                    username={user.username}
                    size={'sm'}
                    url={Utils.imageURLForUser(user?.id ?? '')}
                    className={'avatar-post-preview'}
                />
            </>
            <div className='group-member-name'>
                {Utils.getFullName(user)}
            </div>
            <div className='group-member-username'>
                {`@${user.username}`}
            </div>
            {
                (group.source.toLowerCase() !== GroupSource.Ldap && props.permissionToLeaveGroup) &&
                <button
                    type='button'
                    className='remove-group-member btn-icon'
                    aria-label='Close'
                    onClick={removeUserFromGroup}
                >
                    <LocalizedIcon
                        className='icon icon-trash-can-outline'
                        ariaLabel={{id: t('user_groups_modal.goBackLabel'), defaultMessage: 'Back'}}
                    />
                </button>
            }
        </div>
    );
};

export default React.memo(ViewUserGroupListItem);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';

import {ActionFunc, ActionResult, GenericAction} from 'mattermost-redux/types/actions';
import {GlobalState} from 'types/store';

import {getGroup as getGroupById} from 'mattermost-redux/selectors/entities/groups';
import {removeUsersFromGroup} from 'mattermost-redux/actions/groups';
import {haveIGroupPermission} from 'mattermost-redux/selectors/entities/roles';
import {Permissions} from 'mattermost-redux/constants';

import ViewUserGroupListItem from './view_user_group_list_item';

type Actions = {
    removeUsersFromGroup: (groupId: string, userIds: string[]) => Promise<ActionResult>;
};

type OwnProps = {
    groupId: string;
};

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const group = getGroupById(state, ownProps.groupId);
    const permissionToLeaveGroup = haveIGroupPermission(state, ownProps.groupId, Permissions.MANAGE_CUSTOM_GROUP_MEMBERS);

    return {
        group,
        permissionToLeaveGroup,
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc | GenericAction>, Actions>({
            removeUsersFromGroup,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(ViewUserGroupListItem);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {createRef, RefObject} from 'react';

import {Modal} from 'react-bootstrap';

import {FormattedMessage} from 'react-intl';

import {UserProfile} from '@mattermost/types/users';

import Constants from 'utils/constants';

import * as Utils from 'utils/utils';
import LoadingScreen from 'components/loading_screen';
import {Group, GroupSource} from '@mattermost/types/groups';

import './view_user_group_modal.scss';
import {debounce} from 'mattermost-redux/actions/helpers';

import {ActionResult} from 'mattermost-redux/types/actions';
import Input from 'components/widgets/inputs/input/input';
import NoResultsIndicator from 'components/no_results_indicator';
import {NoResultsVariant} from 'components/no_results_indicator/types';

import ViewUserGroupModalHeader from './view_user_group_modal_header';
import ViewUserGroupListItem from './view_user_group_list_item';

const USERS_PER_PAGE = 60;

export type Props = {
    onExited: () => void;
    searchTerm: string;
    groupId: string;
    group?: Group;
    users: UserProfile[];
    backButtonCallback: () => void;
    backButtonAction: () => void;
    actions: {
        getGroup: (groupId: string, includeMemberCount: boolean) => Promise<{data: Group}>;
        getUsersInGroup: (groupId: string, page: number, perPage: number) => Promise<{data: UserProfile[]}>;
        setModalSearchTerm: (term: string) => void;
        searchProfiles: (term: string, options: any) => Promise<ActionResult>;
    };
}

type State = {
    page: number;
    loading: boolean;
    show: boolean;
    selectedFilter: string;
    memberCount: number;
}

export default class ViewUserGroupModal extends React.PureComponent<Props, State> {
    private divScrollRef: RefObject<HTMLDivElement>;
    private searchTimeoutId: number

    constructor(props: Props) {
        super(props);

        this.divScrollRef = createRef();
        this.searchTimeoutId = 0;
        this.state = {
            page: 0,
            loading: true,
            show: true,
            selectedFilter: 'all',
            memberCount: props.group?.member_count || 0,
        };
    }

    incrementMemberCount = () => {
        this.setState({memberCount: this.state.memberCount + 1});
    }

    decrementMemberCount = () => {
        this.setState({memberCount: this.state.memberCount - 1});
    }

    doHide = () => {
        this.setState({show: false});
    }

    async componentDidMount() {
        const {
            groupId,
            actions,
        } = this.props;

        await Promise.all([
            actions.getGroup(groupId, true),
            actions.getUsersInGroup(groupId, 0, USERS_PER_PAGE),
        ]);
        this.loadComplete();
    }

    componentWillUnmount() {
        this.props.actions.setModalSearchTerm('');
    }

    componentDidUpdate(prevProps: Props) {
        if (prevProps.searchTerm !== this.props.searchTerm) {
            clearTimeout(this.searchTimeoutId);
            const searchTerm = this.props.searchTerm;

            if (searchTerm === '') {
                this.loadComplete();
                this.searchTimeoutId = 0;
                return;
            }

            const searchTimeoutId = window.setTimeout(
                async () => {
                    await prevProps.actions.searchProfiles(searchTerm, {in_group_id: this.props.groupId});
                },
                Constants.SEARCH_TIMEOUT_MILLISECONDS,
            );

            this.searchTimeoutId = searchTimeoutId;
        }
        if (prevProps.group?.member_count !== this.props.group?.member_count) {
            this.setMemberCount(this.props.group?.member_count || 0);
        }
    }

    setMemberCount = (count: number) => {
        this.setState({memberCount: count});
    }

    startLoad = () => {
        this.setState({loading: true});
    }

    loadComplete = () => {
        this.setState({loading: false});
    }

    handleSearch = (e: React.ChangeEvent<HTMLInputElement>) => {
        const term = e.target.value;
        this.props.actions.setModalSearchTerm(term);
    }

    getGroupMembers = debounce(
        async () => {
            const {actions, groupId} = this.props;
            const {page} = this.state;
            const newPage = page + 1;

            this.setState({page: newPage});

            this.startLoad();
            await actions.getUsersInGroup(groupId, newPage, USERS_PER_PAGE);
            this.loadComplete();
        },
        200,
        false,
        (): void => {},
    );

    onScroll = () => {
        const scrollHeight = this.divScrollRef.current?.scrollHeight || 0;
        const scrollTop = this.divScrollRef.current?.scrollTop || 0;
        const clientHeight = this.divScrollRef.current?.clientHeight || 0;

        if (((scrollTop + clientHeight + 30) >= scrollHeight && this.props.group) && (this.props.users.length !== this.props.group.member_count && this.state.loading === false)) {
            this.getGroupMembers();
        }
    }

    mentionName = () => {
        const {group} = this.props;

        if (group) {
            return (
                <div className='group-mention-name'>
                    <span className='group-name'>{`@ ${group.name}`}</span>
                    {
                        group.source.toLowerCase() === GroupSource.Ldap &&
                        <span className='group-source'>
                            <FormattedMessage
                                id='view_user_group_modal.ldapSynced'
                                defaultMessage='AD/LDAP SYNCED'
                            />
                        </span>
                    }
                </div>
            );
        }
        return (<></>);
    }

    render() {
        const {groupId, group, users, onExited} = this.props;

        return (
            <Modal
                dialogClassName='a11y__modal view-user-groups-modal'
                show={this.state.show}
                onHide={this.doHide}
                onExited={onExited}
                role='dialog'
                aria-labelledby='viewUserGroupModalLabel'
            >
                <ViewUserGroupModalHeader
                    onExited={onExited}
                    groupId={groupId}
                    backButtonCallback={this.props.backButtonCallback}
                    backButtonAction={this.props.backButtonAction}
                    incrementMemberCount={this.incrementMemberCount}
                    decrementMemberCount={this.decrementMemberCount}
                />
                <Modal.Body>
                    {this.mentionName()}
                    {((users.length === 0 && !this.props.searchTerm && !this.state.loading) || !group) ?
                        <NoResultsIndicator
                            variant={NoResultsVariant.UserGroupMembers}
                        /> :
                        <>
                            <div className='user-groups-search'>
                                <Input
                                    type='text'
                                    placeholder={Utils.localizeMessage('search_bar.searchGroupMembers', 'Search group members')}
                                    onChange={this.handleSearch}
                                    value={this.props.searchTerm}
                                    data-testid='searchInput'
                                    className={'user-group-search-input'}
                                    inputPrefix={<i className={'icon icon-magnify'}/>}
                                />
                            </div>
                            <div
                                className='user-groups-modal__content group-member-list'
                                onScroll={this.onScroll}
                                ref={this.divScrollRef}
                            >
                                {(users.length !== 0) &&
                                    <h2 className='group-member-count'>
                                        <FormattedMessage
                                            id='view_user_group_modal.memberCount'
                                            defaultMessage='{member_count} {member_count, plural, one {Member} other {Members}}'
                                            values={{
                                                member_count: this.state.memberCount,
                                            }}
                                        />
                                    </h2>
                                }
                                {(users.length === 0 && this.props.searchTerm) &&
                                    <NoResultsIndicator
                                        variant={NoResultsVariant.ChannelSearch}
                                        titleValues={{channelName: `"${this.props.searchTerm}"`}}
                                    />
                                }
                                {users.map((user) => {
                                    return (
                                        <ViewUserGroupListItem
                                            groupId={groupId}
                                            user={user}
                                            decrementMemberCount={this.decrementMemberCount}
                                            key={user.id}
                                        />
                                    );
                                })}
                                {
                                    this.state.loading &&
                                    <LoadingScreen/>
                                }
                            </div>
                        </>
                    }
                </Modal.Body>
            </Modal>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators, Dispatch, ActionCreatorsMapObject} from 'redux';

import {ActionFunc, ActionResult, GenericAction} from 'mattermost-redux/types/actions';

import {GlobalState} from 'types/store';

import {getProfilesInGroup, searchProfilesInGroup} from 'mattermost-redux/selectors/entities/users';
import {getGroup as getGroupById} from 'mattermost-redux/selectors/entities/groups';
import {getGroup} from 'mattermost-redux/actions/groups';
import {Group} from '@mattermost/types/groups';
import {ModalData} from 'types/actions';
import {openModal} from 'actions/views/modals';
import {setModalSearchTerm} from 'actions/views/search';
import {UserProfile} from '@mattermost/types/users';
import {getProfilesInGroup as getUsersInGroup, searchProfiles} from 'mattermost-redux/actions/users';

import ViewUserGroupModal from './view_user_group_modal';

type Actions = {
    getGroup: (groupId: string, includeMemberCount: boolean) => Promise<{data: Group}>;
    getUsersInGroup: (groupId: string, page: number, perPage: number) => Promise<{data: UserProfile[]}>;
    setModalSearchTerm: (term: string) => void;
    openModal: <P>(modalData: ModalData<P>) => void;
    searchProfiles: (term: string, options: any) => Promise<ActionResult>;
};

type OwnProps = {
    groupId: string;
};

function mapStateToProps(state: GlobalState, ownProps: OwnProps) {
    const searchTerm = state.views.search.modalSearch;

    const group = getGroupById(state, ownProps.groupId);

    let users: UserProfile[] = [];
    if (searchTerm) {
        users = searchProfilesInGroup(state, ownProps.groupId, searchTerm);
    } else {
        users = getProfilesInGroup(state, ownProps.groupId);
    }

    return {
        group,
        users,
        searchTerm,
    };
}

function mapDispatchToProps(dispatch: Dispatch) {
    return {
        actions: bindActionCreators<ActionCreatorsMapObject<ActionFunc | GenericAction>, Actions>({
            getGroup,
            getUsersInGroup,
            setModalSearchTerm,
            openModal,
            searchProfiles,
        }, dispatch),
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(ViewUserGroupModal);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo, ReactNode, HTMLAttributes} from 'react';
import classNames from 'classnames';

import './badge.scss';

export type BadgeVariant = 'info' | 'success' | 'warning' | 'danger';

export type BadgeSize = 'xs' | 'sm' | 'md' | 'lg';

type Props = {
    children: ReactNode;
    icon?: ReactNode;
    show?: boolean;
    size?: BadgeSize;
    uppercase?: boolean;
    variant?: BadgeVariant;
};

type Attrs = HTMLAttributes<HTMLElement>

const Badge = ({
    children,
    icon,
    show = true,
    size = 'xs',
    uppercase = false,
    variant,
    ...attrs
}: Props & Attrs) => {
    if (!show) {
        return null;
    }

    const ButtonOrDiv: keyof JSX.IntrinsicElements = attrs.onClick ? 'button' : 'div';

    return (
        <div className='Badge'>
            <ButtonOrDiv
                {...attrs}
                className={classNames(
                    'Badge__box',
                    attrs.className,
                    {
                        [`${variant}`]: variant,
                        [`Badge--${size}`]: size,
                        'Badge--uppercase': uppercase,
                    },
                )}
            >
                {icon && (
                    <span className='Badge__icon'>{icon}</span>
                )}
                {children}
            </ButtonOrDiv>
        </div>
    );
};

export default memo(Badge);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import Badge from './badge';

type Props = {
    className?: string;
    show?: boolean;
}

const BotBadge: React.FC<Props> = (props: Props) => (
    <Badge
        className={'BotBadge ' + props.className}
        show={props.show}
    >
        <FormattedMessage
            id='post_info.bot'
            defaultMessage='BOT'
        />
    </Badge>
);

BotBadge.defaultProps = {
    show: true,
    className: '',
};

export default BotBadge;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';

import Badge from './badge';

type Props = {
    className?: string;
    show?: boolean;
};

const GuestBadge: React.FC<Props> = (props: Props) => (
    <Badge
        className={'GuestBadge ' + props.className}
        show={props.show}
    >
        <FormattedMessage
            id='post_info.guest'
            defaultMessage='GUEST'
        />
    </Badge>
);

GuestBadge.defaultProps = {
    show: true,
    className: '',
};

export default GuestBadge;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function ArchiveIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='16px'
                height='16px'
                viewBox='0 0 16 16'
                role='img'
                aria-label={formatMessage({id: 'generic_icons.archive', defaultMessage: 'Archive Icon'})}
            >
                <path d='M13.994 14.75H2.006V6.50599H3.5V13.256H12.5V6.50599H13.994V14.75ZM1.25 1.24999H14.75V5.74999H1.25V1.24999ZM6.128 7.24399H9.872C9.98 7.24399 10.07 7.27999 10.142 7.35199C10.214 7.42399 10.25 7.51399 10.25 7.62199V8.75599H5.75V7.62199C5.75 7.51399 5.786 7.42399 5.858 7.35199C5.93 7.27999 6.02 7.24399 6.128 7.24399ZM2.744 2.74399V4.25599H13.256V2.74399H2.744Z'/>
            </svg>
        </span>
    );
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function CloseCircleSolidIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='16px'
                height='16px'
                viewBox='0 0 16 16'
                role='img'
                aria-label={formatMessage({id: 'generic_icons.close', defaultMessage: 'Close Icon'})}
            >
                <path
                    d='m 8,0 c 4.424,0 8,3.576 8,8 0,4.424 -3.576,8 -8,8 C 3.576,16 0,12.424 0,8 0,3.576 3.576,0 8,0 Z M 10.872,4 8,6.872 5.128,4 4,5.128 6.872,8 4,10.872 5.128,12 8,9.128 10.872,12 12,10.872 9.128,8 12,5.128 Z'
                />
            </svg>
        </span>
    );
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

import {t} from 'utils/i18n';

export default function CloseIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='24px'
                height='24px'
                viewBox='0 0 24 24'
                role='img'
                aria-label={formatMessage({id: t('generic_icons.close'), defaultMessage: 'Close Icon'})}
            >
                <path
                    fillRule='nonzero'
                    d='M18 7.209L16.791 6 12 10.791 7.209 6 6 7.209 10.791 12 6 16.791 7.209 18 12 13.209 16.791 18 18 16.791 13.209 12z'
                />
            </svg>
        </span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

export default class EmojiIcon extends React.PureComponent<React.HTMLAttributes<HTMLSpanElement>> {
    render() {
        return (
            <span {...this.props}>
                <svg
                    width='16px'
                    height='16px'
                    viewBox='0 0 16 16'
                    role='img'
                    aria-label='Emoji icon'
                >
                    <path d='M9.872 8.00005C10.184 8.00005 10.448 7.88605 10.664 7.65805C10.892 7.43005 11.006 7.16605 11.006 6.86605C11.006 6.56605 10.892 6.30805 10.664 6.09205C10.448 5.86405 10.184 5.75005 9.872 5.75005C9.572 5.75005 9.308 5.86405 9.08 6.09205C8.864 6.30805 8.756 6.56605 8.756 6.86605C8.756 7.16605 8.864 7.43005 9.08 7.65805C9.308 7.88605 9.572 8.00005 9.872 8.00005ZM5.372 8.00005C5.684 8.00005 5.948 7.88605 6.164 7.65805C6.392 7.43005 6.506 7.16605 6.506 6.86605C6.506 6.56605 6.392 6.30805 6.164 6.09205C5.948 5.86405 5.684 5.75005 5.372 5.75005C5.072 5.75005 4.808 5.86405 4.58 6.09205C4.364 6.30805 4.256 6.56605 4.256 6.86605C4.256 7.16605 4.364 7.43005 4.58 7.65805C4.808 7.88605 5.072 8.00005 5.372 8.00005ZM13.22 7.92805C13.244 8.12005 13.256 8.27005 13.256 8.37805C13.256 9.39805 12.998 10.34 12.482 11.204C11.99 12.056 11.318 12.728 10.466 13.22C9.59 13.736 8.642 13.994 7.622 13.994C6.602 13.994 5.654 13.736 4.778 13.22C3.938 12.728 3.266 12.056 2.762 11.204C2.258 10.34 2.006 9.39805 2.006 8.37805C2.006 7.35805 2.264 6.41005 2.78 5.53405C3.272 4.69405 3.944 4.02205 4.796 3.51805C5.66 3.00205 6.602 2.74405 7.622 2.74405C7.73 2.74405 7.88 2.75605 8.072 2.78005C8.144 2.27605 8.306 1.79005 8.558 1.32205C8.15 1.27405 7.838 1.25005 7.622 1.25005C6.338 1.25005 5.138 1.57405 4.022 2.22205C2.954 2.84605 2.102 3.69805 1.466 4.77805C0.818 5.88205 0.494 7.08205 0.494 8.37805C0.494 9.67405 0.818 10.874 1.466 11.978C2.102 13.058 2.954 13.91 4.022 14.534C5.138 15.182 6.338 15.506 7.622 15.506C8.906 15.506 10.106 15.182 11.222 14.534C12.29 13.898 13.142 13.046 13.778 11.978C14.426 10.862 14.75 9.66205 14.75 8.37805C14.75 8.16205 14.726 7.85005 14.678 7.44205C14.21 7.69405 13.724 7.85605 13.22 7.92805ZM11.744 0.494048H13.256V2.74405H15.506V4.25605H13.256V6.50605H11.744V4.25605H9.494V2.74405H11.744V0.494048ZM3.788 9.87205C4.088 10.652 4.586 11.288 5.282 11.78C5.978 12.26 6.758 12.5 7.622 12.5C8.486 12.5 9.266 12.26 9.962 11.78C10.658 11.288 11.162 10.652 11.474 9.87205H3.788Z'/>
                </svg>
            </span>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function AddIcon() {
    const {formatMessage} = useIntl();
    return (
        <i
            className='fa fa-plus'
            title={formatMessage({id: 'generic_icons.add', defaultMessage: 'Add Icon'})}
        />
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function BackIcon() {
    const {formatMessage} = useIntl();
    return (
        <i
            className='fa fa-angle-left'
            title={formatMessage({id: 'generic_icons.back', defaultMessage: 'Back Icon'})}
        />
    );
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function DropdownIcon() {
    const {formatMessage} = useIntl();
    return (
        <i
            className='fa fa-angle-down'
            title={formatMessage({id: 'generic_icons.dropdown', defaultMessage: 'Dropdown Icon'})}
        />
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function EditIcon() {
    const {formatMessage} = useIntl();
    return (
        <i
            className='icon-pencil-outline'
            title={formatMessage({id: 'generic_icons.edit', defaultMessage: 'Edit Icon'})}
        />
    );
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import LocalizedIcon from 'components/localized_icon';
import {t} from 'utils/i18n';

export default function SuccessIcon() {
    return (
        <LocalizedIcon
            className='fa fa-check'
            title={{id: t('generic_icons.success'), defaultMessage: 'Success Icon'}}
        />
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function FlagIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='16px'
                height='16px'
                viewBox='0 0 16 16'
                role='img'
                aria-label={formatMessage({id: 'generic_icons.flag', defaultMessage: 'Flag Icon'})}
            >
                <path d='M11.744 12.5L8 10.862L4.256 12.5V2.74405H11.744V12.5ZM11.744 1.25005H4.256C3.836 1.25005 3.476 1.40005 3.176 1.70005C2.888 1.98805 2.744 2.33605 2.744 2.74405V14.75L8 12.5L13.256 14.75V2.74405C13.256 2.33605 13.106 1.98805 12.806 1.70005C12.518 1.40005 12.164 1.25005 11.744 1.25005Z'/>
            </svg>
        </span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function FlagIconFilled(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='12px'
                height='15px'
                viewBox='0 0 12 15'
                role='img'
                aria-label={formatMessage({id: 'generic_icons.flagged', defaultMessage: 'Flagged Icon'})}
            >
                <g
                    stroke='none'
                    strokeWidth='1'
                    fill='inherit'
                    fillRule='evenodd'
                >
                    <g
                        transform='translate(-1073.000000, -33.000000)'
                        fillRule='nonzero'
                        fill='inherit'
                    >
                        <g transform='translate(-1.000000, 0.000000)'>
                            <g transform='translate(1064.000000, 22.000000)'>
                                <g transform='translate(10.000000, 11.000000)'>
                                    <path d='M9.76172 0.800049H2.23828C1.83984 0.800049 1.48828 0.952393 1.18359 1.25708C0.902344 1.53833 0.761719 1.88989 0.761719 2.31177V14.3L6 12.05L11.2383 14.3V2.31177C11.2383 1.88989 11.0859 1.53833 10.7812 1.25708C10.5 0.952393 10.1602 0.800049 9.76172 0.800049Z'/>
                                </g>
                            </g>
                        </g>
                    </g>
                </g>
            </svg>
        </span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function InfoSmallIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                className='svg-text-color'
                aria-label={formatMessage({id: 'generic_icons.info', defaultMessage: 'Info Icon'})}
                width='24px'
                height='24px'
                viewBox='0 0 24 24'
                version='1.1'
            >
                <g
                    stroke='none'
                    strokeWidth='1'
                    fill='inherit'
                    fillRule='evenodd'
                >
                    <g
                        transform='translate(-1015.000000, -516.000000)'
                        fill='inherit'
                    >
                        <path d='M1027,540 C1020.37258,540 1015,534.627417 1015,528 C1015,521.372583 1020.37258,516 1027,516 C1033.62742,516 1039,521.372583 1039,528 C1039,534.627417 1033.62742,540 1027,540 Z M1027,527 C1025.89543,527 1025,527.895431 1025,529 L1025,533 C1025,534.104569 1025.89543,535 1027,535 C1028.10457,535 1029,534.104569 1029,533 L1029,529 C1029,527.895431 1028.10457,527 1027,527 Z M1027,525 C1028.10457,525 1029,524.104569 1029,523 C1029,521.895431 1028.10457,521 1027,521 C1025.89543,521 1025,521.895431 1025,523 C1025,524.104569 1025.89543,525 1027,525 Z'/>
                    </g>
                </g>
            </svg>
        </span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {CSSProperties} from 'react';
import {useIntl} from 'react-intl';

export default function MattermostLogo(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                version='1.1'
                x='0px'
                y='0px'
                viewBox='0 0 500 500'
                enableBackground='new 0 0 500 500'
                role='img'
                aria-label={formatMessage({id: 'generic_icons.mattermost', defaultMessage: 'Mattermost Logo'})}
            >
                <g>
                    <g>
                        <path
                            style={style}
                            d='M396.9,47.7l2.6,53.1c43,47.5,60,114.8,38.6,178.1c-32,94.4-137.4,144.1-235.4,110.9 S51.1,253.1,83,158.7C104.5,95.2,159.2,52,222.5,40.5l34.2-40.4C150-2.8,49.3,63.4,13.3,169.9C-31,300.6,39.1,442.5,169.9,486.7 s272.6-25.8,316.9-156.6C522.7,223.9,483.1,110.3,396.9,47.7z'
                        />
                    </g>
                    <path
                        style={style}
                        d='M335.6,204.3l-1.8-74.2l-1.5-42.7l-1-37c0,0,0.2-17.8-0.4-22c-0.1-0.9-0.4-1.6-0.7-2.2 c0-0.1-0.1-0.2-0.1-0.3c0-0.1-0.1-0.2-0.1-0.2c-0.7-1.2-1.8-2.1-3.1-2.6c-1.4-0.5-2.9-0.4-4.2,0.2c0,0-0.1,0-0.1,0 c-0.2,0.1-0.3,0.1-0.4,0.2c-0.6,0.3-1.2,0.7-1.8,1.3c-3,3-13.7,17.2-13.7,17.2l-23.2,28.8l-27.1,33l-46.5,57.8 c0,0-21.3,26.6-16.6,59.4s29.1,48.7,48,55.1c18.9,6.4,48,8.5,71.6-14.7C336.4,238.4,335.6,204.3,335.6,204.3z'
                    />
                </g>
            </svg>
        </span>
    );
}

const style: CSSProperties = {
    fillRule: 'evenodd',
    clipRule: 'evenodd',
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function MentionsIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='12px'
                height='12px'
                viewBox='0 0 18 18'
                version='1.1'
                role='img'
                aria-label={formatMessage({id: 'generic_icons.mention', defaultMessage: 'Mention Icon'})}
                fill='inherit'
            >
                <path d='M9 11.7C9.72 11.7 10.35 11.43 10.89 10.89C11.43 10.35 11.7 9.71999 11.7 8.99999C11.7 8.27999 11.43 7.64999 10.89 7.10999C10.35 6.56999 9.72 6.29999 9 6.29999C8.28 6.29999 7.65 6.56999 7.11 7.10999C6.57 7.64999 6.3 8.27999 6.3 8.99999C6.3 9.71999 6.57 10.35 7.11 10.89C7.65 11.43 8.28 11.7 9 11.7ZM9 -1.26362e-05C11.46 -1.26362e-05 13.56 0.869987 15.3 2.60999C16.176 3.48599 16.842 4.45199 17.298 5.50799C17.766 6.59999 18 7.76399 18 8.99999V10.26C18 10.692 17.916 11.118 17.748 11.538C17.592 11.922 17.376 12.276 17.1 12.6C16.788 12.912 16.446 13.14 16.074 13.284C15.714 13.428 15.306 13.5 14.85 13.5C13.746 13.5 12.876 13.05 12.24 12.15C11.34 13.05 10.26 13.5 9 13.5C7.716 13.5 6.666 13.05 5.85 12.15C4.95 11.25 4.5 10.2 4.5 8.99999C4.5 7.70399 4.95 6.65399 5.85 5.84999C6.666 4.94999 7.716 4.49999 9 4.49999C10.296 4.49999 11.346 4.94999 12.15 5.84999C13.05 6.74999 13.5 7.79999 13.5 8.99999V10.26C13.5 10.44 13.536 10.614 13.608 10.782C13.692 10.95 13.8 11.106 13.932 11.25C14.076 11.382 14.232 11.49 14.4 11.574C14.568 11.658 14.718 11.7 14.85 11.7C15.03 11.7 15.204 11.664 15.372 11.592C15.54 11.508 15.696 11.394 15.84 11.25C16.08 11.01 16.2 10.68 16.2 10.26V8.99999C16.2 7.01999 15.48 5.30999 14.04 3.86999C13.332 3.16199 12.564 2.63999 11.736 2.30399C10.908 1.96799 9.996 1.79999 9 1.79999C7.056 1.79999 5.346 2.48999 3.87 3.86999C3.174 4.52999 2.652 5.30399 2.304 6.19199C1.968 7.04399 1.8 7.97999 1.8 8.99999C1.8 9.98399 1.974 10.902 2.322 11.754C2.67 12.594 3.186 13.356 3.87 14.04C4.554 14.724 5.328 15.252 6.192 15.624C7.092 16.008 8.028 16.2 9 16.2H13.5V18H9C7.752 18 6.6 17.772 5.544 17.316C4.488 16.872 3.51 16.2 2.61 15.3C1.71 14.4 1.05 13.44 0.63 12.42C0.21 11.4 0 10.266 0 9.01799C0 7.75799 0.222 6.59399 0.666 5.52599C1.098 4.49399 1.746 3.52199 2.61 2.60999C4.266 0.869987 6.396 -1.26362e-05 9 -1.26362e-05Z'/>
            </svg>
        </span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function PluginIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='61px'
                height='61px'
                viewBox='0 0 61 61'
                aria-label={formatMessage({id: 'generic_icons.plugin', defaultMessage: 'Plugin Icon'})}
            >
                <g
                    stroke='none'
                    strokeWidth='1'
                    fill='inherit'
                    fillRule='evenodd'
                >
                    <g
                        transform='translate(-347.000000, -211.000000)'
                        fill='inherit'
                    >
                        <g transform='translate(377.585786, 241.500000) rotate(-315.000000) translate(-377.585786, -241.500000) translate(358.585786, 200.000000)'>
                            <g transform='translate(0.000000, -0.000000)'>
                                <path
                                    d='M3.28846154,6.10822511 L3.05411255,6.10822511 C1.36737277,6.10822511 2.06566048e-16,4.74085234 0,3.05411255 C-2.06566048e-16,1.36737277 1.36737277,-7.78498519e-14 3.05411255,-7.81597009e-14 L34.9458874,-7.81597009e-14 C36.6326272,-8.16905472e-14 38,1.36737277 38,3.05411255 C38,4.74085234 36.6326272,6.10822511 34.9458874,6.10822511 L34.7115385,6.10822511 L34.7115385,14.7316017 C34.7115385,20.9798931 29.0184395,26.1638765 21.5576923,27.1415606 L21.5576923,33.1964286 C21.5576923,34.5081049 20.4943686,35.5714286 19.1826923,35.5714286 C17.871016,35.5714286 16.8076923,34.5081049 16.8076923,33.1964286 L16.8076923,27.1859094 C9.16823824,26.3322077 3.28846154,21.0815081 3.28846154,14.7316017 L3.28846154,6.10822511 Z M19.1431901,14.7316017 C17.8533303,14.7316017 16.8076923,15.7772397 16.8076923,17.0670996 C16.8076923,18.3569594 17.8533303,19.4025974 19.1431901,19.4025974 L19.2221945,19.4025974 C20.5120543,19.4025974 21.5576923,18.3569594 21.5576923,17.0670996 C21.5576923,15.7772397 20.5120543,14.7316017 19.2221945,14.7316017 L19.1431901,14.7316017 Z'
                                    transform='translate(19.000000, 17.785714) rotate(-180.000000) translate(-19.000000, -17.785714) '
                                />
                                <path
                                    d='M32.1538462,53.5367965 L34.7115385,53.5367965 L34.7115385,62.1601732 C34.7115385,68.4084646 29.0184395,73.592448 21.5576923,74.5701321 L21.5576923,80.625 C21.5576923,81.9366763 20.4943686,83 19.1826923,83 C17.871016,83 16.8076923,81.9366763 16.8076923,80.625 L16.8076923,74.6144809 C9.16823824,73.7607791 3.28846154,68.5100796 3.28846154,62.1601732 L3.28846154,53.5367965 L3.05411255,53.5367965 C1.36737277,53.5367965 2.06566048e-16,52.1694238 0,50.482684 C-2.06566048e-16,48.7959442 1.36737277,47.4285714 3.05411255,47.4285714 L8.40384615,47.4285714 L8.40384615,42.2581169 C8.40384615,40.9464406 9.46716987,39.8831169 10.7788462,39.8831169 C12.0905224,39.8831169 13.1538462,40.9464406 13.1538462,42.2581169 L13.1538462,47.4285714 L24.8461538,47.4285714 L24.8461538,42.2581169 C24.8461538,40.9464406 25.9094776,39.8831169 27.2211538,39.8831169 C28.5328301,39.8831169 29.5961538,40.9464406 29.5961538,42.2581169 L29.5961538,47.4285714 L34.9458874,47.4285714 C36.6326272,47.4285714 38,48.7959442 38,50.482684 C38,52.1694238 36.6326272,53.5367965 34.9458874,53.5367965 L32.1538462,53.5367965 Z M19.1431901,62.1601732 C17.8533303,62.1601732 16.8076923,63.2058112 16.8076923,64.495671 C16.8076923,65.7855308 17.8533303,66.8311688 19.1431901,66.8311688 L19.2221945,66.8311688 C20.5120543,66.8311688 21.5576923,65.7855308 21.5576923,64.495671 C21.5576923,63.2058112 20.5120543,62.1601732 19.2221945,62.1601732 L19.1431901,62.1601732 Z'
                                    transform='translate(19.000000, 61.441558) rotate(-360.000000) translate(-19.000000, -61.441558) '
                                />
                            </g>
                        </g>
                    </g>
                </g>
            </svg>
        </span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function SearchIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='16px'
                height='16px'
                viewBox='0 0 17 17'
                role='img'
                aria-label={formatMessage({id: 'generic_icons.search', defaultMessage: 'Search Icon'})}
            >
                <path d='M16.398 15.138L13.014 11.754C13.458 11.178 13.8 10.548 14.04 9.86399C14.28 9.14399 14.4 8.40599 14.4 7.64999C14.4 6.42599 14.094 5.29199 13.482 4.24799C12.882 3.22799 12.072 2.41799 11.052 1.81799C10.008 1.20599 8.874 0.899988 7.65 0.899988C6.426 0.899988 5.292 1.20599 4.248 1.81799C3.228 2.41799 2.418 3.22799 1.818 4.24799C1.206 5.29199 0.9 6.42599 0.9 7.64999C0.9 8.87399 1.206 10.008 1.818 11.052C2.418 12.072 3.228 12.882 4.248 13.482C5.292 14.094 6.426 14.4 7.65 14.4C8.406 14.4 9.138 14.274 9.846 14.022C10.53 13.794 11.16 13.458 11.736 13.014L15.138 16.398C15.306 16.566 15.516 16.65 15.768 16.65C16.02 16.65 16.23 16.56 16.398 16.38C16.566 16.212 16.65 16.008 16.65 15.768C16.65 15.528 16.566 15.318 16.398 15.138ZM2.7 7.64999C2.7 6.74999 2.922 5.92199 3.366 5.16599C3.81 4.40999 4.41 3.80999 5.166 3.36599C5.922 2.92199 6.75 2.69999 7.65 2.69999C8.55 2.69999 9.378 2.92199 10.134 3.36599C10.89 3.80999 11.49 4.40999 11.934 5.16599C12.378 5.92199 12.6 6.74999 12.6 7.64999C12.6 8.54999 12.378 9.37799 11.934 10.134C11.49 10.89 10.89 11.49 10.134 11.934C9.378 12.378 8.55 12.6 7.65 12.6C6.75 12.6 5.922 12.378 5.166 11.934C4.41 11.49 3.81 10.89 3.366 10.134C2.922 9.37799 2.7 8.54999 2.7 7.64999Z'/>
            </svg>
        </span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function UnreadBelowIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                xmlns='http://www.w3.org/2000/svg'
                width='16'
                height='16'
                viewBox='0 0 16 16'
                role='img'
                aria-label={formatMessage({id: 'generic_icons.arrow.down', defaultMessage: 'Down Arrow Icon'})}
            >
                <path d='M8.696 2H7.184V11L3.062 6.878L2 7.94L7.94 13.88L13.88 7.94L12.818 6.878L8.696 11V2Z'/>
            </svg>
        </span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState, useEffect} from 'react';
import {useIntl} from 'react-intl';

import classNames from 'classnames';

import {ItemStatus} from 'utils/constants';

import './input.scss';

export enum SIZE {
    MEDIUM = 'medium',
    LARGE = 'large',
}

export type CustomMessageInputType = {type: 'info' | 'error' | 'warning' | 'success'; value: string} | null;

interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
    required?: boolean;
    hasError?: boolean;
    addon?: React.ReactElement;
    textPrefix?: string;
    inputPrefix?: JSX.Element;
    inputSuffix?: JSX.Element;
    label?: string;
    containerClassName?: string;
    wrapperClassName?: string;
    inputClassName?: string;
    limit?: number;
    useLegend?: boolean;
    customMessage?: CustomMessageInputType;
    inputSize?: SIZE;
}

const Input = React.forwardRef((
    {
        name,
        value,
        label,
        placeholder,
        useLegend = true,
        className,
        hasError,
        required,
        addon,
        textPrefix,
        inputPrefix,
        inputSuffix,
        containerClassName,
        wrapperClassName,
        inputClassName,
        limit,
        customMessage,
        maxLength,
        inputSize = SIZE.MEDIUM,
        disabled,
        onFocus,
        onBlur,
        onChange,
        ...otherProps
    }: InputProps,
    ref?: React.Ref<HTMLInputElement>,
) => {
    const {formatMessage} = useIntl();

    const [focused, setFocused] = useState(false);
    const [customInputLabel, setCustomInputLabel] = useState<CustomMessageInputType>(null);

    useEffect(() => {
        if (customMessage !== undefined && customMessage !== null && customMessage.value !== '') {
            setCustomInputLabel(customMessage);
        }
    }, [customMessage]);

    const handleOnFocus = (event: React.FocusEvent<HTMLInputElement>) => {
        setFocused(true);

        if (onFocus) {
            onFocus(event);
        }
    };

    const handleOnBlur = (event: React.FocusEvent<HTMLInputElement>) => {
        setFocused(false);
        validateInput();

        if (onBlur) {
            onBlur(event);
        }
    };

    const handleOnChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        setCustomInputLabel(null);

        if (onChange) {
            onChange(event);
        }
    };

    const validateInput = () => {
        if (!required || (value !== null && value !== '')) {
            return;
        }
        const validationErrorMsg = formatMessage({id: 'widget.input.required', defaultMessage: 'This field is required'});
        setCustomInputLabel({type: ItemStatus.ERROR, value: validationErrorMsg});
    };

    const showLegend = Boolean(focused || value);
    const error = customInputLabel?.type === 'error';
    const limitExceeded = limit && value && !Array.isArray(value) ? value.toString().length - limit : 0;

    return (
        <div className={classNames('Input_container', containerClassName, {disabled})}>
            <fieldset
                className={classNames('Input_fieldset', className, {
                    Input_fieldset___error: error || hasError || limitExceeded > 0,
                    Input_fieldset___legend: showLegend,
                })}
            >
                {useLegend && (
                    <legend className={classNames('Input_legend', {Input_legend___focus: showLegend})}>
                        {showLegend ? label || placeholder : null}
                    </legend>
                )}
                <div className={classNames('Input_wrapper', wrapperClassName)}>
                    {inputPrefix}
                    {textPrefix && <span>{textPrefix}</span>}
                    <input
                        ref={ref}
                        id={`input_${name || ''}`}
                        className={classNames('Input form-control', inputSize, inputClassName, {Input__focus: showLegend})}
                        value={value}
                        placeholder={focused ? (label && placeholder) || label : label || placeholder}
                        name={name}
                        disabled={disabled}
                        {...otherProps}
                        maxLength={limit ? undefined : maxLength}
                        onFocus={handleOnFocus}
                        onBlur={handleOnBlur}
                        onChange={handleOnChange}
                    />
                    {limitExceeded > 0 && (
                        <span className='Input_limit-exceeded'>
                            {'-'}{limitExceeded}
                        </span>
                    )}
                    {inputSuffix}
                </div>
                {addon}
            </fieldset>
            {customInputLabel && (
                <div className={`Input___customMessage Input___${customInputLabel.type}`}>
                    <i
                        className={classNames(`icon ${customInputLabel.type}`, {
                            'icon-alert-outline': customInputLabel.type === ItemStatus.WARNING,
                            'icon-alert-circle-outline': customInputLabel.type === ItemStatus.ERROR,
                            'icon-information-outline': customInputLabel.type === ItemStatus.INFO,
                            'icon-check': customInputLabel.type === ItemStatus.SUCCESS,
                        })}
                    />
                    <span>{customInputLabel.value}</span>
                </div>
            )}
        </div>
    );
});

export default Input;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import LocalizedIcon from 'components/localized_icon';

import {t} from 'utils/i18n';

type Props = {
    text: React.ReactNode;
    style?: React.CSSProperties;
}

export default class LoadingSpinner extends React.PureComponent<Props> {
    public static defaultProps: Props = {
        text: null,
    }

    public render() {
        return (
            <span
                id='loadingSpinner'
                className={'LoadingSpinner' + (this.props.text ? ' with-text' : '')}
                style={this.props.style}
            >
                <LocalizedIcon
                    className='fa fa-spinner fa-fw fa-pulse spinner'
                    component='span'
                    title={{id: t('generic_icons.loading'), defaultMessage: 'Loading Icon'}}
                />
                {this.props.text}
            </span>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import LoadingSpinner from './loading_spinner';

type Props = {
    loading: boolean;
    text: React.ReactNode;
    children: React.ReactNode;
}

export default class LoadingWrapper extends React.PureComponent<Props> {
    public static defaultProps: Props = {
        loading: true,
        text: null,
        children: null,
    }

    public render() {
        const {text, loading, children} = this.props;
        if (!loading) {
            return children;
        }

        return <LoadingSpinner text={text}/>;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {CSSProperties} from 'react';
import classNames from 'classnames';

import * as Utils from 'utils/utils';
import {showMobileSubMenuModal} from 'actions/global_actions';

import type {Menu} from 'types/store/plugins';

import './menu_item.scss';
import Constants from 'utils/constants';

// Requires an object conforming to a submenu structure passed to registerPostDropdownSubMenuAction
// of the form:
// {
//     "id": "A",
//     "parentMenuId": null,
//     "text": "A text",
//     "subMenu": [
//         {
//             "id": "B",
//             "parentMenuId": "A",
//             "text": "B text"
//             "subMenu": [],
//             "action": () => {},
//             "filter": () => {},
//         }
//     ],
//     "action": () => {},
//     "filter": () => {},
// }
// Submenus can contain Submenus as well

export type Props = {
    id?: string;
    postId?: string;
    text: React.ReactNode;
    selectedValueText?: React.ReactNode;
    renderSelected?: boolean;
    subMenu?: Menu[];
    subMenuClass?: string;
    icon?: React.ReactNode;
    action?: (id?: string) => void;
    filter?: (id?: string) => boolean;
    ariaLabel?: string;
    root?: boolean;
    show?: boolean;
    direction?: 'left' | 'right';
    openUp?: boolean;
    styleSelectableItem?: boolean;
    extraText?: string;
    rightDecorator?: React.ReactNode;
    isHeader?: boolean;
}

type State = {
    show: boolean;
}

export default class SubMenuItem extends React.PureComponent<Props, State> {
    private node: React.RefObject<HTMLLIElement>;

    public static defaultProps = {
        show: true,
        direction: 'left',
        subMenuClass: 'pl-4',
        renderSelected: true,
    };

    public constructor(props: Props) {
        super(props);
        this.node = React.createRef();

        this.state = {
            show: false,
        };
    }

    show = () => {
        this.setState({show: true});
    }

    hide = () => {
        this.setState({show: false});
    }

    private onClick = (event: React.SyntheticEvent<HTMLElement>) => {
        event.preventDefault();
        const {id, postId, subMenu, action, root, isHeader} = this.props;
        const isMobile = Utils.isMobile();
        if (isHeader) {
            event.stopPropagation();
            return;
        }
        if (isMobile) {
            if (subMenu && subMenu.length) { // if contains a submenu, call openModal with it
                if (!root) { //required to close only the original menu
                    event.stopPropagation();
                }
                showMobileSubMenuModal(subMenu);
            } else if (action) { // leaf node in the tree handles action only
                action(postId);
            }
        } else if (event.currentTarget.id === id && action) {
            action(postId);
        }
    }

    handleKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (Utils.isKeyPressed(event, Constants.KeyCodes.ENTER)) {
            if (this.props.action) {
                this.onClick(event);
            } else {
                this.show();
            }
        }

        if (Utils.isKeyPressed(event, Constants.KeyCodes.RIGHT)) {
            if (this.props.direction === 'right') {
                this.show();
            } else {
                this.hide();
            }
        }

        if (Utils.isKeyPressed(event, Constants.KeyCodes.LEFT)) {
            if (this.props.direction === 'left') {
                this.show();
            } else {
                this.hide();
            }
        }
    }

    public render() {
        const {id, postId, text, selectedValueText, subMenu, icon, filter, ariaLabel, direction, styleSelectableItem, extraText, renderSelected, rightDecorator} = this.props;
        const isMobile = Utils.isMobile();

        if (filter && !filter(id)) {
            return ('');
        }

        let textProp = text;
        if (icon) {
            textProp = (
                <React.Fragment>
                    <span className={classNames(['icon', {'sorting-menu-icon': styleSelectableItem}])}>{icon}</span>
                    {textProp}
                </React.Fragment>
            );
        }

        const hasSubmenu = subMenu && subMenu.length;
        const subMenuStyle: CSSProperties = {
            visibility: (this.state.show && hasSubmenu && !isMobile ? 'visible' : 'hidden') as 'visible' | 'hidden',
            top: this.node && this.node.current ? String(this.node.current.offsetTop) + 'px' : 'unset',
        };

        const menuOffset = '100%';
        if (direction === 'left') {
            subMenuStyle.right = menuOffset;
        } else {
            subMenuStyle.left = menuOffset;
        }

        let subMenuContent: React.ReactNode = '';

        if (!isMobile) {
            subMenuContent = (
                <ul
                    className={classNames(['a11y__popup Menu dropdown-menu SubMenu', {styleSelectableItem}])}
                    style={subMenuStyle}
                >
                    {hasSubmenu ? subMenu!.map((s) => {
                        const hasDivider = s.id === 'ChannelMenu-moveToDivider';
                        return (
                            <span
                                className={classNames(['SubMenuItemContainer', {hasDivider}])}
                                key={s.id}
                            >
                                <SubMenuItem
                                    id={s.id}
                                    postId={postId}
                                    text={s.text}
                                    selectedValueText={s.selectedValueText}
                                    icon={s.icon}
                                    subMenu={s.subMenu}
                                    action={s.action}
                                    filter={s.filter}
                                    ariaLabel={ariaLabel}
                                    root={false}
                                    direction={s.direction}
                                    isHeader={s.isHeader}
                                />
                                {s.text === selectedValueText && <span className='sorting-menu-checkbox'>
                                    <i className='icon-check'/>
                                </span>}
                            </span>
                        );
                    }) : ''}
                </ul>
            );
        }

        return (
            <li
                className={classNames(['SubMenuItem MenuItem', {styleSelectableItem}])}
                role='menuitem'
                id={id + '_menuitem'}
                ref={this.node}
                onClick={this.onClick}
            >
                <div
                    className={classNames([{styleSelectableItemDiv: styleSelectableItem}])}
                    id={id}
                    aria-label={ariaLabel}
                    onMouseEnter={this.show}
                    onMouseLeave={this.hide}
                    onClick={this.onClick}
                    tabIndex={0}
                    onKeyDown={this.handleKeyDown}
                >
                    <div className={icon ? 'grid' : 'flex'}>
                        {textProp}{rightDecorator}
                        {renderSelected && <span className='selected'>{selectedValueText}</span>}
                        {id !== 'ChannelMenu-moveToDivider' &&
                            <span
                                id={'channelHeaderDropdownIconRight_' + id}
                                className={classNames([`fa fa-angle-right SubMenu__icon-right${hasSubmenu ? '' : '-empty'}`, {mobile: isMobile}])}
                                aria-label={Utils.localizeMessage('post_info.submenu.icon', 'submenu icon').toLowerCase()}
                            />
                        }
                    </div>
                    {extraText && <span className='MenuItem__help-text'>{extraText}</span>}
                    {subMenuContent}
                </div>
            </li>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import './menu_header.scss';

type Props = {
    divider?: React.ReactNode;
    children?: React.ReactNode;
    onClick?: () => void;
}

export default class MenuHeader extends React.PureComponent<Props> {
    public render() {
        const {children, onClick} = this.props;

        return (
            <li
                className='MenuHeader'
                onClick={onClick}
            >
                {children}
            </li>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import classNames from 'classnames';
import React from 'react';

import menuItem from './menu_item';

type Props = {
    onClick: (e: React.MouseEvent) => void;
    ariaLabel?: string;
    text: React.ReactNode;
    extraText?: string;
    id?: string;
    buttonClass?: string;
    rightDecorator?: React.ReactNode;
    isDangerous?: boolean;
    disabled?: boolean;
    sibling?: React.ReactNode;
}
export const MenuItemActionImpl = ({
    onClick,
    ariaLabel,
    text,
    extraText,
    id,
    buttonClass,
    rightDecorator,
    isDangerous,
    disabled,
    sibling,
}: Props) => (
    <>
        <button
            data-testid={id}
            id={id}
            aria-label={ariaLabel}
            className={classNames('style--none', buttonClass, {
                'MenuItem__with-help': extraText,
                'MenuItem__with-sibling': sibling,
                disabled,
                MenuItem__dangerous: isDangerous,
            })}
            onClick={onClick}
            disabled={disabled}
        >
            {text && <span className='MenuItem__primary-text'>{text}{rightDecorator}</span>}
            {extraText && <span className='MenuItem__help-text'>{extraText}</span>}
        </button>
        {sibling}
    </>

);

const MenuItemAction = menuItem(MenuItemActionImpl);
MenuItemAction.displayName = 'MenuItemAction';

export default MenuItemAction;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import menuItem from './menu_item';

type Props = {
    url: string;
    text: React.ReactNode;
    onClick?: (event: React.MouseEvent<HTMLElement>) => void;
}
export const MenuItemExternalLinkImpl: React.FC<Props> = ({url, text, onClick}: Props) => (
    <a
        target='_blank'
        rel='noopener noreferrer'
        href={url}
        onClick={onClick}
    >
        <span className='MenuItem__primary-text'>
            {text}
        </span>
    </a>
);

const MenuItemExternalLink = menuItem(MenuItemExternalLinkImpl);
MenuItemExternalLink.displayName = 'MenuItemExternalLink';
export default MenuItemExternalLink;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import classNames from 'classnames';
import React from 'react';
import {Link} from 'react-router-dom';

import menuItem from './menu_item';

type Props = {
    to: string;
    text: React.ReactNode;
    className?: string;
    disabled?: boolean;
    sibling?: React.ReactNode;
}

export const MenuItemLinkImpl = ({to, text, className, disabled, sibling}: Props) => (
    <>
        <Link
            to={to}
            className={classNames(className, {'MenuItem__with-sibling': sibling, disabled})}
            disabled={disabled}
        >
            <span className='MenuItem__primary-text'>{text}</span>
        </Link>
        {sibling}
    </>
);

const MenuItemLink = menuItem(MenuItemLinkImpl);
MenuItemLink.displayName = 'MenuItemLink';

export default MenuItemLink;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';
import {useSelector, useDispatch} from 'react-redux';

import moment from 'moment';

import TrialBenefitsModal from 'components/trial_benefits_modal/trial_benefits_modal';
import LearnMoreTrialModal from 'components/learn_more_trial_modal/learn_more_trial_modal';

import {DispatchFunc} from 'mattermost-redux/types/actions';
import {getLicense} from 'mattermost-redux/selectors/entities/general';
import {isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';
import {getCloudSubscription, getSubscriptionProduct} from 'mattermost-redux/selectors/entities/cloud';

import {openModal} from 'actions/views/modals';

import {ModalIdentifiers, CloudProducts} from 'utils/constants';
import useGetHighestThresholdCloudLimit from 'components/common/hooks/useGetHighestThresholdCloudLimit';
import useOpenPricingModal from 'components/common/hooks/useOpenPricingModal';
import useGetLimits from 'components/common/hooks/useGetLimits';
import useGetUsage from 'components/common/hooks/useGetUsage';

import './menu_item.scss';

type Props = {
    id: string;
}
const MenuCloudTrial = ({id}: Props): JSX.Element | null => {
    const subscription = useSelector(getCloudSubscription);
    const subscriptionProduct = useSelector(getSubscriptionProduct);
    const license = useSelector(getLicense);
    const dispatch = useDispatch<DispatchFunc>();

    const isCloud = license?.Cloud === 'true';
    const isFreeTrial = subscription?.is_free_trial === 'true';
    const noPriorTrial = !(subscription?.is_free_trial === 'false' && subscription?.trial_end_at > 0);
    const freeTrialEndDay = moment(subscription?.trial_end_at).format('MMMM DD');
    const isAdmin = useSelector(isCurrentUserSystemAdmin);
    const openPricingModal = useOpenPricingModal();

    const openTrialBenefitsModal = async () => {
        await dispatch(openModal({
            modalId: ModalIdentifiers.TRIAL_BENEFITS_MODAL,
            dialogType: TrialBenefitsModal,
        }));
    };

    const openLearnMoreTrialModal = async () => {
        await dispatch(openModal({
            modalId: ModalIdentifiers.LEARN_MORE_TRIAL_MODAL,
            dialogType: LearnMoreTrialModal,
        }));
    };

    const someLimitNeedsAttention = Boolean(useGetHighestThresholdCloudLimit(useGetUsage(), useGetLimits()[0]));

    if (!isCloud) {
        return null;
    }

    const isStarter = subscriptionProduct?.sku === CloudProducts.STARTER;

    if (someLimitNeedsAttention || (!isStarter && !isFreeTrial)) {
        return null;
    }

    // for end users only display the trial information
    if (!isAdmin && !isFreeTrial) {
        return null;
    }

    const freeTrialContent = (
        <div className='MenuCloudTrial__free-trial'>
            <h5 className='MenuCloudTrial__free-trial__content-title'>
                <FormattedMessage
                    id='menu.cloudFree.enterpriseTrialTitle'
                    defaultMessage='Enterprise Trial'
                />
            </h5>
            <div className='MenuCloudTrial__free-trial__content-section'>
                <div className='MenuCloudTrial__free-trial__content-section__icon-section'>
                    <i className='icon-arrow-up-bold-circle-outline'/>
                </div>
                <FormattedMessage
                    id='menu.cloudFree.enterpriseTrialDescription'
                    defaultMessage='Your trial is active until {trialEndDay}. Discover our top Enterprise features. <openModalLink>Learn more</openModalLink>'
                    values={
                        {
                            trialEndDay: freeTrialEndDay,
                            openModalLink: (msg: string) => (
                                <a
                                    className='open-trial-benefits-modal style-link'
                                    onClick={isAdmin ? openTrialBenefitsModal : () => openPricingModal({trackingLocation: 'menu_cloud_trial'})}
                                >
                                    {msg}
                                </a>
                            ),
                        }
                    }
                />
            </div>
        </div>
    );

    // menu option displayed when the workspace is not running any trial
    const noFreeTrialContent = noPriorTrial ? (
        <FormattedMessage
            id='menu.cloudFree.priorTrial.tryEnterprise'
            defaultMessage='Interested in a limitless plan with high-security features? <openModalLink>Try Enterprise free for 30 days</openModalLink>'
            values={
                {
                    openModalLink: (msg: string) => (
                        <a
                            className='open-learn-more-trial-modal style-link'
                            onClick={openLearnMoreTrialModal}
                        >
                            {msg}
                        </a>
                    ),
                }
            }
        />
    ) : (
        <FormattedMessage
            id='menu.cloudFree.postTrial.tryEnterprise'
            defaultMessage='Interested in a limitless plan with high-security features? <openModalLink>See plans</openModalLink>'
            values={
                {
                    openModalLink: (msg: string) => (
                        <a
                            className='open-see-plans-modal style-link'
                            onClick={() => openPricingModal({trackingLocation: 'menu_cloud_trial'})}
                        >
                            {msg}
                        </a>
                    ),
                }
            }
        />
    );

    return (
        <li
            className='MenuCloudTrial'
            role='menuitem'
            id={id}
        >
            {isFreeTrial ? freeTrialContent : noFreeTrialContent}
        </li>
    );
};
export default MenuCloudTrial;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect} from 'react';
import {useIntl} from 'react-intl';
import {useDispatch, useSelector} from 'react-redux';

import {ModalIdentifiers, TELEMETRY_CATEGORIES} from 'utils/constants';
import {isTrialLicense} from 'utils/license_utils';

import {trackEvent} from 'actions/telemetry_actions';
import {openModal} from 'actions/views/modals';
import {getPrevTrialLicense} from 'mattermost-redux/actions/admin';
import {getLicense} from 'mattermost-redux/selectors/entities/general';
import {GlobalState} from '@mattermost/types/store';

import {makeAsyncComponent} from 'components/async_load';

import './menu_item.scss';

const TrialBenefitsModal = makeAsyncComponent('TrialBenefitsModal', React.lazy(() => import('components/trial_benefits_modal/trial_benefits_modal')));
const LearnMoreTrialModal = makeAsyncComponent('LearnMoreTrialModal', React.lazy(() => import('components/learn_more_trial_modal/learn_more_trial_modal')));

type Props = {
    id: string;
}

const MenuStartTrial = (props: Props): JSX.Element | null => {
    const {formatMessage} = useIntl();
    const dispatch = useDispatch();

    useEffect(() => {
        dispatch(getPrevTrialLicense());
    }, []);

    const openLearnMoreTrialModal = () => {
        trackEvent(
            TELEMETRY_CATEGORIES.SELF_HOSTED_START_TRIAL_MODAL,
            'open_learn_more_trial_modal',
        );
        dispatch(openModal({
            modalId: ModalIdentifiers.LEARN_MORE_TRIAL_MODAL,
            dialogType: LearnMoreTrialModal,
        }));
    };

    const openTrialBenefitsModal = () => {
        trackEvent(
            TELEMETRY_CATEGORIES.SELF_HOSTED_START_TRIAL_MODAL,
            'open_trial_benefits_modal_from_menu',
        );
        dispatch(openModal({
            modalId: ModalIdentifiers.TRIAL_BENEFITS_MODAL,
            dialogType: TrialBenefitsModal,
        }));
    };

    const prevTrialLicense = useSelector((state: GlobalState) => state.entities.admin.prevTrialLicense);
    const license = useSelector(getLicense);
    const isPrevLicensed = prevTrialLicense?.IsLicensed;
    const isCurrentLicensed = license?.IsLicensed;
    const isCurrentLicenseTrial = isTrialLicense(license);

    // Show this CTA if the instance is currently not licensed and has never had a trial license loaded before
    const show = (isCurrentLicensed === 'false' && isPrevLicensed === 'false') || isCurrentLicenseTrial;
    if (!show) {
        return null;
    }

    return (
        <li
            className={'MenuStartTrial'}
            role='menuitem'
            id={props.id}
        >
            {isCurrentLicenseTrial ? <>
                <div style={{display: 'inline'}}>
                    <span>
                        {formatMessage({id: 'navbar_dropdown.reviewTrialBenefits', defaultMessage: 'Review the features you get with Enterprise. '})}
                    </span>
                    <button onClick={openTrialBenefitsModal}>
                        {formatMessage({id: 'navbar_dropdown.learnMoreTrialBenefits', defaultMessage: 'Learn More'})}
                    </button>
                </div>
            </> : <>
                <div className='start_trial_content'>
                    {formatMessage({id: 'navbar_dropdown.tryTrialNow', defaultMessage: 'Try Enterprise for free now!'})}
                </div>
                <button onClick={openLearnMoreTrialModal}>
                    {formatMessage({id: 'navbar_dropdown.learnMore', defaultMessage: 'Learn More'})}
                </button>
            </>
            }
        </li>
    );
};

export default MenuStartTrial;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import classNames from 'classnames';

import ToggleModalButton from 'components/toggle_modal_button';

import menuItem from './menu_item';

type Props = {
    modalId: string;
    dialogType: React.ComponentType<any>;
    dialogProps?: Record<string, any>;
    extraText?: string;
    text?: React.ReactNode;
    ariaLabel?: string;
    className?: string;
    children?: React.ReactNode;
    sibling?: React.ReactNode;
    showUnread?: boolean;
    disabled?: boolean;
}

export const MenuItemToggleModalReduxImpl: React.FC<Props> = ({modalId, dialogType, dialogProps, text, ariaLabel, extraText, children, className, sibling, showUnread, disabled}: Props) => (
    <>
        <ToggleModalButton
            ariaLabel={ariaLabel}
            modalId={modalId}
            dialogType={dialogType}
            dialogProps={dialogProps}
            className={classNames({
                'MenuItem__with-help': extraText,
                [`${className}`]: className,
                'MenuItem__with-sibling': sibling,
                disabled,
            })}
            showUnread={showUnread}
            disabled={disabled}
        >
            {text && <span className='MenuItem__primary-text'>{text}</span>}
            {extraText && <span className='MenuItem__help-text'>{extraText}</span>}
            {children}
        </ToggleModalButton>
        {sibling}
    </>
);

const MenuItemToggleModalRedux = menuItem(MenuItemToggleModalReduxImpl);
MenuItemToggleModalRedux.displayName = 'MenuItemToggleModalRedux';

export default MenuItemToggleModalRedux;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {useIntl} from 'react-intl';

import {useDispatch, useSelector} from 'react-redux';

import {getSubscriptionProduct} from 'mattermost-redux/selectors/entities/cloud';

import {closeModal} from 'actions/views/modals';

import {ModalIdentifiers, CloudProducts} from 'utils/constants';
import {t, Message} from 'utils/i18n';
import {fallbackStarterLimits, asGBString, LimitTypes} from 'utils/limits';

import useGetHighestThresholdCloudLimit from 'components/common/hooks/useGetHighestThresholdCloudLimit';
import useGetUsage from 'components/common/hooks/useGetUsage';
import useGetLimits from 'components/common/hooks/useGetLimits';
import useOpenPricingModal from 'components/common/hooks/useOpenPricingModal';

import CloudUsageModal from './index';

export default function LHSNearingLimitsModal() {
    const dispatch = useDispatch();
    const product = useSelector(getSubscriptionProduct);
    const usage = useGetUsage();
    const intl = useIntl();
    const openPricingModal = useOpenPricingModal();

    const [limits] = useGetLimits();

    const primaryAction = {
        message: {
            id: t('workspace_limits.modals.view_plans'),
            defaultMessage: 'View plans',
        },
        onClick: () => openPricingModal({trackingLocation: 'cloud_usage_lhs_nearing_limit_modal'}),
    };
    const secondaryAction = {
        message: {
            id: t('workspace_limits.modals.close'),
            defaultMessage: 'Close',
        },
        onClick: () => {
            dispatch(closeModal(ModalIdentifiers.CLOUD_LIMITS));
        },
    };
    const highestLimit = useGetHighestThresholdCloudLimit(usage, limits);
    let title: Message = {
        id: t('workspace_limits.modals.informational.title'),
        defaultMessage: '{planName} limits',
        values: {
            planName: product?.name,
        },
    };

    let description: Message = {
        id: t('workspace_limits.modals.informational.description.freeLimits'),
        defaultMessage: '{planName} is restricted to {messages} message history, {storage} file storage, and {boards} board cards.',
        values: {
            planName: product?.name,
            messages: intl.formatNumber(limits?.messages?.history ?? fallbackStarterLimits.messages.history),
            storage: asGBString(limits?.files?.total_storage ?? fallbackStarterLimits.files.totalStorage, intl.formatNumber),
            boards: limits?.boards?.cards ?? fallbackStarterLimits.boards.cards,
        },
    };
    if (product?.sku === CloudProducts.PROFESSIONAL) {
        description = {
            id: t('workspace_limits.modals.informational.description.professionalLimits'),
            defaultMessage: '{planName} is restricted to {storage} file storage.',
            values: {
                planName: product.name,
                storage: asGBString(limits?.files?.total_storage ?? fallbackStarterLimits.files.totalStorage, intl.formatNumber),
            },
        };
    }

    if (highestLimit && highestLimit.id === LimitTypes.messageHistory) {
        title = {
            id: t('workspace_limits.modals.limits_reached.title.message_history'),
            defaultMessage: 'Message history',
        };

        description = {
            id: t('workspace_limits.modals.limits_reached.description.message_history'),
            defaultMessage: 'Your sent message history is no longer available but you can still send messages. Upgrade to a paid plan and get unlimited access to your message history.',
        };
    }

    return (
        <CloudUsageModal
            title={title}
            description={description}
            primaryAction={primaryAction}
            secondaryAction={secondaryAction}
            onClose={() => {
                dispatch(closeModal(ModalIdentifiers.CLOUD_LIMITS));
            }}
        />
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useDispatch, useSelector} from 'react-redux';

import {isCloudLicense} from 'mattermost-redux/selectors/entities/general';
import {getCloudSubscription} from 'mattermost-redux/selectors/entities/cloud';
import {getCurrentUser} from 'mattermost-redux/selectors/entities/users';
import {isAdmin} from 'mattermost-redux/utils/user_utils';

import {openModal} from 'actions/views/modals';

import {ModalIdentifiers} from 'utils/constants';
import {limitThresholds} from 'utils/limits';

import useGetHighestThresholdCloudLimit from 'components/common/hooks/useGetHighestThresholdCloudLimit';
import useGetLimits from 'components/common/hooks/useGetLimits';
import useGetUsage from 'components/common/hooks/useGetUsage';
import UsagePercentBar from 'components/common/usage_percent_bar';

import LHSNearingLimitsModal from 'components/cloud_usage_modal/lhs_nearing_limit_modal';

import useWords from './useWords';

import './menu_item.scss';

type Props = {
    id: string;
}

const MenuItemCloudLimit = ({id}: Props) => {
    const dispatch = useDispatch();
    const subscription = useSelector(getCloudSubscription);
    const isAdminUser = isAdmin(useSelector(getCurrentUser).roles);
    const isCloud = useSelector(isCloudLicense);
    const isFreeTrial = subscription?.is_free_trial === 'true';
    const [limits] = useGetLimits();
    const usage = useGetUsage();
    const highestLimit = useGetHighestThresholdCloudLimit(usage, limits);
    const words = useWords(highestLimit, isAdminUser, 'menu_item_cloud_limit');

    const show = isCloud && !isFreeTrial;

    // words and highestLimit checks placed here instead of as part of show
    // because typescript doesn't correctly infer values later on otherwise
    if (!show || !words || !highestLimit) {
        return null;
    }

    let itemClass = 'MenuItemCloudLimit';
    if (((highestLimit.usage / highestLimit.limit) * 100) >= limitThresholds.danger) {
        itemClass += ' MenuItemCloudLimit--critical';
    }

    const descriptionClass = 'MenuItemCloudLimit__description';

    return (
        <li
            className={itemClass}
            role='menuitem'
            id={id}
        >
            <div className='MenuItemCloudLimit__title'>
                {words.title}
                {' '}
                <i
                    className='icon icon-information-outline'
                    onClick={() => dispatch(openModal({
                        modalId: ModalIdentifiers.CLOUD_LIMITS,
                        dialogType: LHSNearingLimitsModal,
                    }))}
                />
            </div>
            <div className={descriptionClass}>{words.description}</div>
            <div className='MenuItemCloudLimit__usage'>
                <UsagePercentBar
                    percent={Math.floor((highestLimit.usage / highestLimit.limit) * 100)}
                />
                <span className='MenuItemCloudLimit__usage-label'>{words.status}</span>
            </div>
        </li>
    );
};

export default MenuItemCloudLimit;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';
import {PrimitiveType, FormatXMLElementFn} from 'intl-messageformat';

import {limitThresholds, asGBString, inK, LimitTypes} from 'utils/limits';
import {t} from 'utils/i18n';

import useOpenPricingModal from 'components/common/hooks/useOpenPricingModal';
import {LimitSummary} from 'components/common/hooks/useGetHighestThresholdCloudLimit';
import NotifyAdminCTA from 'components/notify_admin_cta/notify_admin_cta';
import {PaidFeatures, LicenseSkus} from 'utils/constants';

interface Words {
    title: React.ReactNode;
    description: React.ReactNode;
    status: React.ReactNode;
}

export default function useWords(highestLimit: LimitSummary | false, isAdminUser: boolean, callerInfo: string): Words | false {
    const intl = useIntl();
    const openPricingModal = useOpenPricingModal();
    if (!highestLimit) {
        return false;
    }
    const usageRatio = (highestLimit.usage / highestLimit.limit) * 100;

    let callToAction = intl.formatMessage({
        id: 'workspace_limits.menu_limit.view_plans',
        defaultMessage: 'View plans',
    });

    if (isAdminUser) {
        callToAction = intl.formatMessage({
            id: 'workspace_limits.menu_limit.view_upgrade_options',
            defaultMessage: 'View upgrade options.',
        });
    }

    const values: Record<string, PrimitiveType | FormatXMLElementFn<string, string> | ((chunks: React.ReactNode | React.ReactNodeArray) => JSX.Element)> = {
        callToAction,
        a: (chunks: React.ReactNode | React.ReactNodeArray) => (
            <a
                id='view_plans_cta'
                onClick={() => openPricingModal({trackingLocation: callerInfo})}
            >
                {chunks}
            </a>),

    };

    let featureToNotifyOn = '';
    switch (highestLimit.id) {
    case LimitTypes.messageHistory:
        featureToNotifyOn = PaidFeatures.UNLIMITED_MESSAGES;
        break;
    case LimitTypes.fileStorage:
        featureToNotifyOn = PaidFeatures.UNLIMITED_FILE_STORAGE;
        break;
    case LimitTypes.boardsCards:
        featureToNotifyOn = PaidFeatures.UNLIMITED_BOARD_CARDS;
        break;
    default:
        break;
    }

    if (!isAdminUser && (usageRatio >= limitThresholds.danger || usageRatio >= limitThresholds.exceeded)) {
        values.callToAction = intl.formatMessage({
            id: 'workspace_limits.menu_limit.notify_admin',
            defaultMessage: 'Notify admin',
        });
        values.a = (chunks: React.ReactNode | React.ReactNodeArray) => (
            <NotifyAdminCTA
                ctaText={chunks}
                callerInfo={callerInfo}
                notifyRequestData={{
                    required_feature: featureToNotifyOn,
                    required_plan: LicenseSkus.Professional,
                    trial_notification: false}}
            />);
    }

    switch (highestLimit.id) {
    case LimitTypes.messageHistory: {
        let id = t('workspace_limits.menu_limit.warn.messages_history');
        let defaultMessage = 'Youre getting closer to the free {limit} message limit. <a>{callToAction}</a>';
        values.limit = intl.formatNumber(highestLimit.limit);
        if (usageRatio >= limitThresholds.danger) {
            if (isAdminUser) {
                id = t('workspace_limits.menu_limit.critical.messages_history');
                defaultMessage = 'Youre close to hitting the free {limit} message history limit <a>{callToAction}</a>';
            } else {
                id = t('workspace_limits.menu_limit.critical.messages_history_non_admin');
                defaultMessage = 'You\'re almost at the message limit. Your admin can upgrade your plan for unlimited messages. <a>{callToAction}</a>';
            }
        }
        if (usageRatio >= limitThresholds.reached) {
            if (isAdminUser) {
                id = t('workspace_limits.menu_limit.reached.messages_history');
                defaultMessage = 'Youve reached the free message history limit. You can only view up to the last {limit} messages in your history. <a>{callToAction}</a>';
                values.limit = inK(highestLimit.limit);
            } else {
                id = t('workspace_limits.menu_limit.reached.messages_history_non_admin');
                defaultMessage = 'Youve reached your message limit. Your admin can upgrade your plan for unlimited messages. <a>{callToAction}</a>';
            }
        }
        if (usageRatio >= limitThresholds.exceeded) {
            if (isAdminUser) {
                id = t('workspace_limits.menu_limit.over.messages_history');
                defaultMessage = 'Youre over the free message history limit. You can only view up to the last {limit} messages in your history. <a>{callToAction}</a>';
                values.limit = inK(highestLimit.limit);
            } else {
                id = t('workspace_limits.menu_limit.over.messages_history_non_admin');
                defaultMessage = 'You\'re over your message limit. Your admin can upgrade your plan for unlimited messages. <a>{callToAction}</a>';
            }
        }
        return {
            title: intl.formatMessage({
                id: 'workspace_limits.menu_limit.messages',
                defaultMessage: 'Total messages',
            }),
            description: intl.formatMessage(
                {
                    id,
                    defaultMessage,
                },
                values,
            ),
            status: inK(highestLimit.usage),
        };
    }
    case LimitTypes.fileStorage: {
        let id = t('workspace_limits.menu_limit.warn.files_storage');
        let defaultMessage = 'Youre getting closer to the {limit} file storage limit. <a>{callToAction}</a>';
        values.limit = asGBString(highestLimit.limit, intl.formatNumber);
        if (usageRatio >= limitThresholds.danger) {
            id = t('workspace_limits.menu_limit.critical.files_storage');
            defaultMessage = 'Youre getting closer to the {limit} file storage limit. <a>{callToAction}</a>';
        }
        if (usageRatio >= limitThresholds.reached) {
            id = t('workspace_limits.menu_limit.reached.files_storage');
            defaultMessage = 'Youve reached the {limit} file storage limit. You can only access the most recent {limit} worth of files. <a>{callToAction}</a>';
        }
        if (usageRatio >= limitThresholds.exceeded) {
            id = t('workspace_limits.menu_limit.over.files_storage');
            defaultMessage = 'Youre over the {limit} file storage limit. You can only access the most recent {limit} worth of files. <a>{callToAction}</a>';
        }

        return {
            title: intl.formatMessage({
                id: 'workspace_limits.menu_limit.file_storage',
                defaultMessage: 'File storage limit',
            }),
            description: intl.formatMessage(
                {
                    id,
                    defaultMessage,
                },
                values,
            ),
            status: asGBString(highestLimit.usage, intl.formatNumber),
        };
    }
    case LimitTypes.boardsCards: {
        let id = t('workspace_limits.menu_limit.warn.boards_cards');
        let defaultMessage = 'Youre getting closer to the {limit} board card limit. <a>{callToAction}</a>';
        values.limit = highestLimit.limit;
        if (usageRatio >= limitThresholds.danger) {
            id = t('workspace_limits.menu_limit.critical.boards_cards');
            defaultMessage = 'Youre getting closer to the {limit} board card limit. <a>{callToAction}</a>';
        }
        if (usageRatio >= limitThresholds.reached) {
            id = t('workspace_limits.menu_limit.reached.boards_cards');
            defaultMessage = 'Youve reached the {limit} board card limit. You can only access the most recent {limit} board cards. <a>{callToAction}</a>';
        }
        if (usageRatio >= limitThresholds.exceeded) {
            id = t('workspace_limits.menu_limit.over.boards_cards');
            defaultMessage = 'Youre over the {limit} board card limit. You can only access the most recent {limit} board cards. <a>{callToAction}</a>';
        }

        return {
            title: intl.formatMessage({
                id: 'workspace_limits.menu_limit.board_card',
                defaultMessage: 'Board card limit',
            }),
            description: intl.formatMessage(
                {
                    id,
                    defaultMessage,
                },
                values,
            ),
            status: highestLimit.usage,
        };
    }
    default:
        return false;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {CSSProperties} from 'react';
import classNames from 'classnames';

import {isMobile} from 'utils/utils';

import SubMenuItem from './menu_items/submenu_item';

import MenuHeader from './menu_header';
import MenuGroup from './menu_group';
import MenuItemAction from './menu_items/menu_item_action';
import MenuItemExternalLink from './menu_items/menu_item_external_link';
import MenuItemLink from './menu_items/menu_item_link';
import MenuCloudTrial from './menu_items/menu_cloud_trial';
import MenuStartTrial from './menu_items/menu_start_trial';
import MenuItemToggleModalRedux from './menu_items/menu_item_toggle_modal_redux';
import MenuItemCloudLimit from './menu_items/menu_item_cloud_limit';

import './menu.scss';

type Props = {
    children?: React.ReactNode;
    openLeft?: boolean;
    openUp?: boolean;
    id?: string;
    ariaLabel: string;
    customStyles?: CSSProperties;
    className?: string;
    listId?: string;
}

export default class Menu extends React.PureComponent<Props> {
    public static Header = MenuHeader
    public static Group = MenuGroup
    public static ItemAction = MenuItemAction
    public static ItemExternalLink = MenuItemExternalLink
    public static ItemLink = MenuItemLink
    public static ItemToggleModalRedux = MenuItemToggleModalRedux
    public static ItemSubMenu = SubMenuItem
    public static CloudTrial = MenuCloudTrial
    public static StartTrial = MenuStartTrial
    public static ItemCloudLimit = MenuItemCloudLimit

    public node: React.RefObject<HTMLUListElement>; //Public because it is used by tests
    private observer: MutationObserver;

    public constructor(props: Props) {
        super(props);
        this.node = React.createRef();
        this.observer = new MutationObserver(this.hideUnneededDividers);
    }

    public hideUnneededDividers = () => { //Public because it is used by tests
        if (this.node.current === null) {
            return;
        }

        this.observer.disconnect();
        const children = Object.values(this.node.current.children).slice(0, this.node.current.children.length) as HTMLElement[];

        // Hiding dividers at beginning and duplicated ones
        let prevWasDivider = false;
        let isAtBeginning = true;
        for (const child of children) {
            if (child.classList.contains('menu-divider') || child.classList.contains('mobile-menu-divider')) {
                child.style.display = 'block';
                if (isAtBeginning || prevWasDivider) {
                    child.style.display = 'none';
                }
                prevWasDivider = true;
            } else {
                isAtBeginning = false;
                prevWasDivider = false;
            }
        }
        children.reverse();

        // Hiding trailing dividers
        for (const child of children) {
            if (child.classList.contains('menu-divider') || child.classList.contains('mobile-menu-divider')) {
                child.style.display = 'none';
            } else {
                break;
            }
        }
        this.observer.observe(this.node.current, {attributes: true, childList: true, subtree: true});
    }

    public componentDidMount() {
        this.hideUnneededDividers();
    }

    public componentDidUpdate() {
        this.hideUnneededDividers();
    }

    public componentWillUnmount() {
        this.observer.disconnect();
    }

    // Used from DotMenu component to know in which direction show the menu
    public rect() {
        if (this.node && this.node.current) {
            return this.node.current.getBoundingClientRect();
        }
        return null;
    }

    handleMenuClick = (e: React.MouseEvent) => {
        if (e.target === this.node.current) {
            e.preventDefault();
            e.stopPropagation();
        }
    }

    public render() {
        const {children, openUp, openLeft, id, listId, ariaLabel, customStyles} = this.props;
        let styles: CSSProperties = {};
        if (customStyles) {
            styles = customStyles;
        } else {
            if (openLeft) {
                styles.left = 'inherit';
                styles.right = 0;
            }
            if (openUp && !isMobile()) {
                styles.bottom = '100%';
                styles.top = 'auto';
            }
        }

        return (
            <div
                aria-label={ariaLabel}
                className='a11y__popup Menu'
                id={id}
                role='menu'
            >
                <ul
                    id={listId}
                    ref={this.node}
                    style={styles}
                    className={classNames('Menu__content dropdown-menu', this.props.className)}
                    onClick={this.handleMenuClick}
                >
                    {children}
                </ul>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import './menu_group.scss';

type Props = {
    divider?: React.ReactNode;
    children?: React.ReactNode;
}

export default class MenuGroup extends React.PureComponent<Props> {
    handleDividerClick = (e: React.MouseEvent): void => {
        e.preventDefault();
        e.stopPropagation();
    }

    public render() {
        const {children} = this.props;

        const divider = this.props.divider || (
            <li
                className='MenuGroup menu-divider'
                onClick={this.handleDividerClick}
            />
        );

        return (
            <React.Fragment>
                {divider}
                {children}
            </React.Fragment>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import classNames from 'classnames';

import './menu_item.scss';

export default function menuItem(Component: React.ComponentType<any>) {
    type Props = {
        show: boolean;
        id?: string;
        icon?: React.ReactNode;
        text?: React.ReactNode;
    }
    class MenuItem extends React.PureComponent<Props & React.ComponentProps<typeof Component>> {
        public static defaultProps = {
            show: true,
        };

        public static displayName?: string;

        public render() {
            const {id, show, icon, text, ...props} = this.props;
            if (!show) {
                return null;
            }

            let textProp: React.ReactNode = text;
            if (icon) {
                textProp = (
                    <>
                        <span className='icon'>{icon}</span>
                        {text}
                    </>
                );
            }

            return (
                <li
                    className={classNames('MenuItem', {
                        'MenuItem--with-icon': icon,
                    })}
                    role='menuitem'
                    id={id}
                >
                    <Component
                        text={textProp}
                        ariaLabel={text?.toString()}
                        {...props}
                    />
                </li>
            );
        }
    }
    return MenuItem;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect} from 'react';
import {useSelector, useDispatch} from 'react-redux';
import {useIntl, FormattedMessage} from 'react-intl';
import classNames from 'classnames';

import useOpenPricingModal from 'components/common/hooks/useOpenPricingModal';

import {DispatchFunc} from 'mattermost-redux/types/actions';
import {checkHadPriorTrial} from 'mattermost-redux/selectors/entities/cloud';
import {isCurrentUserSystemAdmin} from 'mattermost-redux/selectors/entities/users';
import {getLicense} from 'mattermost-redux/selectors/entities/general';
import {getPrevTrialLicense} from 'mattermost-redux/actions/admin';

import CloudStartTrialButton from 'components/cloud_start_trial/cloud_start_trial_btn';
import StartTrialBtn from 'components/learn_more_trial_modal/start_trial_btn';
import GenericModal from 'components/generic_modal';
import {NotifyStatus} from 'components/common/hooks/useGetNotifyAdmin';
import {useNotifyAdmin} from 'components/notify_admin_cta/notify_admin_cta';

import {closeModal} from 'actions/views/modals';
import {isModalOpen} from 'selectors/views/modals';
import {GlobalState} from 'types/store';
import {FREEMIUM_TO_ENTERPRISE_TRIAL_LENGTH_DAYS} from 'utils/cloud_utils';
import {ModalIdentifiers, AboutLinks, LicenseLinks} from 'utils/constants';

import './feature_restricted_modal.scss';

type FeatureRestrictedModalProps = {
    titleAdminPreTrial: string;
    messageAdminPreTrial: string;
    titleAdminPostTrial: string;
    messageAdminPostTrial: string;
    titleEndUser?: string;
    messageEndUser?: string;
    customSecondaryButton?: {msg: string; action: () => void};
    feature?: string;
    minimumPlanRequiredForFeature?: string;
}

const FeatureRestrictedModal = ({
    titleAdminPreTrial,
    messageAdminPreTrial,
    titleAdminPostTrial,
    messageAdminPostTrial,
    titleEndUser,
    messageEndUser,
    customSecondaryButton,
    feature,
    minimumPlanRequiredForFeature,
}: FeatureRestrictedModalProps) => {
    const {formatMessage} = useIntl();
    const dispatch = useDispatch<DispatchFunc>();

    useEffect(() => {
        dispatch(getPrevTrialLicense());
    }, []);

    const hasCloudPriorTrial = useSelector(checkHadPriorTrial);
    const prevTrialLicense = useSelector((state: GlobalState) => state.entities.admin.prevTrialLicense);
    const hasSelfHostedPriorTrial = prevTrialLicense.IsLicensed === 'true';

    const hasPriorTrial = hasCloudPriorTrial || hasSelfHostedPriorTrial;
    const isSystemAdmin = useSelector(isCurrentUserSystemAdmin);
    const show = useSelector((state: GlobalState) => isModalOpen(state, ModalIdentifiers.FEATURE_RESTRICTED_MODAL));
    const license = useSelector(getLicense);
    const isCloud = license?.Cloud === 'true';
    const openPricingModal = useOpenPricingModal();

    const [notifyAdminBtnText, notifyAdmin, notifyRequestStatus] = useNotifyAdmin({
        ctaText: formatMessage({
            id: 'feature_restricted_modal.button.notify',
            defaultMessage: 'Notify Admin',
        }),
    }, {
        required_feature: feature || '',
        required_plan: minimumPlanRequiredForFeature || '',
        trial_notification: false,
    });

    if (!show) {
        return null;
    }

    const dismissAction = () => {
        dispatch(closeModal(ModalIdentifiers.FEATURE_RESTRICTED_MODAL));
    };

    const handleViewPlansClick = (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {
        if (isSystemAdmin) {
            openPricingModal({trackingLocation: 'feature_restricted_modal'});
            dismissAction();
        } else {
            notifyAdmin(e, 'feature_restricted_modal');
        }
    };

    const getTitle = () => {
        if (isSystemAdmin) {
            return hasPriorTrial ? titleAdminPostTrial : titleAdminPreTrial;
        }

        return titleEndUser;
    };

    const getMessage = () => {
        if (isSystemAdmin) {
            return hasPriorTrial ? messageAdminPostTrial : messageAdminPreTrial;
        }

        return messageEndUser;
    };

    const showStartTrial = isSystemAdmin && !hasPriorTrial;

    // define what is the secondary button text and action, by default will be the View Plan button
    let secondaryBtnMsg = formatMessage({id: 'feature_restricted_modal.button.plans', defaultMessage: 'View plans'});
    if (!isSystemAdmin) {
        secondaryBtnMsg = notifyAdminBtnText as string;
    }
    let secondaryBtnAction = handleViewPlansClick;
    if (customSecondaryButton) {
        secondaryBtnMsg = customSecondaryButton.msg;
        secondaryBtnAction = customSecondaryButton.action;
    }

    let trialBtn;
    if (isCloud) {
        trialBtn = (
            <CloudStartTrialButton
                extraClass='button-trial'
                message={formatMessage({id: 'trial_btn.free.tryFreeFor30Days', defaultMessage: 'Try free for 30 days'})}
                telemetryId={'start_cloud_trial_after_team_creation_restricted'}
                onClick={dismissAction}
            />
        );
    } else {
        trialBtn = (
            <StartTrialBtn
                message={formatMessage({id: 'trial_btn.free.tryFreeFor30Days', defaultMessage: 'Try free for 30 days'})}
                telemetryId='start_self_hosted_trial_after_team_creation_restricted'
                btnClass='btn btn-primary'
                renderAsButton={true}
            />);
    }

    return (
        <GenericModal
            id='FeatureRestrictedModal'
            className='FeatureRestrictedModal'
            compassDesign={true}
            modalHeaderText={getTitle()}
            onExited={dismissAction}
        >
            <div className='FeatureRestrictedModal__body'>
                <p className='FeatureRestrictedModal__description'>
                    {getMessage()}
                </p>
                {showStartTrial && (
                    <p className='FeatureRestrictedModal__terms'>
                        <FormattedMessage
                            id='feature_restricted_modal.agreement'
                            defaultMessage='By selecting <highlight>Try free for {trialLength} days</highlight>, I agree to the <linkEvaluation>Mattermost Software Evaluation Agreement</linkEvaluation>, <linkPrivacy>Privacy Policy</linkPrivacy>, and receiving product emails.'
                            values={{
                                trialLength: FREEMIUM_TO_ENTERPRISE_TRIAL_LENGTH_DAYS,
                                highlight: (msg: React.ReactNode) => (
                                    <strong>{msg}</strong>
                                ),
                                linkEvaluation: (msg: React.ReactNode) => (
                                    <a
                                        href={LicenseLinks.SOFTWARE_EVALUATION_AGREEMENT}
                                        target='_blank'
                                        rel='noreferrer'
                                    >
                                        {msg}
                                    </a>
                                ),
                                linkPrivacy: (msg: React.ReactNode) => (
                                    <a
                                        href={AboutLinks.PRIVACY_POLICY}
                                        target='_blank'
                                        rel='noreferrer'
                                    >
                                        {msg}
                                    </a>
                                ),
                            }}
                        />
                    </p>
                )}
                <div className={classNames('FeatureRestrictedModal__buttons', {single: !showStartTrial})}>
                    <button
                        id='button-plans'
                        className='button-plans'
                        onClick={secondaryBtnAction}
                        disabled={notifyRequestStatus === NotifyStatus.AlreadyComplete}
                    >
                        {secondaryBtnMsg}
                    </button>
                    {showStartTrial && (
                        trialBtn
                    )}
                </div>
            </div>
        </GenericModal>
    );
};

export default FeatureRestrictedModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback} from 'react';
import {useIntl, MessageDescriptor} from 'react-intl';
import classNames from 'classnames';

import FeatureRestrictedModal from 'components/feature_restricted_modal/feature_restricted_modal';
import OverlayTrigger from 'components/overlay_trigger';
import ToggleModalButton from 'components/toggle_modal_button';
import Tooltip from 'components/tooltip';

import {FREEMIUM_TO_ENTERPRISE_TRIAL_LENGTH_DAYS} from 'utils/cloud_utils';
import {Constants, LicenseSkus, ModalIdentifiers} from 'utils/constants';

import './restricted_indicator.scss';

type RestrictedIndicatorProps = {
    useModal?: boolean;
    titleAdminPreTrial?: string;
    messageAdminPreTrial?: string | React.ReactNode;
    titleAdminPostTrial?: string;
    messageAdminPostTrial?: string | React.ReactNode;
    titleEndUser?: string;
    messageEndUser?: string | React.ReactNode;
    blocked?: boolean;
    tooltipTitle?: string;
    tooltipMessage?: string;
    tooltipMessageBlocked?: string | MessageDescriptor;
    ctaExtraContent?: React.ReactNode;
    clickCallback?: () => void;
    customSecondaryButtonInModal?: {msg: string; action: () => void};
    feature?: string;
    minimumPlanRequiredForFeature?: string;
}

function capitalizeFirstLetter(s: string) {
    return s.charAt(0).toUpperCase() + s.slice(1);
}

const RestrictedIndicator = ({
    useModal = true,
    blocked,
    tooltipTitle,
    tooltipMessage,
    tooltipMessageBlocked,
    titleAdminPreTrial,
    messageAdminPreTrial,
    titleAdminPostTrial,
    messageAdminPostTrial,
    titleEndUser,
    messageEndUser,
    ctaExtraContent,
    clickCallback,
    customSecondaryButtonInModal,
    feature,
    minimumPlanRequiredForFeature,
}: RestrictedIndicatorProps) => {
    const {formatMessage} = useIntl();

    const getTooltipMessageBlocked = useCallback(() => {
        if (!tooltipMessageBlocked) {
            return formatMessage(
                {
                    id: 'restricted_indicator.tooltip.message.blocked',
                    defaultMessage: 'This is a paid feature, available with a free {trialLength}-day trial',
                }, {
                    trialLength: FREEMIUM_TO_ENTERPRISE_TRIAL_LENGTH_DAYS,
                },
            );
        }

        return typeof tooltipMessageBlocked === 'string' ? tooltipMessageBlocked : formatMessage(tooltipMessageBlocked, {
            trialLength: FREEMIUM_TO_ENTERPRISE_TRIAL_LENGTH_DAYS,
            article: minimumPlanRequiredForFeature === LicenseSkus.Enterprise ? 'an' : 'a',
            minimumPlanRequiredForFeature,
        });
    }, [tooltipMessageBlocked]);

    const icon = <i className={classNames('RestrictedIndicator__icon-tooltip', 'icon', blocked ? 'icon-key-variant' : 'trial')}/>;

    const handleClickCallback = () => {
        if (clickCallback) {
            clickCallback();
        }
    };

    return (
        <span className='RestrictedIndicator__icon-tooltip-container'>
            <OverlayTrigger
                delayShow={Constants.OVERLAY_TIME_DELAY}
                placement='right'
                overlay={(
                    <Tooltip className='RestrictedIndicator__icon-tooltip'>
                        <span className='title'>
                            {tooltipTitle || formatMessage({id: 'restricted_indicator.tooltip.title', defaultMessage: '{minimumPlanRequiredForFeature} feature'}, {minimumPlanRequiredForFeature: capitalizeFirstLetter(minimumPlanRequiredForFeature!)})}
                        </span>
                        <span className='message'>
                            {blocked ? (
                                getTooltipMessageBlocked()
                            ) : (
                                tooltipMessage || formatMessage({id: 'restricted_indicator.tooltip.mesage', defaultMessage: 'During your trial you are able to use this feature.'})
                            )}
                        </span>
                    </Tooltip>
                )}
            >
                {useModal && blocked ? (
                    <ToggleModalButton
                        id={`${feature}-restricted-indicator`.replaceAll('.', '_')}
                        className='RestrictedIndicator__button'
                        modalId={ModalIdentifiers.FEATURE_RESTRICTED_MODAL}
                        dialogType={FeatureRestrictedModal}
                        onClick={handleClickCallback}
                        dialogProps={{
                            titleAdminPreTrial,
                            messageAdminPreTrial,
                            titleAdminPostTrial,
                            messageAdminPostTrial,
                            titleEndUser,
                            messageEndUser,
                            customSecondaryButton: customSecondaryButtonInModal,
                            feature,
                            minimumPlanRequiredForFeature,
                        }}
                    >
                        {icon}
                        {ctaExtraContent}
                    </ToggleModalButton>
                ) : (
                    <div className='RestrictedIndicator__content'>
                        {icon}
                        {ctaExtraContent}
                    </div>
                )}
            </OverlayTrigger>
        </span>
    );
};

export default RestrictedIndicator;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {CSSTransition} from 'react-transition-group';

import {isMobile} from 'utils/utils';

const ANIMATION_DURATION = 80;

type Props = {
    children?: React.ReactNode;
    show: boolean;
}

export default function MenuWrapperAnimation(props: Props) {
    if (isMobile()) {
        if (props.show) {
            return props.children;
        }

        return null;
    }

    return (
        <CSSTransition
            in={props.show}
            classNames='MenuWrapperAnimation'
            enter={true}
            exit={true}
            mountOnEnter={true}
            unmountOnExit={true}
            timeout={ANIMATION_DURATION}
        >
            {props.children}
        </CSSTransition>
    );
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import Constants from 'utils/constants';

import MenuWrapperAnimation from './menu_wrapper_animation';

import './menu_wrapper.scss';

declare module 'react' {
    interface HTMLAttributes<T> extends AriaAttributes, DOMAttributes<T> {
        disabled?: boolean;
    }
}
type Props = {
    children?: React.ReactNode;
    className: string;
    onToggle?: (open: boolean) => void;
    animationComponent: any;
    id?: string;
    isDisabled?: boolean;
    stopPropagationOnToggle?: boolean;
    open?: boolean;
}

type State = {
    open: boolean;
}

export default class MenuWrapper extends React.PureComponent<Props, State> {
    private node: React.RefObject<HTMLDivElement>;

    public static defaultProps = {
        className: '',
        animationComponent: MenuWrapperAnimation,
    };

    public constructor(props: Props) {
        super(props);
        if (!Array.isArray(props.children) || props.children.length !== 2) {
            throw new Error('MenuWrapper needs exactly 2 children');
        }
        this.state = {
            open: false,
        };
        this.node = React.createRef();
    }

    public componentDidMount() {
        if (this.state.open) {
            this.addEventListeners();
        }
    }

    static getDerivedStateFromProps(props: Props, state: State) {
        if (props.open !== undefined && props.open !== state.open) {
            return {
                open: props.open,
            };
        }
        return null;
    }

    public componentDidUpdate(prevProps: Props, prevState: State) {
        if (this.state.open && !prevState.open) {
            this.addEventListeners();
        } else if (!this.state.open && prevState.open) {
            this.removeEventListeners();
        }
    }

    public componentWillUnmount() {
        if (this.state.open) {
            this.removeEventListeners();
        }
    }

    private addEventListeners() {
        document.addEventListener('click', this.closeOnBlur, true);
        document.addEventListener('keyup', this.keyboardClose, true);
    }

    private removeEventListeners() {
        document.removeEventListener('click', this.closeOnBlur, true);
        document.removeEventListener('keyup', this.keyboardClose, true);
    }

    private keyboardClose = (e: KeyboardEvent) => {
        if (e.key === Constants.KeyCodes.ESCAPE[0]) {
            this.close();
        }

        if (e.key === Constants.KeyCodes.TAB[0]) {
            this.closeOnBlur(e);
        }
    }

    private closeOnBlur = (e: Event) => {
        if (this.node && this.node.current && e.target && this.node.current.contains(e.target as Node)) {
            return;
        }

        this.close();
    }

    public close = () => {
        if (this.state.open) {
            this.setState({open: false});
            if (this.props.onToggle) {
                this.props.onToggle(false);
            }
        }
    }

    toggle = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {
        /**
         * This is only here so that we can toggle the menus in the sidebar, because the default behavior of the mobile
         * version (ie the one that uses a modal) needs propagation to close the modal after selecting something
         * We need to refactor this so that the modal is explicitly closed on toggle, but for now I am aiming to preserve the existing logic
         * so as to not break other things
        **/
        if (this.props.stopPropagationOnToggle) {
            e.preventDefault();
            e.stopPropagation();
        }
        const newState = !this.state.open;
        this.setState({open: newState}, () => {
            if (this.props.onToggle) {
                this.props.onToggle(newState);
            }
        });
    }

    public render() {
        const {children} = this.props;

        const Animation = this.props.animationComponent;

        return (
            <div
                id={this.props.id}
                className={'MenuWrapper ' + this.props.className + (this.state.open ? ' MenuWrapper--open' : '')}
                onClick={this.toggle}
                ref={this.node}
                disabled={this.props.isDisabled}
            >
                {children ? Object.values(children)[0] : {}}
                <Animation show={this.state.open}>
                    {children ? Object.values(children)[1] : {}}
                </Animation>
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useIntl} from 'react-intl';

export default function BackIcon(props: React.HTMLAttributes<HTMLSpanElement>) {
    const {formatMessage} = useIntl();
    return (
        <span {...props}>
            <svg
                width='24px'
                height='24px'
                viewBox='0 0 24 24'
                role='img'
                aria-label={formatMessage({id: 'generic_icons.back', defaultMessage: 'Back Icon'})}
            >
                <path d='M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z'/>
            </svg>
        </span>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {CSSTransition} from 'react-transition-group';
import {injectIntl} from 'react-intl';

import CloseIcon from 'components/widgets/icons/close_icon';
import BackIcon from 'components/widgets/icons/back_icon';

import './full_screen_modal.scss';

// This must be on sync with the animation time in ./full_screen_modal.scss
const ANIMATION_DURATION = 100;

type Props = {
    show: boolean;
    onClose: () => void;
    onGoBack?: () => void;
    children: React.ReactNode;
    ariaLabel?: string;
    ariaLabelledBy?: string;
    intl: any; // TODO This needs to be replaced with IntlShape once react-intl is upgraded
    overrideTargetEvent?: boolean;
};

class FullScreenModal extends React.PureComponent<Props> {
    private modal = React.createRef<HTMLDivElement>();

    public componentDidMount() {
        document.addEventListener('keydown', this.handleKeypress);
        document.addEventListener('focus', this.enforceFocus, this.props.overrideTargetEvent);
        this.enforceFocus();
    }

    public componentWillUnmount() {
        document.removeEventListener('keydown', this.handleKeypress);
        document.removeEventListener('focus', this.enforceFocus, this.props.overrideTargetEvent);
    }

    public enforceFocus = () => {
        setTimeout(() => {
            const currentActiveElement = document.activeElement;
            if (this.modal && this.modal.current && !this.modal.current.contains(currentActiveElement)) {
                this.modal.current.focus();
            }
        });
    }

    private handleKeypress = (e: KeyboardEvent) => {
        const currentActiveElement = document.activeElement;
        if (!this.props.overrideTargetEvent && e.key === 'Escape' && this.props.show && e.target && this.modal.current && this.modal.current.contains(currentActiveElement)) {
            this.close();
        }
        if (this.props.overrideTargetEvent && e.key === 'Escape' && this.props.show) {
            this.close();
        }
    }

    private close = () => {
        this.props.onClose();
    }

    public render() {
        return (
            <CSSTransition
                in={this.props.show}
                classNames='FullScreenModal'
                mountOnEnter={true}
                unmountOnExit={true}
                timeout={ANIMATION_DURATION}
                appear={true}
            >
                <>
                    <div
                        className='FullScreenModal'
                        ref={this.modal}
                        tabIndex={-1}
                        aria-modal={true}
                        aria-label={this.props.ariaLabel}
                        aria-labelledby={this.props.ariaLabelledBy}
                        role='dialog'
                    >
                        {this.props.onGoBack &&
                            <button
                                onClick={this.props.onGoBack}
                                className='back'
                                aria-label={this.props.intl.formatMessage({id: 'full_screen_modal.back', defaultMessage: 'Back'})}
                            >
                                <BackIcon id='backIcon'/>
                            </button>}
                        <button
                            onClick={this.close}
                            className='close-x'
                            aria-label={this.props.intl.formatMessage({id: 'full_screen_modal.close', defaultMessage: 'Close'})}
                        >
                            <CloseIcon id='closeIcon'/>
                        </button>
                        {this.props.children}
                    </div>
                    <div
                        tabIndex={0}
                        style={{display: 'none'}}
                    />
                </>
            </CSSTransition>
        );
    }
}

const wrappedComponent = injectIntl(FullScreenModal, {forwardRef: true});
wrappedComponent.displayName = 'injectIntl(FullScreenModal)';
wrappedComponent.defaultProps = {
    overrideTargetEvent: true,
};
export default wrappedComponent;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Popover as BSPopover, Sizes as BSSizes} from 'react-bootstrap';

const SizeMap = {xs: 'xsmall', sm: 'small', md: 'medium', lg: 'large'};
export type Sizes = 'xs' | 'sm' | 'md' | 'lg';

interface Props {
    id?: string;
    children?: React.ReactNode;
    popoverStyle?: 'info';
    popoverSize?: Sizes;
    title?: React.ReactNode;
    placement?: 'bottom' | 'top' | 'right' | 'left';
    className?: string;
    style?: React.CSSProperties;
    onMouseOut?: React.MouseEventHandler<BSPopover>; // didn't find a better way to satisfy typing, so for now we have a slight 'bootstrap leakage'
    onMouseOver?: React.MouseEventHandler<BSPopover>;
}

export default class Popover extends React.PureComponent<Props> {
    static defaultProps = {
        placement: 'right',
        popoverStyle: 'info',
        popoverSize: 'sm',

    }
    render() {
        const {placement, popoverSize, children, popoverStyle, title, id, onMouseOut, onMouseOver, className, style} = this.props;
        return (
            <BSPopover
                id={id}
                style={style}
                className={className}
                bsStyle={popoverStyle}
                placement={placement}
                bsClass='popover'
                title={title}
                bsSize={popoverSize && SizeMap[popoverSize] as BSSizes} // map our sizes to bootstrap
                onMouseOut={onMouseOut!}
                onMouseOver={onMouseOver}
            >
                {children}
            </BSPopover>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode} from 'react';
import './separator.scss';

type Props = {
    children?: ReactNode;
};

export default class BasicSeparator extends React.PureComponent<Props> {
    public render() {
        const {children} = this.props;
        return (
            <div
                data-testid='basicSeparator'
                className='Separator BasicSeparator'
            >
                <hr className='separator__hr'/>
                {children && (
                    <div className='separator__text'>
                        {children}
                    </div>
                )}
            </div>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import Setting from './setting';

type Props = {
    id: string;
    label: React.ReactNode;
    labelClassName: string;
    helpText?: React.ReactNode;
    placeholder: string;
    value: boolean;
    disabled?: boolean;
    inputClassName: string;
    onChange(name: string, value: any): void; // value is any since onChange is a common func for inputs and checkboxes
    autoFocus?: boolean;
}

export default class BoolSetting extends React.PureComponent<Props> {
    public static defaultProps: Partial<Props> = {
        labelClassName: '',
        inputClassName: '',
    };

    private handleChange: React.ChangeEventHandler<HTMLInputElement> = (e) => {
        this.props.onChange(this.props.id, e.target.checked);
    }

    public render(): JSX.Element {
        return (
            <Setting
                label={this.props.label}
                labelClassName={this.props.labelClassName}
                inputClassName={this.props.inputClassName}
                helpText={this.props.helpText}
                inputId={this.props.id}
            >
                <div className='checkbox'>
                    <label>
                        <input
                            id={this.props.id}
                            disabled={this.props.disabled}
                            autoFocus={this.props.autoFocus}
                            type='checkbox'
                            checked={this.props.value}
                            onChange={this.handleChange}
                        />
                        <span>{this.props.placeholder}</span>
                    </label>
                </div>
            </Setting>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

type Props = {
    inputId?: string;
    label: React.ReactNode;
    labelClassName?: string;
    inputClassName?: string;
    children: React.ReactNode;
    helpText?: React.ReactNode;
    footer?: React.ReactNode;
}

const Setting: React.FC<Props> = ({
    inputId,
    label,
    labelClassName,
    inputClassName,
    children,
    footer,
    helpText,
}: Props) => {
    return (
        <div
            data-testid={inputId}
            className='form-group'
        >
            {label && (
                <label
                    data-testid={inputId + 'label'}
                    className={'control-label ' + labelClassName}
                    htmlFor={inputId}
                >
                    {label}
                </label>
            )}
            <div className={inputClassName}>
                {children}
                <div
                    data-testid={inputId + 'help-text'}
                    className='help-text'
                >
                    {helpText}
                </div>
                {footer}
            </div>
        </div>
    );
};

export default Setting;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import Setting from './setting';

export type InputTypes = 'input' | 'textarea' | 'number' | 'email' | 'tel' | 'url' | 'password'

export type WidgetTextSettingProps = {
    id: string;
    label: React.ReactNode;
    labelClassName?: string;
    placeholder?: string;
    helpText?: React.ReactNode;
    footer?: React.ReactNode;
    value: string | number;
    inputClassName?: string;
    maxLength?: number;
    resizable?: boolean;
    onChange(name: string, value: any): void;
    disabled?: boolean;
    type: InputTypes;
    autoFocus?: boolean;
}

// Since handle change is read from input and textarea element
type HandleChangeTypes = React.ChangeEventHandler<HTMLInputElement | HTMLTextAreaElement>

export default class TextSetting extends React.PureComponent<WidgetTextSettingProps> {
    public static validTypes: string[] = ['input', 'textarea', 'number', 'email', 'tel', 'url', 'password'];

    public static defaultProps: Partial<WidgetTextSettingProps> = {
        labelClassName: '',
        inputClassName: '',
        type: 'input',
        maxLength: -1, // A negative number allows for values of any length
        resizable: true,
    };

    private handleChange: HandleChangeTypes = (e) => {
        if (this.props.type === 'number') {
            this.props.onChange(this.props.id, parseInt(e.target.value, 10));
        } else {
            this.props.onChange(this.props.id, e.target.value);
        }
    }

    public render(): JSX.Element {
        const {resizable} = this.props;
        let {type} = this.props;
        let input = null;

        if (type === 'textarea') {
            let style = {};
            if (!resizable) {
                style = Object.assign({}, {resize: 'none'});
            }

            input = (
                <textarea
                    autoFocus={this.props.autoFocus}
                    data-testid={this.props.id + 'input'}
                    id={this.props.id}
                    dir='auto'
                    style={style}
                    className='form-control'
                    rows={5}
                    placeholder={this.props.placeholder}
                    value={this.props.value}
                    maxLength={this.props.maxLength}
                    onChange={this.handleChange}
                    disabled={this.props.disabled}
                />
            );
        } else {
            type = ['input', 'email', 'tel', 'number', 'url', 'password'].includes(type) ? type : 'input';

            input = (
                <input
                    autoFocus={this.props.autoFocus}
                    data-testid={this.props.id + type}
                    id={this.props.id}
                    className='form-control'
                    type={type}
                    placeholder={this.props.placeholder}
                    value={this.props.value}
                    maxLength={this.props.maxLength}
                    onChange={this.handleChange}
                    disabled={this.props.disabled}
                />
            );
        }

        return (
            <Setting
                label={this.props.label}
                labelClassName={this.props.labelClassName}
                inputClassName={this.props.inputClassName}
                helpText={this.props.helpText}
                inputId={this.props.id}
                footer={this.props.footer}
            >
                {input}
            </Setting>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {ReactNode, ComponentProps, useState, CSSProperties, useMemo} from 'react';

import OverlayTrigger from 'components/overlay_trigger';
import Tooltip from 'components/tooltip';

type Props = {
    id: string;
    content: ReactNode;
    children: ReactNode;
    className?: string;
    arrowOffsetTop?: number | string;
    style?: CSSProperties;
}

const SimpleTooltip = ({
    id,
    content,
    children,
    placement = 'top',
    className = 'hidden-xs',
    delayShow = 500,
    style,
    ...props
}: Props & Omit<ComponentProps<typeof OverlayTrigger>, 'overlay'>) => {
    return (
        <OverlayTrigger
            {...props}
            delayShow={delayShow}
            placement={placement}
            overlay={
                <Tooltip
                    id={id}
                    style={style}
                    className={className}
                    placement={placement}
                >
                    {content}
                </Tooltip>
            }
        >
            {children}
        </OverlayTrigger>
    );
};

export default SimpleTooltip;

export function useSynchronizedImmediate(): [Partial<ComponentProps<typeof SimpleTooltip>>, (isImmediate: boolean) => void] {
    const [isImmediate, setImmediate] = useState(false);

    return [
        useMemo((): Partial<ComponentProps<typeof SimpleTooltip>> => ({
            onEntered: () => setImmediate(true),
            animation: !isImmediate,
            delayShow: isImmediate ? 0 : undefined,
        }), [isImmediate, setImmediate]),
        setImmediate,
    ];
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import classNames from 'classnames';
import {injectIntl, IntlShape} from 'react-intl';

import {Team} from '@mattermost/types/teams';

import {imageURLForTeam} from 'utils/utils';

import './team_icon.scss';

type Props = {

    /** Team icon URL (when available) */
    url?: string | null;

    /** Team display name (used for the initials) if icon URL is not set */
    content: React.ReactNode;

    /**
     * Size of the icon, "sm", "md" or "lg".
     *
     * @default "regular"
     **/
    size?: 'sm' | 'lg';

    /** Whether to add hover effect to the icon */
    withHover?: boolean;

    /** Whether to add additional classnames */
    className?: string;

    /** react-intl helper object */
    intl: IntlShape;
};

/**
 * An icon representing a Team. If `url` is set - shows the image,
 * otherwise shows team initials
 */
export class TeamIcon extends React.PureComponent<Props> {
    public static defaultProps = {
        size: 'sm' as const,
    }

    public render() {
        const {content, url, size, withHover, className} = this.props;
        const hoverCss = withHover ? '' : 'no-hover';
        const {formatMessage} = this.props.intl;

        // FIXME Nowhere does imageURLForTeam seem to check for display_name.
        const teamIconUrl = url || imageURLForTeam({display_name: content} as Team);
        let icon;
        if (typeof content === 'string') {
            if (teamIconUrl) {
                icon = (
                    <div
                        data-testid='teamIconImage'
                        className={`TeamIcon__image TeamIcon__${size}`}
                        aria-label={
                            formatMessage({
                                id: 'sidebar.team_menu.button.teamImage',
                                defaultMessage: '{teamName} Team Image',
                            }, {
                                teamName: content,
                            })
                        }
                        style={{backgroundImage: `url('${teamIconUrl}')`}}
                        role={'img'}
                    />
                );
            } else {
                icon = (
                    <div
                        data-testid='teamIconInitial'
                        className={`TeamIcon__initials TeamIcon__initials__${size}`}
                        aria-label={
                            formatMessage({
                                id: 'sidebar.team_menu.button.teamInitials',
                                defaultMessage: '{teamName} Team Initials',
                            }, {
                                teamName: content,
                            })
                        }
                        role={'img'}
                    >
                        {content ? content.replace(/\s/g, '').substring(0, 2) : '??'}
                    </div>
                );
            }
        } else {
            icon = content;
        }
        return (
            <div className={classNames(`TeamIcon TeamIcon__${size}`, {withImage: teamIconUrl}, className, hoverCss)}>
                <div className={`TeamIcon__content ${hoverCss}`}>
                    {icon}
                </div>
            </div>
        );
    }
}

export default injectIntl(TeamIcon);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo, HTMLAttributes} from 'react';
import classNames from 'classnames';

import './avatar.scss';

import {Client4} from 'mattermost-redux/client';
import BotDefaultIcon from 'images/bot_default_icon.png';

export type TAvatarSizeToken = 'xxs' | 'xs' | 'sm' | 'md' | 'lg' | 'xl' | 'xxl';

export const getAvatarWidth = (size: TAvatarSizeToken) => {
    switch (size) {
    case 'xxs':
        return 16;
    case 'xs':
        return 20;
    case 'sm':
        return 24;
    case 'md':
        return 32;
    case 'lg':
        return 36;
    case 'xl':
        return 50;
    case 'xxl':
        return 128;
    }
    return 0;
};

type Props = {
    url?: string;
    username?: string;
    size?: TAvatarSizeToken;
    text?: string;
};

type Attrs = HTMLAttributes<HTMLElement>;

const isURLForUser = (url: string) => url.startsWith(Client4.getUsersRoute());
const replaceURLWithDefaultImageURL = (url: string) => url.replace(/\?_=(\w+)/, '/default');

const Avatar = ({
    url,
    username,
    size = 'md',
    text,
    ...attrs
}: Props & Attrs) => {
    const classes = classNames(`Avatar Avatar-${size}`, attrs.className);

    if (text) {
        return (
            <div
                {...attrs}
                className={classes + ' Avatar-plain'}
                data-content={text}
            />
        );
    }

    return (
        <img
            tabIndex={0}
            {...attrs}
            className={classes}
            alt={`${username || 'user'} profile image`}
            src={url}
            onError={(e) => {
                const fallbackSrc = (url && isURLForUser(url)) ? replaceURLWithDefaultImageURL(url) : BotDefaultIcon;

                if (e.currentTarget.src !== fallbackSrc) {
                    e.currentTarget.src = fallbackSrc;
                }
            }}
        />
    );
};
export default memo(Avatar);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {memo, ComponentProps, CSSProperties, useMemo, useEffect, useRef} from 'react';
import {useIntl} from 'react-intl';
import {useSelector, useDispatch} from 'react-redux';
import tinycolor from 'tinycolor2';
import styled from 'styled-components';

import {UserProfile} from '@mattermost/types/users';
import {getUser as selectUser, makeDisplayNameGetter} from 'mattermost-redux/selectors/entities/users';
import {getTheme} from 'mattermost-redux/selectors/entities/preferences';
import {getMissingProfilesByIds} from 'mattermost-redux/actions/users';

import {GlobalState} from 'types/store';

import {t} from 'utils/i18n';
import {imageURLForUser} from 'utils/utils';

import SimpleTooltip, {useSynchronizedImmediate} from 'components/widgets/simple_tooltip';
import Avatar from 'components/widgets/users/avatar';
import ProfilePopover from 'components/profile_popover';
import OverlayTrigger, {BaseOverlayTrigger} from 'components/overlay_trigger';

import './avatars.scss';

type Props = {
    userIds: Array<UserProfile['id']>;
    totalUsers?: number;
    breakAt?: number;
    size?: ComponentProps<typeof Avatar>['size'];
    fetchMissingUsers?: boolean;
    disableProfileOverlay?: boolean;
};

interface MMOverlayTrigger extends BaseOverlayTrigger {
    hide: () => void;
}

const OTHERS_DISPLAY_LIMIT = 99;

function countMeta<T>(
    items: T[],
    total = items.length,
): [T[], T[], {overflowUnnamedCount: number; nonDisplayCount: number}] {
    const breakAt = Math.max(items.length, total) > 4 ? 3 : 4;

    const displayItems = items.slice(0, breakAt);
    const overflowItems = items.slice(breakAt);

    const overflowUnnamedCount = Math.max(total - displayItems.length - overflowItems.length, 0);
    const nonDisplayCount = overflowItems.length + overflowUnnamedCount;

    return [displayItems, overflowItems, {overflowUnnamedCount, nonDisplayCount}];
}

const displayNameGetter = makeDisplayNameGetter();

function UserAvatar({
    userId,
    overlayProps,
    disableProfileOverlay,
    ...props
}: {
    userId: UserProfile['id'];
    overlayProps: Partial<ComponentProps<typeof SimpleTooltip>>;
    disableProfileOverlay: boolean;
} & ComponentProps<typeof Avatar>) {
    const user = useSelector((state: GlobalState) => selectUser(state, userId)) as UserProfile | undefined;
    const name = useSelector((state: GlobalState) => displayNameGetter(state, true)(user));

    const profilePictureURL = userId ? imageURLForUser(userId) : '';

    const overlay = useRef<MMOverlayTrigger>(null);

    const hideProfilePopover = () => {
        overlay.current?.hide();
    };

    return (
        <OverlayTrigger
            trigger='click'
            disabled={disableProfileOverlay}
            placement='right'
            rootClose={true}
            ref={overlay}
            overlay={
                <ProfilePopover
                    className='user-profile-popover'
                    userId={userId}
                    src={profilePictureURL}
                    hide={hideProfilePopover}
                />
            }
        >
            <SimpleTooltip
                id={`name-${userId}`}
                content={name}
                {...overlayProps}
            >
                <RoundButton
                    className={'style--none'}
                    onClick={(e) => e.stopPropagation()}
                >
                    <Avatar
                        url={imageURLForUser(userId, user?.last_picture_update)}
                        tabIndex={-1}
                        {...props}
                    />
                </RoundButton>
            </SimpleTooltip>
        </OverlayTrigger>
    );
}

function Avatars({
    size,
    userIds,
    totalUsers,
    fetchMissingUsers = true,
    disableProfileOverlay = false,
}: Props) {
    const {formatMessage} = useIntl();
    const dispatch = useDispatch();
    const [overlayProps, setImmediate] = useSynchronizedImmediate();
    const [displayUserIds, overflowUserIds, {overflowUnnamedCount, nonDisplayCount}] = countMeta(userIds, totalUsers);
    const overflowNames = useSelector((state: GlobalState) => {
        return overflowUserIds.map((userId) => displayNameGetter(state, true)(selectUser(state, userId))).join(', ');
    });

    const {centerChannelBg, centerChannelColor} = useSelector(getTheme);
    const avatarStyle: CSSProperties = useMemo(() => ({
        background: tinycolor.mix(centerChannelBg, centerChannelColor, 8).toRgbString(),
    }), [centerChannelBg, centerChannelColor]);

    useEffect(() => {
        if (fetchMissingUsers) {
            dispatch(getMissingProfilesByIds(userIds));
        }
    }, [fetchMissingUsers, userIds]);

    return (
        <div
            className={`Avatars Avatars___${size}`}
            onMouseLeave={() => setImmediate(false)}
        >
            {displayUserIds.map((id) => (
                <UserAvatar
                    style={avatarStyle}
                    key={id}
                    userId={id}
                    size={size}
                    overlayProps={overlayProps}
                    disableProfileOverlay={disableProfileOverlay}
                />
            ))}
            {Boolean(nonDisplayCount) && (
                <SimpleTooltip
                    id={'names-overflow'}
                    {...overlayProps}
                    content={overflowUserIds.length ? formatMessage(
                        {
                            id: t('avatars.overflowUsers'),
                            defaultMessage: '{overflowUnnamedCount, plural, =0 {{names}} =1 {{names} and one other} other {{names} and # others}}',
                        },
                        {
                            overflowUnnamedCount,
                            names: overflowNames,
                        },
                    ) : formatMessage(
                        {
                            id: t('avatars.overflowUnnamedOnly'),
                            defaultMessage: '{overflowUnnamedCount, plural, =1 {one other} other {# others}}',
                        },
                        {overflowUnnamedCount},
                    )}
                >
                    <Avatar
                        style={avatarStyle}
                        size={size}
                        tabIndex={0}
                        text={nonDisplayCount > OTHERS_DISPLAY_LIMIT ? `${OTHERS_DISPLAY_LIMIT}+` : `+${nonDisplayCount}`}
                    />
                </SimpleTooltip>
            )}
        </div>
    );
}

const RoundButton = styled.button`
    border-radius: 50%;
`;

export default memo(Avatars);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState} from 'react';

import {useIntl} from 'react-intl';

import SwitchSelector from 'react-switch-selector';

import classNames from 'classnames';

import {trackEvent} from 'actions/telemetry_actions';

import './index.scss';

import {TELEMETRY_CATEGORIES} from 'utils/constants';

interface Props {
    updatePrice: (isMonthly: boolean) => void;
    isPurchases: boolean;
    isInitialPlanMonthly: boolean;
}

function YearlyMonthlyToggle(props: Props) {
    const {formatMessage} = useIntl();
    const [isMonthly, setIsMonthly] = useState(props.isInitialPlanMonthly);
    const [moveBorder, setMoveBorder] = useState(false);

    const monthlyLabel = formatMessage({id: 'pricing_modal.monthly', defaultMessage: 'Monthly'});
    const yearlyLabel = formatMessage({id: 'pricing_modal.yearly', defaultMessage: 'Yearly'});

    // handle Enter key being pressed when using Tab to navigate the page
    const handleKeyDown = (event: React.KeyboardEvent) => {
        if (event.key === 'Enter') {
            onToggleChange();

            // click on the unselected label
            const yearlyLabelElement = document.getElementById('text-unselected');
            yearlyLabelElement?.click();
        }
    };

    const options = [
        {
            label: (
                <p
                    className={'label-text'}
                    id={isMonthly ? 'text-unselected' : 'text-selected'}
                >
                    {yearlyLabel}
                </p>
            ),
            value: yearlyLabel,
        },
        {
            label: (
                <p
                    className={'label-text'}
                    id={isMonthly ? 'text-selected' : 'text-unselected'}
                >
                    {monthlyLabel}
                </p>
            ),
            value: monthlyLabel,
        },
    ];

    const onToggleChange = () => {
        setIsMonthly(!isMonthly);

        // After the toggle has been clicked, moveBorder will always be true so it can continue to move if clicked again.
        if (!moveBorder) {
            setMoveBorder(true);
        }

        const telemetryCategory = props.isPurchases ? TELEMETRY_CATEGORIES.CLOUD_PURCHASING : TELEMETRY_CATEGORIES.CLOUD_PRICING;
        trackEvent(telemetryCategory, 'click_yearly_toggle');

        // update the displayed price
        props.updatePrice(!isMonthly);
    };

    const initialPlan = (props.isInitialPlanMonthly) ? monthlyLabel : yearlyLabel;
    const initialSelectedIndex = options.findIndex(({value}) => value === initialPlan);

    return (
        <div className='toggle-monthly-yearly-container'>
            <div
                className={classNames({
                    'toggle-border': true,
                    'toggle-border-yearly': !props.isInitialPlanMonthly,
                    'move-border': moveBorder,
                    'move-left': moveBorder && !isMonthly,
                    'move-right': moveBorder && isMonthly,
                })}
            />
            <div
                className='toggle-monthly-yearly'
                tabIndex={0}
                onKeyPress={handleKeyDown}
            >
                <SwitchSelector
                    onChange={onToggleChange}
                    options={options}
                    initialSelectedIndex={initialSelectedIndex}
                    backgroundColor={''}
                    border={'solid 1px rgba(var(--title-color-indigo-500-rgb), 0.4)'}
                    selectionIndicatorMargin={0}
                    selectedBackgroundColor={'rgba(var(--denim-button-bg-rgb), 0.08)'}
                    wrapperBorderRadius={40}
                    optionBorderRadius={40}
                />
            </div>
        </div>
    );
}

export default YearlyMonthlyToggle;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {batchActions} from 'redux-batched-actions';

import {AdminTypes} from 'mattermost-redux/action_types';
import {General} from '../constants';
import {Client4} from 'mattermost-redux/client';

import {ActionFunc, DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';
import {Compliance} from '@mattermost/types/compliance';
import {GroupSearchOpts} from '@mattermost/types/groups';
import {
    CreateDataRetentionCustomPolicy,
} from '@mattermost/types/data_retention';
import {
    TeamSearchOpts,
} from '@mattermost/types/teams';
import {
    ChannelSearchOpts,
} from '@mattermost/types/channels';

import {CompleteOnboardingRequest} from '@mattermost/types/setup';

import {bindClientFunc, forceLogoutIfNecessary} from './helpers';
import {logError} from './errors';

export function getLogs(page = 0, perPage: number = General.LOGS_PAGE_SIZE_DEFAULT): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getLogs,
        onSuccess: [AdminTypes.RECEIVED_LOGS],
        params: [
            page,
            perPage,
        ],
    });
}

export function getAudits(page = 0, perPage: number = General.PAGE_SIZE_DEFAULT): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getAudits,
        onSuccess: [AdminTypes.RECEIVED_AUDITS],
        params: [
            page,
            perPage,
        ],
    });
}

export function getConfig(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getConfig,
        onSuccess: [AdminTypes.RECEIVED_CONFIG],
    });
}

export function updateConfig(config: Record<string, any>): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.updateConfig,
        onSuccess: [AdminTypes.RECEIVED_CONFIG],
        params: [
            config,
        ],
    });
}

export function reloadConfig(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.reloadConfig,
    });
}

export function getEnvironmentConfig(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getEnvironmentConfig,
        onSuccess: [AdminTypes.RECEIVED_ENVIRONMENT_CONFIG],
    });
}

export function testEmail(config: any): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.testEmail,
        params: [
            config,
        ],
    });
}

export function testSiteURL(siteURL: string): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.testSiteURL,
        params: [
            siteURL,
        ],
    });
}

export function testS3Connection(config: any): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.testS3Connection,
        params: [
            config,
        ],
    });
}

export function invalidateCaches(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.invalidateCaches,
    });
}

export function recycleDatabase(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.recycleDatabase,
    });
}

export function createComplianceReport(job: Partial<Compliance>): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.createComplianceReport,
        onRequest: AdminTypes.CREATE_COMPLIANCE_REQUEST,
        onSuccess: [AdminTypes.RECEIVED_COMPLIANCE_REPORT, AdminTypes.CREATE_COMPLIANCE_SUCCESS],
        onFailure: AdminTypes.CREATE_COMPLIANCE_FAILURE,
        params: [
            job,
        ],
    });
}

export function getComplianceReport(reportId: string): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getComplianceReport,
        onSuccess: [AdminTypes.RECEIVED_COMPLIANCE_REPORT],
        params: [
            reportId,
        ],
    });
}

export function getComplianceReports(page = 0, perPage: number = General.PAGE_SIZE_DEFAULT): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getComplianceReports,
        onSuccess: [AdminTypes.RECEIVED_COMPLIANCE_REPORTS],
        params: [
            page,
            perPage,
        ],
    });
}

export function uploadBrandImage(imageData: File): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.uploadBrandImage,
        params: [
            imageData,
        ],
    });
}

export function deleteBrandImage(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.deleteBrandImage,
    });
}

export function getClusterStatus(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getClusterStatus,
        onSuccess: [AdminTypes.RECEIVED_CLUSTER_STATUS],
    });
}

export function testLdap(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.testLdap,
    });
}

export function syncLdap(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.syncLdap,
    });
}

export function getLdapGroups(page = 0, perPage: number = General.PAGE_SIZE_MAXIMUM, opts: GroupSearchOpts = {q: ''}): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getLdapGroups,
        onSuccess: [AdminTypes.RECEIVED_LDAP_GROUPS],
        params: [
            page,
            perPage,
            opts,
        ],
    });
}

export function linkLdapGroup(key: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.linkLdapGroup(key);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch({type: AdminTypes.LINK_LDAP_GROUP_FAILURE, error, data: key});
            dispatch(logError(error));
            return {error};
        }

        dispatch({
            type: AdminTypes.LINKED_LDAP_GROUP,
            data: {
                primary_key: key,
                name: data.display_name,
                mattermost_group_id: data.id,
                has_syncables: false,
            },
        });

        return {data: true};
    };
}

export function unlinkLdapGroup(key: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        try {
            await Client4.unlinkLdapGroup(key);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch({type: AdminTypes.UNLINK_LDAP_GROUP_FAILURE, error, data: key});
            dispatch(logError(error));
            return {error};
        }

        dispatch({
            type: AdminTypes.UNLINKED_LDAP_GROUP,
            data: key,
        });

        return {data: true};
    };
}

export function getSamlCertificateStatus(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getSamlCertificateStatus,
        onSuccess: [AdminTypes.RECEIVED_SAML_CERT_STATUS],
    });
}

export function uploadPublicSamlCertificate(fileData: File): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.uploadPublicSamlCertificate,
        params: [
            fileData,
        ],
    });
}

export function uploadPrivateSamlCertificate(fileData: File): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.uploadPrivateSamlCertificate,
        params: [
            fileData,
        ],
    });
}

export function uploadPublicLdapCertificate(fileData: File): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.uploadPublicLdapCertificate,
        params: [
            fileData,
        ],
    });
}

export function uploadPrivateLdapCertificate(fileData: File): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.uploadPrivateLdapCertificate,
        params: [
            fileData,
        ],
    });
}

export function uploadIdpSamlCertificate(fileData: File): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.uploadIdpSamlCertificate,
        params: [
            fileData,
        ],
    });
}

export function removePublicSamlCertificate(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.deletePublicSamlCertificate,
    });
}

export function removePrivateSamlCertificate(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.deletePrivateSamlCertificate,
    });
}

export function removePublicLdapCertificate(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.deletePublicLdapCertificate,
    });
}

export function removePrivateLdapCertificate(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.deletePrivateLdapCertificate,
    });
}

export function removeIdpSamlCertificate(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.deleteIdpSamlCertificate,
    });
}

export function testElasticsearch(config: any): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.testElasticsearch,
        params: [
            config,
        ],
    });
}

export function purgeElasticsearchIndexes(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.purgeElasticsearchIndexes,
    });
}

export function uploadLicense(fileData: File): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.uploadLicense,
        params: [
            fileData,
        ],
    });
}

export function removeLicense(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.removeLicense,
    });
}

export function getPrevTrialLicense(): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.getPrevTrialLicense();
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            return {error};
        }

        dispatch({type: AdminTypes.PREV_TRIAL_LICENSE_SUCCESS, data});
        return {data};
    };
}

export function getAnalytics(name: string, teamId = ''): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.getAnalytics(name, teamId);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(logError(error));
            return {error};
        }

        if (teamId === '') {
            dispatch({type: AdminTypes.RECEIVED_SYSTEM_ANALYTICS, data, name});
        } else {
            dispatch({type: AdminTypes.RECEIVED_TEAM_ANALYTICS, data, name, teamId});
        }

        return {data};
    };
}

export function getStandardAnalytics(teamId = ''): ActionFunc {
    return getAnalytics('standard', teamId);
}

export function getAdvancedAnalytics(teamId = ''): ActionFunc {
    return getAnalytics('extra_counts', teamId);
}

export function getPostsPerDayAnalytics(teamId = ''): ActionFunc {
    return getAnalytics('post_counts_day', teamId);
}

export function getBotPostsPerDayAnalytics(teamId = ''): ActionFunc {
    return getAnalytics('bot_post_counts_day', teamId);
}

export function getUsersPerDayAnalytics(teamId = ''): ActionFunc {
    return getAnalytics('user_counts_with_posts_day', teamId);
}

export function uploadPlugin(fileData: File, force = false): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.uploadPlugin(fileData, force);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(logError(error));
            return {error};
        }

        return {data};
    };
}

export function installPluginFromUrl(url: string, force = false): ActionFunc {
    return async (dispatch, getState) => {
        let data;
        try {
            data = await Client4.installPluginFromUrl(url, force);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(logError(error));
            return {error};
        }

        return {data};
    };
}

export function getPlugins(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getPlugins,
        onSuccess: [AdminTypes.RECEIVED_PLUGINS],
    });
}

export function getPluginStatuses(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getPluginStatuses,
        onSuccess: [AdminTypes.RECEIVED_PLUGIN_STATUSES],
    });
}

export function removePlugin(pluginId: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        try {
            await Client4.removePlugin(pluginId);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(logError(error));
            return {error};
        }

        dispatch(batchActions([
            {type: AdminTypes.REMOVED_PLUGIN, data: pluginId},
            {type: AdminTypes.DISABLED_PLUGIN, data: pluginId},
        ]));

        return {data: true};
    };
}

export function enablePlugin(pluginId: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        try {
            await Client4.enablePlugin(pluginId);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(logError(error));
            return {error};
        }

        dispatch({type: AdminTypes.ENABLED_PLUGIN, data: pluginId});

        return {data: true};
    };
}

export function disablePlugin(pluginId: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        dispatch({type: AdminTypes.DISABLE_PLUGIN_REQUEST, data: pluginId});

        try {
            await Client4.disablePlugin(pluginId);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(logError(error));
            return {error};
        }

        dispatch({type: AdminTypes.DISABLED_PLUGIN, data: pluginId});

        return {data: true};
    };
}

export function getSamlMetadataFromIdp(samlMetadataURL: string): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getSamlMetadataFromIdp,
        onSuccess: AdminTypes.RECEIVED_SAML_METADATA_RESPONSE,
        params: [
            samlMetadataURL,
        ],
    });
}

export function setSamlIdpCertificateFromMetadata(certData: string): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.setSamlIdpCertificateFromMetadata,
        params: [
            certData,
        ],
    });
}

export function sendWarnMetricAck(warnMetricId: string, forceAck: boolean) {
    return async (dispatch: DispatchFunc) => {
        try {
            Client4.trackEvent('api', 'api_request_send_metric_ack', {warnMetricId});
            await Client4.sendWarnMetricAck(warnMetricId, forceAck);
            return {data: true};
        } catch (e) {
            dispatch(logError(e));
            return {error: e.message};
        }
    };
}

export function getDataRetentionCustomPolicies(page = 0, perPage = 10): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.getDataRetentionCustomPolicies(page, perPage);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(
                {
                    type: AdminTypes.RECEIVED_DATA_RETENTION_CUSTOM_POLICIES,
                    error,
                },
            );
            return {error};
        }

        dispatch(
            {type: AdminTypes.RECEIVED_DATA_RETENTION_CUSTOM_POLICIES, data},
        );

        return {data};
    };
}

export function getDataRetentionCustomPolicy(id: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.getDataRetentionCustomPolicy(id);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(
                {
                    type: AdminTypes.RECEIVED_DATA_RETENTION_CUSTOM_POLICY,
                    error,
                },
            );
            return {error};
        }

        dispatch(
            {type: AdminTypes.RECEIVED_DATA_RETENTION_CUSTOM_POLICY, data},
        );

        return {data};
    };
}

export function deleteDataRetentionCustomPolicy(id: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        try {
            await Client4.deleteDataRetentionCustomPolicy(id);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(
                {
                    type: AdminTypes.DELETE_DATA_RETENTION_CUSTOM_POLICY_FAILURE,
                    error,
                },
            );
            return {error};
        }
        const data = {
            id,
        };
        dispatch(
            {type: AdminTypes.DELETE_DATA_RETENTION_CUSTOM_POLICY_SUCCESS, data},
        );

        return {data};
    };
}

export function getDataRetentionCustomPolicyTeams(id: string, page = 0, perPage: number = General.TEAMS_CHUNK_SIZE): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.getDataRetentionCustomPolicyTeams(id, page, perPage);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(
                {
                    type: AdminTypes.RECEIVED_DATA_RETENTION_CUSTOM_POLICY_TEAMS,
                    error,
                },
            );
            return {error};
        }

        dispatch(
            {type: AdminTypes.RECEIVED_DATA_RETENTION_CUSTOM_POLICY_TEAMS, data},
        );

        return {data};
    };
}

export function getDataRetentionCustomPolicyChannels(id: string, page = 0, perPage: number = General.TEAMS_CHUNK_SIZE): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.getDataRetentionCustomPolicyChannels(id, page, perPage);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(
                {
                    type: AdminTypes.RECEIVED_DATA_RETENTION_CUSTOM_POLICY_CHANNELS,
                    error,
                },
            );
            return {error};
        }

        dispatch(
            {type: AdminTypes.RECEIVED_DATA_RETENTION_CUSTOM_POLICY_CHANNELS, data},
        );

        return {data};
    };
}

export function searchDataRetentionCustomPolicyTeams(id: string, term: string, opts: TeamSearchOpts): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.searchDataRetentionCustomPolicyTeams(id, term, opts);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(
                {
                    type: AdminTypes.RECEIVED_DATA_RETENTION_CUSTOM_POLICY_TEAMS_SEARCH,
                    error,
                },
            );
            return {error};
        }

        dispatch(
            {type: AdminTypes.RECEIVED_DATA_RETENTION_CUSTOM_POLICY_TEAMS_SEARCH, data},
        );

        return {data};
    };
}

export function searchDataRetentionCustomPolicyChannels(id: string, term: string, opts: ChannelSearchOpts): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.searchDataRetentionCustomPolicyChannels(id, term, opts);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(
                {
                    type: AdminTypes.RECEIVED_DATA_RETENTION_CUSTOM_POLICY_CHANNELS_SEARCH,
                    error,
                },
            );
            return {error};
        }

        dispatch(
            {type: AdminTypes.RECEIVED_DATA_RETENTION_CUSTOM_POLICY_CHANNELS_SEARCH, data},
        );

        return {data};
    };
}

export function createDataRetentionCustomPolicy(policy: CreateDataRetentionCustomPolicy): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.createDataRetentionPolicy(policy);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            return {error};
        }

        dispatch(
            {type: AdminTypes.CREATE_DATA_RETENTION_CUSTOM_POLICY_SUCCESS, data},
        );

        return {data};
    };
}

export function updateDataRetentionCustomPolicy(id: string, policy: CreateDataRetentionCustomPolicy): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.updateDataRetentionPolicy(id, policy);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            return {error};
        }

        dispatch(
            {type: AdminTypes.UPDATE_DATA_RETENTION_CUSTOM_POLICY_SUCCESS, data},
        );

        return {data};
    };
}

export function addDataRetentionCustomPolicyTeams(id: string, teams: string[]): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.addDataRetentionPolicyTeams,
        onSuccess: AdminTypes.ADD_DATA_RETENTION_CUSTOM_POLICY_TEAMS_SUCCESS,
        params: [
            id,
            teams,
        ],
    });
}

export function removeDataRetentionCustomPolicyTeams(id: string, teams: string[]): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        try {
            await Client4.removeDataRetentionPolicyTeams(id, teams);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(
                {
                    type: AdminTypes.REMOVE_DATA_RETENTION_CUSTOM_POLICY_TEAMS_FAILURE,
                    error,
                },
            );
            return {error};
        }
        const data = {
            teams,
        };
        dispatch(
            {type: AdminTypes.REMOVE_DATA_RETENTION_CUSTOM_POLICY_TEAMS_SUCCESS, data},
        );

        return {data};
    };
}

export function addDataRetentionCustomPolicyChannels(id: string, channels: string[]): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.addDataRetentionPolicyChannels,
        onSuccess: AdminTypes.ADD_DATA_RETENTION_CUSTOM_POLICY_CHANNELS_SUCCESS,
        params: [
            id,
            channels,
        ],
    });
}

export function removeDataRetentionCustomPolicyChannels(id: string, channels: string[]): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        try {
            await Client4.removeDataRetentionPolicyChannels(id, channels);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(
                {
                    type: AdminTypes.REMOVE_DATA_RETENTION_CUSTOM_POLICY_CHANNELS_FAILURE,
                    error,
                },
            );
            return {error};
        }
        const data = {
            channels,
        };
        dispatch(
            {type: AdminTypes.REMOVE_DATA_RETENTION_CUSTOM_POLICY_CHANNELS_SUCCESS, data},
        );

        return {data};
    };
}

export function completeSetup(completeSetup: CompleteOnboardingRequest): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.completeSetup,
        params: [completeSetup],
    });
}

export function getAppliedSchemaMigrations(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getAppliedSchemaMigrations,
    });
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {AppsTypes} from 'mattermost-redux/action_types';
import {Client4} from 'mattermost-redux/client';

import {ActionFunc, DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';

import {getChannel, getCurrentChannelId} from 'mattermost-redux/selectors/entities/channels';
import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/common';

import {bindClientFunc} from './helpers';

// This file's contents belong to the Apps Framework feature.
// Apps Framework feature is experimental, and the contents of this file are
// susceptible to breaking changes without pushing the major version of this package.

export function fetchAppBindings(channelID: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        if (!channelID) {
            return {data: true};
        }

        const state = getState();
        const channel = getChannel(state, channelID);
        const userID = getCurrentUserId(state);
        const teamID = channel?.team_id || getCurrentTeamId(state);

        return dispatch(bindClientFunc({
            clientFunc: () => Client4.getAppsBindings(userID, channelID, teamID),
            onSuccess: AppsTypes.RECEIVED_APP_BINDINGS,
            onFailure: AppsTypes.FAILED_TO_FETCH_APP_BINDINGS,
        }));
    };
}

export function fetchRHSAppsBindings(channelID: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();

        const currentChannelID = getCurrentChannelId(state);
        const channel = getChannel(state, channelID);
        const teamID = channel?.team_id || getCurrentTeamId(state);

        if (channelID === currentChannelID) {
            const bindings = JSON.parse(JSON.stringify(state.entities.apps.main.bindings));
            return dispatch({
                data: bindings,
                type: AppsTypes.RECEIVED_APP_RHS_BINDINGS,
            });
        }

        const userID = getCurrentUserId(state);

        return dispatch(bindClientFunc({
            clientFunc: () => Client4.getAppsBindings(userID, channelID, teamID),
            onSuccess: AppsTypes.RECEIVED_APP_RHS_BINDINGS,
            onFailure: AppsTypes.FAILED_TO_FETCH_APP_BINDINGS,
        }));
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {Client4} from 'mattermost-redux/client';

import {ActionFunc, DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';
import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';

import {Board, BoardPatch, BoardTemplate} from '@mattermost/types/boards';
import {PreferenceType} from '@mattermost/types/preferences';

import {Preferences} from '../constants';

import {logError} from './errors';
import {savePreferences} from './preferences';

export function createBoardFromTemplate(templateId: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();
        const teamId = getCurrentTeamId(state);

        try {
            const {boards} = await Client4.createBoardFromTemplate(templateId, teamId);
            return {data: boards[0]};
        } catch (error) {
            dispatch(logError(error));
            return {error};
        }
    };
}

export function getBoardsTemplates(): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();
        const teamId = getCurrentTeamId(state);
        try {
            let templates: BoardTemplate[] = [];

            // first go and fetch the based stablished templates
            const baseTemplates = await Client4.getBoardsTemplates();
            if (baseTemplates) {
                templates = [...baseTemplates];
            }

            // then grab the team templates and return all together
            const teamTemplates = await Client4.getBoardsTemplates(teamId);
            if (teamTemplates) {
                templates = [...templates, ...teamTemplates];
            }
            return {data: templates};
        } catch (error) {
            dispatch(logError(error));
            return {error};
        }
    };
}

export function createEmptyBoard(board: Board): ActionFunc {
    return async (dispatch: DispatchFunc) => {
        try {
            const newBoard = await Client4.createBoard(board);
            return {data: newBoard};
        } catch (error) {
            dispatch(logError(error));
            return {error};
        }
    };
}

export function attachBoardToChannel(newBoardId: string, boardPatch: BoardPatch): ActionFunc {
    return async (dispatch: DispatchFunc) => {
        try {
            const patchedBoard = await Client4.patchBoard(newBoardId, boardPatch);
            return {data: patchedBoard};
        } catch (error) {
            dispatch(logError(error));
            return {error};
        }
    };
}

export function setNewChannelWithBoardPreference(initializationState: Record<string, boolean>): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();
        const currentUserId = getCurrentUserId(state);
        const preference: PreferenceType = {
            user_id: currentUserId,
            category: Preferences.APP_BAR,
            name: Preferences.NEW_CHANNEL_WITH_BOARD_TOUR_SHOWED,
            value: JSON.stringify(initializationState),
        };
        await dispatch(savePreferences(currentUserId, [preference]));
        return {data: true};
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {CloudTypes} from 'mattermost-redux/action_types';
import {Client4} from 'mattermost-redux/client';

import {ActionFunc} from 'mattermost-redux/types/actions';
import {Address, CloudCustomerPatch} from '@mattermost/types/cloud';

import {bindClientFunc} from './helpers';

export function getCloudSubscription(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getSubscription,
        onSuccess: [CloudTypes.RECEIVED_CLOUD_SUBSCRIPTION],
        onFailure: CloudTypes.CLOUD_SUBSCRIPTION_FAILED,
        onRequest: CloudTypes.CLOUD_SUBSCRIPTION_REQUEST,
    });
}

export function getCloudProducts(includeLegacyProducts?: boolean): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getCloudProducts,
        onSuccess: [CloudTypes.RECEIVED_CLOUD_PRODUCTS],
        onFailure: CloudTypes.CLOUD_PRODUCTS_FAILED,
        onRequest: CloudTypes.CLOUD_PRODUCTS_REQUEST,
        params: [includeLegacyProducts],
    });
}

export function getCloudCustomer(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getCloudCustomer,
        onSuccess: [CloudTypes.RECEIVED_CLOUD_CUSTOMER],
        onFailure: CloudTypes.CLOUD_CUSTOMER_FAILED,
        onRequest: CloudTypes.CLOUD_CUSTOMER_REQUEST,
    });
}

export function getInvoices(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getInvoices,
        onSuccess: [CloudTypes.RECEIVED_CLOUD_INVOICES],
        onFailure: CloudTypes.CLOUD_INVOICES_FAILED,
        onRequest: CloudTypes.CLOUD_INVOICES_REQUEST,
    });
}

export function updateCloudCustomer(customerPatch: CloudCustomerPatch): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.updateCloudCustomer,
        onSuccess: [CloudTypes.RECEIVED_CLOUD_CUSTOMER],
        params: [customerPatch],
    });
}

export function updateCloudCustomerAddress(address: Address): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.updateCloudCustomerAddress,
        onSuccess: [CloudTypes.RECEIVED_CLOUD_CUSTOMER],
        params: [address],
    });
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {AnyAction} from 'redux';
import {batchActions} from 'redux-batched-actions';

import {ChannelTypes, GroupTypes, UserTypes} from 'mattermost-redux/action_types';
import {General} from 'mattermost-redux/constants';
import {Client4} from 'mattermost-redux/client';

import {ActionFunc, DispatchFunc, GetStateFunc} from 'mattermost-redux/types/actions';
import {GroupPatch, SyncableType, SyncablePatch, GroupCreateWithUserIds, CustomGroupPatch, GroupSearachParams, GroupSource} from '@mattermost/types/groups';

import {logError} from './errors';
import {bindClientFunc, forceLogoutIfNecessary} from './helpers';

export function linkGroupSyncable(groupID: string, syncableID: string, syncableType: SyncableType, patch: SyncablePatch): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.linkGroupSyncable(groupID, syncableID, syncableType, patch);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(logError(error));
            return {error};
        }

        const dispatches: AnyAction[] = [];
        let type = '';
        switch (syncableType) {
        case SyncableType.Team:
            dispatches.push({type: GroupTypes.RECEIVED_GROUP_ASSOCIATED_TO_TEAM, data: {teamID: syncableID, groups: [{id: groupID}]}});
            type = GroupTypes.LINKED_GROUP_TEAM;
            break;
        case SyncableType.Channel:
            type = GroupTypes.LINKED_GROUP_CHANNEL;
            break;
        default:
            console.warn(`unhandled syncable type ${syncableType}`); // eslint-disable-line no-console
        }

        dispatches.push({type, data});
        dispatch(batchActions(dispatches));

        return {data: true};
    };
}

export function unlinkGroupSyncable(groupID: string, syncableID: string, syncableType: SyncableType): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        try {
            await Client4.unlinkGroupSyncable(groupID, syncableID, syncableType);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(logError(error));
            return {error};
        }

        const dispatches: AnyAction[] = [];

        let type = '';
        const data = {group_id: groupID, syncable_id: syncableID};
        switch (syncableType) {
        case SyncableType.Team:
            type = GroupTypes.UNLINKED_GROUP_TEAM;
            data.syncable_id = syncableID;
            dispatches.push({type: GroupTypes.RECEIVED_GROUPS_NOT_ASSOCIATED_TO_TEAM, data: {teamID: syncableID, groups: [{id: groupID}]}});
            break;
        case SyncableType.Channel:
            type = GroupTypes.UNLINKED_GROUP_CHANNEL;
            data.syncable_id = syncableID;
            break;
        default:
            console.warn(`unhandled syncable type ${syncableType}`); // eslint-disable-line no-console
        }

        dispatches.push({type, data});
        dispatch(batchActions(dispatches));

        return {data: true};
    };
}

export function getGroupSyncables(groupID: string, syncableType: SyncableType): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.getGroupSyncables(groupID, syncableType);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(logError(error));
            return {error};
        }

        let type = '';
        switch (syncableType) {
        case SyncableType.Team:
            type = GroupTypes.RECEIVED_GROUP_TEAMS;
            break;
        case SyncableType.Channel:
            type = GroupTypes.RECEIVED_GROUP_CHANNELS;
            break;
        default:
            console.warn(`unhandled syncable type ${syncableType}`); // eslint-disable-line no-console
        }

        dispatch(batchActions([
            {type, data, group_id: groupID},
        ]));

        return {data: true};
    };
}

export function patchGroupSyncable(groupID: string, syncableID: string, syncableType: SyncableType, patch: SyncablePatch): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.patchGroupSyncable(groupID, syncableID, syncableType, patch);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            return {error};
        }

        const dispatches: AnyAction[] = [];

        let type = '';
        switch (syncableType) {
        case SyncableType.Team:
            type = GroupTypes.PATCHED_GROUP_TEAM;
            break;
        case SyncableType.Channel:
            type = GroupTypes.PATCHED_GROUP_CHANNEL;
            break;
        default:
            console.warn(`unhandled syncable type ${syncableType}`); // eslint-disable-line no-console
        }

        dispatches.push(
            {type, data},
        );
        dispatch(batchActions(dispatches));

        return {data: true};
    };
}

export function getGroup(id: string, includeMemberCount = false): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getGroup,
        onSuccess: [GroupTypes.RECEIVED_GROUP],
        params: [
            id,
            includeMemberCount,
        ],
    });
}

export function getGroups(filterAllowReference = false, page = 0, perPage = 10, includeMemberCount = false): ActionFunc {
    return bindClientFunc({
        clientFunc: async (param1, param2, param3, param4) => {
            const result = await Client4.getGroups(param1, param2, param3, param4);
            return result;
        },
        onSuccess: [GroupTypes.RECEIVED_GROUPS],
        params: [
            filterAllowReference,
            page,
            perPage,
            includeMemberCount,
        ],
    });
}

export function getGroupsNotAssociatedToTeam(teamID: string, q = '', page = 0, perPage: number = General.PAGE_SIZE_DEFAULT, source = GroupSource.Ldap): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getGroupsNotAssociatedToTeam,
        onSuccess: [GroupTypes.RECEIVED_GROUPS],
        params: [
            teamID,
            q,
            page,
            perPage,
            source,
        ],
    });
}

export function getGroupsNotAssociatedToChannel(channelID: string, q = '', page = 0, perPage: number = General.PAGE_SIZE_DEFAULT, filterParentTeamPermitted = false, source = GroupSource.Ldap): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getGroupsNotAssociatedToChannel,
        onSuccess: [GroupTypes.RECEIVED_GROUPS],
        params: [
            channelID,
            q,
            page,
            perPage,
            filterParentTeamPermitted,
            source,
        ],
    });
}

export function getAllGroupsAssociatedToTeam(teamID: string, filterAllowReference = false, includeMemberCount = false): ActionFunc {
    return bindClientFunc({
        clientFunc: async (param1, param2, param3) => {
            const result = await Client4.getAllGroupsAssociatedToTeam(param1, param2, param3);
            result.teamID = param1;
            return result;
        },
        onSuccess: [GroupTypes.RECEIVED_ALL_GROUPS_ASSOCIATED_TO_TEAM],
        params: [
            teamID,
            filterAllowReference,
            includeMemberCount,
        ],
    });
}

export function getAllGroupsAssociatedToChannelsInTeam(teamID: string, filterAllowReference = false): ActionFunc {
    return bindClientFunc({
        clientFunc: async (param1, param2) => {
            const result = await Client4.getAllGroupsAssociatedToChannelsInTeam(param1, param2);
            return {groupsByChannelId: result.groups};
        },
        onSuccess: [GroupTypes.RECEIVED_ALL_GROUPS_ASSOCIATED_TO_CHANNELS_IN_TEAM],
        params: [
            teamID,
            filterAllowReference,
        ],
    });
}

export function getAllGroupsAssociatedToChannel(channelID: string, filterAllowReference = false, includeMemberCount = false): ActionFunc {
    return bindClientFunc({
        clientFunc: async (param1, param2, param3) => {
            const result = await Client4.getAllGroupsAssociatedToChannel(param1, param2, param3);
            result.channelID = param1;
            return result;
        },
        onSuccess: [GroupTypes.RECEIVED_ALL_GROUPS_ASSOCIATED_TO_CHANNEL],
        params: [
            channelID,
            filterAllowReference,
            includeMemberCount,
        ],
    });
}

export function getGroupsAssociatedToTeam(teamID: string, q = '', page = 0, perPage: number = General.PAGE_SIZE_DEFAULT, filterAllowReference = false): ActionFunc {
    return bindClientFunc({
        clientFunc: async (param1, param2, param3, param4, param5) => {
            const result = await Client4.getGroupsAssociatedToTeam(param1, param2, param3, param4, param5);
            return {groups: result.groups, totalGroupCount: result.total_group_count, teamID: param1};
        },
        onSuccess: [GroupTypes.RECEIVED_GROUPS_ASSOCIATED_TO_TEAM],
        params: [
            teamID,
            q,
            page,
            perPage,
            filterAllowReference,
        ],
    });
}

export function getGroupsAssociatedToChannel(channelID: string, q = '', page = 0, perPage: number = General.PAGE_SIZE_DEFAULT, filterAllowReference = false): ActionFunc {
    return bindClientFunc({
        clientFunc: async (param1, param2, param3, param4, param5) => {
            const result = await Client4.getGroupsAssociatedToChannel(param1, param2, param3, param4, param5);
            return {groups: result.groups, totalGroupCount: result.total_group_count, channelID: param1};
        },
        onSuccess: [GroupTypes.RECEIVED_GROUPS_ASSOCIATED_TO_CHANNEL],
        params: [
            channelID,
            q,
            page,
            perPage,
            filterAllowReference,
        ],
    });
}

export function patchGroup(groupID: string, patch: GroupPatch | CustomGroupPatch): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.patchGroup,
        onSuccess: [GroupTypes.PATCHED_GROUP],
        params: [
            groupID,
            patch,
        ],
    });
}

export function getGroupsByUserId(userID: string): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getGroupsByUserId,
        onSuccess: [GroupTypes.RECEIVED_MY_GROUPS],
        params: [
            userID,
        ],
    });
}

export function getGroupsByUserIdPaginated(userId: string, filterAllowReference = false, page = 0, perPage: number = General.PAGE_SIZE_DEFAULT, includeMemberCount = false): ActionFunc {
    return bindClientFunc({
        clientFunc: async (param1, param2, param3, param4, param5) => {
            const result = await Client4.getGroups(param1, param2, param3, param4, param5);
            return result;
        },
        onSuccess: [GroupTypes.RECEIVED_MY_GROUPS, GroupTypes.RECEIVED_GROUPS],
        params: [
            filterAllowReference,
            page,
            perPage,
            includeMemberCount,
            userId,
        ],
    });
}

export function getGroupStats(groupID: string): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getGroupStats,
        onSuccess: [GroupTypes.RECEIVED_GROUP_STATS],
        params: [
            groupID,
        ],
    });
}

export function createGroupWithUserIds(group: GroupCreateWithUserIds): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.createGroupWithUserIds(group);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            return {error};
        }

        dispatch(
            {type: GroupTypes.CREATE_GROUP_SUCCESS, data},
        );

        return {data};
    };
}

export function addUsersToGroup(groupId: string, userIds: string[]): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.addUsersToGroup(groupId, userIds);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            return {error};
        }

        dispatch(
            {
                type: UserTypes.RECEIVED_PROFILES_FOR_GROUP,
                data,
                id: groupId,
            },
        );

        return {data};
    };
}

export function removeUsersFromGroup(groupId: string, userIds: string[]): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.removeUsersFromGroup(groupId, userIds);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            return {error};
        }

        dispatch(
            {
                type: UserTypes.RECEIVED_PROFILES_LIST_TO_REMOVE_FROM_GROUP,
                data,
                id: groupId,
            },
        );

        return {data};
    };
}

export function searchGroups(params: GroupSearachParams): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.searchGroups(params);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            dispatch(logError(error));
            return {error};
        }

        const dispatches: AnyAction[] = [{type: GroupTypes.RECEIVED_GROUPS, data}];

        if (params.user_id) {
            dispatches.push({type: GroupTypes.RECEIVED_MY_GROUPS, data});
        }
        if (params.include_channel_member_count) {
            dispatches.push({type: ChannelTypes.RECEIVED_CHANNEL_MEMBER_COUNTS_FROM_GROUPS_LIST, data, channelId: params.include_channel_member_count});
        }
        dispatch(batchActions(dispatches));

        return {data: true};
    };
}

export function archiveGroup(groupId: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let data;
        try {
            data = await Client4.archiveGroup(groupId);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            return {error};
        }

        dispatch(
            {
                type: GroupTypes.ARCHIVED_GROUP,
                id: groupId,
            },
        );

        return {data};
    };
}

export function createGroupTeamsAndChannels(userID: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        try {
            await Client4.createGroupTeamsAndChannels(userID);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);
            return {error};
        }
        return {user_id: userID};
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {batchActions} from 'redux-batched-actions';

import {IntegrationTypes} from 'mattermost-redux/action_types';
import {General} from '../constants';
import {Client4} from 'mattermost-redux/client';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';
import {getCurrentChannelId} from 'mattermost-redux/selectors/entities/channels';
import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';

import {DispatchFunc, GetStateFunc, ActionFunc} from 'mattermost-redux/types/actions';

import {Command, CommandArgs, DialogSubmission, IncomingWebhook, OAuthApp, OutgoingWebhook} from '@mattermost/types/integrations';

import {logError} from './errors';
import {bindClientFunc, forceLogoutIfNecessary} from './helpers';
export function createIncomingHook(hook: IncomingWebhook): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.createIncomingWebhook,
        onSuccess: [IntegrationTypes.RECEIVED_INCOMING_HOOK],
        params: [
            hook,
        ],
    });
}

export function getIncomingHook(hookId: string): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getIncomingWebhook,
        onSuccess: [IntegrationTypes.RECEIVED_INCOMING_HOOK],
        params: [
            hookId,
        ],
    });
}

export function getIncomingHooks(teamId = '', page = 0, perPage: number = General.PAGE_SIZE_DEFAULT): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getIncomingWebhooks,
        onSuccess: [IntegrationTypes.RECEIVED_INCOMING_HOOKS],
        params: [
            teamId,
            page,
            perPage,
        ],
    });
}

export function removeIncomingHook(hookId: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        try {
            await Client4.removeIncomingWebhook(hookId);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);

            dispatch(logError(error));
            return {error};
        }

        dispatch(batchActions([
            {
                type: IntegrationTypes.DELETED_INCOMING_HOOK,
                data: {id: hookId},
            },
        ]));

        return {data: true};
    };
}

export function updateIncomingHook(hook: IncomingWebhook): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.updateIncomingWebhook,
        onSuccess: [IntegrationTypes.RECEIVED_INCOMING_HOOK],
        params: [
            hook,
        ],
    });
}

export function createOutgoingHook(hook: OutgoingWebhook): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.createOutgoingWebhook,
        onSuccess: [IntegrationTypes.RECEIVED_OUTGOING_HOOK],
        params: [
            hook,
        ],
    });
}

export function getOutgoingHook(hookId: string): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getOutgoingWebhook,
        onSuccess: [IntegrationTypes.RECEIVED_OUTGOING_HOOK],
        params: [
            hookId,
        ],
    });
}

export function getOutgoingHooks(channelId = '', teamId = '', page = 0, perPage: number = General.PAGE_SIZE_DEFAULT): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getOutgoingWebhooks,
        onSuccess: [IntegrationTypes.RECEIVED_OUTGOING_HOOKS],
        params: [
            channelId,
            teamId,
            page,
            perPage,
        ],
    });
}

export function removeOutgoingHook(hookId: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        try {
            await Client4.removeOutgoingWebhook(hookId);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);

            dispatch(logError(error));
            return {error};
        }

        dispatch(batchActions([
            {
                type: IntegrationTypes.DELETED_OUTGOING_HOOK,
                data: {id: hookId},
            },
        ]));

        return {data: true};
    };
}

export function updateOutgoingHook(hook: OutgoingWebhook): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.updateOutgoingWebhook,
        onSuccess: [IntegrationTypes.RECEIVED_OUTGOING_HOOK],
        params: [
            hook,
        ],
    });
}

export function regenOutgoingHookToken(hookId: string): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.regenOutgoingHookToken,
        onSuccess: [IntegrationTypes.RECEIVED_OUTGOING_HOOK],
        params: [
            hookId,
        ],
    });
}

export function getCommands(teamId: string): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getCommandsList,
        onSuccess: [IntegrationTypes.RECEIVED_COMMANDS],
        params: [
            teamId,
        ],
    });
}

export function getAutocompleteCommands(teamId: string, page = 0, perPage: number = General.PAGE_SIZE_DEFAULT): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getAutocompleteCommandsList,
        onSuccess: [IntegrationTypes.RECEIVED_COMMANDS],
        params: [
            teamId,
            page,
            perPage,
        ],
    });
}

export function getCustomTeamCommands(teamId: string): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getCustomTeamCommands,
        onSuccess: [IntegrationTypes.RECEIVED_CUSTOM_TEAM_COMMANDS],
        params: [
            teamId,
        ],
    });
}

export function addCommand(command: Command): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.addCommand,
        onSuccess: [IntegrationTypes.RECEIVED_COMMAND],
        params: [
            command,
        ],
    });
}

export function editCommand(command: Command): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.editCommand,
        onSuccess: [IntegrationTypes.RECEIVED_COMMAND],
        params: [
            command,
        ],
    });
}

export function executeCommand(command: string, args: CommandArgs): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.executeCommand,
        params: [
            command,
            args,
        ],
    });
}

export function regenCommandToken(id: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        let res;
        try {
            res = await Client4.regenCommandToken(id);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);

            dispatch(logError(error));
            return {error};
        }

        dispatch(batchActions([
            {
                type: IntegrationTypes.RECEIVED_COMMAND_TOKEN,
                data: {
                    id,
                    token: res.token,
                },
            },
        ]));

        return {data: true};
    };
}

export function deleteCommand(id: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        try {
            await Client4.deleteCommand(id);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);

            dispatch(logError(error));
            return {error};
        }

        dispatch(batchActions([
            {
                type: IntegrationTypes.DELETED_COMMAND,
                data: {id},
            },
        ]));

        return {data: true};
    };
}

export function addOAuthApp(app: OAuthApp): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.createOAuthApp,
        onSuccess: [IntegrationTypes.RECEIVED_OAUTH_APP],
        params: [
            app,
        ],
    });
}

export function editOAuthApp(app: OAuthApp): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.editOAuthApp,
        onSuccess: IntegrationTypes.RECEIVED_OAUTH_APP,
        params: [
            app,
        ],
    });
}

export function getOAuthApps(page = 0, perPage: number = General.PAGE_SIZE_DEFAULT): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getOAuthApps,
        onSuccess: [IntegrationTypes.RECEIVED_OAUTH_APPS],
        params: [
            page,
            perPage,
        ],
    });
}

export function getAppsOAuthAppIDs(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getAppsOAuthAppIDs,
        onSuccess: [IntegrationTypes.RECEIVED_APPS_OAUTH_APP_IDS],
    });
}

export function getAppsBotIDs(): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getAppsBotIDs,
        onSuccess: [IntegrationTypes.RECEIVED_APPS_BOT_IDS],
    });
}

export function getOAuthApp(appId: string): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.getOAuthApp,
        onSuccess: [IntegrationTypes.RECEIVED_OAUTH_APP],
        params: [
            appId,
        ],
    });
}

export function getAuthorizedOAuthApps(): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();
        const currentUserId = getCurrentUserId(state);

        let data;
        try {
            data = await Client4.getAuthorizedOAuthApps(currentUserId);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);

            dispatch(logError(error));

            return {error};
        }

        return {data};
    };
}

export function deauthorizeOAuthApp(clientId: string): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.deauthorizeOAuthApp,
        params: [clientId],
    });
}

export function deleteOAuthApp(id: string): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        try {
            await Client4.deleteOAuthApp(id);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);

            dispatch(logError(error));
            return {error};
        }

        dispatch(batchActions([
            {
                type: IntegrationTypes.DELETED_OAUTH_APP,
                data: {id},
            },
        ]));

        return {data: true};
    };
}

export function regenOAuthAppSecret(appId: string): ActionFunc {
    return bindClientFunc({
        clientFunc: Client4.regenOAuthAppSecret,
        onSuccess: [IntegrationTypes.RECEIVED_OAUTH_APP],
        params: [
            appId,
        ],
    });
}

export function submitInteractiveDialog(submission: DialogSubmission): ActionFunc {
    return async (dispatch: DispatchFunc, getState: GetStateFunc) => {
        const state = getState();
        submission.channel_id = getCurrentChannelId(state);
        submission.team_id = getCurrentTeamId(state);

        let data;
        try {
            data = await Client4.submitInteractiveDialog(submission);
        } catch (error) {
            forceLogoutIfNecessary(error, dispatch, getState);

            dispatch(logError(error));
            return {error};
        }

        return {data};
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {createSelector} from 'reselect';

import {GlobalState} from '@mattermost/types/store';
import {AppBinding} from '@mattermost/types/apps';
import {ClientConfig} from '@mattermost/types/config';

import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {AppBindingLocations} from 'mattermost-redux/constants/apps';

// This file's contents belong to the Apps Framework feature.
// Apps Framework feature is experimental, and the contents of this file are
// susceptible to breaking changes without pushing the major version of this package.

export const appsPluginIsEnabled = (state: GlobalState) => state.entities.apps.pluginEnabled;

export const appsFeatureFlagEnabled = createSelector(
    'appsConfiguredAsEnabled',
    (state: GlobalState) => getConfig(state),
    (config: Partial<ClientConfig>) => {
        return config?.['FeatureFlagAppsEnabled' as keyof Partial<ClientConfig>] === 'true';
    },
);

export const appsEnabled = createSelector(
    'appsEnabled',
    appsFeatureFlagEnabled,
    appsPluginIsEnabled,
    (featureFlagEnabled: boolean, pluginEnabled: boolean) => {
        return featureFlagEnabled && pluginEnabled;
    },
);

export const appBarEnabled = createSelector(
    'appBarEnabled',
    (state: GlobalState) => getConfig(state),
    (config?: Partial<ClientConfig>) => {
        return config?.EnableAppBar === 'true';
    },
);

export const makeAppBindingsSelector = (location: string) => {
    return createSelector(
        'makeAppBindingsSelector',
        (state: GlobalState) => state.entities.apps.main.bindings,
        (state: GlobalState) => appsEnabled(state),
        (bindings: AppBinding[], areAppsEnabled: boolean) => {
            if (!areAppsEnabled || !bindings) {
                return [];
            }

            const headerBindings = bindings.filter((b) => b.location === location);
            return headerBindings.reduce((accum: AppBinding[], current: AppBinding) => accum.concat(current.bindings || []), []);
        },
    );
};

export const getChannelHeaderAppBindings = createSelector(
    'getChannelHeaderAppBindings',
    appBarEnabled,
    makeAppBindingsSelector(AppBindingLocations.CHANNEL_HEADER_ICON),
    (enabled: boolean, channelHeaderBindings: AppBinding[]) => {
        return enabled ? [] : channelHeaderBindings;
    },
);

export const getAppBarAppBindings = createSelector(
    'getAppBarAppBindings',
    appBarEnabled,
    makeAppBindingsSelector(AppBindingLocations.CHANNEL_HEADER_ICON),
    makeAppBindingsSelector(AppBindingLocations.APP_BAR),
    (enabled: boolean, channelHeaderBindings: AppBinding[], appBarBindings: AppBinding[]) => {
        if (!enabled) {
            return [];
        }

        const appIds = appBarBindings.map((b) => b.app_id);
        const backwardsCompatibleBindings = channelHeaderBindings.filter((b) => !appIds.includes(b.app_id));

        return appBarBindings.concat(backwardsCompatibleBindings);
    },
);

export const makeRHSAppBindingSelector = (location: string) => {
    return createSelector(
        'makeRHSAppBindingSelector',
        (state: GlobalState) => state.entities.apps.rhs.bindings,
        (state: GlobalState) => appsEnabled(state),
        (bindings: AppBinding[], areAppsEnabled: boolean) => {
            if (!areAppsEnabled || !bindings) {
                return [];
            }

            const headerBindings = bindings.filter((b) => b.location === location);
            return headerBindings.reduce((accum: AppBinding[], current: AppBinding) => accum.concat(current.bindings || []), []);
        },
    );
};

export const getAppCommandForm = (state: GlobalState, location: string) => {
    return state.entities.apps.main.forms[location];
};

export const getAppRHSCommandForm = (state: GlobalState, location: string) => {
    return state.entities.apps.rhs.forms[location];
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {
    Limits,
    Subscription,
    Product,
    CloudCustomer,
    CloudState,
    SelfHostedSignupProgress,
} from '@mattermost/types/cloud';
import {GlobalState} from '@mattermost/types/store';
import {ValueOf} from '@mattermost/types/utilities';

import {getLicense} from './general';

export function getCloudLimits(state: GlobalState): Limits {
    return state.entities.cloud.limits.limits;
}

export function getCloudSubscription(state: GlobalState): Subscription | undefined {
    return state.entities.cloud.subscription;
}
export function getCloudCustomer(state: GlobalState): CloudCustomer | undefined {
    return state.entities.cloud.customer;
}

export function getCloudProducts(state: GlobalState): Record<string, Product> | undefined {
    return state.entities.cloud.products;
}

export function getCloudLimitsLoaded(state: GlobalState): boolean {
    return state.entities.cloud.limits.limitsLoaded;
}

export function getCloudErrors(state: GlobalState): CloudState['errors'] {
    return state.entities.cloud.errors;
}

export function getCloudInvoices(state: GlobalState): CloudState['invoices'] {
    return state.entities.cloud.invoices;
}

export function getSubscriptionProduct(state: GlobalState): Product | undefined {
    const subscription = getCloudSubscription(state);
    if (!subscription) {
        return undefined;
    }
    const products = getCloudProducts(state);
    if (!products) {
        return undefined;
    }

    return products[subscription.product_id];
}

export function getSubscriptionProductName(state: GlobalState): string {
    return getSubscriptionProduct(state)?.name || '';
}

export function checkHadPriorTrial(state: GlobalState): boolean {
    const subscription = getCloudSubscription(state);
    return Boolean(subscription?.is_free_trial === 'false' && subscription?.trial_end_at > 0);
}

export function isCurrentLicenseCloud(state: GlobalState): boolean {
    const license = getLicense(state);
    return license?.Cloud === 'true';
}

export function getSelfHostedSignupProgress(state: GlobalState): ValueOf<typeof SelfHostedSignupProgress> {
    return state.entities.cloud.selfHostedSignup.progress;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {createSelector} from 'reselect';

import {getCurrentUserLocale} from 'mattermost-redux/selectors/entities/i18n';

import {FileInfo, FileSearchResultItem} from '@mattermost/types/files';
import {GlobalState} from '@mattermost/types/store';

import {sortFileInfos} from 'mattermost-redux/utils/file_utils';

function getAllFiles(state: GlobalState) {
    return state.entities.files.files;
}

export function getFile(state: GlobalState, id: string) {
    return state.entities.files.files?.[id];
}

function getAllFilesFromSearch(state: GlobalState) {
    return state.entities.files.filesFromSearch;
}

function getFilesIdsForPost(state: GlobalState, postId: string) {
    if (postId) {
        return state.entities.files.fileIdsByPostId[postId] || [];
    }

    return [];
}

export function getFilePublicLink(state: GlobalState) {
    return state.entities.files.filePublicLink;
}

export function makeGetFilesForPost(): (state: GlobalState, postId: string) => FileInfo[] {
    return createSelector(
        'makeGetFilesForPost',
        getAllFiles,
        getFilesIdsForPost,
        getCurrentUserLocale,
        (allFiles, fileIdsForPost, locale) => {
            const fileInfos = fileIdsForPost.map((id) => allFiles[id]).filter((id) => Boolean(id));

            return sortFileInfos(fileInfos, locale);
        },
    );
}

export const getSearchFilesResults: (state: GlobalState) => FileSearchResultItem[] = createSelector(
    'getSearchFilesResults',
    getAllFilesFromSearch,
    (state: GlobalState) => state.entities.search.fileResults,
    (files, fileIds) => {
        if (!fileIds) {
            return [];
        }

        return fileIds.map((id) => files[id]);
    },
);


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {General} from '../constants';
import {Group} from '@mattermost/types/groups';

import {getSuggestionsSplitByMultiple} from './user_utils';

export function filterGroupsMatchingTerm(groups: Group[], term: string): Group[] {
    const lowercasedTerm = term.toLowerCase();
    let trimmedTerm = lowercasedTerm;
    if (trimmedTerm.startsWith('@')) {
        trimmedTerm = trimmedTerm.substr(1);
    }

    return groups.filter((group: Group) => {
        if (!group) {
            return false;
        }

        const groupSuggestions: string[] = [];

        const groupnameSuggestions = getSuggestionsSplitByMultiple((group.name || '').toLowerCase(), General.AUTOCOMPLETE_SPLIT_CHARACTERS);

        groupSuggestions.push(...groupnameSuggestions);
        const displayname = (group.display_name || '').toLowerCase();
        groupSuggestions.push(displayname);

        return groupSuggestions.
            filter((suggestion) => suggestion !== '').
            some((suggestion) => suggestion.startsWith(trimmedTerm));
    });
}

export function sortGroups(groups: Group[] = [], locale: string = General.DEFAULT_LOCALE): Group[] {
    return groups.sort((a, b) => {
        return a.display_name.localeCompare(b.display_name, locale, {numeric: true});
    });
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {createSelector} from 'reselect';

import {Group, GroupSource} from '@mattermost/types/groups';

import {filterGroupsMatchingTerm, sortGroups} from 'mattermost-redux/utils/group_utils';
import {getChannel} from 'mattermost-redux/selectors/entities/channels';
import {getTeam} from 'mattermost-redux/selectors/entities/teams';
import {UserMentionKey} from 'mattermost-redux/selectors/entities/users';
import {GlobalState} from '@mattermost/types/store';

import {getCurrentUserLocale} from './i18n';

const emptyList: any[] = [];
const emptySyncables = {
    teams: [],
    channels: [],
};

function getGroupInfoForIds(groupsSet: Record<string, Group>, groupIds: string[]) {
    const groups: Group[] = [];

    for (let i = 0; i < groupIds.length; i++) {
        const id = groupIds[i];
        groups.push(groupsSet[id]);
    }

    return groups;
}

export function getAllGroups(state: GlobalState) {
    return state.entities.groups.groups;
}

export function getMyGroupIds(state: GlobalState) {
    return state.entities.groups.myGroups;
}

export function getAllGroupStats(state: GlobalState) {
    return state.entities.groups.stats;
}

export function getGroupStats(state: GlobalState, id: string) {
    return getAllGroupStats(state)[id] || {};
}

export function getGroup(state: GlobalState, id: string) {
    return getAllGroups(state)[id];
}

export function getGroupMemberCount(state: GlobalState, id: string) {
    return getGroupStats(state, id).total_member_count;
}

function getGroupSyncables(state: GlobalState, id: string) {
    return state.entities.groups.syncables[id] || emptySyncables;
}

export function getGroupTeams(state: GlobalState, id: string) {
    return getGroupSyncables(state, id).teams;
}

export function getGroupChannels(state: GlobalState, id: string) {
    return getGroupSyncables(state, id).channels;
}

export const getAssociatedGroupsByName: (state: GlobalState, teamID: string, channelId: string) => Record<string, Group> = createSelector(
    'getAssociatedGroupsByName',
    getAssociatedGroupsForReference,
    (groups) => {
        const groupsByName: Record<string, Group> = {};

        for (const id in groups) {
            if (groups.hasOwnProperty(id)) {
                const group = groups[id];
                groupsByName[group.name] = group;
            }
        }

        return groupsByName;
    },
);

export const getAssociatedGroupsForReferenceByMention: (state: GlobalState, teamID: string, channelId: string) => Map<string, Group> = createSelector(
    'getAssociatedGroupsForReferenceByMention',
    getAssociatedGroupsForReference,
    (groups) => {
        return new Map(groups.map((group) => [`@${group.name}`, group]));
    },
);

export function searchAssociatedGroupsForReferenceLocal(state: GlobalState, term: string, teamId: string, channelId: string): Group[] {
    const groups = getAssociatedGroupsForReference(state, teamId, channelId);
    if (!groups) {
        return emptyList;
    }
    const filteredGroups = filterGroupsMatchingTerm(groups, term);
    return filteredGroups;
}

export function getAssociatedGroupsForReference(state: GlobalState, teamId: string, channelId: string): Group[] {
    const team = getTeam(state, teamId);
    const channel = getChannel(state, channelId);

    let groupsForReference = [];
    if (team && team.group_constrained && channel && channel.group_constrained) {
        const groupsFromChannel = getGroupsAssociatedToChannelForReference(state, channelId);
        const groupsFromTeam = getGroupsAssociatedToTeamForReference(state, teamId);
        groupsForReference = groupsFromChannel.concat(groupsFromTeam.filter((item) => groupsFromChannel.indexOf(item) < 0));
    } else if (team && team.group_constrained) {
        groupsForReference = getGroupsAssociatedToTeamForReference(state, teamId);
    } else if (channel && channel.group_constrained) {
        groupsForReference = getGroupsAssociatedToChannelForReference(state, channelId);
    } else {
        groupsForReference = getAllAssociatedGroupsForReference(state);
    }
    return groupsForReference;
}

const teamGroupIDs = (state: GlobalState, teamID: string) => state.entities.teams.groupsAssociatedToTeam[teamID]?.ids || [];

const channelGroupIDs = (state: GlobalState, channelID: string) => state.entities.channels.groupsAssociatedToChannel[channelID]?.ids || [];

const getTeamGroupIDSet = createSelector(
    'getTeamGroupIDSet',
    teamGroupIDs,
    (teamIDs) => new Set(teamIDs),
);

const getChannelGroupIDSet = createSelector(
    'getChannelGroupIDSet',
    channelGroupIDs,
    (channelIDs) => new Set(channelIDs),
);

export const getMyGroups: (state: GlobalState) => Group[] = createSelector(
    'getGroupsNotAssociatedToTeam',
    getAllGroups,
    getMyGroupIds,
    (allGroups, myGroupIds) => {
        return sortGroups(getGroupInfoForIds(allGroups, myGroupIds));
    },
);

export const getGroupsNotAssociatedToTeam: (state: GlobalState, teamID: string) => Group[] = createSelector(
    'getGroupsNotAssociatedToTeam',
    getAllGroups,
    (state: GlobalState, teamID: string) => getTeamGroupIDSet(state, teamID),
    (allGroups, teamGroupIDSet) => {
        return Object.entries(allGroups).filter(([groupID, group]) => !teamGroupIDSet.has(groupID) && group.source === GroupSource.Ldap).map((entry) => entry[1]);
    },
);

export const getGroupsAssociatedToTeam: (state: GlobalState, teamID: string) => Group[] = createSelector(
    'getGroupsAssociatedToTeam',
    getAllGroups,
    (state: GlobalState, teamID: string) => getTeamGroupIDSet(state, teamID),
    (allGroups, teamGroupIDSet) => {
        return Object.entries(allGroups).filter(([groupID]) => teamGroupIDSet.has(groupID)).map((entry) => entry[1]);
    },
);

export const getGroupsNotAssociatedToChannel: (state: GlobalState, channelID: string, teamID: string) => Group[] = createSelector(
    'getGroupsNotAssociatedToChannel',
    getAllGroups,
    (state: GlobalState, channelID: string) => getChannelGroupIDSet(state, channelID),
    (state: GlobalState, channelID: string, teamID: string) => getTeam(state, teamID),
    (state: GlobalState, channelID: string, teamID: string) => getGroupsAssociatedToTeam(state, teamID),
    (allGroups, channelGroupIDSet, team, teamGroups) => {
        let result = Object.values(allGroups).filter((group) => !channelGroupIDSet.has(group.id) && group.source === GroupSource.Ldap);
        if (team.group_constrained) {
            const gids = teamGroups.map((group) => group.id);
            result = result.filter((group) => gids?.includes(group.id));
        }
        return result;
    },
);

export const getGroupsAssociatedToChannel: (state: GlobalState, channelID: string) => Group[] = createSelector(
    'getGroupsAssociatedToChannel',
    getAllGroups,
    (state: GlobalState, channelID: string) => getChannelGroupIDSet(state, channelID),
    (allGroups, channelGroupIDSet) => {
        return Object.entries(allGroups).filter(([groupID]) => channelGroupIDSet.has(groupID)).map((entry) => entry[1]);
    },
);

export const getGroupsAssociatedToTeamForReference: (state: GlobalState, teamID: string) => Group[] = createSelector(
    'getGroupsAssociatedToTeamForReference',
    getAllGroups,
    (state: GlobalState, teamID: string) => getTeamGroupIDSet(state, teamID),
    (allGroups, teamGroupIDSet) => {
        return Object.entries(allGroups).filter(([groupID]) => teamGroupIDSet.has(groupID)).filter((entry) => (entry[1].allow_reference && entry[1].delete_at === 0)).map((entry) => entry[1]);
    },
);

export const getGroupsAssociatedToChannelForReference: (state: GlobalState, channelID: string) => Group[] = createSelector(
    'getGroupsAssociatedToChannelForReference',
    getAllGroups,
    (state: GlobalState, channelID: string) => getChannelGroupIDSet(state, channelID),
    (allGroups, channelGroupIDSet) => {
        return Object.entries(allGroups).filter(([groupID]) => channelGroupIDSet.has(groupID)).filter((entry) => (entry[1].allow_reference && entry[1].delete_at === 0)).map((entry) => entry[1]);
    },
);

export const getAllAssociatedGroupsForReference: (state: GlobalState) => Group[] = createSelector(
    'getAllAssociatedGroupsForReference',
    getAllGroups,
    getCurrentUserLocale,
    (allGroups, locale) => {
        const groups = Object.entries(allGroups).filter((entry) => (entry[1].allow_reference && entry[1].delete_at === 0)).map((entry) => entry[1]);

        return sortGroups(groups, locale);
    },
);

export const getAllGroupsForReferenceByName: (state: GlobalState) => Record<string, Group> = createSelector(
    'getAllGroupsForReferenceByName',
    getAllAssociatedGroupsForReference,
    (groups) => {
        const groupsByName: Record<string, Group> = {};

        for (const id in groups) {
            if (groups.hasOwnProperty(id)) {
                const group = groups[id];
                groupsByName[group.name] = group;
            }
        }

        return groupsByName;
    },
);

export const getMyAllowReferencedGroups: (state: GlobalState) => Group[] = createSelector(
    'getMyAllowReferencedGroups',
    getMyGroups,
    getCurrentUserLocale,
    (myGroups, locale) => {
        const groups = myGroups.filter((group) => group.allow_reference && group.delete_at === 0);

        return sortGroups(groups, locale);
    },
);

export const getMyGroupsAssociatedToChannelForReference: (state: GlobalState, teamId: string, channelId: string) => Group[] = createSelector(
    'getMyGroupsAssociatedToChannelForReference',
    getMyGroups,
    getAssociatedGroupsByName,
    (myGroups, groups) => {
        return myGroups.filter((group) => group.allow_reference && group.delete_at === 0 && groups[group.name]);
    },
);

export const getMyGroupMentionKeys: (state: GlobalState) => UserMentionKey[] = createSelector(
    'getMyGroupMentionKeys',
    getMyAllowReferencedGroups,
    (groups: Group[]) => {
        const keys: UserMentionKey[] = [];
        groups.forEach((group) => keys.push({key: `@${group.name}`}));
        return keys;
    },
);

export const getMyGroupMentionKeysForChannel: (state: GlobalState, teamId: string, channelId: string) => UserMentionKey[] = createSelector(
    'getMyGroupMentionKeysForChannel',
    getMyGroupsAssociatedToChannelForReference,
    (groups: Group[]) => {
        const keys: UserMentionKey[] = [];
        groups.forEach((group) => keys.push({key: `@${group.name}`}));
        return keys;
    },
);

export const searchAllowReferencedGroups: (state: GlobalState, term: string) => Group[] = createSelector(
    'searchAllowReferencedGroups',
    getAllAssociatedGroupsForReference,
    (state: GlobalState, term: string) => term,
    (groups, term) => {
        return filterGroupsMatchingTerm(groups, term);
    },
);

export const searchMyAllowReferencedGroups: (state: GlobalState, term: string) => Group[] = createSelector(
    'searchMyAllowReferencedGroups',
    getMyAllowReferencedGroups,
    (state: GlobalState, term: string) => term,
    (groups, term) => {
        return filterGroupsMatchingTerm(groups, term);
    },
);

export const isMyGroup: (state: GlobalState, groupId: string) => boolean = createSelector(
    'isMyGroup',
    getMyGroupIds,
    (state: GlobalState, groupId: string) => groupId,
    (myGroupIDs: string[], groupId: string) => {
        let isMyGroup = false;
        myGroupIDs.forEach((myGroupId) => {
            if (myGroupId === groupId) {
                isMyGroup = true;
            }
        });
        return isMyGroup;
    },
);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {createSelector} from 'reselect';

import {getCurrentTeamId} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentUserMentionKeys, UserMentionKey} from 'mattermost-redux/selectors/entities/users';
import {getMyGroupMentionKeys} from 'mattermost-redux/selectors/entities/groups';

import {GlobalState} from '@mattermost/types/store';

export const getCurrentSearchForCurrentTeam: (state: GlobalState) => string = createSelector(
    'getCurrentSearchForCurrentTeam',
    (state: GlobalState) => state.entities.search.current,
    getCurrentTeamId,
    (current, teamId) => {
        return current[teamId];
    },
);

export const getAllUserMentionKeys: (state: GlobalState) => UserMentionKey[] = createSelector(
    'getAllUserMentionKeys',
    getCurrentUserMentionKeys,
    getMyGroupMentionKeys,
    (userMentionKeys, groupMentionKeys) => {
        return userMentionKeys.concat(groupMentionKeys);
    },
);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {CloudUsage} from '@mattermost/types/cloud';
import {GlobalState} from '@mattermost/types/store';

export function getUsage(state: GlobalState): CloudUsage {
    return state.entities.usage;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {createSelector} from 'reselect';

import {getMyChannelMemberships, getAllDmChannels} from 'mattermost-redux/selectors/entities/channels';
import {getCurrentUserId, getUserStatuses} from 'mattermost-redux/selectors/entities/users';

import {GlobalState} from '@mattermost/types/store';
import {UserProfile, UserProfileWithLastViewAt} from '@mattermost/types/users';
import {getDirectChannelName} from 'mattermost-redux/utils/channel_utils';

export function makeAddLastViewAtToProfiles(): (state: GlobalState, profiles: UserProfile[]) => UserProfileWithLastViewAt[] {
    return createSelector(
        'makeAddLastViewAtToProfiles',
        getCurrentUserId,
        getMyChannelMemberships,
        getAllDmChannels,
        getUserStatuses,
        (_: GlobalState, profiles: UserProfile[]) => profiles,
        (currentUserId, memberships, allDmChannels, userStatuses, profiles) => {
            const formattedProfiles: UserProfileWithLastViewAt[] = profiles.map((profile) => {
                const channelName = getDirectChannelName(currentUserId, profile.id);
                const channel = allDmChannels[channelName];
                const membership = channel ? memberships[channel.id] : null;
                const status = userStatuses[profile.id];

                return {
                    ...profile,
                    status,
                    last_viewed_at: channel && membership ? membership.last_viewed_at : 0,
                };
            });

            return formattedProfiles;
        },
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {Files, General} from '../constants';
import {Client4} from 'mattermost-redux/client';
import {FileInfo} from '@mattermost/types/files';

export function getFormattedFileSize(file: FileInfo): string {
    const bytes = file.size;
    const fileSizes = [
        ['TB', 1024 * 1024 * 1024 * 1024],
        ['GB', 1024 * 1024 * 1024],
        ['MB', 1024 * 1024],
        ['KB', 1024],
    ];
    const size = fileSizes.find((unitAndMinBytes) => {
        const minBytes = unitAndMinBytes[1];
        return bytes > minBytes;
    });

    if (size) {
        return `${Math.floor(bytes / (size[1] as any))} ${size[0]}`;
    }

    return `${bytes} B`;
}

export function getFileType(file: FileInfo): string {
    if (!file || !file.extension) {
        return 'other';
    }

    const fileExt = file.extension.toLowerCase();
    const fileTypes = [
        'image',
        'code',
        'pdf',
        'video',
        'audio',
        'spreadsheet',
        'text',
        'word',
        'presentation',
        'patch',
    ];
    return fileTypes.find((fileType) => {
        const constForFileTypeExtList = `${fileType}_types`.toUpperCase();
        const fileTypeExts = Files[constForFileTypeExtList];
        return fileTypeExts.indexOf(fileExt) > -1;
    }) || 'other';
}

export function getFileUrl(fileId: string): string {
    return Client4.getFileRoute(fileId);
}

export function getFileDownloadUrl(fileId: string): string {
    return `${Client4.getFileRoute(fileId)}?download=1`;
}

export function getFileThumbnailUrl(fileId: string): string {
    return `${Client4.getFileRoute(fileId)}/thumbnail`;
}

export function getFilePreviewUrl(fileId: string): string {
    return `${Client4.getFileRoute(fileId)}/preview`;
}

export function getFileMiniPreviewUrl(fileInfo?: FileInfo): string | undefined {
    if (!fileInfo?.mini_preview || !fileInfo?.mime_type) {
        return undefined;
    }
    return `data:${fileInfo.mime_type};base64,${fileInfo.mini_preview}`;
}

export function sortFileInfos(fileInfos: FileInfo[] = [], locale: string = General.DEFAULT_LOCALE): FileInfo[] {
    return fileInfos.sort((a, b) => {
        if (a.create_at !== b.create_at) {
            return a.create_at - b.create_at;
        }

        return a.name.localeCompare(b.name, locale, {numeric: true});
    });
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {DialogElement} from '@mattermost/types/integrations';

type DialogError = {
    id: string;
    defaultMessage: string;
    values?: any;
};
export function checkDialogElementForError(elem: DialogElement, value: any): DialogError | undefined | null {
    if (!value && !elem.optional) {
        return {
            id: 'interactive_dialog.error.required',
            defaultMessage: 'This field is required.',
        };
    }

    const type = elem.type;

    if (type === 'text' || type === 'textarea') {
        if (value && value.length < elem.min_length) {
            return {
                id: 'interactive_dialog.error.too_short',
                defaultMessage: 'Minimum input length is {minLength}.',
                values: {minLength: elem.min_length},
            };
        }

        if (elem.subtype === 'email') {
            if (value && !value.includes('@')) {
                return {
                    id: 'interactive_dialog.error.bad_email',
                    defaultMessage: 'Must be a valid email address.',
                };
            }
        }

        if (elem.subtype === 'number') {
            if (value && isNaN(value)) {
                return {
                    id: 'interactive_dialog.error.bad_number',
                    defaultMessage: 'Must be a number.',
                };
            }
        }

        if (elem.subtype === 'url') {
            if (value && !value.includes('http://') && !value.includes('https://')) {
                return {
                    id: 'interactive_dialog.error.bad_url',
                    defaultMessage: 'URL must include http:// or https://.',
                };
            }
        }
    } else if (type === 'radio') {
        const options = elem.options;

        if (typeof value !== 'undefined' && Array.isArray(options) && !options.some((e) => e.value === value)) {
            return {
                id: 'interactive_dialog.error.invalid_option',
                defaultMessage: 'Must be a valid option',
            };
        }
    }

    return null;
}

// If we're returned errors that don't match any of the elements we have,
// ignore them and complete the dialog

export function checkIfErrorsMatchElements(errors: {
    [x: string]: DialogError;
} = {}, elements: DialogElement[] = []) {
    for (const name in errors) {
        if (!errors.hasOwnProperty(name)) {
            continue;
        }
        for (const elem of elements) {
            if (elem.name === name) {
                return true;
            }
        }
    }

    return false;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {MarketplaceApp, MarketplacePlugin} from '@mattermost/types/marketplace';

// This file's contents belong to the Apps Framework feature.
// Apps Framework feature is experimental, and the contents of this file are
// susceptible to breaking changes without pushing the major version of this package.
export function isPlugin(item: MarketplacePlugin | MarketplaceApp): item is MarketplacePlugin {
    return (item as MarketplacePlugin).manifest.id !== undefined;
}

export function getName(item: MarketplacePlugin | MarketplaceApp): string {
    if (isPlugin(item)) {
        return item.manifest.name;
    }
    return item.manifest.display_name;
}

"use strict";
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroupSource = exports.SyncableType = void 0;
var SyncableType;
(function (SyncableType) {
    SyncableType["Team"] = "team";
    SyncableType["Channel"] = "channel";
})(SyncableType = exports.SyncableType || (exports.SyncableType = {}));
var GroupSource;
(function (GroupSource) {
    GroupSource["Ldap"] = "ldap";
    GroupSource["Custom"] = "custom";
})(GroupSource = exports.GroupSource || (exports.GroupSource = {}));

"use strict";
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.PostPriority = void 0;
var PostPriority;
(function (PostPriority) {
    PostPriority["URGENT"] = "urgent";
    PostPriority["IMPORTANT"] = "important";
})(PostPriority = exports.PostPriority || (exports.PostPriority = {}));

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionTypes} from 'utils/constants';
import {hideRHSPlugin as hideRHSPluginAction} from 'actions/views/rhs';
import {getPluggableId} from 'selectors/rhs';

export const removeWebappPlugin = (manifest) => {
    return (dispatch) => {
        dispatch(hideRHSPlugin(manifest.id));
        dispatch({type: ActionTypes.REMOVED_WEBAPP_PLUGIN, data: manifest});
    };
};

// hideRHSPlugin closes the RHS if currently showing this plugin.
const hideRHSPlugin = (manifestId) => {
    return (dispatch, getState) => {
        const state = getState();
        const rhsPlugins = state.plugins.components.RightHandSidebarComponent || [];
        const pluggableId = getPluggableId(state);
        const pluginComponent = rhsPlugins.find((element) => element.id === pluggableId && element.pluginId === manifestId);

        // Hide RHS if its showing this plugin
        if (pluginComponent) {
            dispatch(hideRHSPluginAction(pluggableId));
        }
    };
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import regeneratorRuntime from 'regenerator-runtime';

import {Client4} from 'mattermost-redux/client';

import {Preferences} from 'mattermost-redux/constants';

import {getConfig, isPerformanceDebuggingEnabled} from 'mattermost-redux/selectors/entities/general';
import {getBool} from 'mattermost-redux/selectors/entities/preferences';

import store from 'stores/redux_store.jsx';
import {ActionTypes} from 'utils/constants';
import {getSiteURL} from 'utils/url';
import PluginRegistry from 'plugins/registry';
import {unregisterAllPluginWebSocketEvents, unregisterPluginReconnectHandler} from 'actions/websocket_actions.jsx';
import {unregisterPluginTranslationsSource} from 'actions/views/root';
import {unregisterAdminConsolePlugin} from 'actions/admin_actions';
import {trackPluginInitialization} from 'actions/telemetry_actions';

import {removeWebappPlugin} from './actions';

// Including the fullscreen modal css to make it available to the plugins
// (without lazy loading). This should be removed in the future whenever we
// have all plugins migrated to common components that can be reused there.
import 'components/widgets/modals/full_screen_modal.scss';

// Plugins may have been compiled with the regenerator runtime. Ensure this remains available
// as a global export even though the webapp does not depend on same.
window.regeneratorRuntime = regeneratorRuntime;

// plugins records all active web app plugins by id.
window.plugins = {};

// registerPlugin, on the global window object, should be invoked by a plugin's web app bundle as
// it is loaded.
//
// During the beta, plugins manipulated the global window.plugins data structure directly. This
// remains possible, but is officially deprecated and may be removed in a future release.
function registerPlugin(id, plugin) {
    const oldPlugin = window.plugins[id];
    if (oldPlugin && oldPlugin.uninitialize) {
        oldPlugin.uninitialize();
    }

    window.plugins[id] = plugin;
}
window.registerPlugin = registerPlugin;

function arePluginsEnabled(state) {
    if (getConfig(state).PluginsEnabled !== 'true') {
        return false;
    }

    if (
        isPerformanceDebuggingEnabled(state) &&
        getBool(state, Preferences.CATEGORY_PERFORMANCE_DEBUGGING, Preferences.NAME_DISABLE_CLIENT_PLUGINS)
    ) {
        return false;
    }

    return true;
}

// initializePlugins queries the server for all enabled plugins and loads each in turn.
export async function initializePlugins() {
    if (!arePluginsEnabled(store.getState())) {
        return;
    }

    const {data, error} = await getPlugins()(store.dispatch);
    if (error) {
        console.error(error); //eslint-disable-line no-console
        return;
    }

    if (data == null || data.length === 0) {
        return;
    }

    await Promise.all(data.map((m) => {
        return loadPlugin(m).catch((loadErr) => {
            console.error(loadErr.message); //eslint-disable-line no-console
        });
    }));

    trackPluginInitialization(data);
}

// getPlugins queries the server for all enabled plugins
export function getPlugins() {
    return async (dispatch) => {
        let plugins;
        try {
            plugins = await Client4.getWebappPlugins();
        } catch (error) {
            return {error};
        }

        dispatch({type: ActionTypes.RECEIVED_WEBAPP_PLUGINS, data: plugins});

        return {data: plugins};
    };
}

// loadedPlugins tracks which plugins have been added as script tags to the page
const loadedPlugins = {};

// describePlugin takes a manifest and spits out a string suitable for console.log messages.
const describePlugin = (manifest) => (
    'plugin ' + manifest.id + ', version ' + manifest.version
);

// loadPlugin fetches the web app bundle described by the given manifest, waits for the bundle to
// load, and then ensures the plugin has been initialized.
export function loadPlugin(manifest) {
    return new Promise((resolve, reject) => {
        if (!arePluginsEnabled(store.getState())) {
            return;
        }

        // Don't load it again if previously loaded
        const oldManifest = loadedPlugins[manifest.id];
        if (oldManifest && oldManifest.webapp.bundle_path === manifest.webapp.bundle_path) {
            resolve();
            return;
        }

        if (oldManifest) {
            // upgrading, perform cleanup
            store.dispatch(removeWebappPlugin(manifest));
        }

        function onLoad() {
            initializePlugin(manifest);
            console.log('Loaded ' + describePlugin(manifest)); //eslint-disable-line no-console
            resolve();
        }

        function onError() {
            reject(new Error('Unable to load bundle for ' + describePlugin(manifest)));
        }

        // Backwards compatibility for old plugins
        let bundlePath = manifest.webapp.bundle_path;
        if (bundlePath.includes('/static/') && !bundlePath.includes('/static/plugins/')) {
            bundlePath = bundlePath.replace('/static/', '/static/plugins/');
        }

        console.log('Loading ' + describePlugin(manifest)); //eslint-disable-line no-console

        const script = document.createElement('script');
        script.id = 'plugin_' + manifest.id;
        script.type = 'text/javascript';
        script.src = getSiteURL() + bundlePath;
        script.onload = onLoad;
        script.onerror = onError;

        document.getElementsByTagName('head')[0].appendChild(script);
        loadedPlugins[manifest.id] = manifest;
    });
}

// initializePlugin creates a registry specific to the plugin and invokes any initialize function
// on the registered plugin class.
function initializePlugin(manifest) {
    // Initialize the plugin
    const plugin = window.plugins[manifest.id];
    const registry = new PluginRegistry(manifest.id);
    if (plugin && plugin.initialize) {
        plugin.initialize(registry, store);
    }
}

// removePlugin triggers any uninitialize callback on the registered plugin, unregisters any
// event handlers, and removes the plugin script from the DOM entirely. The plugin is responsible
// for removing any of its registered components.
export function removePlugin(manifest) {
    if (!loadedPlugins[manifest.id]) {
        return;
    }
    console.log('Removing ' + describePlugin(manifest)); //eslint-disable-line no-console

    delete loadedPlugins[manifest.id];

    store.dispatch(removeWebappPlugin(manifest));

    const plugin = window.plugins[manifest.id];
    if (plugin && plugin.uninitialize) {
        plugin.uninitialize();

    // Support the deprecated deinitialize callback from the plugins beta.
    } else if (plugin && plugin.deinitialize) {
        plugin.deinitialize();
    }
    unregisterAllPluginWebSocketEvents(manifest.id);
    unregisterPluginReconnectHandler(manifest.id);
    store.dispatch(unregisterAdminConsolePlugin(manifest.id));
    unregisterPluginTranslationsSource(manifest.id);
    const script = document.getElementById('plugin_' + manifest.id);
    if (!script) {
        return;
    }
    script.parentNode.removeChild(script);
    console.log('Removed ' + describePlugin(manifest)); //eslint-disable-line no-console
}

// loadPluginsIfNecessary synchronizes the current state of loaded plugins with that of the server,
// loading any newly added plugins and unloading any removed ones.
export async function loadPluginsIfNecessary() {
    if (!arePluginsEnabled(store.getState())) {
        return;
    }

    const oldManifests = store.getState().plugins.plugins;

    const {error} = await getPlugins()(store.dispatch);
    if (error) {
        console.error(error); //eslint-disable-line no-console
        return;
    }

    const newManifests = store.getState().plugins.plugins;

    // Get new plugins and update existing plugins if version changed
    Object.values(newManifests).forEach((newManifest) => {
        const oldManifest = oldManifests[newManifest.id];
        if (!oldManifest || oldManifest.version !== newManifest.version) {
            loadPlugin(newManifest).catch((loadErr) => {
                console.error(loadErr.message); //eslint-disable-line no-console
            });
        }
    });

    // Remove old plugins
    Object.keys(oldManifests).forEach((id) => {
        if (!newManifests.hasOwnProperty(id)) {
            const oldManifest = oldManifests[id];
            removePlugin(oldManifest);
        }
    });
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';
import styled from 'styled-components';

type Props = {
    children: React.ReactNode;
    pluginId?: string;
}

type State = {
    hasError: boolean;
}

const WrapperDiv = styled.div`
    align-items: center;
    display: flex;
    flex-direction: column;
    height: 100%;
    justify-content: center;
    width: 100%;

    #root > & {
        // prevent root layout error; fit into announcement area
        grid-area: announcement;
        display: flex;
        word-break: normal;
        flex-direction: row;
        gap: 10px;
        height: 40px;
    }
`;

export default class PluggableErrorBoundary extends React.PureComponent<Props, State> {
    state = {
        hasError: false,
    };

    static getDerivedStateFromError() {
        return {
            hasError: true,
        };
    }

    clearErrorState = (e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();

        this.setState({hasError: false});
    }

    render() {
        if (this.state.hasError) {
            return (
                <WrapperDiv>
                    <FormattedMessage
                        id='pluggable.errorOccurred'
                        defaultMessage='An error occurred in the {pluginId} plugin.'
                        values={{
                            pluginId: this.props.pluginId,
                        }}
                    />
                    <br/>
                    <a
                        href='#'
                        onClick={this.clearErrorState}
                    >
                        <FormattedMessage
                            id='pluggable.errorRefresh'
                            defaultMessage='Refresh?'
                            values={{
                                pluginId: this.props.pluginId,
                            }}
                        />
                    </a>
                </WrapperDiv>
            );
        }

        return this.props.children;
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {WebSocketClient} from '@mattermost/client';

import {Theme} from 'mattermost-redux/selectors/entities/preferences';

import {ProductComponent} from 'types/store/plugins';
import {GlobalState} from 'types/store';

import webSocketClient from 'client/web_websocket_client';

import PluggableErrorBoundary from './error_boundary';

type Props = {

    /*
     * Override the component to be plugged
     */
    pluggableName: string;

    /*
     * Components for overriding provided by plugins
     */
    components: GlobalState['plugins']['components'];

    /*
     * Logged in user's theme
     */
    theme: Theme;

    /*
     * Id of the specific component to be plugged.
     */
    pluggableId?: string;

    /*
     * Name of the sub component to use. Defaults to 'component' if unspecified.
     *
     * Only supported when pluggableName is "Product".
     */
    subComponentName?: 'mainComponent' | 'headerCentreComponent' | 'headerRightComponent';

    /*
     * Accept any other prop to pass onto the plugin component
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [name: string]: any;
}

type BaseChildProps = {
    theme: Theme;
    webSocketClient?: WebSocketClient;
}

export default function Pluggable(props: Props): JSX.Element | null {
    const {
        components,
        pluggableId,
        pluggableName,
        subComponentName = '',
        theme,
        ...otherProps
    } = props;

    if (!pluggableName || !Object.hasOwnProperty.call(components, pluggableName)) {
        return null;
    }

    let pluginComponents = components[pluggableName]!;

    if (pluggableId) {
        pluginComponents = pluginComponents.filter(
            (element) => element.id === pluggableId);
    }

    // Override the default component with any registered plugin's component
    // Select a specific component by pluginId if available
    let content;

    if (pluggableName === 'Product') {
        content = (pluginComponents as ProductComponent[]).map((pc) => {
            if (!subComponentName || !pc[subComponentName]) {
                return null;
            }

            const Component = pc[subComponentName]! as React.ComponentType<BaseChildProps>;

            return (
                <PluggableErrorBoundary
                    key={pluggableName + pc.id}
                    pluginId={pc.pluginId}
                >
                    <Component
                        {...otherProps}
                        theme={theme}
                    />
                </PluggableErrorBoundary>
            );
        });
    } else {
        content = pluginComponents.map((p) => {
            if (!p.component) {
                return null;
            }

            const Component = p.component as React.ComponentType<BaseChildProps>;

            return (
                <PluggableErrorBoundary
                    key={pluggableName + p.id}
                    pluginId={p.pluginId}
                >
                    <Component
                        {...otherProps}
                        theme={theme}
                        webSocketClient={webSocketClient}
                    />
                </PluggableErrorBoundary>
            );
        });
    }

    return (
        <React.Fragment>
            {content}
        </React.Fragment>
    );
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getTheme} from 'mattermost-redux/selectors/entities/preferences';

import {GlobalState} from 'types/store';

import Pluggable from './pluggable';

function mapStateToProps(state: GlobalState) {
    return {
        components: state.plugins.components,
        theme: getTheme(state),
    };
}

export default connect(mapStateToProps)(Pluggable);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {intersection, isPlainObject, zipObject} from 'lodash';

/**
 * Transform a function with multiple args into one that receives a normalized args object.
 * @param keyOrder the ordered keys/args for object-normalization and backwards-compatibility
 * @param func the normal method definition that receives the normalized args object
 * @returns func-invoker that supports ordered arguments or a single object argument
 * @remarks it's best to provide a type for {@link TArgs} which enables {@link keyOrder} type checking.
 * @example
 * const wrappedMethod = reArg(['a', 'b', 'c', 'd', 'e', 'f', 'g'], (props: TArgs) => {
 *     // do stuff
 *     const a = props.a;
 *     const {b, c, d, e, f, g: z} = props;
 * });
 * // invoke via:
 * wrappedMethod({a, b, c, d, e, f, g});
 * // or:
 * wrappedMethod(a, b, c, d, e, f, g);
 */
export function reArg<TArgs extends Record<string, unknown>, TResult>(keyOrder: Array<keyof TArgs>, func: (args: TArgs) => TResult) {
    // Ordered-argument typing (`| any[]` bellow) could possibly be improved to support type checking when not invoking with via TArgs
    return (...args: [TArgs] | any[]) => {
        const isConfigObjectArg = args.length === 1 && isPlainObject(args[0]);

        // validate against key-name clashes if arg is an object
        const objKeys = isConfigObjectArg && Object.keys(args[0]);
        const keysMatch = objKeys && intersection(objKeys, keyOrder).length === objKeys.length;

        return func(isConfigObjectArg && keysMatch ? args[0] : zipObject(keyOrder, args));
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {isValidElementType} from 'react-is';
import {Reducer} from 'redux';

import {ProductScope} from '@mattermost/types/products';

import reducerRegistry from 'mattermost-redux/store/reducer_registry';

import {
    registerPluginWebSocketEvent,
    unregisterPluginWebSocketEvent,
    registerPluginReconnectHandler,
    unregisterPluginReconnectHandler,
} from 'actions/websocket_actions.jsx';

import {showRHSPlugin, hideRHSPlugin, toggleRHSPlugin} from 'actions/views/rhs';

import {
    registerPluginTranslationsSource,
    TranslationPluginFunction,
} from 'actions/views/root';

import {
    registerAdminConsolePlugin,
    unregisterAdminConsolePlugin,
    registerAdminConsoleCustomSetting,
} from 'actions/admin_actions';

import store from 'stores/redux_store.jsx';
import {ActionTypes} from 'utils/constants';
import {generateId} from 'utils/utils';
import {PluginComponent, PluginsState, ProductComponent, NeedsTeamComponent} from 'types/store/plugins';
import {GlobalState} from 'types/store';
import {FileInfo} from '@mattermost/types/files';
import {Channel, ChannelMembership} from '@mattermost/types/channels';
import {reArg} from 'utils/func';

const defaultShouldRender = () => true;

type DPluginComponentProp = {component: PluginComponent['component']};
function dispatchPluginComponentAction(name: keyof PluginsState['components'], pluginId: string, component: PluginComponent['component'], id = generateId()) {
    store.dispatch({
        type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
        name,
        data: {
            id,
            pluginId,
            component,
        },
    });

    return id;
}

type ReactResolvable = React.ReactNode | React.ElementType;
const resolveReactElement = (element: ReactResolvable) => {
    if (
        element &&
        !React.isValidElement(element) &&
        isValidElementType(element) &&
        typeof element !== 'string'
    ) {
        // Allow element to be passed as the name of the component, instead of a React element.
        return React.createElement(element);
    }

    return element;
};

const standardizeRoute = (route: string) => {
    let fixedRoute = route.trim();
    if (fixedRoute[0] === '/') {
        fixedRoute = fixedRoute.substring(1);
    }
    return fixedRoute;
};

export default class PluginRegistry {
    id: string;
    constructor(id: string) {
        this.id = id;
    }

    supports = {
        globalAppBar: true,
        globalRhs: true,
    }

    // Register a component at the root of the channel view of the app.
    // Accepts a React component. Returns a unique identifier.
    registerRootComponent = reArg(['component'], ({component}: DPluginComponentProp) => {
        return dispatchPluginComponentAction('Root', this.id, component);
    });

    // Register a component in the user attributes section of the profile popover (hovercard), below the default user attributes.
    // Accepts a React component. Returns a unique identifier.
    registerPopoverUserAttributesComponent = reArg(['component'], ({component}: DPluginComponentProp) => {
        return dispatchPluginComponentAction('PopoverUserAttributes', this.id, component);
    });

    // Register a component in the user actions of the profile popover (hovercard), below the default actions.
    // Accepts a React component. Returns a unique identifier.
    registerPopoverUserActionsComponent = reArg(['component'], ({component}: DPluginComponentProp) => {
        return dispatchPluginComponentAction('PopoverUserActions', this.id, component);
    });

    // Register a component fixed to the top of the left-hand channel sidebar.
    // Accepts a React component. Returns a unique identifier.
    registerLeftSidebarHeaderComponent = reArg(['component'], ({component}: DPluginComponentProp) => {
        return dispatchPluginComponentAction('LeftSidebarHeader', this.id, component);
    });

    // Register a component fixed to the bottom of the team sidebar. Does not render if
    // user is only on one team and the team sidebar is not shown.
    // Accepts a React component. Returns a unique identifier.
    registerBottomTeamSidebarComponent = reArg(['component'], ({component}: DPluginComponentProp) => {
        return dispatchPluginComponentAction('BottomTeamSidebar', this.id, component);
    });

    // Register a component fixed to the bottom of the post message.
    // Accepts a React component. Returns a unique identifier.
    registerPostMessageAttachmentComponent = reArg(['component'], ({component}: DPluginComponentProp) => {
        return dispatchPluginComponentAction('PostMessageAttachment', this.id, component);
    });

    // Register a component to show as a tooltip when a user hovers on a link in a post.
    // Accepts a React component. Returns a unique identifier.
    // The component will be passed the following props:
    // - href - The URL for this link
    // - show - A boolean used to signal that the user is currently hovering over this link. Use this value to initialize your component when this boolean is true for the first time, using `componentDidUpdate` or `useEffect`.
    registerLinkTooltipComponent = reArg(['component'], ({component}: DPluginComponentProp) => {
        return dispatchPluginComponentAction('LinkTooltip', this.id, component);
    });

    // Add a button to the channel header. If there are more than one buttons registered by any
    // plugin, a dropdown menu is created to contain all the plugin buttons.
    // Accepts the following:
    // - icon - React element to use as the button's icon
    // - action - a function called when the button is clicked, passed the channel and channel member as arguments
    // - dropdownText - string or React element shown for the dropdown button description
    // - tooltipText - string or React element shown for tooltip appear on hover
    registerChannelHeaderButtonAction = reArg([
        'icon',
        'action',
        'dropdownText',
        'tooltipText',
    ], ({
        icon,
        action,
        dropdownText,
        tooltipText,
    }: {
        icon: ReactResolvable;
        action: PluginComponent['action'];
        dropdownText: ReactResolvable;
        tooltipText: ReactResolvable;
    }) => {
        const id = generateId();

        const data = {
            id,
            pluginId: this.id,
            icon: resolveReactElement(icon),
            action,
            dropdownText: resolveReactElement(dropdownText),
            tooltipText: resolveReactElement(tooltipText),
        };

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'ChannelHeaderButton',
            data,
        });

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'MobileChannelHeaderButton',
            data,
        });

        return id;
    });

    // Add a button to the channel intro message.
    // Accepts the following:
    // - icon - React element to use as the button's icon
    // - action - a function called when the button is clicked, passed the channel and channel member as arguments
    // - tooltipText - string or React element shown for tooltip appear on hover
    registerChannelIntroButtonAction = reArg([
        'icon',
        'action',
        'tooltipText',
    ], ({
        icon,
        action,
        tooltipText,
    }: {
        icon: ReactResolvable;
        action: PluginComponent['action'];
        tooltipText: ReactResolvable;
    }) => {
        const id = generateId();

        const data = {
            id,
            pluginId: this.id,
            icon: resolveReactElement(icon),
            action,
            tooltipText: resolveReactElement(tooltipText),
        };

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'ChannelIntroButton',
            data,
        });

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'MobileChannelIntroButton',
            data,
        });

        return id;
    });

    // Add a "call button" to the channel header. If there is more than one button registered by any
    // plugin, a dropdown menu is created to contain all the call plugin buttons.
    // Accepts the following:
    // - button - A React element to use as the main button to be displayed in case of a single registration.
    // - dropdownButton -A React element to use as the dropdown button to be displayed in case of multiple registrations.
    // - action - A function called when the button is clicked, passed the channel and channel member as arguments.
    // Returns an unique identifier
    // Minimum required version: 6.5
    registerCallButtonAction = reArg([
        'button',
        'dropdownButton',
        'action',
    ], ({
        button,
        dropdownButton,
        action,
    }: {
        button: ReactResolvable;
        dropdownButton: ReactResolvable;
        action: (currentChannel: Channel, myCurrentChannelMembership: ChannelMembership) => void;
    }) => {
        const id = generateId();

        const data = {
            id,
            pluginId: this.id,
            button: resolveReactElement(button),
            dropdownButton: resolveReactElement(dropdownButton),
            action,
        };

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'CallButton',
            data,
        });

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'MobileChannelHeaderButton',
            data,
        });

        return id;
    });

    // Register a component to render a custom body for posts with a specific type.
    // Custom post types must be prefixed with 'custom_'.
    // Custom post types can also apply for ephemeral posts.
    // Accepts a string type and a component.
    // Returns a unique identifier.
    registerPostTypeComponent = reArg(['type', 'component'], ({type, component}) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_POST_COMPONENT,
            data: {
                id,
                pluginId: this.id,
                type,
                component,
            },
        });

        return id;
    });

    // Register a component to render a custom body for post cards with a specific type.
    // Custom post types must be prefixed with 'custom_'.
    // Accepts a string type and a component.
    // Returns a unique identifier.
    registerPostCardTypeComponent = reArg(['type', 'component'], ({type, component}) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_POST_CARD_COMPONENT,
            data: {
                id,
                pluginId: this.id,
                type,
                component,
            },
        });

        return id;
    });

    // Register a component to render a custom embed preview for post links.
    // Accepts the following:
    // - match - A function that receives the embed object and returns a
    //   boolean indicating if the plugin is able to process it.
    //   The embed object contains the embed `type`, the `url` of the post link
    //   and in some cases, a `data` object with information related to the
    //   link (the opengraph or the image details, for example).
    // - component - The component that renders the embed view for the link
    // - toggleable - A boolean indicating if the embed view should be collapsable
    // Returns a unique identifier.
    registerPostWillRenderEmbedComponent = reArg(['match', 'component', 'toggleable'], ({match, component, toggleable}) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'PostWillRenderEmbedComponent',
            data: {
                id,
                pluginId: this.id,
                component,
                match,
                toggleable,
            },
        });

        return id;
    });

    // Register a main menu list item by providing some text and an action function.
    // Accepts the following:
    // - text - A string or React element to display in the menu
    // - action - A function to trigger when component is clicked on
    // - mobileIcon - A React element to display as the icon in the menu in mobile view
    // Returns a unique identifier.
    registerMainMenuAction = reArg([
        'text',
        'action',
        'mobileIcon',
    ], ({
        text,
        action,
        mobileIcon,
    }: {
        text: ReactResolvable;
        action: PluginComponent['action'];
        mobileIcon: ReactResolvable;
    }) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'MainMenu',
            data: {
                id,
                pluginId: this.id,
                text: resolveReactElement(text),
                action,
                mobileIcon: resolveReactElement(mobileIcon),
            },
        });

        return id;
    });

    // Register a channel menu list item by providing some text and an action function.
    // Accepts the following:
    // - text - A string or React element to display in the menu
    // - action - A function that receives the channelId and is called when the menu items is clicked.
    // - shouldRender - A function that receives the state before the
    // component is about to render, allowing for conditional rendering.
    // Returns a unique identifier.
    registerChannelHeaderMenuAction = reArg([
        'text',
        'action',
        'shouldRender',
    ], ({
        text,
        action,
        shouldRender = defaultShouldRender,
    }: {
        text: ReactResolvable;
        action: PluginComponent['action'];
        shouldRender?: (state: GlobalState) => boolean;
    }) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'ChannelHeader',
            data: {
                id,
                pluginId: this.id,
                text: resolveReactElement(text),
                action,
                shouldRender,
            },
        });

        return id;
    });

    // Register a files dropdown list item by providing some text and an action function.
    // Accepts the following:
    // - match - A function  that receives the fileInfo and returns a boolean indicating if the plugin is able to process it.
    // - text - A string or React element to display in the menu
    // - action - A function that receives the fileInfo and is called when the menu items is clicked.
    // Returns a unique identifier.
    registerFileDropdownMenuAction = reArg([
        'match',
        'text',
        'action',
    ], ({
        match,
        text,
        action,
    }: {
        match: (fileInfo: FileInfo) => boolean;
        text: ReactResolvable;
        action: PluginComponent['action'];
    }) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'FilesDropdown',
            data: {
                id,
                pluginId: this.id,
                match,
                text: resolveReactElement(text),
                action,
            },
        });

        return id;
    });

    // Register a user guide dropdown list item by providing some text and an action function.
    // Accepts the following:
    // - text - A string or React element to display in the menu
    // - action - A function that receives the fileInfo and is called when the menu items is clicked.
    // Returns a unique identifier.
    registerUserGuideDropdownMenuAction = reArg([
        'text',
        'action',
    ], ({
        text,
        action,
    }: {
        text: ReactResolvable;
        action: PluginComponent['action'];
    }) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'UserGuideDropdown',
            data: {
                id,
                pluginId: this.id,
                text: resolveReactElement(text),
                action,
            },
        });

        return id;
    });

    // Register a post menu list item by providing some text and an action function.
    // Accepts the following:
    // - text - A string or React element to display in the menu
    // - action - A function to trigger when component is clicked on
    // - filter - A function whether to apply the plugin into the post' dropdown menu
    // Returns a unique identifier.
    registerPostDropdownMenuAction = reArg([
        'text',
        'action',
        'filter',
    ], ({
        text,
        action,
        filter,
    }: {
        text: ReactResolvable;
        action: PluginComponent['action'];
        filter: PluginComponent['filter'];
    }) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'PostDropdownMenu',
            data: {
                id,
                pluginId: this.id,
                text: resolveReactElement(text),
                action,
                filter,
            },
        });

        return id;
    });

    // Register a post sub menu list item by providing some text and an action function.
    // Accepts the following:
    // - text - A string or React element to display in the menu
    // - action - A function to trigger when component is clicked on
    // - filter - A function whether to apply the plugin into the post' dropdown menu
    //
    // Returns a unique identifier for the root submenu, and a function to register submenu items.
    // At this time, only one level of nesting is allowed to avoid rendering issue in the RHS.
    registerPostDropdownSubMenuAction = reArg([
        'text',
        'action',
        'filter',
    ], ({
        text,
        action,
        filter,
    }: {
        text: ReactResolvable;
        action: PluginComponent['action'];
        filter: PluginComponent['filter'];
    }) => {
        const id = generateId();

        const registerMenuItem = (
            pluginId: string,
            id: string,
            parentMenuId: string | null,
            innerText: ReactResolvable,
            innerAction: PluginComponent['action'],
            innerFilter: PluginComponent['filter'],
        ) => {
            store.dispatch({
                type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
                name: 'PostDropdownMenu',
                data: {
                    id,
                    parentMenuId,
                    pluginId,
                    text: resolveReactElement(innerText),
                    subMenu: [],
                    action: innerAction,
                    filter: innerFilter,
                },
            });

            type TInnerParams = [
                innerText: ReactResolvable,
                innerAction: PluginComponent['action'],
                innerFilter: PluginComponent['filter'],
            ];

            return function registerSubMenuItem(...args: TInnerParams) {
                if (parentMenuId) {
                    throw new Error('Submenus are currently limited to a single level.');
                }

                return registerMenuItem(pluginId, generateId(), id, ...args);
            };
        };

        return {id, rootRegisterMenuItem: registerMenuItem(this.id, id, null, text, action, filter)};
    });

    // Register a component at the bottom of the post dropdown menu.
    // Accepts a React component. Returns a unique identifier.
    registerPostDropdownMenuComponent = reArg(['component'], ({component}: DPluginComponentProp) => {
        return dispatchPluginComponentAction('PostDropdownMenuItem', this.id, component);
    });

    // Register a file upload method by providing some text, an icon, and an action function.
    // Accepts the following:
    // - icon - JSX element to use as the button's icon
    // - text - A string or JSX element to display in the file upload menu
    // - action - A function to trigger when the menu item is selected.
    // Returns a unique identifier.
    registerFileUploadMethod = reArg([
        'icon',
        'action',
        'text',
    ], ({
        icon,
        action,
        text,
    }: {
        icon: ReactResolvable;
        action: PluginComponent['action'];
        text: ReactResolvable;
    }) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'FileUploadMethod',
            data: {
                id,
                pluginId: this.id,
                text,
                action,
                icon,
            },
        });

        return id;
    });

    // Register a hook to intercept file uploads before they take place.
    // Accepts a function to run before files get uploaded. Receives an array of
    // files and a function to upload files at a later time as arguments. Must
    // return an object that can contain two properties:
    // - message - An error message to display, leave blank or null to display no message
    // - files - Modified array of files to upload, set to null to reject all files
    // Returns a unique identifier.
    registerFilesWillUploadHook = reArg(['hook'], ({hook}) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'FilesWillUploadHook',
            data: {
                id,
                pluginId: this.id,
                hook,
            },
        });

        return id;
    });

    // Unregister a component, action or hook using the unique identifier returned after registration.
    // Accepts a string id.
    // Returns undefined in all cases.
    unregisterComponent = reArg(['componentId'], ({componentId}: {componentId: string}) => {
        store.dispatch({
            type: ActionTypes.REMOVED_PLUGIN_COMPONENT,
            id: componentId,
        });
    });

    // Unregister a component that provided a custom body for posts with a specific type.
    // Accepts a string id.
    // Returns undefined in all cases.
    unregisterPostTypeComponent = reArg(['componentId'], ({componentId}: {componentId: string}) => {
        store.dispatch({
            type: ActionTypes.REMOVED_PLUGIN_POST_COMPONENT,
            id: componentId,
        });
    });

    // Register a reducer against the Redux store. It will be accessible in redux state
    // under "state['plugins-<yourpluginid>']"
    // Accepts a reducer. Returns undefined.
    registerReducer = reArg(['reducer'], ({reducer}: {reducer: Reducer}) => {
        reducerRegistry.register('plugins-' + this.id, reducer);
    });

    // Register a handler for WebSocket events.
    // Accepts the following:
    // - event - the event type, can be a regular server event or an event from plugins.
    // Plugin events will have "custom_<pluginid>_" prepended
    // - handler - a function to handle the event, receives the event message as an argument
    // Returns undefined.
    registerWebSocketEventHandler = reArg(['event', 'handler'], ({event, handler}) => {
        registerPluginWebSocketEvent(this.id, event, handler);
    });

    // Unregister a handler for a custom WebSocket event.
    // Accepts a string event type.
    // Returns undefined.
    unregisterWebSocketEventHandler = reArg(['event'], ({event}) => {
        unregisterPluginWebSocketEvent(this.id, event);
    });

    // Register a handler that will be called when the app reconnects to the
    // internet after previously disconnecting.
    // Accepts a function to handle the event. Returns undefined.
    registerReconnectHandler = reArg(['handler'], ({handler}) => {
        registerPluginReconnectHandler(this.id, handler);
    });

    // Unregister a previously registered reconnect handler.
    // Returns undefined.
    unregisterReconnectHandler() {
        unregisterPluginReconnectHandler(this.id);
    }

    // Register a hook that will be called when a message is posted by the user before it
    // is sent to the server. Accepts a function that receives the post as an argument.
    //
    // To reject a post, return an object containing an error such as
    //     {error: {message: 'Rejected'}}
    // To modify or allow the post without modification, return an object containing the post
    // such as
    //     {post: {...}}
    //
    // If the hook function is asynchronous, the message will not be sent to the server
    // until the hook returns.
    registerMessageWillBePostedHook = reArg(['hook'], ({hook}) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'MessageWillBePosted',
            data: {
                id,
                pluginId: this.id,
                hook,
            },
        });

        return id;
    });

    // Register a hook that will be called when a slash command is posted by the user before it
    // is sent to the server. Accepts a function that receives the message (string) and the args
    // (object) as arguments.
    // The args object is:
    //        {
    //            channel_id: channelId,
    //            team_id: teamId,
    //            root_id: rootId,
    //        }
    //
    // To reject a command, return an object containing an error:
    //     {error: {message: 'Rejected'}}
    // To ignore a command, return an empty object (to prevent an error from being displayed):
    //     {}
    // To modify or allow the command without modification, return an object containing the new message
    // and args. It is not likely that you will need to change the args, so return the object that was provided:
    //     {message: {...}, args}
    //
    // If the hook function is asynchronous, the command will not be sent to the server
    // until the hook returns.
    registerSlashCommandWillBePostedHook = reArg(['hook'], ({hook}) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'SlashCommandWillBePosted',
            data: {
                id,
                pluginId: this.id,
                hook,
            },
        });

        return id;
    });

    // Register a hook that will be called before a message is formatted into Markdown.
    // Accepts a function that receives the unmodified post and the message (potentially
    // already modified by other hooks) as arguments. This function must return a string
    // message that will be formatted.
    // Returns a unique identifier.
    registerMessageWillFormatHook = reArg(['hook'], ({hook}) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'MessageWillFormat',
            data: {
                id,
                pluginId: this.id,
                hook,
            },
        });

        return id;
    });

    // Register a component to override file previews. Accepts a function to run before file is
    // previewed and a react component to be rendered as the file preview.
    // - override - A function to check whether preview needs to be overridden. Receives fileInfo and post as arguments.
    // Returns true is preview should be overridden and false otherwise.
    // - component - A react component to display instead of original preview. Receives fileInfo and post as props.
    // Returns a unique identifier.
    // Only one plugin can override a file preview at a time. If two plugins try to override the same file preview, the first plugin will perform the override and the second will not. Plugin precedence is ordered alphabetically by plugin ID.
    registerFilePreviewComponent = reArg(['override', 'component'], ({override, component}) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'FilePreview',
            data: {
                id,
                pluginId: this.id,
                override,
                component,
            },
        });

        return id;
    });

    registerTranslations = reArg(['getTranslationsForLocale'], ({getTranslationsForLocale}: {getTranslationsForLocale: TranslationPluginFunction}) => {
        store.dispatch(registerPluginTranslationsSource(this.id, getTranslationsForLocale));
    });

    // Register a admin console definitions override function
    // Note that this is a low-level interface primarily meant for internal use, and is not subject
    // to semver guarantees. It may change in the future.
    // Accepts the following:
    // - func - A function that recieve the admin console config definitions and return a new
    //          version of it, which is used for build the admin console.
    // Each plugin can register at most one admin console plugin function, with newer registrations
    // replacing older ones.
    registerAdminConsolePlugin = reArg(['func'], ({func}) => {
        store.dispatch(registerAdminConsolePlugin(this.id, func));
    });

    // Register a custom React component to manage the plugin configuration for the given setting key.
    // Accepts the following:
    // - key - A key specified in the settings_schema.settings block of the plugin's manifest.
    // - component - A react component to render in place of the default handling.
    // - options - Object for the following available options to display the setting:
    //     showTitle - Optional boolean that if true the display_name of the setting will be rendered
    // on the left column of the settings page and the registered component will be displayed on the
    // available space in the right column.
    registerAdminConsoleCustomSetting = reArg([
        'key',
        'component',
        'options',
    ], ({
        key,
        component,
        options: {showTitle} = {showTitle: false},
    }: {
        key: string;
        component: PluginComponent['component'];
        options?: {showTitle: boolean};
    }) => {
        store.dispatch(registerAdminConsoleCustomSetting(this.id, key, component, {showTitle}));
    });

    // Unregister a previously registered admin console definition override function.
    // Returns undefined.
    unregisterAdminConsolePlugin() {
        store.dispatch(unregisterAdminConsolePlugin(this.id));
    }

    // Register a Right-Hand Sidebar component by providing a title for the right hand component.
    // Accepts the following:
    // - component - A react component to display in the Right-Hand Sidebar.
    // - title - A string or JSX element to display as a title for the RHS.
    // Returns:
    // - id: a unique identifier
    // - showRHSPlugin: the action to dispatch that will open the RHS.
    // - hideRHSPlugin: the action to dispatch that will close the RHS
    // - toggleRHSPlugin: the action to dispatch that will toggle the RHS
    registerRightHandSidebarComponent = reArg(['component', 'title'], ({component, title}: {component: PluginComponent['component']; title: ReactResolvable}) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'RightHandSidebarComponent',
            data: {
                id,
                pluginId: this.id,
                component,
                title: resolveReactElement(title),
            },
        });

        return {id, showRHSPlugin: showRHSPlugin(id), hideRHSPlugin: hideRHSPlugin(id), toggleRHSPlugin: toggleRHSPlugin(id)};
    });

    // Register a Needs Team component by providing a route past /:team/:pluginId/ to be displayed at.
    // Accepts the following:
    // - route - The route to be displayed at.
    // - component - A react component to display.
    // Returns:
    // - id: a unique identifier
    registerNeedsTeamRoute = reArg([
        'route',
        'component',
    ], ({
        route,
        component,
    }: {
        route: string;
        component: NeedsTeamComponent['component'];
    }) => {
        const id = generateId();
        let fixedRoute = standardizeRoute(route);
        fixedRoute = this.id + '/' + fixedRoute;

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'NeedsTeamComponent',
            data: {
                id,
                pluginId: this.id,
                component,
                route: fixedRoute,
            },
        });

        return id;
    });

    /**
     * Register a component to be displayed at a custom route under /plug/:pluginId
     * Accepts the following:
     * - route - The route to be displayed at.
     * - component - A react component to display.
     * @remarks you must specify a `grid-area` (recommended: `grid-area: center`) for `component` using CSS in order to be placed properly in the root layout
     * @returns a unique identifier
     */
    registerCustomRoute = reArg([
        'route',
        'component',
    ], ({
        route,
        component,
    }: {
        route: string;
        component: PluginComponent['component'];
    }) => {
        const id = generateId();
        let fixedRoute = standardizeRoute(route);
        fixedRoute = this.id + '/' + fixedRoute;

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'CustomRouteComponent',
            data: {
                id,
                pluginId: this.id,
                component,
                route: fixedRoute,
            },
        });

        return id;
    })

    /**
     * INTERNAL: Subject to change without notice.
     * Register a Product, consisting of a global header menu item, mainComponent, and other pluggables.
     * @remarks DANGER: Interferes with historic routes.
     * @see {@link ProductComponent}
     * @returns {string}
     */
    registerProduct = reArg([
        'baseURL',
        'switcherIcon',
        'switcherText',
        'switcherLinkURL',
        'mainComponent',
        'headerCentreComponent',
        'headerRightComponent',
        'showTeamSidebar',
        'showAppBar',
        'wrapped',
    ], ({
        baseURL,
        switcherIcon,
        switcherText,
        switcherLinkURL,
        mainComponent,
        headerCentreComponent = () => null,
        headerRightComponent = () => null,
        showTeamSidebar = false,
        showAppBar = false,
        wrapped = true,
    }: Omit<ProductComponent, 'id' | 'pluginId'>) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'Product',
            data: {
                id,
                pluginId: this.id,
                switcherIcon,
                switcherText: resolveReactElement(switcherText),
                baseURL: '/' + standardizeRoute(baseURL),
                switcherLinkURL: '/' + standardizeRoute(switcherLinkURL),
                mainComponent,
                headerCentreComponent,
                headerRightComponent,
                showTeamSidebar,
                showAppBar,
                wrapped,
            },
        });

        return id;
    });

    // Register a hook that will be called when a message is edited by the user before it
    // is sent to the server. Accepts a function that receives the post as an argument.
    //
    // To reject a post, return an object containing an error such as
    //     {error: {message: 'Rejected'}}
    // To modify or allow the post without modification, return an object containing the post
    // such as
    //     {post: {...}}
    //
    // If the hook function is asynchronous, the message will not be sent to the server
    // until the hook returns.
    registerMessageWillBeUpdatedHook = reArg(['hook'], ({hook}) => {
        const id = generateId();

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'MessageWillBeUpdated',
            data: {
                id,
                pluginId: this.id,
                hook,
            },
        });

        return id;
    });

    // INTERNAL: Subject to change without notice.
    // Register a component to render in the LHS next to a channel's link label.
    // All parameters are required.
    // Returns a unique identifier.
    registerSidebarChannelLinkLabelComponent = reArg(['component'], ({component}: DPluginComponentProp) => {
        return dispatchPluginComponentAction('SidebarChannelLinkLabel', this.id, component);
    });

    // INTERNAL: Subject to change without notice.
    // Register a component to render in channel's center view, in place of a channel toast.
    // All parameters are required.
    // Returns a unique identifier.
    registerChannelToastComponent = reArg(['component'], ({component}: DPluginComponentProp) => {
        return dispatchPluginComponentAction('ChannelToast', this.id, component);
    });

    // INTERNAL: Subject to change without notice.
    // Register a global component at the root of the app that survives across product switches.
    // All parameters are required.
    // Returns a unique identifier.
    registerGlobalComponent = reArg(['component'], ({component}: DPluginComponentProp) => {
        return dispatchPluginComponentAction('Global', this.id, component);
    });

    /**
     * INTERNAL: Subject to change without notice.
     * Add an item to the App Bar.
     * @param {string} iconUrl resolvable URL to use as the button's icon.
     * @param {PluginComponent['action'] | undefined} action called when the button is clicked, passed the channel and channel member as arguments.
     * @param {React.ReactNode} tooltipText string or React element shown for tooltip appear on hover.
     * @param {null | string | Array<null | string>} supportedProductIds specifies one or multiple product identifier(s),
     * identifiers can either be the "real" product uuid, or a product's more commonly accessible plugin id, or '*' to match everything.
     * @param {PluginComponent['component'] | undefined} rhsComponent an optional corresponding RHS component. If provided, its toggler is automatically wired to the action.
     * @param {ReactResolvable | undefined} rhsTitle the corresponding RHS component's title.
     * @returns {string} unique identifier
     */
    registerAppBarComponent = reArg([
        'iconUrl',
        'action',
        'tooltipText',
        'supportedProductIds',
        'rhsComponent',
        'rhsTitle',
    ], ({
        iconUrl,
        action,
        tooltipText,
        supportedProductIds = null,
        rhsComponent,
        rhsTitle,
    }: {
        iconUrl: string;
        tooltipText: ReactResolvable;
        supportedProductIds: ProductScope;
    } & ({
        action: PluginComponent['action'];
        rhsComponent?: never;
        rhsTitle?: never;
    } | {
        action?: never;
        rhsComponent: PluginComponent;
        rhsTitle: ReactResolvable;
    })) => {
        const id = generateId();

        const registeredRhsComponent = rhsComponent && this.registerRightHandSidebarComponent({title: rhsTitle, component: rhsComponent});

        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_COMPONENT,
            name: 'AppBar',
            data: {
                id,
                pluginId: this.id,
                iconUrl,
                tooltipText: resolveReactElement(tooltipText),
                supportedProductIds,
                ...registeredRhsComponent ? {
                    action: () => store.dispatch(registeredRhsComponent.toggleRHSPlugin),
                    rhsComponentId: registeredRhsComponent.id,
                } : {
                    action,
                },
            },
        });

        return registeredRhsComponent ? {id, rhsComponent: registeredRhsComponent} : id;
    });

    // INTERNAL: Subject to change without notice.
    // Register a handler to retrieve stats that will be displayed on the system console
    // Accepts the following:
    // - handler - Func to be called to retrieve the stats from plugin api. It must be type PluginSiteStatsHandler.
    // Returns undefined
    registerSiteStatisticsHandler = reArg(['handler'], ({handler}) => {
        const data = {
            pluginId: this.id,
            handler,
        };
        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_STATS_HANDLER,
            data,
        });
    });

    registerInsightsHandler = reArg(['handler'], ({handler}) => {
        store.dispatch({
            type: ActionTypes.RECEIVED_PLUGIN_INSIGHT,
            data: {
                pluginId: this.id,
                handler,
            },
        });
    });
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {GlobalState} from 'types/store';
import {get} from 'mattermost-redux/selectors/entities/preferences';
import {Preferences} from 'mattermost-redux/constants';
import {getIsMobileView} from 'selectors/views/browser';

export function showActionsDropdownPulsatingDot(state: GlobalState): boolean {
    if (getIsMobileView(state)) {
        return false;
    }
    const actionsMenuTutorialState = get(state, Preferences.CATEGORY_ACTIONS_MENU, Preferences.NAME_ACTIONS_MENU_TUTORIAL_STATE, false);
    const modalAlreadyViewed = actionsMenuTutorialState && JSON.parse(actionsMenuTutorialState)[Preferences.ACTIONS_MENU_VIEWED];
    return !modalAlreadyViewed;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {Invoice, Subscription} from '@mattermost/types/cloud';

import {getConfig} from 'mattermost-redux/selectors/entities/general';
import {getCurrentUser} from 'mattermost-redux/selectors/entities/users';
import {createSelector} from 'reselect';

import {GlobalState} from 'types/store';

export enum InquiryType {
    Technical = 'technical',
    Sales = 'sales',
    Billing = 'billing',
}

export enum TechnicalInquiryIssue {
    AdminConsole = 'admin_console',
    MattermostMessaging = 'mm_messaging',
    DataExport = 'data_export',
    Other = 'other',
}

export enum SalesInquiryIssue {
    AboutPurchasing = 'about_purchasing',
    CancelAccount = 'cancel_account',
    PurchaseNonprofit = 'purchase_nonprofit',
    TrialQuestions = 'trial_questions',
    UpgradeEnterprise = 'upgrade_enterprise',
    SomethingElse = 'something_else',
}

type Issue = SalesInquiryIssue | TechnicalInquiryIssue

export const getCloudContactUsLink: (state: GlobalState) => (inquiry: InquiryType, inquiryIssue?: Issue) => string = createSelector(
    'getCloudContactUsLink',
    getConfig,
    getCurrentUser,
    (config, user) => {
        // cloud/contact-us with query params for name, email and inquiry
        const cwsUrl = config.CWSURL;
        const fullName = `${user.first_name} ${user.last_name}`;
        return (inquiry: InquiryType, inquiryIssue?: Issue) => {
            const inquiryIssueQuery = inquiryIssue ? `&inquiry-issue=${inquiryIssue}` : '';

            return `${cwsUrl}/cloud/contact-us?email=${encodeURIComponent(user.email)}&name=${encodeURIComponent(fullName)}&inquiry=${inquiry}${inquiryIssueQuery}`;
        };
    },
);

export const getCloudDelinquentInvoices = createSelector(
    'getCloudDelinquentInvoices',
    (state: GlobalState) => state.entities.cloud.invoices as Record<string, Invoice>,
    (invoices: Record<string, Invoice>) => {
        if (!invoices) {
            return [];
        }

        return Object.values(invoices || []).filter((invoice) => invoice.status !== 'paid' && invoice.total > 0);
    },
);

export const isCloudDelinquencyGreaterThan90Days = createSelector(
    'isCloudDelinquencyGreaterThan90Days',
    (state: GlobalState) => state.entities.cloud.subscription as Subscription,
    (subscription: Subscription) => {
        if (!subscription || !subscription.delinquent_since) {
            return false;
        }
        const now = new Date();
        const delinquentDate = new Date(subscription.delinquent_since * 1000);
        return (Math.floor((now.getTime() - delinquentDate.getTime()) / (1000 * 60 * 60 * 24)) >= 90);
    },
);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {GlobalState} from 'types/store';

export function getIsLhsOpen(state: GlobalState): boolean {
    return state.views.lhs.isOpen;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {getCurrentTeamId, getTeamByName} from 'mattermost-redux/selectors/entities/teams';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';

import localStorageStore from 'stores/local_storage_store';

import type {GlobalState} from '@mattermost/types/store';

// getLastViewedChannelName combines data from the Redux store and localStorage to return the
// previously selected channel name, returning the default channel if none exists.
//
// See LocalStorageStore for context.
export const getLastViewedChannelName = (state: GlobalState) => {
    const userId = getCurrentUserId(state);
    const teamId = getCurrentTeamId(state);

    return localStorageStore.getPreviousChannelName(userId, teamId);
};

export const getPenultimateViewedChannelName = (state: GlobalState) => {
    const userId = getCurrentUserId(state);
    const teamId = getCurrentTeamId(state);

    return localStorageStore.getPenultimateChannelName(userId, teamId);
};

// getLastViewedChannelNameByTeamName combines data from the Redux store and localStorage to return
// the url to the previously selected channel, returning the path to the default channel if none
// exists.
//
// See LocalStorageStore for context.
export const getLastViewedChannelNameByTeamName = (state: GlobalState, teamName: string) => {
    const userId = getCurrentUserId(state);
    const team = getTeamByName(state, teamName);
    const teamId = team && team.id;

    return localStorageStore.getPreviousChannelName(userId, teamId);
};

export const getLastViewedTypeByTeamName = (state: GlobalState, teamName: string) => {
    const userId = getCurrentUserId(state);
    const team = getTeamByName(state, teamName);
    const teamId = team && team.id;

    return localStorageStore.getPreviousViewedType(userId, teamId);
};

export const getPreviousTeamId = (state: GlobalState) => {
    const userId = getCurrentUserId(state);

    return localStorageStore.getPreviousTeamId(userId);
};

export const getPreviousTeamLastViewedType = (state: GlobalState) => {
    const previousTeamID = getPreviousTeamId(state);
    const userId = getCurrentUserId(state);

    return localStorageStore.getPreviousViewedType(userId, previousTeamID, state);
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {isMobile} from 'utils/utils';

import {createSelector} from 'reselect';

import {makeGetCategory, getBool} from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentUser, isFirstAdmin} from 'mattermost-redux/selectors/entities/users';

import {OnboardingTaskCategory, OnboardingTaskList} from 'components/onboarding_tasks';

import {GlobalState} from 'types/store';

import {RecommendedNextStepsLegacy, Preferences} from 'utils/constants';

const getCategory = makeGetCategory();
export const getABTestPreferences = (() => {
    return (state: GlobalState) => getCategory(state, Preferences.AB_TEST_PREFERENCE_VALUE);
})();

const getFirstChannelNamePref = createSelector(
    'getFirstChannelNamePref',
    getABTestPreferences,
    (preferences) => {
        return preferences.find((pref) => pref.name === RecommendedNextStepsLegacy.CREATE_FIRST_CHANNEL);
    },
);

export function getFirstChannelNameViews(state: GlobalState) {
    return state.views.channelSidebar.firstChannelName;
}

export function getFirstChannelName(state: GlobalState) {
    return getFirstChannelNameViews(state) || getFirstChannelNamePref(state)?.value || '';
}

export function getShowLaunchingWorkspace(state: GlobalState) {
    return state.views.modals.showLaunchingWorkspace;
}

// Legacy nextSteps section used to determine when to hide the onboarding to end users who have already completed/unfinished it
export type StepType = {
    id: string;

    // An array of all roles a user must have in order to see the step e.g. admins are both system_admin and system_user
    // so you would require ['system_admin','system_user'] to match.
    // to show step for all roles, leave the roles array blank.
    // for a step that must be shown only to the first admin, add the first_admin role to that step
    roles: string[];
};

export const Steps: StepType[] = [
    {
        id: RecommendedNextStepsLegacy.COMPLETE_PROFILE,
        roles: [],
    },
    {
        id: RecommendedNextStepsLegacy.TEAM_SETUP,
        roles: ['first_admin'],
    },
    {
        id: RecommendedNextStepsLegacy.NOTIFICATION_SETUP,
        roles: ['system_user'],
    },
    {
        id: RecommendedNextStepsLegacy.PREFERENCES_SETUP,
        roles: ['system_user'],
    },
    {
        id: RecommendedNextStepsLegacy.INVITE_MEMBERS,
        roles: ['system_admin', 'system_user'],
    },
    {
        id: RecommendedNextStepsLegacy.DOWNLOAD_APPS,
        roles: [],
    },
];

// Filter the steps shown by checking if our user has any of the required roles for that step
export function isStepForUser(step: StepType, roles: string): boolean {
    const userRoles = roles?.split(' ');
    return (
        userRoles?.some((role) => step.roles.includes(role)) ||
          step.roles.length === 0
    );
}

const getSteps = createSelector(
    'getSteps',
    (state: GlobalState) => getCurrentUser(state),
    (state: GlobalState) => isFirstAdmin(state),
    (currentUser, firstAdmin) => {
        const roles = firstAdmin ? `first_admin ${currentUser?.roles}` : currentUser?.roles;
        return Steps.filter((step) => isStepForUser(step, roles));
    },
);

// Loop through all Steps. For each step, check that
export const legacyNextStepsNotFinished = createSelector(
    'legacyNextStepsNotFinished',
    (state: GlobalState) => getCategory(state, Preferences.RECOMMENDED_NEXT_STEPS),
    (state: GlobalState) => getCurrentUser(state),
    (state: GlobalState) => isFirstAdmin(state),
    (state: GlobalState) => getSteps(state),
    (stepPreferences, currentUser, firstAdmin, mySteps) => {
        const roles = firstAdmin ? `first_admin ${currentUser?.roles}` : currentUser?.roles;
        const checkPref = (step: StepType) => stepPreferences.some((pref) => (pref.name === step.id && pref.value === 'true') || !isStepForUser(step, roles));
        return !mySteps.every(checkPref);
    },
);

// Loop through all Steps. For each step, check that
export const hasLegacyNextStepsPreferences = createSelector(
    'hasLegacyNextStepsPreferences',
    (state: GlobalState) => getCategory(state, Preferences.RECOMMENDED_NEXT_STEPS),
    (state: GlobalState) => getSteps(state),
    (stepPreferences, mySteps) => {
        const checkPref = (step: StepType) => stepPreferences.some((pref) => (pref.name === step.id));
        return mySteps.some(checkPref);
    },
);

export const getShowTaskListBool = createSelector(
    'getShowTaskListBool',
    (state: GlobalState) => state,
    (state: GlobalState) => getCategory(state, OnboardingTaskCategory),
    (state: GlobalState) => getCategory(state, Preferences.RECOMMENDED_NEXT_STEPS),
    (state, onboardingPreferences, legacyStepsPreferences) => {
        const isMobileView = isMobile();

        // conditions to validate scenario where users (initially first_admins) had already set any of the onboarding task list preferences values.
        // We check wether the preference value exists meaning the onboarding tasks list already started no matter what the state of the process is
        const hasUserStartedOnboardingTaskListProcess = onboardingPreferences?.some((pref) =>
            pref.name === OnboardingTaskList.ONBOARDING_TASK_LIST_SHOW || pref.name === OnboardingTaskList.ONBOARDING_TASK_LIST_OPEN);

        const taskListStatus = getBool(state, OnboardingTaskCategory, OnboardingTaskList.ONBOARDING_TASK_LIST_SHOW);

        if (hasUserStartedOnboardingTaskListProcess) {
            return [(taskListStatus && !isMobileView), false];
        }

        // validate is a new user that must do the first time onboarding by checking that:
        // 1. has not preferences related to the new onboarding task list.
        // 2. has no legacy skip preference
        // 3. has no legacy steps preferences
        // 4. has completed legacy next steps (hide value for recommended_next_steps category set to false)

        // This condition verifies existing users hasn't finished nor skipped legacy next steps or there are still steps not completed
        const hasSkipLegacyStepsPreference = legacyStepsPreferences.some((pref) => (pref.name === RecommendedNextStepsLegacy.SKIP));
        const hideLegacyStepsSetToFalse = legacyStepsPreferences.some((pref) => (pref.name === RecommendedNextStepsLegacy.HIDE && pref.value === 'false'));
        const hasAnyOfTheLegacyStepsPreferences = hasLegacyNextStepsPreferences(state);
        const areFirstUserPrefs = !hasSkipLegacyStepsPreference && hideLegacyStepsSetToFalse && !hasAnyOfTheLegacyStepsPreferences;

        const completelyNewUserForOnboarding = !hasUserStartedOnboardingTaskListProcess && areFirstUserPrefs;

        if (completelyNewUserForOnboarding) {
            return [(!isMobileView), true];
        }

        // If none of the previous conditions matched, then it is an existing user with legacy prefs.
        // To determine if we show the new onboarding task list we need to validate:
        // has not skipped nor completed the legacy steps
        const hasSkippedLegacySteps = legacyStepsPreferences.some((pref) => (pref.name === RecommendedNextStepsLegacy.SKIP && pref.value === 'true'));
        const hasCompletedLegacySteps = legacyStepsPreferences.some((pref) => (pref.name === RecommendedNextStepsLegacy.HIDE && pref.value === 'true'));

        const existingUserHasntFinishedNorSkippedLegacyNextSteps = !hasSkippedLegacySteps && !hasCompletedLegacySteps;

        const showTaskList = existingUserHasntFinishedNorSkippedLegacyNextSteps && !isMobileView;
        const firstTimeOnboarding = existingUserHasntFinishedNorSkippedLegacyNextSteps;

        return [showTaskList, firstTimeOnboarding];
    },
);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {createSelector} from 'reselect';

import {appBarEnabled, getAppBarAppBindings} from 'mattermost-redux/selectors/entities/apps';
import {createShallowSelector} from 'mattermost-redux/utils/helpers';

import {get} from 'mattermost-redux/selectors/entities/preferences';
import {Preferences} from 'mattermost-redux/constants';

import {GlobalState} from 'types/store';

import {AppBinding} from '@mattermost/types/apps';

import {FileDropdownPluginComponent, PluginComponent} from '../types/store/plugins';

export const getFilesDropdownPluginMenuItems = createSelector(
    'getFilesDropdownPluginMenuItems',
    (state: GlobalState) => state.plugins.components.FilesDropdown,
    (components) => {
        return (components || []) as unknown as FileDropdownPluginComponent[];
    },
);

export const getUserGuideDropdownPluginMenuItems = createSelector(
    'getUserGuideDropdownPluginMenuItems',
    (state: GlobalState) => state.plugins.components.UserGuideDropdown,
    (components) => {
        return components;
    },
);

export const getChannelHeaderPluginComponents = createSelector(
    'getChannelHeaderPluginComponents',
    (state: GlobalState) => appBarEnabled(state),
    (state: GlobalState) => state.plugins.components.ChannelHeaderButton,
    (state: GlobalState) => state.plugins.components.AppBar,
    (enabled, channelHeaderComponents = [], appBarComponents = []) => {
        if (!enabled || !appBarComponents.length) {
            return channelHeaderComponents as unknown as PluginComponent[];
        }

        // Remove channel header icons for plugins that have also registered an app bar component
        const appBarPluginIds = appBarComponents.map((appBarComponent) => appBarComponent.pluginId);
        return channelHeaderComponents.filter((channelHeaderComponent) => !appBarPluginIds.includes(channelHeaderComponent.pluginId));
    },
);

const getChannelHeaderMenuPluginComponentsShouldRender = createSelector(
    'getChannelHeaderMenuPluginComponentsShouldRender',
    (state: GlobalState) => state,
    (state: GlobalState) => state.plugins.components.ChannelHeader,
    (state, channelHeaderMenuComponents = []) => {
        return channelHeaderMenuComponents.map((component) => {
            if (typeof component.shouldRender === 'function') {
                return component.shouldRender(state);
            }

            return true;
        });
    },
);

export const getChannelHeaderMenuPluginComponents = createShallowSelector(
    'getChannelHeaderMenuPluginComponents',
    getChannelHeaderMenuPluginComponentsShouldRender,
    (state: GlobalState) => state.plugins.components.ChannelHeader,
    (componentShouldRender = [], channelHeaderMenuComponents = []) => {
        return channelHeaderMenuComponents.filter((component, idx) => componentShouldRender[idx]);
    },
);

export const getChannelIntroPluginComponents = createSelector(
    'getChannelIntroPluginComponents',
    (state: GlobalState) => state.plugins.components.ChannelIntroButton,
    (components = []) => {
        return components;
    },
);

export const getAppBarPluginComponents = createSelector(
    'getAppBarPluginComponents',
    (state: GlobalState) => state.plugins.components.AppBar,
    (components = []) => {
        return components;
    },
);

export const shouldShowAppBar = createSelector(
    'shouldShowAppBar',
    appBarEnabled,
    getAppBarAppBindings,
    getAppBarPluginComponents,
    getChannelHeaderPluginComponents,
    (enabled: boolean, bindings: AppBinding[], appBarComponents: PluginComponent[], channelHeaderComponents) => {
        return enabled && Boolean(bindings.length || appBarComponents.length || channelHeaderComponents.length);
    },
);

export function showNewChannelWithBoardPulsatingDot(state: GlobalState): boolean {
    const pulsatingDotState = get(state, Preferences.APP_BAR, Preferences.NEW_CHANNEL_WITH_BOARD_TOUR_SHOWED, '');
    const showPulsatingDot = pulsatingDotState !== '' && JSON.parse(pulsatingDotState)[Preferences.NEW_CHANNEL_WITH_BOARD_TOUR_SHOWED] === false;
    return showPulsatingDot;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ProductIdentifier} from '@mattermost/types/products';

import {GlobalState} from 'types/store';
import type {ProductComponent} from '../types/store/plugins';

import {getCurrentProduct} from 'utils/products';

export function selectCurrentProduct(state: GlobalState, pathname: string): ProductComponent | null {
    return getCurrentProduct(selectProducts(state), pathname);
}

export function selectCurrentProductId(state: GlobalState, pathname: string): ProductIdentifier {
    return selectCurrentProduct(state, pathname)?.id ?? null;
}

export const selectProducts = (state: GlobalState) => state.plugins.components.Product;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import type {GlobalState} from 'types/store';

export function getNavigationBlocked(state: GlobalState) {
    return state.views.admin.navigationBlock.blocked;
}

export function showNavigationPrompt(state: GlobalState) {
    return state.views.admin.navigationBlock.showNavigationPrompt;
}

export function getOnNavigationConfirmed(state: GlobalState) {
    return state.views.admin.navigationBlock.onNavigationConfirmed;
}

export function getNeedsLoggedInLimitReachedCheck(state: GlobalState): boolean {
    return state.views.admin.needsLoggedInLimitReachedCheck;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import type {GlobalState} from 'types/store';

export function getAnnouncementBarCount(state: GlobalState) {
    return state.views.announcementBar.announcementBarState.announcementBarCount;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {GlobalState} from 'types/store';

export const getLastPostsApiTimeForChannel = (state: GlobalState, channelId: string) => state.views.channel.lastGetPosts[channelId];
export const getToastStatus = (state: GlobalState) => state.views.channel.toastStatus;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {createSelector} from 'reselect';

import {isPlugin} from 'mattermost-redux/utils/marketplace';
import type {MarketplaceApp, MarketplacePlugin} from '@mattermost/types/marketplace';

import {GlobalState} from 'types/store';

export const getPlugins = (state: GlobalState): MarketplacePlugin[] => state.views.marketplace.plugins;

export const getApps = (state: GlobalState): MarketplaceApp[] => state.views.marketplace.apps;

export const getListing = createSelector(
    'getListing',
    getPlugins,
    getApps,
    (plugins, apps) => {
        if (plugins) {
            return (plugins as Array<MarketplacePlugin | MarketplaceApp>).concat(apps);
        }

        return apps;
    },
);

export const getInstalledListing = createSelector(
    'getInstalledListing',
    getListing,
    (listing) => listing.filter((i) => {
        if (isPlugin(i)) {
            return i.installed_version !== '';
        }

        return i.installed;
    }),
);

export const getPlugin = (state: GlobalState, id: string): MarketplacePlugin | undefined =>
    getPlugins(state).find(((p) => p.manifest && p.manifest.id === id));

export const getApp = (state: GlobalState, id: string): MarketplaceApp | undefined =>
    getApps(state).find(((p) => p.manifest && p.manifest.app_id === id));

export const getFilter = (state: GlobalState): string => state.views.marketplace.filter;

export const getInstalling = (state: GlobalState, id: string): boolean => Boolean(state.views.marketplace.installing[id]);

export const getError = (state: GlobalState, id: string): string => state.views.marketplace.errors[id];

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import type {GlobalState} from 'types/store';

export function isModalOpen(state: GlobalState, modalId: string) {
    return Boolean(state.views.modals.modalState[modalId] && state.views.modals.modalState[modalId].open);
}
export function isAnyModalOpen(state: GlobalState) {
    return Boolean(state.views.modals.modalState && findOpenModal(state));
}

function findOpenModal(state: GlobalState) {
    let isOpen = false;
    const modalStateObject = state.views.modals.modalState;
    for (const modal in modalStateObject) {
        if (modal && modalStateObject[modal].open) {
            isOpen = true;
            break;
        }
    }
    return isOpen;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import type {GlobalState} from 'types/store';

export function connectionErrorCount(state: GlobalState) {
    return state.views.system.websocketConnectionErrorCount;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import type {GlobalState} from 'types/store';

export function showPreviewOnCreateComment(state: GlobalState) {
    return state.views.textbox.shouldShowPreviewOnCreateComment;
}

export function showPreviewOnCreatePost(state: GlobalState) {
    return state.views.textbox.shouldShowPreviewOnCreatePost;
}

export function showPreviewOnEditChannelHeaderModal(state: GlobalState) {
    return state.views.textbox.shouldShowPreviewOnEditChannelHeaderModal;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import type {GlobalState} from 'types/store';

export const getSocketStatus = (state: GlobalState) => state.websocket;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {getHistory} from 'utils/browser_history';
import {ErrorPageTypes, StoragePrefixes, LandingPreferenceTypes} from 'utils/constants';
import * as Utils from 'utils/utils';

class BrowserStoreClass {
    private hasCheckedLocalStorage?: boolean;
    private localStorageSupported?: boolean;

    signalLogout() {
        if (this.isLocalStorageSupported()) {
            // PLT-1285 store an identifier in session storage so we can catch if the logout came from this tab on IE11
            const logoutId = Utils.generateId();

            Utils.removePrefixFromLocalStorage(StoragePrefixes.ANNOUNCEMENT);
            Utils.removePrefixFromLocalStorage(StoragePrefixes.DELINQUENCY);

            sessionStorage.setItem(StoragePrefixes.LOGOUT, logoutId);
            localStorage.setItem(StoragePrefixes.LOGOUT, logoutId);
            localStorage.removeItem(StoragePrefixes.LOGOUT);
        }
    }

    isSignallingLogout(logoutId: string) {
        return logoutId === sessionStorage.getItem(StoragePrefixes.LOGOUT);
    }

    signalLogin() {
        if (this.isLocalStorageSupported()) {
            // PLT-1285 store an identifier in session storage so we can catch if the logout came from this tab on IE11
            const loginId = Utils.generateId();

            sessionStorage.setItem(StoragePrefixes.LOGIN, loginId);
            localStorage.setItem(StoragePrefixes.LOGIN, loginId);
            localStorage.removeItem(StoragePrefixes.LOGIN);
        }
    }

    isSignallingLogin(loginId: string) {
        return loginId === sessionStorage.getItem(StoragePrefixes.LOGIN);
    }

    isLocalStorageSupported() {
        if (this.hasCheckedLocalStorage) {
            return this.localStorageSupported;
        }

        this.localStorageSupported = false;

        try {
            localStorage.setItem('__testLocal__', '1');
            if (localStorage.getItem('__testLocal__') === '1') {
                this.localStorageSupported = true;
            }
            localStorage.removeItem('__testLocal__');
        } catch (e) {
            this.localStorageSupported = false;
        }

        try {
            sessionStorage.setItem('__testSession__', '1');
            sessionStorage.removeItem('__testSession__');
        } catch (e) {
            // Session storage not usable, website is unusable
            getHistory().push('/error?type=' + ErrorPageTypes.LOCAL_STORAGE);
        }

        this.hasCheckedLocalStorage = true;

        return this.localStorageSupported;
    }

    hasSeenLandingPage() {
        return localStorage.getItem(StoragePrefixes.LANDING_PAGE_SEEN);
    }

    setLandingPageSeen(landingPageSeen: boolean) {
        localStorage.setItem(StoragePrefixes.LANDING_PAGE_SEEN, String(landingPageSeen));
    }

    getLandingPreference(siteUrl?: string) {
        return localStorage.getItem(StoragePrefixes.LANDING_PREFERENCE + String(siteUrl));
    }

    setLandingPreferenceToMattermostApp(siteUrl?: string) {
        localStorage.setItem(StoragePrefixes.LANDING_PREFERENCE + String(siteUrl), LandingPreferenceTypes.MATTERMOSTAPP);
    }

    setLandingPreferenceToBrowser(siteUrl?: string) {
        localStorage.setItem(StoragePrefixes.LANDING_PREFERENCE + String(siteUrl), LandingPreferenceTypes.BROWSER);
    }

    clearLandingPreference(siteUrl?: string) {
        localStorage.removeItem(StoragePrefixes.LANDING_PREFERENCE + String(siteUrl));
    }
}

const BrowserStore = new BrowserStoreClass();
export default BrowserStore;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {ActionResult} from 'mattermost-redux/types/actions';

export type SuccessResult = {data: any}

export type ErrorResult = {error: any}

export function isSuccess(result: ActionResult): result is SuccessResult {
    return 'data' in result && !isError(result);
}

export function isError(result: ActionResult): result is ErrorResult {
    return Boolean((result as ErrorResult).error);
}

export type ModalData<ModalProps> = {
    modalId: string;
    dialogProps?: Omit<ModalProps, 'onHide' | 'onExited'> & {onHide?: () => void; onExited?: () => void};
    dialogType: React.ElementType<ModalProps>;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {AppCallResponseTypes} from 'mattermost-redux/constants/apps';
import {AppCall, AppCallRequest, AppCallResponse, AppCallValues, AppContext, AppExpand, AppSelectOption} from '@mattermost/types/apps';

export const appsPluginID = 'com.mattermost.apps';

export function createCallContext(
    appID: string,
    location?: string,
    channelID?: string,
    teamID?: string,
    postID?: string,
    rootID?: string,
): AppContext {
    return {
        app_id: appID,
        location,
        channel_id: channelID,
        team_id: teamID,
        post_id: postID,
        root_id: rootID,
    };
}

export function createCallRequest(
    call: AppCall,
    context: AppContext,
    defaultExpand: AppExpand = {},
    values?: AppCallValues,
    rawCommand?: string,
): AppCallRequest {
    return {
        ...call,
        context,
        values,
        expand: {
            ...defaultExpand,
            ...call.expand,
        },
        raw_command: rawCommand,
    };
}

export const makeCallErrorResponse = (errMessage: string): AppCallResponse<any> => {
    return {
        type: AppCallResponseTypes.ERROR,
        text: errMessage,
    };
};

export const filterEmptyOptions = (option: AppSelectOption) => option.value && !option.value.match(/^[ \t]+$/);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {Product, CloudCustomer, Limits} from '@mattermost/types/cloud';
import {trackEvent} from 'actions/telemetry_actions';
import {CloudProducts, CloudLinks} from 'utils/constants';
import {hasSomeLimits} from 'utils/limits';

export function isCustomerCardExpired(customer?: CloudCustomer): boolean {
    if (!customer) {
        return false;
    }

    const expiryYear = customer.payment_method.exp_year;

    // If not expiry year, or its 0, it's not expired (because it probably isn't set)
    if (!expiryYear) {
        return false;
    }

    // This works because we store the expiry month as the actual 1-12 base month, but Date uses a 0-11 base month
    // But credit cards expire at the end of their expiry month, so we can just use that number.
    const lastExpiryDate = new Date(expiryYear, customer.payment_method.exp_month, 1);
    return lastExpiryDate <= new Date();
}

export function openExternalPricingLink() {
    trackEvent('cloud_admin', 'click_pricing_link');
    window.open(CloudLinks.PRICING, '_blank');
}

export function isCloudFreePlan(product: Product | undefined, limits: Limits): boolean {
    return product?.sku === CloudProducts.STARTER && hasSomeLimits(limits);
}

export const FREEMIUM_TO_ENTERPRISE_TRIAL_LENGTH_DAYS = 30;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import moment from 'moment-timezone';

const shouldTruncate = new Map<Intl.RelativeTimeFormatUnit, boolean>([
    ['year', true],
    ['quarter', true],
    ['month', true],
    ['week', true],
    ['day', true],
    ['hour', false],
    ['minute', false],
    ['second', true],
]);

export function isWithin(
    a: Date,
    b: Date,
    timeZone: string = new Intl.DateTimeFormat().resolvedOptions().timeZone,
    unit: Intl.RelativeTimeFormatUnit,
    threshold = 1,
    truncateEndpoints = shouldTruncate.get(unit) || false,
): boolean {
    const diff = getDiff(a, b, timeZone, unit, truncateEndpoints);
    return threshold >= 0 ? diff <= threshold && diff >= 0 : diff >= threshold && diff <= 0;
}

export function isEqual(
    a: Date,
    b: Date,
    timeZone: string = new Intl.DateTimeFormat().resolvedOptions().timeZone,
    unit: Intl.RelativeTimeFormatUnit,
    threshold = 1,
    truncateEndpoints = shouldTruncate.get(unit) || false,
): boolean {
    return threshold === getDiff(a, b, timeZone, unit, truncateEndpoints);
}

export function getDiff(
    a: Date,
    b: Date,
    timeZone: string = new Intl.DateTimeFormat().resolvedOptions().timeZone,
    unit: Intl.RelativeTimeFormatUnit,
    truncateEndpoints = shouldTruncate.get(unit) || false,
): number {
    const momentA = moment.utc(a.getTime());
    const momentB = moment.utc(b.getTime());

    if (timeZone) {
        momentA.tz(timeZone);
        momentB.tz(timeZone);
    }

    return truncateEndpoints ? momentA.startOf(unit).diff(momentB.startOf(unit), unit) : momentA.diff(b, unit, true);
}

export function isSameDay(a: Date, b: Date = new Date()): boolean {
    return a.getDate() === b.getDate() && isSameMonth(a, b);
}

export function isWithinLastWeek(a: Date): boolean {
    return moment(a).isAfter(
        moment().subtract(6, 'days').startOf('day'),
    );
}

export function isSameMonth(a: Date, b: Date = new Date()): boolean {
    return a.getMonth() === b.getMonth() && isSameYear(a, b);
}

export function isSameYear(a: Date, b: Date = new Date()): boolean {
    return a.getFullYear() === b.getFullYear();
}

export function isToday(date: Date): boolean {
    return isSameDay(date);
}

export function isYesterday(date: Date): boolean {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);

    return isSameDay(date, yesterday);
}

export function toUTCUnix(date: Date): number {
    return Math.round(new Date(date.toISOString()).getTime() / 1000);
}


// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

export default class DelayedAction {
    private action: () => void;
    private timer: number;

    public constructor(action: () => void) {
        this.action = action;

        this.timer = -1;

        // bind fire since it doesn't get passed the correct this value with setTimeout
        this.fire = this.fire.bind(this);
    }

    public fire() {
        this.action();

        this.timer = -1;
    }

    public fireAfter(timeout: number) {
        if (this.timer >= 0) {
            window.clearTimeout(this.timer);
        }

        this.timer = window.setTimeout(this.fire, timeout);
    }

    public cancel() {
        window.clearTimeout(this.timer);
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import exif2css from 'exif2css';

import Constants from 'utils/constants';
import * as UserAgent from 'utils/user_agent';
import {ClientConfig} from '@mattermost/types/config';

export const FileSizes = {
    Bit: 1,
    Byte: 1 * 8,
    Kilobyte: 1 * 8 * 1024,
    Megabyte: 1 * 8 * 1024 * 1024,
    Gigabyte: 1 * 8 * 1024 * 1024 * 1024,
};

export function canUploadFiles(config: Partial<ClientConfig>): boolean {
    const enableFileAttachments = config.EnableFileAttachments === 'true';
    const enableMobileFileUpload = config.EnableMobileFileUpload === 'true';

    if (!enableFileAttachments) {
        return false;
    }

    if (UserAgent.isMobileApp()) {
        return enableMobileFileUpload;
    }

    return true;
}

export function isFileAttachmentsEnabled(config: Partial<ClientConfig>): boolean {
    return config.EnableFileAttachments === 'true';
}

export function canDownloadFiles(config: Partial<ClientConfig>): boolean {
    if (UserAgent.isMobileApp()) {
        return config.EnableMobileFileDownload === 'true';
    }

    return true;
}

export function trimFilename(filename: string) {
    let trimmedFilename = filename;
    if (filename.length > Constants.MAX_FILENAME_LENGTH) {
        trimmedFilename = filename.substring(0, Math.min(Constants.MAX_FILENAME_LENGTH, filename.length)) + '...';
    }

    return trimmedFilename;
}

export function getFileTypeFromMime(mimetype: string) {
    const mimeTypeSplitBySlash = mimetype.split('/');
    const mimeTypePrefix = mimeTypeSplitBySlash[0];
    const mimeTypeSuffix = mimeTypeSplitBySlash[1];

    if (mimeTypePrefix === 'video') {
        return 'video';
    } else if (mimeTypePrefix === 'audio') {
        return 'audio';
    } else if (mimeTypePrefix === 'image') {
        return 'image';
    }

    if (mimeTypeSuffix) {
        if (mimeTypeSuffix === 'pdf') {
            return 'pdf';
        } else if (mimeTypeSuffix.includes('vnd.ms-excel') || mimeTypeSuffix.includes('spreadsheetml') || mimeTypeSuffix.includes('vnd.sun.xml.calc') || mimeTypeSuffix.includes('opendocument.spreadsheet')) {
            return 'spreadsheet';
        } else if (mimeTypeSuffix.includes('vnd.ms-powerpoint') || mimeTypeSuffix.includes('presentationml') || mimeTypeSuffix.includes('vnd.sun.xml.impress') || mimeTypeSuffix.includes('opendocument.presentation')) {
            return 'presentation';
        } else if ((mimeTypeSuffix === 'msword') || mimeTypeSuffix.includes('vnd.ms-word') || mimeTypeSuffix.includes('officedocument.wordprocessingml') || mimeTypeSuffix.includes('application/x-mswrite')) {
            return 'word';
        }
    }

    return 'other';
}

// based on https://stackoverflow.com/questions/7584794/accessing-jpeg-exif-rotation-data-in-javascript-on-the-client-side/32490603#32490603
export function getExifOrientation(data: ArrayBufferLike) {
    const view = new DataView(data);

    if (view.getUint16(0, false) !== 0xFFD8) {
        return -2;
    }

    const length = view.byteLength;
    let offset = 2;

    while (offset < length) {
        const marker = view.getUint16(offset, false);
        offset += 2;

        if (marker === 0xFFE1) {
            if (view.getUint32(offset += 2, false) !== 0x45786966) {
                return -1;
            }

            const little = view.getUint16(offset += 6, false) === 0x4949;
            offset += view.getUint32(offset + 4, little);
            const tags = view.getUint16(offset, little);
            offset += 2;

            for (let i = 0; i < tags; i++) {
                if (view.getUint16(offset + (i * 12), little) === 0x0112) {
                    return view.getUint16(offset + (i * 12) + 8, little);
                }
            }
        } else if ((marker & 0xFF00) === 0xFF00) {
            offset += view.getUint16(offset, false);
        } else {
            break;
        }
    }
    return -1;
}

export function getOrientationStyles(orientation: number) {
    const {
        transform,
        'transform-origin': transformOrigin,
    } = exif2css(orientation);
    return {transform, transformOrigin};
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import moment from 'moment';

import {ClientLicense} from '@mattermost/types/config';

import {LicenseSkus} from 'utils/constants';

const LICENSE_EXPIRY_NOTIFICATION = 1000 * 60 * 60 * 24 * 60; // 60 days
const LICENSE_GRACE_PERIOD = 1000 * 60 * 60 * 24 * 10; // 10 days

export function isLicenseExpiring(license: ClientLicense) {
    // Skip license expiration checks for cloud licenses
    if (license.IsLicensed !== 'true' || isCloudLicense(license)) {
        return false;
    }

    if (license.IsTrial === 'true') {
        return true;
    }

    const timeDiff = parseInt(license.ExpiresAt, 10) - Date.now();
    return timeDiff <= LICENSE_EXPIRY_NOTIFICATION;
}

export function daysToLicenseExpire(license: ClientLicense) {
    if (license.IsLicensed !== 'true' || isCloudLicense(license)) {
        return undefined;
    }

    const endDate = new Date(parseInt(license?.ExpiresAt, 10));
    return moment(endDate).startOf('day').diff(moment().startOf('day'), 'days');
}

export function isLicenseExpired(license: ClientLicense) {
    if (license.IsLicensed !== 'true' || isCloudLicense(license)) {
        return false;
    }

    const endDate = new Date(parseInt(license?.ExpiresAt, 10));
    const timeDiff = moment(endDate).startOf('day').diff(moment().startOf('day'), 'days');
    return timeDiff < 0;
}

export function isLicensePastGracePeriod(license: ClientLicense) {
    if (license.IsLicensed !== 'true' || isCloudLicense(license)) {
        return false;
    }

    const timeDiff = Date.now() - parseInt(license.ExpiresAt, 10);
    return timeDiff > LICENSE_GRACE_PERIOD;
}

export function isTrialLicense(license: ClientLicense) {
    if (license.IsLicensed !== 'true') {
        return false;
    }

    if (license.IsTrial === 'true') {
        return true;
    }

    // Currently all trial licenses are issued with a 30 day, 8 hours duration.
    // We're using this logic to detect a trial license until we add the right field in the license itself.
    const timeDiff = parseInt(license.ExpiresAt, 10) - parseInt(license.StartsAt, 10);

    // 30 days + 8 hours
    const trialLicenseDuration = (1000 * 60 * 60 * 24 * 30) + (1000 * 60 * 60 * 8);

    return timeDiff === trialLicenseDuration;
}

export function isCloudLicense(license: ClientLicense) {
    return license?.Cloud === 'true';
}

export function getIsStarterLicense(license: ClientLicense) {
    return license?.SkuShortName === LicenseSkus.Starter;
}

export function isEnterpriseOrE20License(license: ClientLicense) {
    return license?.SkuShortName === LicenseSkus.Enterprise || license?.SkuShortName === LicenseSkus.E20;
}

export const isEnterpriseLicense = (license?: ClientLicense) => {
    switch (license?.SkuShortName) {
    case LicenseSkus.Enterprise:
    case LicenseSkus.E20:
        return true;
    }

    return false;
};

export const isNonEnterpriseLicense = (license?: ClientLicense) => !isEnterpriseLicense(license);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {FormatNumberOptions} from 'react-intl';

import {CloudUsage, Limits} from '@mattermost/types/cloud';

import {FileSizes} from './file_utils';

export function asGBString(bits: number, formatNumber: (b: number, options: FormatNumberOptions) => string): string {
    return `${formatNumber(bits / FileSizes.Gigabyte, {maximumFractionDigits: 1})}GB`;
}

export function inK(num: number): string {
    return `${Math.floor(num / 1000)}K`;
}

// usage percent meaning 0-100 (for use in usage bar)
export function toUsagePercent(usage: number, limit: number): number {
    return Math.floor((usage / limit) * 100);
}

// These are to be used when we need values
// even if network requests are failing for some reason.
// Use as a fallback.
export const fallbackStarterLimits = {
    messages: {
        history: 10000,
    },
    files: {
        totalStorage: FileSizes.Gigabyte * 10,
    },
    teams: {
        active: 1,
    },
    boards: {
        cards: 500,
        views: 5,
    },
};

// These are to be used when we need values
// even if network requests are failing for some reason.
// Use as a fallback.
export const fallbackProfessionalLimits = {
    files: {
        totalStorage: FileSizes.Gigabyte * 250,
    },
};

// A positive usage value means they are over the limit. This function simply tells you whether ANY LIMIT has been reached/surpassed.
export function anyUsageDeltaExceededLimit(deltas: CloudUsage) {
    let foundAPositive = false;

    // JSON.parse recursively moves through the object tree, passing the key and value post transformation
    // We can use the `reviver` argument to see if any of those arguments are numbers, and negative.
    JSON.parse(JSON.stringify(deltas), (key, value) => {
        if (typeof value === 'number' && value > 0) {
            foundAPositive = true;
        }
    });
    return foundAPositive;
}

export function hasSomeLimits(limits: Limits): boolean {
    return Object.keys(limits).length > 0;
}

export const limitThresholds = Object.freeze({
    ok: 0,
    warn: 50,
    danger: 66,
    reached: 100,
    exceeded: 100.000001,
});

export const LimitTypes = {
    messageHistory: 'messageHistory',
    fileStorage: 'fileStorage',
    boardsCards: 'boardsCards',
} as const;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

export type MarkdownMode = 'bold' | 'italic' | 'link' | 'strike' | 'code' | 'heading' | 'quote' | 'ul' | 'ol'

export type ApplyMarkdownOptions = {
    markdownMode: MarkdownMode;
    selectionStart: number | null;
    selectionEnd: number | null;
    message: string;
}

type ApplyMarkdownReturnValue = {
    selectionStart: number;
    selectionEnd: number;
    message: string;
}

type ApplySpecificMarkdownOptions = ApplyMarkdownReturnValue & {
    delimiter?: string;
}

export function applyMarkdown(options: ApplyMarkdownOptions): ApplyMarkdownReturnValue {
    const {selectionEnd, selectionStart, message, markdownMode} = options;

    if (selectionStart === null || selectionEnd === null) {
        /**
         * in case we do not get the selectionStart or selectionEnd values
         * from the textbox we simply set it to be at the end of the message
         * string and return the message without changing it.
         *
         * This should never happen, so this just serves as an insurance fallback for very strange browser-bugs!
         */
        return {
            message,
            selectionStart: message.length,
            selectionEnd: message.length,
        };
    }

    let delimiter: string;

    /**
     * all options that need to be handled in a ver specific way have their own applyMarkdown (sub-)functions.
     * The rest just define their delimiters and return the basic applyMarkdownToSelection function.
     *
     * In a strange case where nothing works we throw an error.
     */
    switch (markdownMode) {
    case 'bold':
        return applyBoldMarkdown({selectionEnd, selectionStart, message});
    case 'italic':
        return applyItalicMarkdown({selectionEnd, selectionStart, message});
    case 'link':
        return applyLinkMarkdown({selectionEnd, selectionStart, message});
    case 'ol':
        return applyOlMarkdown({selectionEnd, selectionStart, message});
    case 'ul':
        delimiter = '- ';
        return applyMarkdownToSelectedLines({selectionEnd, selectionStart, message, delimiter});
    case 'heading':
        delimiter = '### ';
        return applyMarkdownToSelectedLines({selectionEnd, selectionStart, message, delimiter});
    case 'quote':
        delimiter = '> ';
        return applyMarkdownToSelectedLines({selectionEnd, selectionStart, message, delimiter});
    case 'strike':
        delimiter = '~~';
        return applyMarkdownToSelection({selectionEnd, selectionStart, message, delimiter});
    case 'code':
        delimiter = '```';
        return applyMarkdownToSelection({selectionEnd, selectionStart, message, delimiter});
    }

    throw Error('Unsupported markdown mode: ' + markdownMode);
}

const getMultilineSuffix = (suffix: string): string => {
    if (suffix.startsWith('\n')) {
        return '';
    }

    return suffix.indexOf('\n') === -1 ? suffix : suffix.slice(0, suffix.indexOf('\n'));
};

const getNewSuffix = (suffix: string): string => {
    if (suffix.startsWith('\n')) {
        return suffix;
    }

    return suffix.indexOf('\n') === -1 ? '' : suffix.slice(suffix.indexOf('\n'));
};

const applyOlMarkdown = ({selectionEnd, selectionStart, message}: ApplySpecificMarkdownOptions) => {
    const prefix = message.slice(0, selectionStart);
    const selection = message.slice(selectionStart, selectionEnd);
    const suffix = message.slice(selectionEnd);

    const newPrefix = prefix.includes('\n') ? prefix.slice(0, prefix.lastIndexOf('\n')) : '';

    const multilineSuffix = getMultilineSuffix(suffix);
    const newSuffix = getNewSuffix(suffix);

    const delimiterLength = 3;
    const getDelimiter = (num?: number) => {
        getDelimiter.counter = num || getDelimiter.counter;
        return `${getDelimiter.counter++}. `;
    };
    getDelimiter.counter = 1;

    const multilinePrefix = prefix.includes('\n') ? prefix.slice(prefix.lastIndexOf('\n')) : prefix;
    let multilineSelection = multilinePrefix + selection + multilineSuffix;
    const isFirstLineSelected = !multilineSelection.startsWith('\n');

    if (selection.startsWith('\n')) {
        multilineSelection = prefix + selection + multilineSuffix;
    }

    const getHasCurrentMarkdown = (): boolean => {
        const linesQuantity = (multilineSelection.match(/\n/g) || []).length;
        const newLinesWithDelimitersQuantity = (multilineSelection.match(/\n\d\. /g) || []).length;

        if (newLinesWithDelimitersQuantity === linesQuantity && !isFirstLineSelected) {
            return true;
        }

        return linesQuantity === newLinesWithDelimitersQuantity && (/^\d\. /).test(multilineSelection);
    };

    let newValue: string;
    let newStart: number;
    let newEnd: number;

    if (getHasCurrentMarkdown()) {
        // clear first line from delimiter
        if (isFirstLineSelected) {
            multilineSelection = multilineSelection.slice(delimiterLength);
        }

        newValue = newPrefix + multilineSelection.replace(/\n\d\. /g, '\n') + newSuffix;
        let count = 0;

        if (isFirstLineSelected) {
            count++;
        }
        count += (multilineSelection.match(/\n/g) || []).length;

        newStart = Math.max(selectionStart - delimiterLength, 0);
        newEnd = Math.max(selectionEnd - (delimiterLength * count), 0);
    } else {
        let count = 0;
        if (isFirstLineSelected) {
            multilineSelection = getDelimiter() + multilineSelection;
            count++;
        }
        const selectionArr = Array.from(multilineSelection);
        for (let i = 0; i < selectionArr.length; i++) {
            if (selectionArr[i] === '\n') {
                selectionArr[i] = `\n${getDelimiter()}`;
            }
        }
        multilineSelection = selectionArr.join('');
        newValue = newPrefix + multilineSelection + newSuffix;

        count += (multilineSelection.match(new RegExp('\\n', 'g')) || []).length;

        newStart = selectionStart + delimiterLength;
        newEnd = selectionEnd + (delimiterLength * count);
    }

    return {
        message: newValue,
        selectionStart: newStart,
        selectionEnd: newEnd,
    };
};

export const applyMarkdownToSelectedLines = ({
    selectionEnd,
    selectionStart,
    message,
    delimiter,
}: ApplySpecificMarkdownOptions) => {
    if (!delimiter) {
        /**
         * in case no delimiter is set return the values without changing anything
         */
        return {
            message,
            selectionStart,
            selectionEnd,
        };
    }

    const prefix = message.slice(0, selectionStart);
    const selection = message.slice(selectionStart, selectionEnd);
    const suffix = message.slice(selectionEnd);

    const newPrefix = prefix.includes('\n') ? prefix.slice(0, prefix.lastIndexOf('\n')) : '';
    const multilinePrefix = prefix.includes('\n') ? prefix.slice(prefix.lastIndexOf('\n')) : prefix;

    const multilineSuffix = getMultilineSuffix(suffix);
    const newSuffix = getNewSuffix(suffix);
    let multilineSelection: string = multilinePrefix + selection + multilineSuffix;

    const isFirstLineSelected = !multilineSelection.startsWith('\n');

    if (selection.startsWith('\n')) {
        multilineSelection = prefix + selection + multilineSuffix;
    }

    const getHasCurrentMarkdown = (): boolean => {
        const linesQuantity = (multilineSelection.match(/\n/g) || []).length;
        const newLinesWithDelimitersQuantity = (multilineSelection.match(new RegExp(`\n${delimiter}`, 'g')) || []).
            length;

        if (newLinesWithDelimitersQuantity === linesQuantity && !isFirstLineSelected) {
            return true;
        }

        return linesQuantity === newLinesWithDelimitersQuantity && multilineSelection.startsWith(delimiter);
    };

    let newValue: string;
    let newStart: number;
    let newEnd: number;

    if (getHasCurrentMarkdown()) {
        // clear first line from delimiter
        if (isFirstLineSelected) {
            multilineSelection = multilineSelection.slice(delimiter.length);
        }

        newValue = newPrefix + multilineSelection.replace(new RegExp(`\n${delimiter}`, 'g'), '\n') + newSuffix;
        let count = 0;
        if (isFirstLineSelected) {
            count++;
        }
        count += (multilineSelection.match(/\n/g) || []).length;

        newStart = Math.max(selectionStart - delimiter.length, 0);
        newEnd = Math.max(selectionEnd - (delimiter.length * count), 0);
    } else {
        newValue = newPrefix + multilineSelection.replace(/\n/g, `\n${delimiter}`) + newSuffix;
        let count = 0;
        if (isFirstLineSelected) {
            newValue = delimiter + newValue;
            count++;
        }

        count += (multilineSelection.match(new RegExp('\\n', 'g')) || []).length;

        newStart = selectionStart + delimiter.length;
        newEnd = selectionEnd + (delimiter.length * count);
    }

    return {
        message: newValue,
        selectionStart: newStart,
        selectionEnd: newEnd,
    };
};

const applyMarkdownToSelection = ({
    selectionEnd,
    selectionStart,
    message,
    delimiter,
}: ApplySpecificMarkdownOptions) => {
    if (!delimiter) {
        /**
         * in case no delimiter is set return the values without changing anything
         */
        return {
            message,
            selectionStart,
            selectionEnd,
        };
    }

    // the part of the message that comes before the selection
    let prefix = message.slice(0, selectionStart);

    // the selected part of the message where the markdown needs to be added/removed
    let selection = message.slice(selectionStart, selectionEnd);

    // the part of the message that comes after the selection
    let suffix = message.slice(selectionEnd);

    // Does the selection have current hotkey's markdown?
    const hasCurrentMarkdown = prefix.endsWith(delimiter) && suffix.startsWith(delimiter);

    let newValue: string;
    let newStart = selectionStart;
    let newEnd = selectionEnd;

    if (selection.endsWith(' ')) {
        selection = selection.slice(0, -1);
        suffix = ` ${suffix}`;
        newEnd -= 1;
    }

    if (selection.startsWith(' ')) {
        selection = selection.slice(1);
        prefix = `${prefix} `;
        newStart += 1;
    }

    if (hasCurrentMarkdown) {
        // selection already has the markdown, so we remove it here
        newValue = prefix.slice(0, prefix.length - delimiter.length) + selection + suffix.slice(delimiter.length);
        newStart -= delimiter.length;
        newEnd -= delimiter.length;
    } else {
        // add markdown to the selection
        newValue = prefix + delimiter + selection + delimiter + suffix;
        newStart += delimiter.length;
        newEnd += delimiter.length;
    }

    return {
        message: newValue,
        selectionStart: newStart,
        selectionEnd: newEnd,
    };
};

function applyBoldMarkdown(options: ApplySpecificMarkdownOptions) {
    return applyBoldItalicMarkdown({...options, markdownMode: 'bold'});
}

function applyItalicMarkdown(options: ApplySpecificMarkdownOptions) {
    return applyBoldItalicMarkdown({...options, markdownMode: 'italic'});
}

function applyBoldItalicMarkdown({selectionEnd, selectionStart, message, markdownMode}: ApplySpecificMarkdownOptions & Pick<ApplyMarkdownOptions, 'markdownMode'>) {
    const BOLD_MD = '**';
    const ITALIC_MD = '*';

    const isForceItalic = markdownMode === 'italic';
    const isForceBold = markdownMode === 'bold';

    let prefix = message.slice(0, selectionStart);
    let selection = message.slice(selectionStart, selectionEnd);
    let suffix = message.slice(selectionEnd);

    let newValue: string;
    let newStart = selectionStart;
    let newEnd = selectionEnd;

    if (selection.endsWith(' ')) {
        selection = selection.slice(0, -1);
        suffix = ` ${suffix}`;
        newEnd -= 1;
    }

    if (selection.startsWith(' ')) {
        selection = selection.slice(1);
        prefix = `${prefix} `;
        newStart += 1;
    }

    // Is it italic hot key on existing bold markdown? i.e. italic on **haha**
    let isItalicFollowedByBold = false;
    let delimiter = '';

    if (isForceBold) {
        delimiter = BOLD_MD;
    } else if (isForceItalic) {
        delimiter = ITALIC_MD;
        isItalicFollowedByBold = prefix.endsWith(BOLD_MD) && suffix.startsWith(BOLD_MD);
    }

    // Does the selection have current hotkey's markdown?
    const hasCurrentMarkdown = prefix.endsWith(delimiter) && suffix.startsWith(delimiter);

    // Does current selection have both of the markdown around it? i.e. ***haha***
    const hasItalicAndBold = prefix.endsWith(BOLD_MD + ITALIC_MD) && suffix.startsWith(BOLD_MD + ITALIC_MD);

    if (hasItalicAndBold || (hasCurrentMarkdown && !isItalicFollowedByBold)) {
        // message already has the markdown; remove it
        newValue = prefix.slice(0, prefix.length - delimiter.length) + selection + suffix.slice(delimiter.length);
        newStart -= delimiter.length;
        newEnd -= delimiter.length;
    } else {
        // Add italic or bold markdown
        newValue = prefix + delimiter + selection + delimiter + suffix;
        newStart += delimiter.length;
        newEnd += delimiter.length;
    }

    return {
        message: newValue,
        selectionStart: newStart,
        selectionEnd: newEnd,
    };
}

function applyLinkMarkdown({selectionEnd, selectionStart, message}: ApplySpecificMarkdownOptions) {
    // <prefix> <selection> <suffix>
    const prefix = message.slice(0, selectionStart);
    const selection = message.slice(selectionStart, selectionEnd);
    const suffix = message.slice(selectionEnd);

    const delimiterStart = '[';
    const delimiterEnd = '](url)';

    // Does the selection have link markdown?
    const hasMarkdown = prefix.endsWith(delimiterStart) && suffix.startsWith(delimiterEnd);

    let newValue: string;
    let newStart: number;
    let newEnd: number;

    // When url is to be selected in [...](url), selection cursors need to shift by this much.
    const urlShift = delimiterStart.length + 2; // ']'.length + ']('.length
    if (hasMarkdown) {
        // message already has the markdown; remove it
        newValue =
            prefix.slice(0, prefix.length - delimiterStart.length) +
            selection +
            suffix.slice(delimiterEnd.length);
        newStart = selectionStart - delimiterStart.length;
        newEnd = selectionEnd - delimiterStart.length;
    } else if (message.length === 0) {
        // no input; Add [|](url)
        newValue = delimiterStart + delimiterEnd;
        newStart = delimiterStart.length;
        newEnd = delimiterStart.length;
    } else if (selectionStart < selectionEnd) {
        // there is something selected; put markdown around it and preserve selection
        newValue = prefix + delimiterStart + selection + delimiterEnd + suffix;
        newStart = selectionEnd + urlShift;
        newEnd = newStart + urlShift;
    } else {
        // nothing is selected
        const spaceBefore = prefix.charAt(prefix.length - 1) === ' ';
        const spaceAfter = suffix.charAt(0) === ' ';
        const cursorBeforeWord =
            (selectionStart !== 0 && spaceBefore && !spaceAfter) || (selectionStart === 0 && !spaceAfter);
        const cursorAfterWord =
            (selectionEnd !== message.length && spaceAfter && !spaceBefore) ||
            (selectionEnd === message.length && !spaceBefore);

        if (cursorBeforeWord) {
            // cursor before a word
            const word = message.slice(selectionStart, findWordEnd(message, selectionStart));

            newValue = prefix + delimiterStart + word + delimiterEnd + suffix.slice(word.length);
            newStart = selectionStart + word.length + urlShift;
            newEnd = newStart + urlShift;
        } else if (cursorAfterWord) {
            // cursor after a word
            const cursorAtEndOfLine = selectionStart === selectionEnd && selectionEnd === message.length;
            if (cursorAtEndOfLine) {
                // cursor at end of line
                newValue = message + ' ' + delimiterStart + delimiterEnd;
                newStart = selectionEnd + 1 + delimiterStart.length;
                newEnd = newStart;
            } else {
                // cursor not at end of line
                const word = message.slice(findWordStart(message, selectionStart), selectionStart);

                newValue =
                    prefix.slice(0, prefix.length - word.length) + delimiterStart + word + delimiterEnd + suffix;
                newStart = selectionStart + urlShift;
                newEnd = newStart + urlShift;
            }
        } else {
            // cursor is in between a word
            const wordStart = findWordStart(message, selectionStart);
            const wordEnd = findWordEnd(message, selectionStart);
            const word = message.slice(wordStart, wordEnd);

            newValue = prefix.slice(0, wordStart) + delimiterStart + word + delimiterEnd + message.slice(wordEnd);
            newStart = wordEnd + urlShift;
            newEnd = newStart + urlShift;
        }
    }

    return {
        message: newValue,
        selectionStart: newStart,
        selectionEnd: newEnd,
    };
}

function findWordEnd(text: string, start: number) {
    const wordEnd = text.indexOf(' ', start);
    return wordEnd === -1 ? text.length : wordEnd;
}

function findWordStart(text: string, start: number) {
    const wordStart = text.lastIndexOf(' ', start - 1) + 1;
    return wordStart === -1 ? 0 : wordStart;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect} from 'react';
import {useDispatch, useSelector} from 'react-redux';
import {useIntl} from 'react-intl';
import {useHistory} from 'react-router-dom';

import styled from 'styled-components';

import {getCurrentChannel} from 'mattermost-redux/selectors/entities/channels';

import {getUsers, getUserStatuses} from 'mattermost-redux/selectors/entities/users';
import {displayUsername} from 'mattermost-redux/utils/user_utils';
import {getTeammateNameDisplaySetting} from 'mattermost-redux/selectors/entities/preferences';
import {getCurrentRelativeTeamUrl} from 'mattermost-redux/selectors/entities/teams';
import {openDirectChannelToUserId} from 'actions/channel_actions';
import {isModalOpen} from 'selectors/views/modals';
import {closeModal} from 'actions/views/modals';
import {getMissingProfilesByIds} from 'mattermost-redux/actions/users';

import {GlobalState} from 'types/store';

import {mapFeatureIdToTranslation} from 'utils/notify_admin_utils';
import {ModalIdentifiers} from 'utils/constants';

import {ListItemType} from 'components/channel_members_rhs/channel_members_rhs';
import GenericModal from 'components/generic_modal';

import MemberList from '../channel_members_rhs/member_list';
import {ChannelMembership} from '@mattermost/types/channels';
import {UserProfile} from '@mattermost/types/users';

import './notification_from_members_modal.scss';

type Props = {
    feature: string;
    userIds: string[];
}

export interface ChannelMember {
    user: UserProfile;
    membership?: ChannelMembership;
    status?: string;
    displayName: string;
}

export interface ListItem {
    type: ListItemType;
    data: ChannelMember | JSX.Element;
}

const MembersContainer = styled.div`
    flex: 1 1 auto;
    padding: 0 4px 16px;
    min-height: 500px;
    height: auto;
    width: 100%;
    overflow: auto;
`;

const unknownUser: UserProfile = {id: 'unknown', username: 'unknown'} as UserProfile;

function NotificationFromMembersModal(props: Props) {
    const dispatch = useDispatch();
    const history = useHistory();
    const {formatMessage} = useIntl();

    useEffect(() => {
        dispatch(getMissingProfilesByIds(props.userIds));
    }, [dispatch, props.userIds]);

    const channel = useSelector(getCurrentChannel);
    const teamUrl = useSelector(getCurrentRelativeTeamUrl);
    const userProfiles = useSelector(getUsers);
    const userStatuses = useSelector(getUserStatuses);
    const displaySetting = useSelector(getTeammateNameDisplaySetting);
    const show = useSelector((state: GlobalState) => isModalOpen(state, ModalIdentifiers.SUM_OF_MEMBERS_MODAL));

    const members: ListItem[] = props.userIds.map((userId: string) => {
        const user = userProfiles[userId];
        const status = userStatuses[userId];
        const displayName = displayUsername(user, displaySetting);
        return {
            type: ListItemType.Member,
            data: {
                user: user || unknownUser,
                displayName,
                status,
            },
        };
    });

    const openDirectMessage = async (user: UserProfile) => {
        // we first prepare the DM channel...
        await dispatch(openDirectChannelToUserId(user.id));

        // ... and then redirect to it
        history.push(teamUrl + '/messages/@' + user.username);
    };

    const handleOnClose = () => {
        dispatch(closeModal(ModalIdentifiers.SUM_OF_MEMBERS_MODAL));
    };

    const loadMore = () => {};

    if (!show) {
        return null;
    }

    const modalTitle = formatMessage({id: 'postypes.custom_open_pricing_modal_post_renderer.membersThatRequested', defaultMessage: 'Members that requested '});

    const modalHeaderText = (<h1 id='invitation_modal_title'>
        {`${modalTitle}${mapFeatureIdToTranslation(props.feature, formatMessage)}`}
    </h1>);

    return (
        <GenericModal
            id='notificationFromMembersModal'
            className='NotificationFromMembersModal'
            backdrop={true}
            show={show}
            onExited={handleOnClose}
            aria-modal='true'
            modalHeaderText={modalHeaderText}
        >
            <MembersContainer>
                <MemberList
                    channel={channel}
                    members={members}
                    searchTerms={''}
                    editing={false}
                    actions={{openDirectMessage, loadMore}}
                    hasNextPage={false}
                    isNextPageLoading={false}
                />
            </MembersContainer>
        </GenericModal>
    );
}

export default NotificationFromMembersModal;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {useDispatch} from 'react-redux';

import {openModal} from 'actions/views/modals';
import {ModalIdentifiers} from 'utils/constants';

import NotificationFromMembersModal from './notification_from_members_modal';

type Props = {
    postId: string;
    text: string;
    userIds: string[];
    messageMetadata: Record<string, string>;
}

function AtSumOfMembersMention(props: Props) {
    const dispatch = useDispatch();
    const handleOpen = (e: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => {
        e.preventDefault();
        dispatch(openModal({
            modalId: ModalIdentifiers.SUM_OF_MEMBERS_MODAL,
            dialogType: NotificationFromMembersModal,
            dialogProps: {
                userIds: props.userIds,
                feature: props.messageMetadata.requestedFeature,
            },
        }));
    };

    return (
        <>
            <a
                id={`${props.postId}_at_sum_of_members_mention`}
                onClick={handleOpen}
            >
                {props.text}
            </a>
        </>

    );
}

export default AtSumOfMembersMention;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';
import type {KatexOptions} from 'katex';

type Katex = typeof import('katex');

type Props = {
    content: string;
    enableLatex: boolean;
};

type State = {
    katex?: Katex;
}

export default class LatexBlock extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            katex: undefined,
        };
    }

    componentDidMount(): void {
        import('katex').then((katex) => {
            this.setState({katex: katex.default});
        });
    }

    render(): React.ReactNode {
        if (!this.props.enableLatex || this.state.katex === undefined) {
            return (
                <div
                    className='post-body--code tex'
                >
                    {this.props.content}
                </div>
            );
        }

        try {
            const katexOptions: KatexOptions = {
                throwOnError: false,
                displayMode: true,
                maxSize: 200,
                maxExpand: 100,
                fleqn: true,
            };

            const html = this.state.katex.renderToString(this.props.content, katexOptions);

            return (
                <div
                    className='post-body--code tex'
                    dangerouslySetInnerHTML={{__html: html}}
                />
            );
        } catch (e) {
            return (
                <div
                    className='post-body--code tex'
                >
                    <FormattedMessage
                        id='katex.error'
                        defaultMessage="Couldn't compile your Latex code. Please review the syntax and try again."
                    />
                </div>
            );
        }
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getConfig} from 'mattermost-redux/selectors/entities/general';

import {GlobalState} from '@mattermost/types/store';

import LatexBlock from './latex_block';

function mapStateToProps(state: GlobalState) {
    const config = getConfig(state);
    return {
        enableLatex: config.EnableLatex === 'true',
    };
}

export default connect(mapStateToProps)(LatexBlock);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {FormattedMessage} from 'react-intl';
import type {KatexOptions} from 'katex';

type Katex = typeof import('katex');

type Props = {
    content: string;
    enableInlineLatex: boolean;
};

type State = {
    katex?: Katex;
}

export default class LatexInline extends React.PureComponent<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            katex: undefined,
        };
    }

    componentDidMount(): void {
        import('katex').then((katex) => {
            this.setState({katex: katex.default});
        });
    }

    render(): React.ReactNode {
        if (!this.props.enableInlineLatex || this.state.katex === undefined) {
            return (
                <span
                    className='post-body--code inline-tex'
                >
                    {'$' + this.props.content + '$'}
                </span>
            );
        }

        try {
            const katexOptions: KatexOptions = {
                throwOnError: false,
                displayMode: false,
                maxSize: 200,
                maxExpand: 100,
                fleqn: true,
            };

            const html = this.state.katex.renderToString(this.props.content, katexOptions);

            return (
                <span
                    className='post-body--code inline-tex'
                    dangerouslySetInnerHTML={{__html: html}}
                />
            );
        } catch (e) {
            return (
                <span
                    className='post-body--code inline-tex'
                >
                    <FormattedMessage
                        id='katex.error'
                        defaultMessage="Couldn't compile your Latex code. Please review the syntax and try again."
                    />
                </span>
            );
        }
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getConfig} from 'mattermost-redux/selectors/entities/general';

import {GlobalState} from '@mattermost/types/store';

import LatexInline from './latex_inline';

function mapStateToProps(state: GlobalState) {
    const config = getConfig(state);
    return {
        enableInlineLatex: config.EnableLatex === 'true' && config.EnableInlineLatex === 'true',
    };
}

export default connect(mapStateToProps)(LatexInline);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {RefObject, CSSProperties} from 'react';
import Popper from 'popper.js';
import ReactDOM from 'react-dom';
import classNames from 'classnames';

import {Constants} from 'utils/constants';
import Pluggable from 'plugins/pluggable';

import './link_tooltip.scss';

const tooltipContainerStyles: CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    zIndex: 1070,
    position: 'absolute',
    top: -1000,
    left: -1000,
};

type Props = {
    href: string;
    attributes: {[attribute: string]: string};
    children?: React.ReactNode;
}

type State = {
    show: boolean;
}

export default class LinkTooltip extends React.PureComponent<Props, State> {
    private tooltipContainerRef: RefObject<HTMLDivElement>;
    private hideTimeout: number;
    private showTimeout: number;
    private popper?: Popper;

    public constructor(props: Props) {
        super(props);

        this.tooltipContainerRef = React.createRef();
        this.showTimeout = -1;
        this.hideTimeout = -1;

        this.state = {
            show: false,
        };
    }

    public showTooltip = (e: React.MouseEvent<HTMLSpanElement>): void => {
        //clear the hideTimeout in the case when the cursor is moved from a tooltipContainer child to the link
        window.clearTimeout(this.hideTimeout);

        if (!this.state.show) {
            const target = e.currentTarget;
            const tooltipContainer = this.tooltipContainerRef.current;

            //clear the old this.showTimeout if there is any before overriding
            window.clearTimeout(this.showTimeout);

            this.showTimeout = window.setTimeout(() => {
                this.setState({show: true});

                if (!tooltipContainer) {
                    return;
                }

                const addChildEventListeners = (node: Node) => {
                    node.addEventListener('mouseover', () => clearTimeout(this.hideTimeout));
                    (node as HTMLElement).addEventListener('mouseleave', (event) => {
                        if (event.relatedTarget !== null) {
                            this.hideTooltip();
                        }
                    });
                };
                tooltipContainer.childNodes.forEach(addChildEventListeners);

                this.popper = new Popper(target, tooltipContainer, {
                    placement: 'bottom',
                    modifiers: {
                        preventOverflow: {enabled: false},
                        hide: {enabled: false},
                    },
                });
            }, Constants.OVERLAY_TIME_DELAY);
        }
    };

    public hideTooltip = (): void => {
        //clear the old this.hideTimeout if there is any before overriding
        window.clearTimeout(this.hideTimeout);

        this.hideTimeout = window.setTimeout(() => {
            this.setState({show: false});

            //prevent executing the showTimeout after the hideTooltip
            clearTimeout(this.showTimeout);
        }, Constants.OVERLAY_TIME_DELAY_SMALL);
    };

    public render() {
        const {href, children, attributes} = this.props;

        const dataAttributes = {
            'data-hashtag': attributes['data-hashtag'],
            'data-link': attributes['data-link'],
            'data-channel-mention': attributes['data-channel-mention'],
        };
        return (
            <React.Fragment>
                {ReactDOM.createPortal(
                    <div
                        style={tooltipContainerStyles}
                        ref={this.tooltipContainerRef}
                        className={classNames('tooltip-container', {visible: this.state.show})}
                    >
                        <Pluggable
                            href={href}
                            show={this.state.show}
                            pluggableName='LinkTooltip'
                        />
                    </div>,
                    document.getElementById('root') as HTMLElement,
                )}
                <span
                    onMouseOver={this.showTooltip}
                    onMouseLeave={this.hideTooltip}
                    {...dataAttributes}
                >
                    {children}
                </span>
            </React.Fragment>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useEffect} from 'react';
import './markdown_image_expand.scss';

export type Props = {
    alt: string;
    imageKey: string;
    children: React.ReactNode;
    isExpanded: boolean;
    postId: string;
    onToggle?: (isExpanded: boolean) => void;
    actions: {
        toggleInlineImageVisibility: (postId: string, imageKey: string) => void;
    };
};

const MarkdownImageExpand: React.FC<Props> = ({children, alt, isExpanded, postId, actions, onToggle, imageKey}: Props) => {
    const {toggleInlineImageVisibility} = actions;

    useEffect(() => {
        onToggle?.(isExpanded);
    }, [isExpanded]);

    const handleToggleButtonClick = () => {
        toggleInlineImageVisibility(postId, imageKey);
    };

    const wrapperClassName = `markdown-image-expand ${isExpanded ? 'markdown-image-expand--expanded' : ''}`;

    return (
        <div className={wrapperClassName}>
            {
                isExpanded &&
                <>
                    <button
                        className='markdown-image-expand__collapse-button'
                        type='button'
                        onClick={handleToggleButtonClick}
                    >
                        <span className='icon icon-menu-down'/>
                    </button>
                    {children}
                </>
            }

            {
                !isExpanded &&
                <button
                    className='markdown-image-expand__expand-button'
                    type='button'
                    onClick={handleToggleButtonClick}
                >
                    <span className='icon icon-menu-right markdown-image-expand__expand-icon'/>

                    <span className='markdown-image-expand__alt-text'>
                        {alt}
                    </span>
                </button>
            }
        </div>
    );
};

export default MarkdownImageExpand;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {bindActionCreators, Dispatch} from 'redux';

import {connect} from 'react-redux';

import {GenericAction} from 'mattermost-redux/types/actions';

import {toggleInlineImageVisibility} from 'actions/post_actions';
import {isInlineImageVisible} from 'selectors/posts';
import {GlobalState} from 'types/store';

import MarkdownImageExpand, {Props} from './markdown_image_expand';

const mapStateToProps = (state: GlobalState, {postId, imageKey}: Props) => {
    return {
        isExpanded: isInlineImageVisible(state, postId, imageKey),
    };
};

const mapDispatchToProps = (dispatch: Dispatch<GenericAction>) => {
    return {
        actions: bindActionCreators({toggleInlineImageVisibility}, dispatch),
    };
};

export default connect(mapStateToProps, mapDispatchToProps)(MarkdownImageExpand);

export default __webpack_public_path__ + "files/82c53ca565ed83a033dfb4284740873d.png";
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import PropTypes from 'prop-types';
import React from 'react';

import Constants, {ModalIdentifiers} from 'utils/constants';

import MarkdownImageExpand from 'components/markdown_image_expand';
import ExternalImage from 'components/external_image';
import SizeAwareImage from 'components/size_aware_image';
import FilePreviewModal from 'components/file_preview_modal';

import brokenImageIcon from 'images/icons/brokenimage.png';

export default class MarkdownImage extends React.PureComponent {
    static defaultProps = {
        imageMetadata: {},
    };

    static propTypes = {
        alt: PropTypes.string,
        imageMetadata: PropTypes.object,
        src: PropTypes.string.isRequired,

        // height and width come from the Markdown renderer as either "auto" or a string containing a number.
        height: PropTypes.string,
        width: PropTypes.string,

        title: PropTypes.string,
        className: PropTypes.string.isRequired,
        postId: PropTypes.string.isRequired,
        imageIsLink: PropTypes.bool.isRequired,
        onImageLoaded: PropTypes.func,
        onImageHeightChanged: PropTypes.func,
        postType: PropTypes.string,

        actions: PropTypes.shape({
            openModal: PropTypes.func,
        }).isRequired,
    }

    constructor(props) {
        super(props);

        this.state = {
            loadFailed: false,
            loaded: false,
        };
    }

    getHeight = () => {
        const {
            height,
            imageMetadata,
            width,
        } = this.props;

        if (!height) {
            return imageMetadata.height;
        }

        if (height === 'auto') {
            const widthNumber = parseInt(width, 10);

            return (imageMetadata.height / imageMetadata.width) * widthNumber;
        }

        return parseInt(height, 10);
    }

    getFileExtensionFromUrl = (url) => {
        const index = url.lastIndexOf('.');
        return index > 0 ? url.substring(index + 1) : null;
    };

    showModal = (e, link) => {
        const extension = this.getFileExtensionFromUrl(link);

        if (!this.props.imageIsLink && extension) {
            e.preventDefault();

            this.props.actions.openModal({
                modalId: ModalIdentifiers.FILE_PREVIEW_MODAL,
                dialogType: FilePreviewModal,
                dialogProps: {
                    postId: this.props.postId,
                    fileInfos: [{
                        has_preview_image: false,
                        link,
                        extension: this.props.imageMetadata.format || extension,
                        name: this.props.alt,
                    }],
                },
            });
        }
    }

    handleLoadFail = () => {
        this.setState({loadFailed: true});
    }

    isHeaderChangeMessage = () => {
        return this.props.postType &&
            this.props.postType === Constants.PostTypes.HEADER_CHANGE;
    }

    componentDidUpdate(prevProps) {
        this.onUpdated(prevProps.src);
    }

    onUpdated = (prevSrc) => {
        if (this.props.src && this.props.src !== prevSrc) {
            this.setState({loadFailed: false});
        }
    }

    handleImageLoaded = ({height, width}) => {
        this.setState({
            loaded: true,
        }, () => { // Call onImageLoaded prop only after state has already been set
            if (this.props.onImageLoaded) {
                this.props.onImageLoaded({height, width});
            }
        });
    }

    render() {
        const {imageMetadata, src, alt, imageIsLink} = this.props;
        if (src === '' || this.state.loadFailed) {
            let className = 'markdown-inline-img broken-image';
            if (this.isHeaderChangeMessage()) {
                className += ' broken-image--scaled-down';
            }

            return (
                <div style={{display: 'inline-block'}}>
                    <img
                        className={className}
                        alt={alt}
                        src={brokenImageIcon}
                    />
                </div>
            );
        }
        return (
            <ExternalImage
                src={src}
                imageMetadata={imageMetadata}
            >
                {(safeSrc) => {
                    if (!safeSrc) {
                        return (
                            <a
                                className='theme markdown__link'
                                href={src}
                                rel='noopener noreferrer'
                                target='_blank'
                                title={this.props.title}
                            >
                                {alt}
                            </a>
                        );
                    }

                    const extension = this.getFileExtensionFromUrl(safeSrc);

                    let className = '';
                    if (this.state.loaded) {
                        className = imageIsLink || !extension ? `${this.props.className} markdown-inline-img--hover markdown-inline-img--no-border` : `${this.props.className} markdown-inline-img--hover cursor--pointer a11y--active`;

                        if (this.isHeaderChangeMessage()) {
                            className += ' markdown-inline-img--scaled-down';
                        }
                    } else {
                        const loadingClass = this.isHeaderChangeMessage() ? 'markdown-inline-img--scaled-down-loading' : 'markdown-inline-img--loading';
                        className = `${this.props.className} ${loadingClass}`;
                    }

                    const {height, width, title, postId, onImageHeightChanged} = this.props;

                    let imageElement = (
                        <SizeAwareImage
                            alt={alt}
                            className={className}
                            src={safeSrc}
                            height={height === 'auto' ? undefined : height}
                            width={width === 'auto' ? undefined : width}
                            title={title}
                            dimensions={imageMetadata}
                            showLoader={false}
                            onClick={this.showModal}
                            onImageLoadFail={this.handleLoadFail}
                            onImageLoaded={this.handleImageLoaded}
                        />
                    );

                    const actualHeight = this.getHeight();
                    if (actualHeight >= Constants.EXPANDABLE_INLINE_IMAGE_MIN_HEIGHT) {
                        imageElement = (
                            <MarkdownImageExpand
                                alt={alt || safeSrc}
                                postId={postId}
                                imageKey={safeSrc}
                                onToggle={onImageHeightChanged}
                            >
                                {imageElement}
                            </MarkdownImageExpand>
                        );
                    }

                    return imageElement;
                }}
            </ExternalImage>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';

import {openModal} from 'actions/views/modals';

import MarkdownImage from './markdown_image';

function mapDispatchToProps(dispatch) {
    return {
        actions: bindActionCreators({
            openModal,
        }, dispatch),
    };
}

const connector = connect(null, mapDispatchToProps);

export default connector(MarkdownImage);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

interface PostEmojiProps {
    name: string;
    imageUrl: string;
}
declare module 'react' {
    interface HTMLAttributes<T> extends AriaAttributes, DOMAttributes<T> {
        alt?: string;
    }
}

export default class PostEmoji extends React.PureComponent<PostEmojiProps> {
    public render() {
        const emojiText = ':' + this.props.name + ':';

        if (!this.props.imageUrl) {
            return emojiText;
        }

        return (
            <span
                alt={emojiText}
                className='emoticon'
                title={emojiText}
                style={{backgroundImage: 'url(' + this.props.imageUrl + ')'}}
            >
                {emojiText}
            </span>
        );
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {connect} from 'react-redux';

import {getEmojiImageUrl} from 'mattermost-redux/utils/emoji_utils';

import {getEmojiMap} from 'selectors/emojis';

import {GlobalState} from 'types/store';

import PostEmoji from './post_emoji';

type Props = {
    name: string;
};

function mapStateToProps(state: GlobalState, ownProps: Props) {
    const emojiMap = getEmojiMap(state);
    const emoji = emojiMap.get(ownProps.name);

    return {
        imageUrl: emoji ? getEmojiImageUrl(emoji) : '',
    };
}

export default connect(mapStateToProps)(PostEmoji);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useCallback, useEffect, useState} from 'react';

import {ContextMenu, ContextMenuTrigger, MenuItem} from 'react-contextmenu';

import {FormattedMessage} from 'react-intl';

import CopyButton from 'components/copy_button';

import * as SyntaxHighlighting from 'utils/syntax_highlighting';

import RootPortal from 'components/root_portal';
import {copyToClipboard} from 'utils/utils';

import * as TextFormatting from 'utils/text_formatting';

type Props = {
    id: string;
    code: string;
    language: string;
    searchedContent?: string;
}

const CodeBlock: React.FC<Props> = ({id, code, language, searchedContent}: Props) => {
    const getUsedLanguage = useCallback(() => {
        let usedLanguage = language || '';
        usedLanguage = usedLanguage.toLowerCase();

        if (usedLanguage === 'texcode' || usedLanguage === 'latexcode') {
            usedLanguage = 'latex';
        }

        // treat html as xml to prevent injection attacks
        if (usedLanguage === 'html') {
            usedLanguage = 'xml';
        }

        return usedLanguage;
    }, [language]);

    const usedLanguage = getUsedLanguage();

    let className = 'post-code';
    if (!usedLanguage) {
        className += ' post-code--wrap';
    }

    let header: JSX.Element = <></>;
    let lineNumbers: JSX.Element = <></>;
    if (SyntaxHighlighting.canHighlight(usedLanguage)) {
        header = (
            <span className='post-code__language'>
                {SyntaxHighlighting.getLanguageName(usedLanguage)}
            </span>
        );
        lineNumbers = (
            <div className='post-code__line-numbers'>
                {SyntaxHighlighting.renderLineNumbers(code)}
            </div>
        );
    }

    // If we have to apply syntax highlighting AND highlighting of search terms, create two copies
    // of the code block, one with syntax highlighting applied and another with invisible text, but
    // search term highlighting and overlap them
    const [content, setContent] = useState(TextFormatting.sanitizeHtml(code));
    useEffect(() => {
        SyntaxHighlighting.highlight(usedLanguage, code).then((content) => setContent(content));
    }, [usedLanguage, code]);

    let htmlContent = content;
    if (searchedContent) {
        htmlContent = `${searchedContent} ${content}`;
    }

    const copyText = () => {
        copyToClipboard(code);
    };

    const copyMarkdown = useCallback(() => {
        const markdown = `\`\`\`${language}\n${code}\n\`\`\``;
        copyToClipboard(markdown);
    }, [language, code]);

    const contextMenu = (
        <RootPortal>
            <ContextMenu
                className='post-code__context-menu'
                id={`copy-code-block-context-menu-${id}`}
            >
                <MenuItem onClick={copyText}>
                    <FormattedMessage
                        id='copy.message'
                        defaultMessage='Copy'
                    />
                </MenuItem>
                <MenuItem divider={true}/>
                <MenuItem onClick={copyMarkdown}>
                    <FormattedMessage
                        id='copy.block.message'
                        defaultMessage='Copy code block'
                    />
                </MenuItem>
            </ContextMenu>
        </RootPortal>
    );

    return (
        <div className={className}>
            <div className='post-code__overlay'>
                <CopyButton content={code}/>
                {header}
            </div>
            {contextMenu}
            <ContextMenuTrigger
                id={`copy-code-block-context-menu-${id}`}
                holdToDisplay={-1}
            >
                <div className='hljs'>
                    {lineNumbers}
                    <code dangerouslySetInnerHTML={{__html: htmlContent}}/>
                </div>
            </ContextMenuTrigger>
        </div>
    );
};

export default CodeBlock;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import useOpenPricingModal from 'components/common/hooks/useOpenPricingModal';

type Props = {
    plan: string;
}

function AtPlanMention(props: Props) {
    const openPricingModal = useOpenPricingModal();

    const handleClick = (e: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => {
        e.preventDefault();
        openPricingModal({trackingLocation: 'notify_admin_message_view'});
    };
    return (
        <a
            id='at_plan_mention'
            onClick={handleClick}
        >
            {props.plan}
        </a>

    );
}

export default AtPlanMention;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';
import {Parser, ProcessNodeDefinitions} from 'html-to-react';

import AtMention from 'components/at_mention';
import AtSumOfMembersMention from 'components/at_sum_members_mention';
import LatexBlock from 'components/latex_block';
import LatexInline from 'components/latex_inline';
import LinkTooltip from 'components/link_tooltip/link_tooltip';
import MarkdownImage from 'components/markdown_image';
import PostEmoji from 'components/post_emoji';
import PostEditedIndicator from 'components/post_view/post_edited_indicator';
import CodeBlock from 'components/code_block/code_block';
import AtPlanMention from 'components/at_plan_mention';

/*
 * Converts HTML to React components using html-to-react.
 * The following options can be specified:
 * - mentions - If specified, mentions are replaced with the AtMention component. Defaults to true.
 * - mentionHighlight - If specified, mentions for the current user are highlighted. Defaults to true.
 * - disableGroupHighlight - If specified, group mentions are not displayed as blue links. Defaults to false.
 * - emoji - If specified, emoji text is replaced with the PostEmoji component. Defaults to true.
 * - images - If specified, markdown images are replaced with the image component. Defaults to true.
 * - imageProps - If specified, any extra props that should be passed into the image component.
 * - latex - If specified, latex is replaced with the LatexBlock component. Defaults to true.
 * - imagesMetadata - the dimensions of the image as retrieved from post.metadata.images.
 * - hasPluginTooltips - If specified, the LinkTooltip component is placed inside links. Defaults to false.
 * - channelId = If specified, to be passed along to ProfilePopover via AtMention
 */
export function messageHtmlToComponent(html, isRHS, options = {}) {
    if (!html) {
        return null;
    }

    const parser = new Parser();
    const processNodeDefinitions = new ProcessNodeDefinitions(React);

    function isValidNode() {
        return true;
    }

    const processingInstructions = [

        // Workaround to fix MM-14931
        {
            replaceChildren: false,
            shouldProcessNode: (node) => node.type === 'tag' && node.name === 'input' && node.attribs.type === 'checkbox',
            processNode: (node) => {
                const attribs = node.attribs || {};
                node.attribs.checked = Boolean(attribs.checked);

                return React.createElement('input', {...node.attribs});
            },
        },
        {
            replaceChildren: false,
            shouldProcessNode: (node) => node.type === 'tag' && node.name === 'span' && node.attribs['data-edited-post-id'] && node.attribs['data-edited-post-id'] === options.postId,
            processNode: () => {
                return options.postId && options.editedAt > 0 ? (
                    <>
                        {' '}
                        <PostEditedIndicator
                            key={options.postId}
                            postId={options.postId}
                            editedAt={options.editedAt}
                        />
                    </>
                ) : null;
            },
        },
    ];

    if (options.hasPluginTooltips) {
        const hrefAttrib = 'href';
        processingInstructions.push({
            replaceChildren: true,
            shouldProcessNode: (node) => node.type === 'tag' && node.name === 'a' && node.attribs[hrefAttrib],
            processNode: (node, children) => {
                return (
                    <LinkTooltip
                        href={node.attribs[hrefAttrib]}
                        attributes={node.attribs}
                    >
                        {children}
                    </LinkTooltip>
                );
            },
        });
    }

    if (!('mentions' in options) || options.mentions) {
        const mentionHighlight = 'mentionHighlight' in options ? options.mentionHighlight : true;
        const disableGroupHighlight = 'disableGroupHighlight' in options ? options.disableGroupHighlight === true : false;
        const mentionAttrib = 'data-mention';
        processingInstructions.push({
            replaceChildren: true,
            shouldProcessNode: (node) => node.attribs && node.attribs[mentionAttrib],
            processNode: (node, children) => {
                const mentionName = node.attribs[mentionAttrib];
                const callAtMention = (
                    <AtMention
                        mentionName={mentionName}
                        isRHS={isRHS}
                        hasMention={true}
                        disableHighlight={!mentionHighlight}
                        disableGroupHighlight={disableGroupHighlight}
                        channelId={options.channelId}
                    >
                        {children}
                    </AtMention>
                );
                return callAtMention;
            },
        });
    }

    if (options.atSumOfMembersMentions) {
        const mentionAttrib = 'data-sum-of-members-mention';
        processingInstructions.push({
            replaceChildren: true,
            shouldProcessNode: (node) => node.attribs && node.attribs[mentionAttrib],
            processNode: (node) => {
                const mentionName = node.attribs[mentionAttrib];
                const sumOfMembersMention = (
                    <AtSumOfMembersMention
                        postId={options.postId}
                        userIds={options.userIds}
                        messageMetadata={options.messageMetadata}
                        text={mentionName}
                    />);
                return sumOfMembersMention;
            },
        });
    }

    if (options.atPlanMentions) {
        const mentionAttrib = 'data-plan-mention';
        processingInstructions.push({
            replaceChildren: true,
            shouldProcessNode: (node) => node.attribs && node.attribs[mentionAttrib],
            processNode: (node) => {
                const mentionName = node.attribs[mentionAttrib];
                const sumOfMembersMention = (
                    <AtPlanMention
                        plan={mentionName}
                    />);
                return sumOfMembersMention;
            },
        });
    }

    if (!('emoji' in options) || options.emoji) {
        const emojiAttrib = 'data-emoticon';
        processingInstructions.push({
            replaceChildren: true,
            shouldProcessNode: (node) => node.attribs && node.attribs[emojiAttrib],
            processNode: (node) => {
                const emojiName = node.attribs[emojiAttrib];

                return <PostEmoji name={emojiName}/>;
            },
        });
    }

    if (!('images' in options) || options.images) {
        processingInstructions.push({
            shouldProcessNode: (node) => node.type === 'tag' && node.name === 'img',
            processNode: (node) => {
                const {
                    class: className,
                    ...attribs
                } = node.attribs;

                const imageIsLink = (parentNode) => {
                    if (parentNode &&
                        parentNode.type === 'tag' &&
                        parentNode.name === 'a'
                    ) {
                        return true;
                    }
                    return false;
                };

                return (
                    <MarkdownImage
                        className={className}
                        imageMetadata={options.imagesMetadata && options.imagesMetadata[attribs.src]}
                        {...attribs}
                        {...options.imageProps}
                        postId={options.postId}
                        imageIsLink={imageIsLink(node.parentNode)}
                        postType={options.postType}
                    />
                );
            },
        });
    }

    if (!('latex' in options) || options.latex) {
        processingInstructions.push({
            shouldProcessNode: (node) => node.attribs && node.attribs['data-latex'],
            processNode: (node) => {
                return (
                    <LatexBlock content={node.attribs['data-latex']}/>
                );
            },
        });
    }

    if (!('inlinelatex' in options) || options.inlinelatex) {
        processingInstructions.push({
            shouldProcessNode: (node) => node.attribs && node.attribs['data-inline-latex'],
            processNode: (node) => {
                return (
                    <LatexInline content={node.attribs['data-inline-latex']}/>
                );
            },
        });
    }

    if (!('markdown' in options) || options.markdown) {
        processingInstructions.push({
            shouldProcessNode: (node) => node.attribs && node.attribs['data-codeblock-code'],
            processNode: (node) => {
                return (
                    <CodeBlock
                        id={options.postId}
                        code={node.attribs['data-codeblock-code']}
                        language={node.attribs['data-codeblock-language']}
                        searchedContent={node.attribs['data-codeblock-searchedcontent']}
                    />
                );
            },
        });
    }

    processingInstructions.push({
        shouldProcessNode: () => true,
        processNode: processNodeDefinitions.processDefaultNode,
    });

    return parser.parseWithInstructions(html, isValidNode, processingInstructions);
}

export default messageHtmlToComponent;

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {PaidFeatures} from './constants';

// eslint-disable-next-line @typescript-eslint/ban-types
export function mapFeatureIdToTranslation(id: string, formatMessage: Function): string {
    switch (id) {
    case PaidFeatures.GUEST_ACCOUNTS:
        return formatMessage({id: 'webapp.mattermost.feature.guest_accounts', defaultMessage: 'Guest Accounts'});
    case PaidFeatures.CUSTOM_USER_GROUPS:
        return formatMessage({id: 'webapp.mattermost.feature.custom_user_groups', defaultMessage: 'Custom User groups'});
    case PaidFeatures.CREATE_MULTIPLE_TEAMS:
        return formatMessage({id: 'webapp.mattermost.feature.create_multiple_teams', defaultMessage: 'Create Multiple Teams'});
    case PaidFeatures.START_CALL:
        return formatMessage({id: 'webapp.mattermost.feature.start_call', defaultMessage: 'Start call'});
    case PaidFeatures.PLAYBOOKS_RETRO:
        return formatMessage({id: 'webapp.mattermost.feature.playbooks_retro', defaultMessage: 'Playbooks Retrospective'});
    case PaidFeatures.UNLIMITED_MESSAGES:
        return formatMessage({id: 'webapp.mattermost.feature.unlimited_messages', defaultMessage: 'Unlimited Messages'});
    case PaidFeatures.UNLIMITED_FILE_STORAGE:
        return formatMessage({id: 'webapp.mattermost.feature.unlimited_file_storage', defaultMessage: 'Unlimited File Storage'});
    case PaidFeatures.UNLIMITED_BOARD_CARDS:
        return formatMessage({id: 'webapp.mattermost.feature.unlimited_board_cards', defaultMessage: 'Unlimited Board cards'});
    case PaidFeatures.ALL_PROFESSIONAL_FEATURES:
        return formatMessage({id: 'webapp.mattermost.feature.all_professional', defaultMessage: 'All Professional features'});
    case PaidFeatures.ALL_ENTERPRISE_FEATURES:
        return formatMessage({id: 'webapp.mattermost.feature.all_enterprise', defaultMessage: 'All Enterprise features'});
    case PaidFeatures.UPGRADE_DOWNGRADED_WORKSPACE:
        return formatMessage({id: 'webapp.mattermost.feature.upgrade_downgraded_workspace', defaultMessage: 'Revert the workspace to a paid plan'});
    default:
        return '';
    }
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {OverActiveUserLimits} from './constants';

type CalculateOverageUsersActivatedArgs = {
    seatsPurchased: number;
    activeUsers: number;
}

export const calculateOverageUserActivated = ({activeUsers, seatsPurchased}: CalculateOverageUsersActivatedArgs) => {
    const minimumOverSeats = Math.ceil(seatsPurchased * OverActiveUserLimits.MIN) + seatsPurchased;
    const maximumOverSeats = Math.ceil(seatsPurchased * OverActiveUserLimits.MAX) + seatsPurchased;
    const isBetween5PercerntAnd10PercentPurchasedSeats = minimumOverSeats <= activeUsers && activeUsers < maximumOverSeats;
    const isOver10PercerntPurchasedSeats = maximumOverSeats <= activeUsers;

    return {
        minimumOverSeats,
        maximumOverSeats,
        isBetween5PercerntAnd10PercentPurchasedSeats,
        isOver10PercerntPurchasedSeats,
    };
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import TurndownService from 'turndown';
import {tables} from '@guyplusplus/turndown-plugin-gfm';

import {splitMessageBasedOnCaretPosition, splitMessageBasedOnTextSelection} from 'utils/post_utils';

type FormatCodeOptions = {
    message: string;
    clipboardData: DataTransfer;
    selectionStart: number | null;
    selectionEnd: number | null;
};

export function parseTable(html: string): HTMLTableElement | null {
    return new DOMParser().parseFromString(html, 'text/html').querySelector('table');
}

export function getTable(clipboardData: DataTransfer): HTMLTableElement | null {
    if (Array.from(clipboardData.types).indexOf('text/html') === -1) {
        return null;
    }

    const html = clipboardData.getData('text/html');

    if (!(/<table/i).test(html)) {
        return null;
    }

    const table = parseTable(html);
    if (!table) {
        return null;
    }

    return table;
}

export function hasHtmlLink(clipboardData: DataTransfer): boolean {
    return Array.from(clipboardData.types).includes('text/html') && (/<a/i).test(clipboardData.getData('text/html'));
}

export function getPlainText(clipboardData: DataTransfer): string | boolean {
    if (Array.from(clipboardData.types).indexOf('text/plain') === -1) {
        return false;
    }

    const plainText = clipboardData.getData('text/plain');

    return plainText;
}

export function isGitHubCodeBlock(tableClassName: string): boolean {
    const result = (/\b(js|blob|diff)-./).test(tableClassName);
    return result;
}

function isHeaderlessTable(table: HTMLTableElement): boolean {
    return table.querySelectorAll('th').length === 0;
}

export function formatMarkdownMessage(clipboardData: DataTransfer, message?: string, caretPosition?: number): string {
    const html = clipboardData.getData('text/html');

    //TODO@michel: Instantiate turndown service in a central file instead
    const service = new TurndownService({emDelimiter: '*'}).remove('style');
    service.use(tables);
    let markdownFormattedMessage = service.turndown(html).trim();

    const table = getTable(clipboardData);

    if (table && isHeaderlessTable(table)) {
        markdownFormattedMessage += '\n';
    }

    if (!message) {
        return markdownFormattedMessage;
    }
    if (typeof caretPosition === 'undefined') {
        return `${message}\n\n${markdownFormattedMessage}`;
    }
    const newMessage = [message.slice(0, caretPosition) + '\n', markdownFormattedMessage, message.slice(caretPosition)];
    return newMessage.join('\n');
}

export function formatGithubCodePaste({message, clipboardData, selectionStart, selectionEnd}: FormatCodeOptions): {formattedMessage: string; formattedCodeBlock: string} {
    const textSelected = selectionStart !== selectionEnd;
    const {firstPiece, lastPiece} = textSelected ?
        splitMessageBasedOnTextSelection(selectionStart ?? message.length, selectionEnd ?? message.length, message) :
        splitMessageBasedOnCaretPosition(selectionStart ?? message.length, message);

    // Add new lines if content exists before or after the cursor.
    const requireStartLF = firstPiece === '' ? '' : '\n';
    const requireEndLF = lastPiece === '' ? '' : '\n';
    const formattedCodeBlock = requireStartLF + '```\n' + getPlainText(clipboardData) + '\n```' + requireEndLF;
    const formattedMessage = `${firstPiece}${formattedCodeBlock}${lastPiece}`;

    return {formattedMessage, formattedCodeBlock};
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

export function popOverOverlayPosition(
    targetBounds: DOMRect,
    innerHeight: number,
    spaceRequiredAbove: number,
    spaceRequiredBelow?: number,
    horizontalPosition?: 'left' | 'right',
): string {
    let placement: string;

    if (targetBounds.top > spaceRequiredAbove) {
        placement = 'top';
    } else if (innerHeight - targetBounds.bottom > (spaceRequiredBelow || spaceRequiredAbove)) {
        placement = 'bottom';
    } else {
        placement = horizontalPosition || 'left';
    }
    return placement;
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useLocation, matchPath} from 'react-router-dom';

import {useSelector} from 'react-redux';

import {ProductIdentifier, ProductScope} from '@mattermost/types/products';
import {Product} from '@mattermost/types/cloud';

import {ProductComponent} from 'types/store/plugins';
import {selectProducts, selectCurrentProductId, selectCurrentProduct} from 'selectors/products';
import {GlobalState} from 'types/store';

export const getCurrentProductId = (
    products: ProductComponent[],
    pathname: string,
): ProductIdentifier => {
    return getCurrentProduct(products, pathname)?.id ?? null;
};

export const getCurrentProduct = (
    products: ProductComponent[],
    pathname: string,
): ProductComponent | null => {
    return products?.find(({baseURL}) => matchPath(pathname, {path: baseURL, exact: false, strict: false})) ?? null;
};

export const useProducts = (): ProductComponent[] | undefined => {
    return useSelector(selectProducts);
};

export const useCurrentProductId = () => {
    const {pathname} = useLocation();
    return useSelector((state: GlobalState) => selectCurrentProductId(state, pathname));
};

export const useCurrentProduct = () => {
    const {pathname} = useLocation();
    return useSelector((state: GlobalState) => selectCurrentProduct(state, pathname));
};

export const inScope = (scope: ProductScope, productId: ProductIdentifier, pluginId?: string) => {
    if (scope === '*' || scope?.includes('*')) {
        return true;
    }
    if (Array.isArray(scope)) {
        return scope.includes(productId) || (pluginId !== undefined && scope.includes(pluginId));
    }
    return scope === productId || (pluginId !== undefined && scope === pluginId);
};

export const isChannels = (productId: ProductIdentifier) => productId === null;

// find a product based on its SKU an RecurringInterval
export const findProductBySkuAndInterval = (products: Record<string, Product>, sku: string, interval: string) => {
    return Object.values(products).find(((product) => {
        return product.sku === sku && product.recurring_interval === interval;
    }));
};

export const findProductByID = (products: Record<string, Product>, id: string) => {
    return Object.values(products).find(((product) => {
        return product.id === id;
    }));
};

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import hlJS from 'highlight.js/lib/core';

import * as TextFormatting from 'utils/text_formatting';

import Constants from './constants';

type LanguageObject = {
    [key: string]: {
        name: string;
        extensions: string[];
        aliases?: string[];
    };
}

const HighlightedLanguages: LanguageObject = Constants.HighlightedLanguages;

export async function highlight(lang: string, code: string) {
    const language = getLanguageFromNameOrAlias(lang);

    if (language) {
        try {
            await registerLanguage(language);
            return hlJS.highlight(code, {language}).value;
        } catch (e) {
            // fall through if highlighting fails and handle below
        }
    }

    return TextFormatting.sanitizeHtml(code);
}

export function renderLineNumbers(code: string) {
    const numberOfLines = code.split(/\r\n|\n|\r/g).length;
    const lineNumbers = [];
    for (let i = 0; i < numberOfLines; i++) {
        lineNumbers.push((i + 1).toString());
    }

    return lineNumbers.join('\n');
}

export function getLanguageFromFileExtension(extension: string): string | null {
    for (const key in HighlightedLanguages) {
        if (HighlightedLanguages[key].extensions.find((x: string) => x === extension)) {
            return key;
        }
    }

    return null;
}

export function canHighlight(language: string): boolean {
    return Boolean(getLanguageFromNameOrAlias(language));
}

export function getLanguageName(language: string): string {
    if (canHighlight(language)) {
        const name: string | undefined = getLanguageFromNameOrAlias(language);
        if (!name) {
            return '';
        }
        return HighlightedLanguages[name].name;
    }

    return '';
}

function getLanguageFromNameOrAlias(name: string) {
    const langName: string = name.toLowerCase();
    if (HighlightedLanguages[langName]) {
        return langName;
    }

    return Object.keys(HighlightedLanguages).find((key) => {
        const aliases = HighlightedLanguages[key].aliases;
        return aliases && aliases.find((a) => a === langName);
    });
}

async function registerLanguage(languageName: string) {
    const languageImports: {
        [key: string]: any;
    } = {
        '1c': () => import('highlight.js/lib/languages/1c'),
        actionscript: () => import('highlight.js/lib/languages/actionscript'),
        applescript: () => import('highlight.js/lib/languages/applescript'),
        bash: () => import('highlight.js/lib/languages/bash'),
        clojure: () => import('highlight.js/lib/languages/clojure'),
        coffeescript: () => import('highlight.js/lib/languages/coffeescript'),
        cpp: () => import('highlight.js/lib/languages/cpp'),
        csharp: () => import('highlight.js/lib/languages/csharp'),
        css: () => import('highlight.js/lib/languages/css'),
        d: () => import('highlight.js/lib/languages/d'),
        dart: () => import('highlight.js/lib/languages/dart'),
        delphi: () => import('highlight.js/lib/languages/delphi'),
        diff: () => import('highlight.js/lib/languages/diff'),
        django: () => import('highlight.js/lib/languages/django'),
        dockerfile: () => import('highlight.js/lib/languages/dockerfile'),
        elixir: () => import('highlight.js/lib/languages/elixir'),
        erlang: () => import('highlight.js/lib/languages/erlang'),
        fortran: () => import('highlight.js/lib/languages/fortran'),
        fsharp: () => import('highlight.js/lib/languages/fsharp'),
        gcode: () => import('highlight.js/lib/languages/gcode'),
        go: () => import('highlight.js/lib/languages/go'),
        groovy: () => import('highlight.js/lib/languages/groovy'),
        handlebars: () => import('highlight.js/lib/languages/handlebars'),
        haskell: () => import('highlight.js/lib/languages/haskell'),
        haxe: () => import('highlight.js/lib/languages/haxe'),
        java: () => import('highlight.js/lib/languages/java'),
        javascript: () => import('highlight.js/lib/languages/javascript'),
        json: () => import('highlight.js/lib/languages/json'),
        julia: () => import('highlight.js/lib/languages/julia'),
        kotlin: () => import('highlight.js/lib/languages/kotlin'),
        latex: () => import('highlight.js/lib/languages/latex'),
        less: () => import('highlight.js/lib/languages/less'),
        lisp: () => import('highlight.js/lib/languages/lisp'),
        lua: () => import('highlight.js/lib/languages/lua'),
        makefile: () => import('highlight.js/lib/languages/makefile'),
        markdown: () => import('highlight.js/lib/languages/markdown'),
        matlab: () => import('highlight.js/lib/languages/matlab'),
        objectivec: () => import('highlight.js/lib/languages/objectivec'),
        ocaml: () => import('highlight.js/lib/languages/ocaml'),
        perl: () => import('highlight.js/lib/languages/perl'),
        pgsql: () => import('highlight.js/lib/languages/pgsql'),
        php: () => import('highlight.js/lib/languages/php'),
        plaintext: () => import('highlight.js/lib/languages/plaintext'),
        powershell: () => import('highlight.js/lib/languages/powershell'),
        puppet: () => import('highlight.js/lib/languages/puppet'),
        python: () => import('highlight.js/lib/languages/python'),
        r: () => import('highlight.js/lib/languages/r'),
        ruby: () => import('highlight.js/lib/languages/ruby'),
        rust: () => import('highlight.js/lib/languages/rust'),
        scala: () => import('highlight.js/lib/languages/scala'),
        scheme: () => import('highlight.js/lib/languages/scheme'),
        scss: () => import('highlight.js/lib/languages/scss'),
        smalltalk: () => import('highlight.js/lib/languages/smalltalk'),
        sql: () => import('highlight.js/lib/languages/sql'),
        stylus: () => import('highlight.js/lib/languages/stylus'),
        swift: () => import('highlight.js/lib/languages/swift'),
        typescript: () => import('highlight.js/lib/languages/typescript'),
        vbnet: () => import('highlight.js/lib/languages/vbnet'),
        vbscript: () => import('highlight.js/lib/languages/vbscript'),
        verilog: () => import('highlight.js/lib/languages/verilog'),
        vhdl: () => import('highlight.js/lib/languages/vhdl'),
        xml: () => import('highlight.js/lib/languages/xml'),
        yaml: () => import('highlight.js/lib/languages/yaml'),
    };

    if (!languageImports[languageName]) {
        return;
    }

    const language = (await languageImports[languageName]()).default;

    hlJS.registerLanguage(languageName, language);
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {Team} from '@mattermost/types/teams';

// Use when sorting multiple teams by their `display_name` field
function compareTeamsByDisplayName(locale: string, a: Team, b: Team) {
    if (a.display_name !== null) {
        if (a.display_name !== b.display_name) {
            return a.display_name.localeCompare(b.display_name, locale, {numeric: true});
        }
    }

    return a.name.localeCompare(b.name, locale, {numeric: true});
}

// Use to filter out teams that are deleted and without display_name, then sort by their `display_name` field
export function filterAndSortTeamsByDisplayName<T extends Team>(teams: T[], locale: string, teamsOrder = '') {
    if (!teams) {
        return [];
    }

    const teamsOrderList = teamsOrder.split(',');

    const customSortedTeams = teams.filter((team) => {
        if (team !== null) {
            return teamsOrderList.includes(team.id);
        }
        return false;
    }).sort((a, b) => {
        return teamsOrderList.indexOf(a.id) - teamsOrderList.indexOf(b.id);
    });

    const otherTeams = teams.filter((team) => {
        if (team !== null) {
            return !teamsOrderList.includes(team.id);
        }
        return false;
    }).sort((a, b) => {
        return compareTeamsByDisplayName(locale, a, b);
    });

    return [...customSortedTeams, ...otherTeams].filter((team) => {
        // TODO: Fix. Asserting type right now because do not want to affect in productino behavior.
        return team && (!team.delete_at as unknown as number) > 0 && team.display_name != null;
    });
}

export function makeNewTeam(displayName: string, name: string): Team {
    return {
        id: '',
        create_at: 0,
        update_at: 0,
        delete_at: 0,
        display_name: displayName,
        name,
        description: '',
        email: '',
        type: 'O',
        company_name: '',
        allowed_domains: '',
        invite_id: '',
        allow_open_invite: false,
        scheme_id: '',
        group_constrained: false,
    };
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React from 'react';

import {WebSocketClient} from '@mattermost/client';

export const WebSocketContext = React.createContext<WebSocketClient>(null!);

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useContext, useEffect} from 'react';

import {WebSocketClient, WebSocketMessage} from '@mattermost/client';

import {WebSocketContext} from './context';

export type UseWebSocketOptions = {
    handler: (msg: WebSocketMessage) => void;
}

export function useWebSocket({handler}: UseWebSocketOptions) {
    const wsClient = useWebSocketClient();

    useEffect(() => {
        wsClient.addMessageListener(handler);

        return () => {
            wsClient.removeMessageListener(handler);
        };
    }, [wsClient, handler]);
}

export function useWebSocketClient(): WebSocketClient {
    return useContext(WebSocketContext);
}

export default __webpack_public_path__ + "files/f6e98d6b5fccaa0c93bd8091b05295ad.png";
export default __webpack_public_path__ + "files/377564d283f9bc35cce974f33e37eaf3.png";
export default __webpack_public_path__ + "files/c768bfe69b3d4a980e7b2e8a9fb17528.svg";